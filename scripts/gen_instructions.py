#!/usr/bin/env python
import pathlib
import sys
import textwrap
import typing

CPYTHON_PATH = (
    pathlib.Path(__file__).parents[2] / "cpython"  # Local filesystem path of cpython
)

_cases_generator_path = CPYTHON_PATH / "Tools" / "cases_generator"
sys.path.append(str(_cases_generator_path))


import analyzer
from generators_common import DEFAULT_INPUT
from opcode_metadata_generator import cflags

ROOT = pathlib.Path(__file__).parents[1]
OUT_PATH = ROOT / "compiler" / "core" / "src" / "instruction.rs"


class Instruction(typing.NamedTuple):
    cname: str
    id: int
    flags: frozenset[str]
    has_oparg: bool

    @property
    def name(self) -> str:
        return self.cname.title().replace("_", "")

    def as_member(self) -> str:
        out = self.name
        if self.has_oparg:
            out += "(Arg<u32>)"
        out += f" = {self.id}"
        return out

    @classmethod
    def iter_instructions(cls, analysis: analyzer.Analysis):
        """
        Adapted from https://github.com/python/cpython/blob/bcee1c322115c581da27600f2ae55e5439c027eb/Tools/cases_generator/opcode_metadata_generator.py#L186-L213
        """
        opmap = analysis.opmap
        for inst in sorted(analysis.instructions.values(), key=lambda t: t.name):
            name = inst.name
            flags = frozenset(cflags(inst.properties).split(" | "))

            yield cls(
                cname=name, id=opmap[name], flags=flags, has_oparg=inst.properties.oparg
            )

        for pseudo in sorted(analysis.pseudos.values(), key=lambda t: t.name):
            name = pseudo.name
            flags = cflags(pseudo.properties)
            for flag in pseudo.flags:
                if flags == "0":
                    flags = f"{flag}_FLAG"
                else:
                    flags += f" | {flag}_FLAG"

            yield cls(
                cname=name,
                id=opmap[name],
                has_oparg=pseudo.properties.oparg,
                flags=frozenset(flags.split(" | ")),
            )


def gen_by_comment() -> str:
    path = pathlib.Path(__file__).absolute().relative_to(ROOT).as_posix()
    return textwrap.indent(
        f"""
This file is generated by {path}
Do not edit!
""".strip(),
        "// ",
    )


def main():
    analysis = analyzer.analyze_files([DEFAULT_INPUT])

    instruction_memebers = textwrap.indent(
        ",\n".join(ins.as_member() for ins in Instruction.iter_instructions(analysis)),
        " " * 4,
    )

    header = "///! Python opcode implementation. Currently aligned with cpython 3.13.7"

    derive = ", ".join(sorted({"Clone", "Copy", "Debug", "PartialEq", "Eq"}))

    out = f"""
{header}

{gen_by_comment()}

/// A Single bytecode instruction.
#[derive({derive})]
#[repr(u16)]
pub enum Instruction {{
{instruction_memebers}
}}

impl Instruction {{
}}
    """.strip()

    OUT_PATH.write_text(out + "\n")


if __name__ == "__main__":
    main()
