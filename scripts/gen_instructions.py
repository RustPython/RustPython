#!/usr/bin/env python
import pathlib
import subprocess  # for `cargo fmt`
import sys
import textwrap
import typing

if typing.TYPE_CHECKING:
    from collections.abc import Iterator

CPYTHON_PATH = (
    pathlib.Path(__file__).parents[2] / "cpython"  # Local filesystem path of cpython
)

_cases_generator_path = CPYTHON_PATH / "Tools" / "cases_generator"
sys.path.append(str(_cases_generator_path))


import analyzer
from generators_common import DEFAULT_INPUT
from opcode_metadata_generator import cflags

ROOT = pathlib.Path(__file__).parents[1]
OUT_PATH = ROOT / "compiler" / "core" / "src" / "instruction.rs"


class Instruction(typing.NamedTuple):
    cname: str
    id: int
    flags: frozenset[str]
    has_oparg: bool

    @property
    def name(self) -> str:
        return self.cname.title().replace("_", "")

    def as_member(self) -> str:
        out = self.name
        if self.has_oparg:
            out += "(Arg<u32>)"
        out += f" = {self.id}"
        return out

    def as_matched(self) -> str:
        out = self.name
        if self.has_oparg:
            out += "(_)"
        return out

    @classmethod
    def iter_instructions(cls, analysis: analyzer.Analysis) -> "Iterator[typing.Self]":
        """
        Adapted from https://github.com/python/cpython/blob/bcee1c322115c581da27600f2ae55e5439c027eb/Tools/cases_generator/opcode_metadata_generator.py#L186-L213
        """
        opmap = analysis.opmap
        for inst in sorted(analysis.instructions.values(), key=lambda t: t.name):
            name = inst.name
            flags = frozenset(cflags(inst.properties).split(" | "))

            yield cls(
                cname=name, id=opmap[name], flags=flags, has_oparg=inst.properties.oparg
            )

        for pseudo in sorted(analysis.pseudos.values(), key=lambda t: t.name):
            name = pseudo.name
            flags = cflags(pseudo.properties)
            for flag in pseudo.flags:
                if flags == "0":
                    flags = f"{flag}_FLAG"
                else:
                    flags += f" | {flag}_FLAG"

            yield cls(
                cname=name,
                id=opmap[name],
                has_oparg=pseudo.properties.oparg,
                flags=frozenset(flags.split(" | ")),
            )

    def __lt__(self, other) -> bool:
        return self.id < other.id


def group_nums(nums: list[int]) -> "Iterator[range]":
    nums = sorted(nums)
    start = prev = nums[0]

    for n in nums[1:] + [None]:
        if n is None or n != prev + 1:
            yield range(start, prev + 1)
            start = n
        prev = n


def gen_valid_ranges(ids: list[int]) -> str:
    return " | ".join(
        " | ".join(r) if len(r) < 3 else f"{r.start}..={r.stop - 1}"
        for r in group_nums(ids)
    )


def gen_has_attr_fn(
    instructions: frozenset[Instruction],
    *,
    attrs: tuple[str, ...] = ("arg", "const", "name", "jump", "free", "local", "exc"),
) -> "Iterator[str]":
    for attr in attrs:
        flag_name = "pure" if attr == "exc" else attr
        flag = f"has_{flag_name}_flag".upper()
        matches = " | ".join(
            ins.as_matched() for ins in sorted(instructions) if flag in ins.flags
        )
        yield f"""
/// Whether opcode had '{flag}' set.
#[must_use]
pub const fn has_{attr}(&self) -> bool {{
    matches!(self, {matches})
}}
""".strip()


def main():
    INDENT = " " * 4
    script_path = pathlib.Path(__file__).absolute().relative_to(ROOT).as_posix()

    analysis = analyzer.analyze_files([DEFAULT_INPUT])
    instructions = frozenset(Instruction.iter_instructions(analysis))

    has_attr_methods = textwrap.indent(
        "\n\n".join(gen_has_attr_fn(instructions)), INDENT
    )

    members = textwrap.indent(
        ",\n".join(ins.as_member() for ins in sorted(instructions)), INDENT
    )
    valid_ranges = gen_valid_ranges([ins.id for ins in instructions])

    out = f"""
///! Python opcode implementation. Currently aligned with cpython 3.13.7

// This file is generated by {script_path}
// Do not edit!

/// A Single bytecode instruction.
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(u16)]
pub enum Instruction {{
{members}
}}

impl Instruction {{
    /// Creates a new Instruction without validating that the `id` is valid before.
    #[must_use]
    pub const unsafe fn new_unchecked(id: u16) -> Self {{
        // SAFETY: Caller responsebility.
        unsafe {{ std::mem::transmute::<u16, Self>(id) }}
    }}

    /// Whether the given ID matches one of the opcode IDs.
    #[must_use]
    pub const fn is_valid(id: u16) -> bool {{
        matches!(id, {valid_ranges})
    }}

{has_attr_methods}
}}

impl TryFrom<u16> for Instruction {{
    type Error = crate::marshal::MarshalError;

    fn try_from(id: u16) -> Result<Self, Self::Error> {{
        if Self::is_valid(id) {{
            Ok(Self::new_unchecked(id))
        }} else {{
            Err(Self::Error::InvalidBytecode)
        }}
    }}
}}
    """.strip()

    OUT_PATH.write_text(out + "\n")

    print("DONE")
    print("Running `cargo fmt`")
    subprocess.run(["cargo", "fmt"], cwd=ROOT)


if __name__ == "__main__":
    main()
