#!/usr/bin/env python
import pathlib
import sys
import textwrap
import typing

CPYTHON_PATH = (
    pathlib.Path(__file__).parents[2] / "cpython"  # Local filesystem path of cpython
)

_cases_generator_path = CPYTHON_PATH / "Tools" / "cases_generator"
sys.path.append(str(_cases_generator_path))


import analyzer
from generators_common import DEFAULT_INPUT
from opcode_metadata_generator import cflags

ROOT = pathlib.Path(__file__).parents[1]
OUT_PATH = ROOT / "compiler" / "core" / "src" / "instruction.rs"


class Instruction(typing.NamedTuple):
    cname: str
    id: int
    flags: frozenset[str]
    has_oparg: bool

    @property
    def name(self) -> str:
        return self.cname.title().replace("_", "")

    def as_member(self) -> str:
        out = self.name
        if self.has_oparg:
            out += "(Arg<u32>)"
        out += f" = {self.id}"
        return out

    @classmethod
    def iter_instructions(cls, analysis: analyzer.Analysis):
        """
        Adapted from https://github.com/python/cpython/blob/bcee1c322115c581da27600f2ae55e5439c027eb/Tools/cases_generator/opcode_metadata_generator.py#L186-L213
        """
        opmap = analysis.opmap
        for inst in sorted(analysis.instructions.values(), key=lambda t: t.name):
            name = inst.name
            flags = frozenset(cflags(inst.properties).split(" | "))

            yield cls(
                cname=name, id=opmap[name], flags=flags, has_oparg=inst.properties.oparg
            )

        for pseudo in sorted(analysis.pseudos.values(), key=lambda t: t.name):
            name = pseudo.name
            flags = cflags(pseudo.properties)
            for flag in pseudo.flags:
                if flags == "0":
                    flags = f"{flag}_FLAG"
                else:
                    flags += f" | {flag}_FLAG"

            yield cls(
                cname=name,
                id=opmap[name],
                has_oparg=pseudo.properties.oparg,
                flags=frozenset(flags.split(" | ")),
            )

    def __lt__(self, other) -> bool:
        return self.id < other.id


def group_nums(nums: list[int]):
    nums = sorted(nums)
    start = prev = nums[0]

    for n in nums[1:] + [None]:
        if n is None or n != prev + 1:
            yield range(start, prev + 1)
            start = n
        prev = n


def gen_valid_ranges(ids: list[int]) -> str:
    return " | ".join(
        " | ".join(r) if len(r) < 3 else f"{r.start}..={r.stop - 1}"
        for r in group_nums(ids)
    )


def main():
    INDENT = " " * 4
    analysis = analyzer.analyze_files([DEFAULT_INPUT])
    instructions = frozenset(Instruction.iter_instructions(analysis))

    members = textwrap.indent(
        ",\n".join(ins.as_member() for ins in sorted(instructions)), INDENT
    )
    valid_ranges = gen_valid_ranges([ins.id for ins in instructions])

    script_path = pathlib.Path(__file__).absolute().relative_to(ROOT).as_posix()
    out = f"""
///! Python opcode implementation. Currently aligned with cpython 3.13.7

// This file is generated by {script_path}
// Do not edit!

/// A Single bytecode instruction.
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(u16)]
pub enum Instruction {{
{members}
}}

impl Instruction {{
    /// Creates a new Instruction without validating that the `id` is valid before.
    #[must_use]
    pub unsafe const fn new_unchecked(id: u16) -> Self {{
        // SAFETY: Caller responsebility.
        unsafe {{ std::mem::transmute::<u16, Self>(id) }}
    }}

    /// Whether the given ID matches one of the opcode IDs.
    #[must_use]
    pub const fn is_valid(id: u16) -> bool {{
        matches!(id, {valid_ranges})
    }}
}}

impl TryFrom<u16> for Instruction {{
    type Error = crate::marshal::MarshalError;

    fn try_from(id: u16) -> Result<Self, Self::Error> {{
        if Self::is_valid(id) {{
            Ok(Self::new_unchecked(id))
        }} else {{
            Err(Self::Error::InvalidBytecode)
        }}
    }}
}}
    """.strip()

    OUT_PATH.write_text(out + "\n")


if __name__ == "__main__":
    main()
