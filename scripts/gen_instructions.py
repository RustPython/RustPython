#!/usr/bin/env python
import pathlib
import sys
import textwrap
import typing

CPYTHON_PATH = (
    pathlib.Path(__file__).parents[2] / "cpython"  # Local filesystem path of cpython
)

_cases_generator_path = CPYTHON_PATH / "Tools" / "cases_generator"
sys.path.append(str(_cases_generator_path))


import analyzer
from generators_common import DEFAULT_INPUT
from opcode_metadata_generator import cflags, get_format

ROOT = pathlib.Path(__file__).parents[1]
OUT_PATH = ROOT / "compiler" / "core" / "src" / "instruction.rs"


class Instruction(typing.NamedTuple):
    cname: str
    id: int
    fmt: str
    flags: frozenset[str]

    @property
    def name(self) -> str:
        return self.cname.title().replace("_", "")

    def as_member(self) -> str:
        out = self.name
        match self.fmt:
            case "INSTR_FMT_IB":
                out += " { index: Arg<u32> }"
        out += f" = {self.id}"
        return out

    @classmethod
    def iter_instructions(cls, analysis: analyzer.Analysis):
        """
        Adopted from https://github.com/python/cpython/blob/bcee1c322115c581da27600f2ae55e5439c027eb/Tools/cases_generator/opcode_metadata_generator.py#L186-L213
        """
        opmap = analysis.opmap
        for inst in sorted(analysis.instructions.values(), key=lambda t: t.name):
            name = inst.name
            fmt = get_format(inst)
            flags = frozenset(cflags(inst.properties).split(" | "))

            yield cls(cname=name, id=opmap[name], fmt=fmt, flags=flags)

        # TODO: What about `analysis.pseudos` ?

    def __lt__(self, other: typing.Self) -> bool:
        return self.id < other.id


def gen_by_comment() -> str:
    path = pathlib.Path(__file__).absolute().relative_to(ROOT).as_posix()
    return textwrap.indent(
        f"""
This file is generated by {path}
Do not edit!
""".strip(),
        "// ",
    )


def main():
    analysis = analyzer.analyze_files([DEFAULT_INPUT])

    instruction_memebers = textwrap.indent(
        ",\n".join(
            ins.as_member() for ins in sorted(Instruction.iter_instructions(analysis))
        ),
        " " * 4,
    )

    header = "///! Python opcode implementation. Currently aligned with cpython 3.13.7"

    derive = ", ".join(sorted({"Clone", "Copy", "Debug", "PartialEq", "Eq"}))

    out = f"""
{header}

{gen_by_comment()}

/// A Single bytecode instruction.
#[derive({derive})]
#[repr(u16)]
pub enum Instruction {{
{instruction_memebers}
}}
    """.strip()

    OUT_PATH.write_text(out + "\n")


if __name__ == "__main__":
    main()
