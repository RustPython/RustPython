use rustpython_sre_engine::{Request, State, StrDrive};

struct Pattern {
    pattern: &'static str,
    code: &'static [u32],
}

impl Pattern {
    fn state<'a, S: StrDrive>(&self, string: S) -> (Request<'a, S>, State) {
        let req = Request::new(string, 0, usize::MAX, self.code, false);
        let state = State::default();
        (req, state)
    }
}

#[test]
fn test_2427() {
    // pattern lookbehind = re.compile(r'(?<!\.)x\b')
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let lookbehind = Pattern { pattern: "(?<!\\.)x\\b", code: &[14, 4, 0, 1, 1, 5, 5, 1, 16, 46, 1, 16, 120, 6, 10, 1] };
    // END GENERATED
    let (req, mut state) = lookbehind.state("x");
    assert!(state.pymatch(&req));
}

#[test]
fn test_assert() {
    // pattern positive_lookbehind = re.compile(r'(?<=abc)def')
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let positive_lookbehind = Pattern { pattern: "(?<=abc)def", code: &[14, 4, 0, 3, 3, 4, 9, 3, 16, 97, 16, 98, 16, 99, 1, 16, 100, 16, 101, 16, 102, 1] };
    // END GENERATED
    let (req, mut state) = positive_lookbehind.state("abcdef");
    assert!(state.search(req));
}

#[test]
fn test_string_boundaries() {
    // pattern big_b = re.compile(r'\B')
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let big_b = Pattern { pattern: "\\B", code: &[14, 4, 0, 0, 0, 6, 11, 1] };
    // END GENERATED
    let (req, mut state) = big_b.state("");
    assert!(!state.search(req));
}

#[test]
fn test_zerowidth() {
    // pattern p = re.compile(r'\b|:+')
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p = Pattern { pattern: "\\b|:+", code: &[14, 4, 0, 0, 4294967295, 7, 5, 6, 10, 15, 12, 10, 24, 6, 1, 4294967295, 16, 58, 1, 15, 2, 0, 1] };
    // END GENERATED
    let (mut req, mut state) = p.state("a:");
    req.must_advance = true;
    assert!(state.search(req));
    assert_eq!(state.cursor.position, 1);
}

#[test]
fn test_repeat_context_panic() {
    use optional::Optioned;
    // pattern p = re.compile(r'(?:a*?(xx)??z)*')
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p = Pattern { pattern: "(?:a*?(xx)??z)*", code: &[14, 4, 0, 0, 4294967295, 23, 25, 0, 4294967295, 26, 6, 0, 4294967295, 16, 97, 1, 23, 11, 0, 1, 17, 0, 16, 120, 16, 120, 17, 1, 19, 16, 122, 18, 1] };
    // END GENERATED
    let (req, mut state) = p.state("axxzaz");
    assert!(state.pymatch(&req));
    assert_eq!(
        *state.marks.raw(),
        vec![Optioned::some(1), Optioned::some(3)]
    );
}

#[test]
fn test_double_max_until() {
    // pattern p = re.compile(r'((1)?)*')
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p = Pattern { pattern: "((1)?)*", code: &[14, 4, 0, 0, 4294967295, 23, 18, 0, 4294967295, 17, 0, 23, 9, 0, 1, 17, 2, 16, 49, 17, 3, 18, 17, 1, 18, 1] };
    // END GENERATED
    let (req, mut state) = p.state("1111");
    assert!(state.pymatch(&req));
    assert_eq!(state.cursor.position, 4);
}

#[test]
fn test_info_single() {
    // pattern p = re.compile(r'aa*')
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p = Pattern { pattern: "aa*", code: &[14, 8, 1, 1, 4294967295, 1, 1, 97, 0, 16, 97, 24, 6, 0, 4294967295, 16, 97, 1, 1] };
    // END GENERATED
    let (req, mut state) = p.state("baaaa");
    assert!(state.search(req));
    assert_eq!(state.start, 1);
    assert_eq!(state.cursor.position, 5);
}

#[test]
fn test_info_single2() {
    // pattern p = re.compile(r'Python|Perl')
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p = Pattern { pattern: "Python|Perl", code: &[14, 8, 1, 4, 6, 1, 1, 80, 0, 16, 80, 7, 13, 16, 121, 16, 116, 16, 104, 16, 111, 16, 110, 15, 11, 9, 16, 101, 16, 114, 16, 108, 15, 2, 0, 1] };
    // END GENERATED
    let (req, mut state) = p.state("Perl");
    assert!(state.search(req));
}

#[test]
fn test_info_literal() {
    // pattern p = re.compile(r'ababc+')
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p = Pattern { pattern: "ababc+", code: &[14, 14, 1, 5, 4294967295, 4, 4, 97, 98, 97, 98, 0, 0, 1, 2, 16, 97, 16, 98, 16, 97, 16, 98, 24, 6, 1, 4294967295, 16, 99, 1, 1] };
    // END GENERATED
    let (req, mut state) = p.state("!ababc");
    assert!(state.search(req));
}

#[test]
fn test_info_literal2() {
    // pattern p = re.compile(r'(python)\1')
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p = Pattern { pattern: "(python)\\1", code: &[14, 18, 1, 12, 12, 6, 0, 112, 121, 116, 104, 111, 110, 0, 0, 0, 0, 0, 0, 17, 0, 16, 112, 16, 121, 16, 116, 16, 104, 16, 111, 16, 110, 17, 1, 11, 0, 1] };
    // END GENERATED
    let (req, mut state) = p.state("pythonpython");
    assert!(state.search(req));
}

#[test]
fn test_repeat_in_assertions() {
    // pattern p = re.compile('^([ab]*?)(?=(b)?)c', re.IGNORECASE)
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p = Pattern { pattern: "^([ab]*?)(?=(b)?)c", code: &[14, 4, 0, 1, 4294967295, 6, 0, 17, 0, 26, 10, 0, 4294967295, 39, 5, 22, 97, 98, 0, 1, 17, 1, 4, 14, 0, 23, 9, 0, 1, 17, 2, 40, 98, 17, 3, 18, 1, 40, 99, 1] };
    // END GENERATED
    let (req, mut state) = p.state("abc");
    assert!(state.search(req));
}

#[test]
fn test_possessive_quantifier() {
    // pattern p = re.compile('e++a')
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p = Pattern { pattern: "e++a", code: &[14, 4, 0, 2, 4294967295, 29, 6, 1, 4294967295, 16, 101, 1, 16, 97, 1] };
    // END GENERATED
    let (req, mut state) = p.state("eeea");
    assert!(state.pymatch(&req));
}

#[test]
fn test_possessive_atomic_group() {
    // pattern p = re.compile('(?>x)++x')
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p = Pattern { pattern: "(?>x)++x", code: &[14, 4, 0, 2, 4294967295, 28, 8, 1, 4294967295, 27, 4, 16, 120, 1, 1, 16, 120, 1] };
    // END GENERATED
    let (req, mut state) = p.state("xxx");
    assert!(!state.pymatch(&req));
}

#[test]
fn test_bug_20998() {
    // pattern p = re.compile('[a-c]+', re.I)
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p = Pattern { pattern: "[a-c]+", code: &[14, 4, 0, 1, 4294967295, 24, 10, 1, 4294967295, 39, 5, 22, 97, 99, 0, 1, 1] };
    // END GENERATED
    let (mut req, mut state) = p.state("ABC");
    req.match_all = true;
    assert!(state.pymatch(&req));
    assert_eq!(state.cursor.position, 3);
}

#[test]
fn test_bigcharset() {
    // pattern p = re.compile('[a-z]*', re.I)
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p = Pattern { pattern: "[a-z]*", code: &[14, 4, 0, 0, 4294967295, 24, 97, 0, 4294967295, 39, 92, 10, 3, 33685760, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 33686018, 0, 0, 0, 134217726, 0, 0, 0, 0, 0, 131072, 0, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1] };
    // END GENERATED
    let (req, mut state) = p.state("x ");
    assert!(state.pymatch(&req));
    assert_eq!(state.cursor.position, 1);
}

#[test]
fn test_search_nonascii() {
    // pattern p = re.compile('\xe0+')
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p = Pattern { pattern: "\u{e0}+", code: &[14, 4, 0, 1, 4294967295, 24, 6, 1, 4294967295, 16, 224, 1, 1] };
    // END GENERATED
}
