// File automatically generated by ast/asdl_rs.py.

#![allow(clippy::all)]

use super::*;
use crate::common::ascii;

#[pyclass(module = "_ast", name = "mod", base = "AstNode")]
struct NodeKindMod;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeKindMod {}
#[pyclass(module = "_ast", name = "Module", base = "NodeKindMod")]
struct NodeModule;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeModule {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("type_ignores")).into(),
            ])
            .into(),
        );
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Interactive", base = "NodeKindMod")]
struct NodeInteractive;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeInteractive {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("body")).into()])
                .into(),
        );
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Expression", base = "NodeKindMod")]
struct NodeExpression;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExpression {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("body")).into()])
                .into(),
        );
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "FunctionType", base = "NodeKindMod")]
struct NodeFunctionType;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeFunctionType {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("argtypes")).into(),
                ctx.new_str(ascii!("returns")).into(),
            ])
            .into(),
        );
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "stmt", base = "AstNode")]
struct NodeKindStmt;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeKindStmt {}
#[pyclass(module = "_ast", name = "FunctionDef", base = "NodeKindStmt")]
struct NodeFunctionDef;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeFunctionDef {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("name")).into(),
                ctx.new_str(ascii!("args")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("decorator_list")).into(),
                ctx.new_str(ascii!("returns")).into(),
                ctx.new_str(ascii!("type_comment")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "AsyncFunctionDef", base = "NodeKindStmt")]
struct NodeAsyncFunctionDef;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeAsyncFunctionDef {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("name")).into(),
                ctx.new_str(ascii!("args")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("decorator_list")).into(),
                ctx.new_str(ascii!("returns")).into(),
                ctx.new_str(ascii!("type_comment")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "ClassDef", base = "NodeKindStmt")]
struct NodeClassDef;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeClassDef {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("name")).into(),
                ctx.new_str(ascii!("bases")).into(),
                ctx.new_str(ascii!("keywords")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("decorator_list")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Return", base = "NodeKindStmt")]
struct NodeReturn;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeReturn {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("value")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Delete", base = "NodeKindStmt")]
struct NodeDelete;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeDelete {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("targets")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Assign", base = "NodeKindStmt")]
struct NodeAssign;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeAssign {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("targets")).into(),
                ctx.new_str(ascii!("value")).into(),
                ctx.new_str(ascii!("type_comment")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "AugAssign", base = "NodeKindStmt")]
struct NodeAugAssign;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeAugAssign {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("target")).into(),
                ctx.new_str(ascii!("op")).into(),
                ctx.new_str(ascii!("value")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "AnnAssign", base = "NodeKindStmt")]
struct NodeAnnAssign;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeAnnAssign {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("target")).into(),
                ctx.new_str(ascii!("annotation")).into(),
                ctx.new_str(ascii!("value")).into(),
                ctx.new_str(ascii!("simple")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "For", base = "NodeKindStmt")]
struct NodeFor;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeFor {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("target")).into(),
                ctx.new_str(ascii!("iter")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("orelse")).into(),
                ctx.new_str(ascii!("type_comment")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "AsyncFor", base = "NodeKindStmt")]
struct NodeAsyncFor;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeAsyncFor {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("target")).into(),
                ctx.new_str(ascii!("iter")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("orelse")).into(),
                ctx.new_str(ascii!("type_comment")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "While", base = "NodeKindStmt")]
struct NodeWhile;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeWhile {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("test")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("orelse")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "If", base = "NodeKindStmt")]
struct NodeIf;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeIf {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("test")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("orelse")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "With", base = "NodeKindStmt")]
struct NodeWith;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeWith {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("items")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("type_comment")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "AsyncWith", base = "NodeKindStmt")]
struct NodeAsyncWith;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeAsyncWith {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("items")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("type_comment")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Match", base = "NodeKindStmt")]
struct NodeMatch;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeMatch {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("subject")).into(),
                ctx.new_str(ascii!("cases")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Raise", base = "NodeKindStmt")]
struct NodeRaise;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeRaise {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("exc")).into(),
                ctx.new_str(ascii!("cause")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Try", base = "NodeKindStmt")]
struct NodeTry;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeTry {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("handlers")).into(),
                ctx.new_str(ascii!("orelse")).into(),
                ctx.new_str(ascii!("finalbody")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "TryStar", base = "NodeKindStmt")]
struct NodeTryStar;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeTryStar {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("handlers")).into(),
                ctx.new_str(ascii!("orelse")).into(),
                ctx.new_str(ascii!("finalbody")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Assert", base = "NodeKindStmt")]
struct NodeAssert;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeAssert {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("test")).into(),
                ctx.new_str(ascii!("msg")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Import", base = "NodeKindStmt")]
struct NodeImport;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeImport {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("names")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "ImportFrom", base = "NodeKindStmt")]
struct NodeImportFrom;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeImportFrom {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("module")).into(),
                ctx.new_str(ascii!("names")).into(),
                ctx.new_str(ascii!("level")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Global", base = "NodeKindStmt")]
struct NodeGlobal;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeGlobal {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("names")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Nonlocal", base = "NodeKindStmt")]
struct NodeNonlocal;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeNonlocal {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("names")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Expr", base = "NodeKindStmt")]
struct NodeExpr;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExpr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("value")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Pass", base = "NodeKindStmt")]
struct NodePass;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodePass {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Break", base = "NodeKindStmt")]
struct NodeBreak;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeBreak {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Continue", base = "NodeKindStmt")]
struct NodeContinue;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeContinue {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "expr", base = "AstNode")]
struct NodeKindExpr;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeKindExpr {}
#[pyclass(module = "_ast", name = "BoolOp", base = "NodeKindExpr")]
struct NodeBoolOp;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeBoolOp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("op")).into(),
                ctx.new_str(ascii!("values")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "NamedExpr", base = "NodeKindExpr")]
struct NodeNamedExpr;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeNamedExpr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("target")).into(),
                ctx.new_str(ascii!("value")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "BinOp", base = "NodeKindExpr")]
struct NodeBinOp;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeBinOp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("left")).into(),
                ctx.new_str(ascii!("op")).into(),
                ctx.new_str(ascii!("right")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "UnaryOp", base = "NodeKindExpr")]
struct NodeUnaryOp;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeUnaryOp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("op")).into(),
                ctx.new_str(ascii!("operand")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Lambda", base = "NodeKindExpr")]
struct NodeLambda;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeLambda {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("args")).into(),
                ctx.new_str(ascii!("body")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "IfExp", base = "NodeKindExpr")]
struct NodeIfExp;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeIfExp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("test")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("orelse")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Dict", base = "NodeKindExpr")]
struct NodeDict;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeDict {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("keys")).into(),
                ctx.new_str(ascii!("values")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Set", base = "NodeKindExpr")]
struct NodeSet;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeSet {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("elts")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "ListComp", base = "NodeKindExpr")]
struct NodeListComp;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeListComp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("elt")).into(),
                ctx.new_str(ascii!("generators")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "SetComp", base = "NodeKindExpr")]
struct NodeSetComp;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeSetComp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("elt")).into(),
                ctx.new_str(ascii!("generators")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "DictComp", base = "NodeKindExpr")]
struct NodeDictComp;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeDictComp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("key")).into(),
                ctx.new_str(ascii!("value")).into(),
                ctx.new_str(ascii!("generators")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "GeneratorExp", base = "NodeKindExpr")]
struct NodeGeneratorExp;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeGeneratorExp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("elt")).into(),
                ctx.new_str(ascii!("generators")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Await", base = "NodeKindExpr")]
struct NodeAwait;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeAwait {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("value")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Yield", base = "NodeKindExpr")]
struct NodeYield;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeYield {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("value")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "YieldFrom", base = "NodeKindExpr")]
struct NodeYieldFrom;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeYieldFrom {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("value")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Compare", base = "NodeKindExpr")]
struct NodeCompare;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeCompare {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("left")).into(),
                ctx.new_str(ascii!("ops")).into(),
                ctx.new_str(ascii!("comparators")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Call", base = "NodeKindExpr")]
struct NodeCall;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeCall {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("func")).into(),
                ctx.new_str(ascii!("args")).into(),
                ctx.new_str(ascii!("keywords")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "FormattedValue", base = "NodeKindExpr")]
struct NodeFormattedValue;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeFormattedValue {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("value")).into(),
                ctx.new_str(ascii!("conversion")).into(),
                ctx.new_str(ascii!("format_spec")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "JoinedStr", base = "NodeKindExpr")]
struct NodeJoinedStr;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeJoinedStr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("values")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Constant", base = "NodeKindExpr")]
struct NodeConstant;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeConstant {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("value")).into(),
                ctx.new_str(ascii!("kind")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Attribute", base = "NodeKindExpr")]
struct NodeAttribute;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeAttribute {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("value")).into(),
                ctx.new_str(ascii!("attr")).into(),
                ctx.new_str(ascii!("ctx")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Subscript", base = "NodeKindExpr")]
struct NodeSubscript;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeSubscript {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("value")).into(),
                ctx.new_str(ascii!("slice")).into(),
                ctx.new_str(ascii!("ctx")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Starred", base = "NodeKindExpr")]
struct NodeStarred;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStarred {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("value")).into(),
                ctx.new_str(ascii!("ctx")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Name", base = "NodeKindExpr")]
struct NodeName;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeName {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("id")).into(),
                ctx.new_str(ascii!("ctx")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "List", base = "NodeKindExpr")]
struct NodeList;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeList {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("elts")).into(),
                ctx.new_str(ascii!("ctx")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Tuple", base = "NodeKindExpr")]
struct NodeTuple;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeTuple {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("elts")).into(),
                ctx.new_str(ascii!("ctx")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Slice", base = "NodeKindExpr")]
struct NodeSlice;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeSlice {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("lower")).into(),
                ctx.new_str(ascii!("upper")).into(),
                ctx.new_str(ascii!("step")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "expr_context", base = "AstNode")]
struct NodeKindExprContext;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeKindExprContext {}
#[pyclass(module = "_ast", name = "Load", base = "NodeKindExprContext")]
struct NodeLoad;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeLoad {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Store", base = "NodeKindExprContext")]
struct NodeStore;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStore {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Del", base = "NodeKindExprContext")]
struct NodeDel;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeDel {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "boolop", base = "AstNode")]
struct NodeKindBoolop;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeKindBoolop {}
#[pyclass(module = "_ast", name = "And", base = "NodeKindBoolop")]
struct NodeAnd;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeAnd {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Or", base = "NodeKindBoolop")]
struct NodeOr;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeOr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "operator", base = "AstNode")]
struct NodeKindOperator;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeKindOperator {}
#[pyclass(module = "_ast", name = "Add", base = "NodeKindOperator")]
struct NodeAdd;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeAdd {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Sub", base = "NodeKindOperator")]
struct NodeSub;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeSub {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Mult", base = "NodeKindOperator")]
struct NodeMult;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeMult {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "MatMult", base = "NodeKindOperator")]
struct NodeMatMult;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeMatMult {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Div", base = "NodeKindOperator")]
struct NodeDiv;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeDiv {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Mod", base = "NodeKindOperator")]
struct NodeMod;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeMod {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Pow", base = "NodeKindOperator")]
struct NodePow;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodePow {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "LShift", base = "NodeKindOperator")]
struct NodeLShift;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeLShift {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "RShift", base = "NodeKindOperator")]
struct NodeRShift;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeRShift {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "BitOr", base = "NodeKindOperator")]
struct NodeBitOr;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeBitOr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "BitXor", base = "NodeKindOperator")]
struct NodeBitXor;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeBitXor {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "BitAnd", base = "NodeKindOperator")]
struct NodeBitAnd;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeBitAnd {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "FloorDiv", base = "NodeKindOperator")]
struct NodeFloorDiv;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeFloorDiv {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "unaryop", base = "AstNode")]
struct NodeKindUnaryop;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeKindUnaryop {}
#[pyclass(module = "_ast", name = "Invert", base = "NodeKindUnaryop")]
struct NodeInvert;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeInvert {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Not", base = "NodeKindUnaryop")]
struct NodeNot;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeNot {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "UAdd", base = "NodeKindUnaryop")]
struct NodeUAdd;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeUAdd {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "USub", base = "NodeKindUnaryop")]
struct NodeUSub;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeUSub {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "cmpop", base = "AstNode")]
struct NodeKindCmpop;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeKindCmpop {}
#[pyclass(module = "_ast", name = "Eq", base = "NodeKindCmpop")]
struct NodeEq;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeEq {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "NotEq", base = "NodeKindCmpop")]
struct NodeNotEq;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeNotEq {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Lt", base = "NodeKindCmpop")]
struct NodeLt;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeLt {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "LtE", base = "NodeKindCmpop")]
struct NodeLtE;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeLtE {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Gt", base = "NodeKindCmpop")]
struct NodeGt;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeGt {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "GtE", base = "NodeKindCmpop")]
struct NodeGtE;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeGtE {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Is", base = "NodeKindCmpop")]
struct NodeIs;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeIs {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "IsNot", base = "NodeKindCmpop")]
struct NodeIsNot;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeIsNot {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "In", base = "NodeKindCmpop")]
struct NodeIn;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeIn {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "NotIn", base = "NodeKindCmpop")]
struct NodeNotIn;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeNotIn {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "comprehension", base = "AstNode")]
struct NodeComprehension;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeComprehension {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("target")).into(),
                ctx.new_str(ascii!("iter")).into(),
                ctx.new_str(ascii!("ifs")).into(),
                ctx.new_str(ascii!("is_async")).into(),
            ])
            .into(),
        );
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "excepthandler", base = "AstNode")]
struct NodeKindExcepthandler;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeKindExcepthandler {}
#[pyclass(
    module = "_ast",
    name = "ExceptHandler",
    base = "NodeKindExcepthandler"
)]
struct NodeExceptHandler;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExceptHandler {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("type")).into(),
                ctx.new_str(ascii!("name")).into(),
                ctx.new_str(ascii!("body")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "arguments", base = "AstNode")]
struct NodeArguments;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeArguments {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("posonlyargs")).into(),
                ctx.new_str(ascii!("args")).into(),
                ctx.new_str(ascii!("vararg")).into(),
                ctx.new_str(ascii!("kwonlyargs")).into(),
                ctx.new_str(ascii!("kw_defaults")).into(),
                ctx.new_str(ascii!("kwarg")).into(),
                ctx.new_str(ascii!("defaults")).into(),
            ])
            .into(),
        );
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "arg", base = "AstNode")]
struct NodeArg;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeArg {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("arg")).into(),
                ctx.new_str(ascii!("annotation")).into(),
                ctx.new_str(ascii!("type_comment")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "keyword", base = "AstNode")]
struct NodeKeyword;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeKeyword {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("arg")).into(),
                ctx.new_str(ascii!("value")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "alias", base = "AstNode")]
struct NodeAlias;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeAlias {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("name")).into(),
                ctx.new_str(ascii!("asname")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "withitem", base = "AstNode")]
struct NodeWithitem;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeWithitem {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("context_expr")).into(),
                ctx.new_str(ascii!("optional_vars")).into(),
            ])
            .into(),
        );
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "match_case", base = "AstNode")]
struct NodeMatchCase;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeMatchCase {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("pattern")).into(),
                ctx.new_str(ascii!("guard")).into(),
                ctx.new_str(ascii!("body")).into(),
            ])
            .into(),
        );
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "pattern", base = "AstNode")]
struct NodeKindPattern;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeKindPattern {}
#[pyclass(module = "_ast", name = "MatchValue", base = "NodeKindPattern")]
struct NodeMatchValue;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeMatchValue {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("value")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "MatchSingleton", base = "NodeKindPattern")]
struct NodeMatchSingleton;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeMatchSingleton {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("value")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "MatchSequence", base = "NodeKindPattern")]
struct NodeMatchSequence;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeMatchSequence {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("patterns")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "MatchMapping", base = "NodeKindPattern")]
struct NodeMatchMapping;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeMatchMapping {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("keys")).into(),
                ctx.new_str(ascii!("patterns")).into(),
                ctx.new_str(ascii!("rest")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "MatchClass", base = "NodeKindPattern")]
struct NodeMatchClass;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeMatchClass {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("cls")).into(),
                ctx.new_str(ascii!("patterns")).into(),
                ctx.new_str(ascii!("kwd_attrs")).into(),
                ctx.new_str(ascii!("kwd_patterns")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "MatchStar", base = "NodeKindPattern")]
struct NodeMatchStar;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeMatchStar {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("name")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "MatchAs", base = "NodeKindPattern")]
struct NodeMatchAs;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeMatchAs {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("pattern")).into(),
                ctx.new_str(ascii!("name")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "MatchOr", base = "NodeKindPattern")]
struct NodeMatchOr;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeMatchOr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("patterns")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "type_ignore", base = "AstNode")]
struct NodeKindTypeIgnore;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeKindTypeIgnore {}
#[pyclass(module = "_ast", name = "TypeIgnore", base = "NodeKindTypeIgnore")]
struct NodeTypeIgnore;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeTypeIgnore {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("tag")).into(),
            ])
            .into(),
        );
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}

impl NamedNode for ast::Mod {
    const NAME: &'static str = "mod";
}
impl Node for ast::Mod {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::Mod::Module { body, type_ignores } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeModule::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("body", body.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("type_ignores", type_ignores.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::Mod::Interactive { body } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeInteractive::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("body", body.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::Mod::Expression { body } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeExpression::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("body", body.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::Mod::FunctionType { argtypes, returns } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeFunctionType::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("argtypes", argtypes.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("returns", returns.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(if _cls.is(NodeModule::static_type()) {
            ast::Mod::Module {
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "mod")?)?,
                type_ignores: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "type_ignores", "mod")?,
                )?,
            }
        } else if _cls.is(NodeInteractive::static_type()) {
            ast::Mod::Interactive {
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "mod")?)?,
            }
        } else if _cls.is(NodeExpression::static_type()) {
            ast::Mod::Expression {
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "mod")?)?,
            }
        } else if _cls.is(NodeFunctionType::static_type()) {
            ast::Mod::FunctionType {
                argtypes: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "argtypes", "mod")?,
                )?,
                returns: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "returns", "mod")?,
                )?,
            }
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of mod, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
impl NamedNode for ast::StmtKind {
    const NAME: &'static str = "stmt";
}
impl Node for ast::StmtKind {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::StmtKind::FunctionDef {
                name,
                args,
                body,
                decorator_list,
                returns,
                type_comment,
            } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeFunctionDef::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("name", name.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("args", args.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("body", body.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("decorator_list", decorator_list.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("returns", returns.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("type_comment", type_comment.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::AsyncFunctionDef {
                name,
                args,
                body,
                decorator_list,
                returns,
                type_comment,
            } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeAsyncFunctionDef::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("name", name.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("args", args.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("body", body.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("decorator_list", decorator_list.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("returns", returns.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("type_comment", type_comment.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::ClassDef {
                name,
                bases,
                keywords,
                body,
                decorator_list,
            } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeClassDef::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("name", name.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("bases", bases.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("keywords", keywords.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("body", body.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("decorator_list", decorator_list.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::Return { value } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeReturn::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("value", value.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::Delete { targets } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeDelete::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("targets", targets.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::Assign {
                targets,
                value,
                type_comment,
            } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeAssign::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("targets", targets.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("value", value.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("type_comment", type_comment.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::AugAssign { target, op, value } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeAugAssign::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("target", target.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict.set_item("op", op.ast_to_object(_vm), _vm).unwrap();
                _dict
                    .set_item("value", value.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::AnnAssign {
                target,
                annotation,
                value,
                simple,
            } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeAnnAssign::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("target", target.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("annotation", annotation.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("value", value.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("simple", simple.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::For {
                target,
                iter,
                body,
                orelse,
                type_comment,
            } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeFor::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("target", target.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("iter", iter.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("body", body.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("orelse", orelse.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("type_comment", type_comment.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::AsyncFor {
                target,
                iter,
                body,
                orelse,
                type_comment,
            } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeAsyncFor::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("target", target.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("iter", iter.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("body", body.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("orelse", orelse.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("type_comment", type_comment.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::While { test, body, orelse } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeWhile::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("test", test.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("body", body.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("orelse", orelse.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::If { test, body, orelse } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeIf::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("test", test.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("body", body.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("orelse", orelse.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::With {
                items,
                body,
                type_comment,
            } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeWith::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("items", items.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("body", body.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("type_comment", type_comment.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::AsyncWith {
                items,
                body,
                type_comment,
            } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeAsyncWith::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("items", items.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("body", body.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("type_comment", type_comment.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::Match { subject, cases } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeMatch::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("subject", subject.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("cases", cases.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::Raise { exc, cause } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeRaise::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("exc", exc.ast_to_object(_vm), _vm).unwrap();
                _dict
                    .set_item("cause", cause.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::Try {
                body,
                handlers,
                orelse,
                finalbody,
            } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeTry::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("body", body.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("handlers", handlers.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("orelse", orelse.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("finalbody", finalbody.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::TryStar {
                body,
                handlers,
                orelse,
                finalbody,
            } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeTryStar::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("body", body.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("handlers", handlers.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("orelse", orelse.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("finalbody", finalbody.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::Assert { test, msg } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeAssert::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("test", test.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict.set_item("msg", msg.ast_to_object(_vm), _vm).unwrap();
                _node.into()
            }
            ast::StmtKind::Import { names } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeImport::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("names", names.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::ImportFrom {
                module,
                names,
                level,
            } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeImportFrom::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("module", module.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("names", names.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("level", level.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::Global { names } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeGlobal::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("names", names.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::Nonlocal { names } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeNonlocal::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("names", names.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::Expr { value } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeExpr::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("value", value.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::Pass {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodePass::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::Break {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeBreak::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::StmtKind::Continue {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeContinue::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _location = ast::Location::new(
            Node::ast_from_object(_vm, get_node_field(_vm, &_object, "lineno", "stmt")?)?,
            Node::ast_from_object(_vm, get_node_field(_vm, &_object, "col_offset", "stmt")?)?,
        );
        let _cls = _object.class();
        Ok(if _cls.is(NodeFunctionDef::static_type()) {
            ast::StmtKind::FunctionDef {
                name: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "name", "stmt")?)?,
                args: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "args", "stmt")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                decorator_list: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "decorator_list", "stmt")?,
                )?,
                returns: get_node_field_opt(_vm, &_object, "returns")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
                type_comment: get_node_field_opt(_vm, &_object, "type_comment")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
            }
        } else if _cls.is(NodeAsyncFunctionDef::static_type()) {
            ast::StmtKind::AsyncFunctionDef {
                name: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "name", "stmt")?)?,
                args: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "args", "stmt")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                decorator_list: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "decorator_list", "stmt")?,
                )?,
                returns: get_node_field_opt(_vm, &_object, "returns")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
                type_comment: get_node_field_opt(_vm, &_object, "type_comment")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
            }
        } else if _cls.is(NodeClassDef::static_type()) {
            ast::StmtKind::ClassDef {
                name: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "name", "stmt")?)?,
                bases: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "bases", "stmt")?)?,
                keywords: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "keywords", "stmt")?,
                )?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                decorator_list: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "decorator_list", "stmt")?,
                )?,
            }
        } else if _cls.is(NodeReturn::static_type()) {
            ast::StmtKind::Return {
                value: get_node_field_opt(_vm, &_object, "value")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
            }
        } else if _cls.is(NodeDelete::static_type()) {
            ast::StmtKind::Delete {
                targets: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "targets", "stmt")?,
                )?,
            }
        } else if _cls.is(NodeAssign::static_type()) {
            ast::StmtKind::Assign {
                targets: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "targets", "stmt")?,
                )?,
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "stmt")?)?,
                type_comment: get_node_field_opt(_vm, &_object, "type_comment")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
            }
        } else if _cls.is(NodeAugAssign::static_type()) {
            ast::StmtKind::AugAssign {
                target: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "target", "stmt")?,
                )?,
                op: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "op", "stmt")?)?,
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "stmt")?)?,
            }
        } else if _cls.is(NodeAnnAssign::static_type()) {
            ast::StmtKind::AnnAssign {
                target: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "target", "stmt")?,
                )?,
                annotation: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "annotation", "stmt")?,
                )?,
                value: get_node_field_opt(_vm, &_object, "value")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
                simple: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "simple", "stmt")?,
                )?,
            }
        } else if _cls.is(NodeFor::static_type()) {
            ast::StmtKind::For {
                target: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "target", "stmt")?,
                )?,
                iter: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "iter", "stmt")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                orelse: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "orelse", "stmt")?,
                )?,
                type_comment: get_node_field_opt(_vm, &_object, "type_comment")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
            }
        } else if _cls.is(NodeAsyncFor::static_type()) {
            ast::StmtKind::AsyncFor {
                target: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "target", "stmt")?,
                )?,
                iter: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "iter", "stmt")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                orelse: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "orelse", "stmt")?,
                )?,
                type_comment: get_node_field_opt(_vm, &_object, "type_comment")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
            }
        } else if _cls.is(NodeWhile::static_type()) {
            ast::StmtKind::While {
                test: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "test", "stmt")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                orelse: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "orelse", "stmt")?,
                )?,
            }
        } else if _cls.is(NodeIf::static_type()) {
            ast::StmtKind::If {
                test: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "test", "stmt")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                orelse: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "orelse", "stmt")?,
                )?,
            }
        } else if _cls.is(NodeWith::static_type()) {
            ast::StmtKind::With {
                items: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "items", "stmt")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                type_comment: get_node_field_opt(_vm, &_object, "type_comment")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
            }
        } else if _cls.is(NodeAsyncWith::static_type()) {
            ast::StmtKind::AsyncWith {
                items: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "items", "stmt")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                type_comment: get_node_field_opt(_vm, &_object, "type_comment")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
            }
        } else if _cls.is(NodeMatch::static_type()) {
            ast::StmtKind::Match {
                subject: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "subject", "stmt")?,
                )?,
                cases: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "cases", "stmt")?)?,
            }
        } else if _cls.is(NodeRaise::static_type()) {
            ast::StmtKind::Raise {
                exc: get_node_field_opt(_vm, &_object, "exc")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
                cause: get_node_field_opt(_vm, &_object, "cause")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
            }
        } else if _cls.is(NodeTry::static_type()) {
            ast::StmtKind::Try {
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                handlers: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "handlers", "stmt")?,
                )?,
                orelse: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "orelse", "stmt")?,
                )?,
                finalbody: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "finalbody", "stmt")?,
                )?,
            }
        } else if _cls.is(NodeTryStar::static_type()) {
            ast::StmtKind::TryStar {
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                handlers: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "handlers", "stmt")?,
                )?,
                orelse: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "orelse", "stmt")?,
                )?,
                finalbody: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "finalbody", "stmt")?,
                )?,
            }
        } else if _cls.is(NodeAssert::static_type()) {
            ast::StmtKind::Assert {
                test: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "test", "stmt")?)?,
                msg: get_node_field_opt(_vm, &_object, "msg")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
            }
        } else if _cls.is(NodeImport::static_type()) {
            ast::StmtKind::Import {
                names: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "names", "stmt")?)?,
            }
        } else if _cls.is(NodeImportFrom::static_type()) {
            ast::StmtKind::ImportFrom {
                module: get_node_field_opt(_vm, &_object, "module")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
                names: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "names", "stmt")?)?,
                level: get_node_field_opt(_vm, &_object, "level")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
            }
        } else if _cls.is(NodeGlobal::static_type()) {
            ast::StmtKind::Global {
                names: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "names", "stmt")?)?,
            }
        } else if _cls.is(NodeNonlocal::static_type()) {
            ast::StmtKind::Nonlocal {
                names: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "names", "stmt")?)?,
            }
        } else if _cls.is(NodeExpr::static_type()) {
            ast::StmtKind::Expr {
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "stmt")?)?,
            }
        } else if _cls.is(NodePass::static_type()) {
            ast::StmtKind::Pass {}
        } else if _cls.is(NodeBreak::static_type()) {
            ast::StmtKind::Break {}
        } else if _cls.is(NodeContinue::static_type()) {
            ast::StmtKind::Continue {}
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of stmt, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
impl NamedNode for ast::ExprKind {
    const NAME: &'static str = "expr";
}
impl Node for ast::ExprKind {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::ExprKind::BoolOp { op, values } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeBoolOp::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("op", op.ast_to_object(_vm), _vm).unwrap();
                _dict
                    .set_item("values", values.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::NamedExpr { target, value } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeNamedExpr::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("target", target.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("value", value.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::BinOp { left, op, right } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeBinOp::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("left", left.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict.set_item("op", op.ast_to_object(_vm), _vm).unwrap();
                _dict
                    .set_item("right", right.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::UnaryOp { op, operand } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeUnaryOp::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("op", op.ast_to_object(_vm), _vm).unwrap();
                _dict
                    .set_item("operand", operand.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::Lambda { args, body } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeLambda::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("args", args.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("body", body.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::IfExp { test, body, orelse } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeIfExp::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("test", test.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("body", body.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("orelse", orelse.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::Dict { keys, values } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeDict::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("keys", keys.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("values", values.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::Set { elts } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeSet::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("elts", elts.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::ListComp { elt, generators } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeListComp::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("elt", elt.ast_to_object(_vm), _vm).unwrap();
                _dict
                    .set_item("generators", generators.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::SetComp { elt, generators } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeSetComp::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("elt", elt.ast_to_object(_vm), _vm).unwrap();
                _dict
                    .set_item("generators", generators.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::DictComp {
                key,
                value,
                generators,
            } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeDictComp::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("key", key.ast_to_object(_vm), _vm).unwrap();
                _dict
                    .set_item("value", value.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("generators", generators.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::GeneratorExp { elt, generators } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeGeneratorExp::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("elt", elt.ast_to_object(_vm), _vm).unwrap();
                _dict
                    .set_item("generators", generators.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::Await { value } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeAwait::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("value", value.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::Yield { value } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeYield::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("value", value.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::YieldFrom { value } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeYieldFrom::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("value", value.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::Compare {
                left,
                ops,
                comparators,
            } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeCompare::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("left", left.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict.set_item("ops", ops.ast_to_object(_vm), _vm).unwrap();
                _dict
                    .set_item("comparators", comparators.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::Call {
                func,
                args,
                keywords,
            } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeCall::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("func", func.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("args", args.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("keywords", keywords.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::FormattedValue {
                value,
                conversion,
                format_spec,
            } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeFormattedValue::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("value", value.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("conversion", conversion.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("format_spec", format_spec.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::JoinedStr { values } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeJoinedStr::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("values", values.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::Constant { value, kind } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeConstant::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("value", value.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("kind", kind.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::ExprKind::Attribute { value, attr, ctx } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeAttribute::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("value", value.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("attr", attr.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
                _node.into()
            }
            ast::ExprKind::Subscript { value, slice, ctx } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeSubscript::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("value", value.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("slice", slice.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
                _node.into()
            }
            ast::ExprKind::Starred { value, ctx } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeStarred::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("value", value.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
                _node.into()
            }
            ast::ExprKind::Name { id, ctx } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeName::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("id", id.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
                _node.into()
            }
            ast::ExprKind::List { elts, ctx } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeList::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("elts", elts.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
                _node.into()
            }
            ast::ExprKind::Tuple { elts, ctx } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeTuple::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("elts", elts.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
                _node.into()
            }
            ast::ExprKind::Slice { lower, upper, step } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeSlice::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("lower", lower.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("upper", upper.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("step", step.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _location = ast::Location::new(
            Node::ast_from_object(_vm, get_node_field(_vm, &_object, "lineno", "expr")?)?,
            Node::ast_from_object(_vm, get_node_field(_vm, &_object, "col_offset", "expr")?)?,
        );
        let _cls = _object.class();
        Ok(if _cls.is(NodeBoolOp::static_type()) {
            ast::ExprKind::BoolOp {
                op: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "op", "expr")?)?,
                values: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "values", "expr")?,
                )?,
            }
        } else if _cls.is(NodeNamedExpr::static_type()) {
            ast::ExprKind::NamedExpr {
                target: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "target", "expr")?,
                )?,
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "expr")?)?,
            }
        } else if _cls.is(NodeBinOp::static_type()) {
            ast::ExprKind::BinOp {
                left: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "left", "expr")?)?,
                op: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "op", "expr")?)?,
                right: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "right", "expr")?)?,
            }
        } else if _cls.is(NodeUnaryOp::static_type()) {
            ast::ExprKind::UnaryOp {
                op: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "op", "expr")?)?,
                operand: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "operand", "expr")?,
                )?,
            }
        } else if _cls.is(NodeLambda::static_type()) {
            ast::ExprKind::Lambda {
                args: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "args", "expr")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "expr")?)?,
            }
        } else if _cls.is(NodeIfExp::static_type()) {
            ast::ExprKind::IfExp {
                test: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "test", "expr")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "expr")?)?,
                orelse: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "orelse", "expr")?,
                )?,
            }
        } else if _cls.is(NodeDict::static_type()) {
            ast::ExprKind::Dict {
                keys: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "keys", "expr")?)?,
                values: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "values", "expr")?,
                )?,
            }
        } else if _cls.is(NodeSet::static_type()) {
            ast::ExprKind::Set {
                elts: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "elts", "expr")?)?,
            }
        } else if _cls.is(NodeListComp::static_type()) {
            ast::ExprKind::ListComp {
                elt: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "elt", "expr")?)?,
                generators: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "generators", "expr")?,
                )?,
            }
        } else if _cls.is(NodeSetComp::static_type()) {
            ast::ExprKind::SetComp {
                elt: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "elt", "expr")?)?,
                generators: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "generators", "expr")?,
                )?,
            }
        } else if _cls.is(NodeDictComp::static_type()) {
            ast::ExprKind::DictComp {
                key: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "key", "expr")?)?,
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "expr")?)?,
                generators: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "generators", "expr")?,
                )?,
            }
        } else if _cls.is(NodeGeneratorExp::static_type()) {
            ast::ExprKind::GeneratorExp {
                elt: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "elt", "expr")?)?,
                generators: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "generators", "expr")?,
                )?,
            }
        } else if _cls.is(NodeAwait::static_type()) {
            ast::ExprKind::Await {
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "expr")?)?,
            }
        } else if _cls.is(NodeYield::static_type()) {
            ast::ExprKind::Yield {
                value: get_node_field_opt(_vm, &_object, "value")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
            }
        } else if _cls.is(NodeYieldFrom::static_type()) {
            ast::ExprKind::YieldFrom {
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "expr")?)?,
            }
        } else if _cls.is(NodeCompare::static_type()) {
            ast::ExprKind::Compare {
                left: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "left", "expr")?)?,
                ops: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ops", "expr")?)?,
                comparators: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "comparators", "expr")?,
                )?,
            }
        } else if _cls.is(NodeCall::static_type()) {
            ast::ExprKind::Call {
                func: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "func", "expr")?)?,
                args: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "args", "expr")?)?,
                keywords: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "keywords", "expr")?,
                )?,
            }
        } else if _cls.is(NodeFormattedValue::static_type()) {
            ast::ExprKind::FormattedValue {
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "expr")?)?,
                conversion: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "conversion", "expr")?,
                )?,
                format_spec: get_node_field_opt(_vm, &_object, "format_spec")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
            }
        } else if _cls.is(NodeJoinedStr::static_type()) {
            ast::ExprKind::JoinedStr {
                values: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "values", "expr")?,
                )?,
            }
        } else if _cls.is(NodeConstant::static_type()) {
            ast::ExprKind::Constant {
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "expr")?)?,
                kind: get_node_field_opt(_vm, &_object, "kind")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
            }
        } else if _cls.is(NodeAttribute::static_type()) {
            ast::ExprKind::Attribute {
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "expr")?)?,
                attr: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "attr", "expr")?)?,
                ctx: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ctx", "expr")?)?,
            }
        } else if _cls.is(NodeSubscript::static_type()) {
            ast::ExprKind::Subscript {
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "expr")?)?,
                slice: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "slice", "expr")?)?,
                ctx: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ctx", "expr")?)?,
            }
        } else if _cls.is(NodeStarred::static_type()) {
            ast::ExprKind::Starred {
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "expr")?)?,
                ctx: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ctx", "expr")?)?,
            }
        } else if _cls.is(NodeName::static_type()) {
            ast::ExprKind::Name {
                id: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "id", "expr")?)?,
                ctx: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ctx", "expr")?)?,
            }
        } else if _cls.is(NodeList::static_type()) {
            ast::ExprKind::List {
                elts: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "elts", "expr")?)?,
                ctx: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ctx", "expr")?)?,
            }
        } else if _cls.is(NodeTuple::static_type()) {
            ast::ExprKind::Tuple {
                elts: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "elts", "expr")?)?,
                ctx: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ctx", "expr")?)?,
            }
        } else if _cls.is(NodeSlice::static_type()) {
            ast::ExprKind::Slice {
                lower: get_node_field_opt(_vm, &_object, "lower")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
                upper: get_node_field_opt(_vm, &_object, "upper")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
                step: get_node_field_opt(_vm, &_object, "step")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
            }
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of expr, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
impl NamedNode for ast::ExprContext {
    const NAME: &'static str = "expr_context";
}
impl Node for ast::ExprContext {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::ExprContext::Load {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeLoad::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::ExprContext::Store {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeStore::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::ExprContext::Del {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeDel::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(if _cls.is(NodeLoad::static_type()) {
            ast::ExprContext::Load {}
        } else if _cls.is(NodeStore::static_type()) {
            ast::ExprContext::Store {}
        } else if _cls.is(NodeDel::static_type()) {
            ast::ExprContext::Del {}
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of expr_context, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
impl NamedNode for ast::Boolop {
    const NAME: &'static str = "boolop";
}
impl Node for ast::Boolop {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::Boolop::And {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeAnd::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Boolop::Or {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeOr::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(if _cls.is(NodeAnd::static_type()) {
            ast::Boolop::And {}
        } else if _cls.is(NodeOr::static_type()) {
            ast::Boolop::Or {}
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of boolop, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
impl NamedNode for ast::Operator {
    const NAME: &'static str = "operator";
}
impl Node for ast::Operator {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::Operator::Add {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeAdd::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Operator::Sub {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeSub::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Operator::Mult {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeMult::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Operator::MatMult {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeMatMult::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Operator::Div {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeDiv::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Operator::Mod {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeMod::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Operator::Pow {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodePow::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Operator::LShift {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeLShift::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Operator::RShift {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeRShift::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Operator::BitOr {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeBitOr::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Operator::BitXor {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeBitXor::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Operator::BitAnd {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeBitAnd::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Operator::FloorDiv {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeFloorDiv::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(if _cls.is(NodeAdd::static_type()) {
            ast::Operator::Add {}
        } else if _cls.is(NodeSub::static_type()) {
            ast::Operator::Sub {}
        } else if _cls.is(NodeMult::static_type()) {
            ast::Operator::Mult {}
        } else if _cls.is(NodeMatMult::static_type()) {
            ast::Operator::MatMult {}
        } else if _cls.is(NodeDiv::static_type()) {
            ast::Operator::Div {}
        } else if _cls.is(NodeMod::static_type()) {
            ast::Operator::Mod {}
        } else if _cls.is(NodePow::static_type()) {
            ast::Operator::Pow {}
        } else if _cls.is(NodeLShift::static_type()) {
            ast::Operator::LShift {}
        } else if _cls.is(NodeRShift::static_type()) {
            ast::Operator::RShift {}
        } else if _cls.is(NodeBitOr::static_type()) {
            ast::Operator::BitOr {}
        } else if _cls.is(NodeBitXor::static_type()) {
            ast::Operator::BitXor {}
        } else if _cls.is(NodeBitAnd::static_type()) {
            ast::Operator::BitAnd {}
        } else if _cls.is(NodeFloorDiv::static_type()) {
            ast::Operator::FloorDiv {}
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of operator, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
impl NamedNode for ast::Unaryop {
    const NAME: &'static str = "unaryop";
}
impl Node for ast::Unaryop {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::Unaryop::Invert {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeInvert::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Unaryop::Not {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeNot::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Unaryop::UAdd {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeUAdd::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Unaryop::USub {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeUSub::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(if _cls.is(NodeInvert::static_type()) {
            ast::Unaryop::Invert {}
        } else if _cls.is(NodeNot::static_type()) {
            ast::Unaryop::Not {}
        } else if _cls.is(NodeUAdd::static_type()) {
            ast::Unaryop::UAdd {}
        } else if _cls.is(NodeUSub::static_type()) {
            ast::Unaryop::USub {}
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of unaryop, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
impl NamedNode for ast::Cmpop {
    const NAME: &'static str = "cmpop";
}
impl Node for ast::Cmpop {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::Cmpop::Eq {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeEq::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Cmpop::NotEq {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeNotEq::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Cmpop::Lt {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeLt::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Cmpop::LtE {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeLtE::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Cmpop::Gt {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeGt::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Cmpop::GtE {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeGtE::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Cmpop::Is {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeIs::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Cmpop::IsNot {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeIsNot::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Cmpop::In {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeIn::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
            ast::Cmpop::NotIn {} => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeNotIn::static_type().to_owned())
                    .unwrap();
                _node.into()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(if _cls.is(NodeEq::static_type()) {
            ast::Cmpop::Eq {}
        } else if _cls.is(NodeNotEq::static_type()) {
            ast::Cmpop::NotEq {}
        } else if _cls.is(NodeLt::static_type()) {
            ast::Cmpop::Lt {}
        } else if _cls.is(NodeLtE::static_type()) {
            ast::Cmpop::LtE {}
        } else if _cls.is(NodeGt::static_type()) {
            ast::Cmpop::Gt {}
        } else if _cls.is(NodeGtE::static_type()) {
            ast::Cmpop::GtE {}
        } else if _cls.is(NodeIs::static_type()) {
            ast::Cmpop::Is {}
        } else if _cls.is(NodeIsNot::static_type()) {
            ast::Cmpop::IsNot {}
        } else if _cls.is(NodeIn::static_type()) {
            ast::Cmpop::In {}
        } else if _cls.is(NodeNotIn::static_type()) {
            ast::Cmpop::NotIn {}
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of cmpop, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
impl NamedNode for ast::Comprehension {
    const NAME: &'static str = "comprehension";
}
impl Node for ast::Comprehension {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::Comprehension {
            target,
            iter,
            ifs,
            is_async,
        } = self;
        let _node = AstNode
            .into_ref_with_type(_vm, NodeComprehension::static_type().to_owned())
            .unwrap();
        let _dict = _node.as_object().dict().unwrap();
        _dict
            .set_item("target", target.ast_to_object(_vm), _vm)
            .unwrap();
        _dict
            .set_item("iter", iter.ast_to_object(_vm), _vm)
            .unwrap();
        _dict.set_item("ifs", ifs.ast_to_object(_vm), _vm).unwrap();
        _dict
            .set_item("is_async", is_async.ast_to_object(_vm), _vm)
            .unwrap();
        _node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::Comprehension {
            target: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "target", "comprehension")?,
            )?,
            iter: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "iter", "comprehension")?,
            )?,
            ifs: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "ifs", "comprehension")?,
            )?,
            is_async: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "is_async", "comprehension")?,
            )?,
        })
    }
}
impl NamedNode for ast::ExcepthandlerKind {
    const NAME: &'static str = "excepthandler";
}
impl Node for ast::ExcepthandlerKind {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::ExcepthandlerKind::ExceptHandler { type_, name, body } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeExceptHandler::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("type", type_.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("name", name.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("body", body.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _location = ast::Location::new(
            Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "lineno", "excepthandler")?,
            )?,
            Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "col_offset", "excepthandler")?,
            )?,
        );
        let _cls = _object.class();
        Ok(if _cls.is(NodeExceptHandler::static_type()) {
            ast::ExcepthandlerKind::ExceptHandler {
                type_: get_node_field_opt(_vm, &_object, "type")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
                name: get_node_field_opt(_vm, &_object, "name")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
                body: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "body", "excepthandler")?,
                )?,
            }
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of excepthandler, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
impl NamedNode for ast::Arguments {
    const NAME: &'static str = "arguments";
}
impl Node for ast::Arguments {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::Arguments {
            posonlyargs,
            args,
            vararg,
            kwonlyargs,
            kw_defaults,
            kwarg,
            defaults,
        } = self;
        let _node = AstNode
            .into_ref_with_type(_vm, NodeArguments::static_type().to_owned())
            .unwrap();
        let _dict = _node.as_object().dict().unwrap();
        _dict
            .set_item("posonlyargs", posonlyargs.ast_to_object(_vm), _vm)
            .unwrap();
        _dict
            .set_item("args", args.ast_to_object(_vm), _vm)
            .unwrap();
        _dict
            .set_item("vararg", vararg.ast_to_object(_vm), _vm)
            .unwrap();
        _dict
            .set_item("kwonlyargs", kwonlyargs.ast_to_object(_vm), _vm)
            .unwrap();
        _dict
            .set_item("kw_defaults", kw_defaults.ast_to_object(_vm), _vm)
            .unwrap();
        _dict
            .set_item("kwarg", kwarg.ast_to_object(_vm), _vm)
            .unwrap();
        _dict
            .set_item("defaults", defaults.ast_to_object(_vm), _vm)
            .unwrap();
        _node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::Arguments {
            posonlyargs: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "posonlyargs", "arguments")?,
            )?,
            args: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "args", "arguments")?)?,
            vararg: get_node_field_opt(_vm, &_object, "vararg")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            kwonlyargs: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "kwonlyargs", "arguments")?,
            )?,
            kw_defaults: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "kw_defaults", "arguments")?,
            )?,
            kwarg: get_node_field_opt(_vm, &_object, "kwarg")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            defaults: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "defaults", "arguments")?,
            )?,
        })
    }
}
impl NamedNode for ast::ArgData {
    const NAME: &'static str = "arg";
}
impl Node for ast::ArgData {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::ArgData {
            arg,
            annotation,
            type_comment,
        } = self;
        let _node = AstNode
            .into_ref_with_type(_vm, NodeArg::static_type().to_owned())
            .unwrap();
        let _dict = _node.as_object().dict().unwrap();
        _dict.set_item("arg", arg.ast_to_object(_vm), _vm).unwrap();
        _dict
            .set_item("annotation", annotation.ast_to_object(_vm), _vm)
            .unwrap();
        _dict
            .set_item("type_comment", type_comment.ast_to_object(_vm), _vm)
            .unwrap();
        _node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _location = ast::Location::new(
            Node::ast_from_object(_vm, get_node_field(_vm, &_object, "lineno", "arg")?)?,
            Node::ast_from_object(_vm, get_node_field(_vm, &_object, "col_offset", "arg")?)?,
        );
        Ok(ast::ArgData {
            arg: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "arg", "arg")?)?,
            annotation: get_node_field_opt(_vm, &_object, "annotation")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            type_comment: get_node_field_opt(_vm, &_object, "type_comment")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
        })
    }
}
impl NamedNode for ast::KeywordData {
    const NAME: &'static str = "keyword";
}
impl Node for ast::KeywordData {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::KeywordData { arg, value } = self;
        let _node = AstNode
            .into_ref_with_type(_vm, NodeKeyword::static_type().to_owned())
            .unwrap();
        let _dict = _node.as_object().dict().unwrap();
        _dict.set_item("arg", arg.ast_to_object(_vm), _vm).unwrap();
        _dict
            .set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        _node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _location = ast::Location::new(
            Node::ast_from_object(_vm, get_node_field(_vm, &_object, "lineno", "keyword")?)?,
            Node::ast_from_object(_vm, get_node_field(_vm, &_object, "col_offset", "keyword")?)?,
        );
        Ok(ast::KeywordData {
            arg: get_node_field_opt(_vm, &_object, "arg")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "keyword")?)?,
        })
    }
}
impl NamedNode for ast::AliasData {
    const NAME: &'static str = "alias";
}
impl Node for ast::AliasData {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::AliasData { name, asname } = self;
        let _node = AstNode
            .into_ref_with_type(_vm, NodeAlias::static_type().to_owned())
            .unwrap();
        let _dict = _node.as_object().dict().unwrap();
        _dict
            .set_item("name", name.ast_to_object(_vm), _vm)
            .unwrap();
        _dict
            .set_item("asname", asname.ast_to_object(_vm), _vm)
            .unwrap();
        _node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _location = ast::Location::new(
            Node::ast_from_object(_vm, get_node_field(_vm, &_object, "lineno", "alias")?)?,
            Node::ast_from_object(_vm, get_node_field(_vm, &_object, "col_offset", "alias")?)?,
        );
        Ok(ast::AliasData {
            name: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "name", "alias")?)?,
            asname: get_node_field_opt(_vm, &_object, "asname")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
        })
    }
}
impl NamedNode for ast::Withitem {
    const NAME: &'static str = "withitem";
}
impl Node for ast::Withitem {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::Withitem {
            context_expr,
            optional_vars,
        } = self;
        let _node = AstNode
            .into_ref_with_type(_vm, NodeWithitem::static_type().to_owned())
            .unwrap();
        let _dict = _node.as_object().dict().unwrap();
        _dict
            .set_item("context_expr", context_expr.ast_to_object(_vm), _vm)
            .unwrap();
        _dict
            .set_item("optional_vars", optional_vars.ast_to_object(_vm), _vm)
            .unwrap();
        _node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::Withitem {
            context_expr: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "context_expr", "withitem")?,
            )?,
            optional_vars: get_node_field_opt(_vm, &_object, "optional_vars")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
        })
    }
}
impl NamedNode for ast::MatchCase {
    const NAME: &'static str = "match_case";
}
impl Node for ast::MatchCase {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::MatchCase {
            pattern,
            guard,
            body,
        } = self;
        let _node = AstNode
            .into_ref_with_type(_vm, NodeMatchCase::static_type().to_owned())
            .unwrap();
        let _dict = _node.as_object().dict().unwrap();
        _dict
            .set_item("pattern", pattern.ast_to_object(_vm), _vm)
            .unwrap();
        _dict
            .set_item("guard", guard.ast_to_object(_vm), _vm)
            .unwrap();
        _dict
            .set_item("body", body.ast_to_object(_vm), _vm)
            .unwrap();
        _node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::MatchCase {
            pattern: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "pattern", "match_case")?,
            )?,
            guard: get_node_field_opt(_vm, &_object, "guard")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "match_case")?)?,
        })
    }
}
impl NamedNode for ast::PatternKind {
    const NAME: &'static str = "pattern";
}
impl Node for ast::PatternKind {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::PatternKind::MatchValue { value } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeMatchValue::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("value", value.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::PatternKind::MatchSingleton { value } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeMatchSingleton::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("value", value.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::PatternKind::MatchSequence { patterns } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeMatchSequence::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("patterns", patterns.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::PatternKind::MatchMapping {
                keys,
                patterns,
                rest,
            } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeMatchMapping::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("keys", keys.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("patterns", patterns.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("rest", rest.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::PatternKind::MatchClass {
                cls,
                patterns,
                kwd_attrs,
                kwd_patterns,
            } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeMatchClass::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("cls", cls.ast_to_object(_vm), _vm).unwrap();
                _dict
                    .set_item("patterns", patterns.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("kwd_attrs", kwd_attrs.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("kwd_patterns", kwd_patterns.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::PatternKind::MatchStar { name } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeMatchStar::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("name", name.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::PatternKind::MatchAs { pattern, name } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeMatchAs::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("pattern", pattern.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict
                    .set_item("name", name.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
            ast::PatternKind::MatchOr { patterns } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeMatchOr::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("patterns", patterns.ast_to_object(_vm), _vm)
                    .unwrap();
                _node.into()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _location = ast::Location::new(
            Node::ast_from_object(_vm, get_node_field(_vm, &_object, "lineno", "pattern")?)?,
            Node::ast_from_object(_vm, get_node_field(_vm, &_object, "col_offset", "pattern")?)?,
        );
        let _cls = _object.class();
        Ok(if _cls.is(NodeMatchValue::static_type()) {
            ast::PatternKind::MatchValue {
                value: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "value", "pattern")?,
                )?,
            }
        } else if _cls.is(NodeMatchSingleton::static_type()) {
            ast::PatternKind::MatchSingleton {
                value: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "value", "pattern")?,
                )?,
            }
        } else if _cls.is(NodeMatchSequence::static_type()) {
            ast::PatternKind::MatchSequence {
                patterns: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "patterns", "pattern")?,
                )?,
            }
        } else if _cls.is(NodeMatchMapping::static_type()) {
            ast::PatternKind::MatchMapping {
                keys: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "keys", "pattern")?,
                )?,
                patterns: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "patterns", "pattern")?,
                )?,
                rest: get_node_field_opt(_vm, &_object, "rest")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
            }
        } else if _cls.is(NodeMatchClass::static_type()) {
            ast::PatternKind::MatchClass {
                cls: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "cls", "pattern")?)?,
                patterns: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "patterns", "pattern")?,
                )?,
                kwd_attrs: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "kwd_attrs", "pattern")?,
                )?,
                kwd_patterns: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "kwd_patterns", "pattern")?,
                )?,
            }
        } else if _cls.is(NodeMatchStar::static_type()) {
            ast::PatternKind::MatchStar {
                name: get_node_field_opt(_vm, &_object, "name")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
            }
        } else if _cls.is(NodeMatchAs::static_type()) {
            ast::PatternKind::MatchAs {
                pattern: get_node_field_opt(_vm, &_object, "pattern")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
                name: get_node_field_opt(_vm, &_object, "name")?
                    .map(|obj| Node::ast_from_object(_vm, obj))
                    .transpose()?,
            }
        } else if _cls.is(NodeMatchOr::static_type()) {
            ast::PatternKind::MatchOr {
                patterns: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "patterns", "pattern")?,
                )?,
            }
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of pattern, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
impl NamedNode for ast::TypeIgnore {
    const NAME: &'static str = "type_ignore";
}
impl Node for ast::TypeIgnore {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::TypeIgnore::TypeIgnore { lineno, tag } => {
                let _node = AstNode
                    .into_ref_with_type(_vm, NodeTypeIgnore::static_type().to_owned())
                    .unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict
                    .set_item("lineno", lineno.ast_to_object(_vm), _vm)
                    .unwrap();
                _dict.set_item("tag", tag.ast_to_object(_vm), _vm).unwrap();
                _node.into()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(if _cls.is(NodeTypeIgnore::static_type()) {
            ast::TypeIgnore::TypeIgnore {
                lineno: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "lineno", "type_ignore")?,
                )?,
                tag: Node::ast_from_object(
                    _vm,
                    get_node_field(_vm, &_object, "tag", "type_ignore")?,
                )?,
            }
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of type_ignore, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}

pub fn extend_module_nodes(vm: &VirtualMachine, module: &Py<PyModule>) {
    extend_module!(vm, module, {
        "mod" => NodeKindMod::make_class(&vm.ctx),
        "Module" => NodeModule::make_class(&vm.ctx),
        "Interactive" => NodeInteractive::make_class(&vm.ctx),
        "Expression" => NodeExpression::make_class(&vm.ctx),
        "FunctionType" => NodeFunctionType::make_class(&vm.ctx),
        "stmt" => NodeKindStmt::make_class(&vm.ctx),
        "FunctionDef" => NodeFunctionDef::make_class(&vm.ctx),
        "AsyncFunctionDef" => NodeAsyncFunctionDef::make_class(&vm.ctx),
        "ClassDef" => NodeClassDef::make_class(&vm.ctx),
        "Return" => NodeReturn::make_class(&vm.ctx),
        "Delete" => NodeDelete::make_class(&vm.ctx),
        "Assign" => NodeAssign::make_class(&vm.ctx),
        "AugAssign" => NodeAugAssign::make_class(&vm.ctx),
        "AnnAssign" => NodeAnnAssign::make_class(&vm.ctx),
        "For" => NodeFor::make_class(&vm.ctx),
        "AsyncFor" => NodeAsyncFor::make_class(&vm.ctx),
        "While" => NodeWhile::make_class(&vm.ctx),
        "If" => NodeIf::make_class(&vm.ctx),
        "With" => NodeWith::make_class(&vm.ctx),
        "AsyncWith" => NodeAsyncWith::make_class(&vm.ctx),
        "Match" => NodeMatch::make_class(&vm.ctx),
        "Raise" => NodeRaise::make_class(&vm.ctx),
        "Try" => NodeTry::make_class(&vm.ctx),
        "TryStar" => NodeTryStar::make_class(&vm.ctx),
        "Assert" => NodeAssert::make_class(&vm.ctx),
        "Import" => NodeImport::make_class(&vm.ctx),
        "ImportFrom" => NodeImportFrom::make_class(&vm.ctx),
        "Global" => NodeGlobal::make_class(&vm.ctx),
        "Nonlocal" => NodeNonlocal::make_class(&vm.ctx),
        "Expr" => NodeExpr::make_class(&vm.ctx),
        "Pass" => NodePass::make_class(&vm.ctx),
        "Break" => NodeBreak::make_class(&vm.ctx),
        "Continue" => NodeContinue::make_class(&vm.ctx),
        "expr" => NodeKindExpr::make_class(&vm.ctx),
        "BoolOp" => NodeBoolOp::make_class(&vm.ctx),
        "NamedExpr" => NodeNamedExpr::make_class(&vm.ctx),
        "BinOp" => NodeBinOp::make_class(&vm.ctx),
        "UnaryOp" => NodeUnaryOp::make_class(&vm.ctx),
        "Lambda" => NodeLambda::make_class(&vm.ctx),
        "IfExp" => NodeIfExp::make_class(&vm.ctx),
        "Dict" => NodeDict::make_class(&vm.ctx),
        "Set" => NodeSet::make_class(&vm.ctx),
        "ListComp" => NodeListComp::make_class(&vm.ctx),
        "SetComp" => NodeSetComp::make_class(&vm.ctx),
        "DictComp" => NodeDictComp::make_class(&vm.ctx),
        "GeneratorExp" => NodeGeneratorExp::make_class(&vm.ctx),
        "Await" => NodeAwait::make_class(&vm.ctx),
        "Yield" => NodeYield::make_class(&vm.ctx),
        "YieldFrom" => NodeYieldFrom::make_class(&vm.ctx),
        "Compare" => NodeCompare::make_class(&vm.ctx),
        "Call" => NodeCall::make_class(&vm.ctx),
        "FormattedValue" => NodeFormattedValue::make_class(&vm.ctx),
        "JoinedStr" => NodeJoinedStr::make_class(&vm.ctx),
        "Constant" => NodeConstant::make_class(&vm.ctx),
        "Attribute" => NodeAttribute::make_class(&vm.ctx),
        "Subscript" => NodeSubscript::make_class(&vm.ctx),
        "Starred" => NodeStarred::make_class(&vm.ctx),
        "Name" => NodeName::make_class(&vm.ctx),
        "List" => NodeList::make_class(&vm.ctx),
        "Tuple" => NodeTuple::make_class(&vm.ctx),
        "Slice" => NodeSlice::make_class(&vm.ctx),
        "expr_context" => NodeKindExprContext::make_class(&vm.ctx),
        "Load" => NodeLoad::make_class(&vm.ctx),
        "Store" => NodeStore::make_class(&vm.ctx),
        "Del" => NodeDel::make_class(&vm.ctx),
        "boolop" => NodeKindBoolop::make_class(&vm.ctx),
        "And" => NodeAnd::make_class(&vm.ctx),
        "Or" => NodeOr::make_class(&vm.ctx),
        "operator" => NodeKindOperator::make_class(&vm.ctx),
        "Add" => NodeAdd::make_class(&vm.ctx),
        "Sub" => NodeSub::make_class(&vm.ctx),
        "Mult" => NodeMult::make_class(&vm.ctx),
        "MatMult" => NodeMatMult::make_class(&vm.ctx),
        "Div" => NodeDiv::make_class(&vm.ctx),
        "Mod" => NodeMod::make_class(&vm.ctx),
        "Pow" => NodePow::make_class(&vm.ctx),
        "LShift" => NodeLShift::make_class(&vm.ctx),
        "RShift" => NodeRShift::make_class(&vm.ctx),
        "BitOr" => NodeBitOr::make_class(&vm.ctx),
        "BitXor" => NodeBitXor::make_class(&vm.ctx),
        "BitAnd" => NodeBitAnd::make_class(&vm.ctx),
        "FloorDiv" => NodeFloorDiv::make_class(&vm.ctx),
        "unaryop" => NodeKindUnaryop::make_class(&vm.ctx),
        "Invert" => NodeInvert::make_class(&vm.ctx),
        "Not" => NodeNot::make_class(&vm.ctx),
        "UAdd" => NodeUAdd::make_class(&vm.ctx),
        "USub" => NodeUSub::make_class(&vm.ctx),
        "cmpop" => NodeKindCmpop::make_class(&vm.ctx),
        "Eq" => NodeEq::make_class(&vm.ctx),
        "NotEq" => NodeNotEq::make_class(&vm.ctx),
        "Lt" => NodeLt::make_class(&vm.ctx),
        "LtE" => NodeLtE::make_class(&vm.ctx),
        "Gt" => NodeGt::make_class(&vm.ctx),
        "GtE" => NodeGtE::make_class(&vm.ctx),
        "Is" => NodeIs::make_class(&vm.ctx),
        "IsNot" => NodeIsNot::make_class(&vm.ctx),
        "In" => NodeIn::make_class(&vm.ctx),
        "NotIn" => NodeNotIn::make_class(&vm.ctx),
        "comprehension" => NodeComprehension::make_class(&vm.ctx),
        "excepthandler" => NodeKindExcepthandler::make_class(&vm.ctx),
        "ExceptHandler" => NodeExceptHandler::make_class(&vm.ctx),
        "arguments" => NodeArguments::make_class(&vm.ctx),
        "arg" => NodeArg::make_class(&vm.ctx),
        "keyword" => NodeKeyword::make_class(&vm.ctx),
        "alias" => NodeAlias::make_class(&vm.ctx),
        "withitem" => NodeWithitem::make_class(&vm.ctx),
        "match_case" => NodeMatchCase::make_class(&vm.ctx),
        "pattern" => NodeKindPattern::make_class(&vm.ctx),
        "MatchValue" => NodeMatchValue::make_class(&vm.ctx),
        "MatchSingleton" => NodeMatchSingleton::make_class(&vm.ctx),
        "MatchSequence" => NodeMatchSequence::make_class(&vm.ctx),
        "MatchMapping" => NodeMatchMapping::make_class(&vm.ctx),
        "MatchClass" => NodeMatchClass::make_class(&vm.ctx),
        "MatchStar" => NodeMatchStar::make_class(&vm.ctx),
        "MatchAs" => NodeMatchAs::make_class(&vm.ctx),
        "MatchOr" => NodeMatchOr::make_class(&vm.ctx),
        "type_ignore" => NodeKindTypeIgnore::make_class(&vm.ctx),
        "TypeIgnore" => NodeTypeIgnore::make_class(&vm.ctx),
    })
}
