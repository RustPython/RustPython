// File automatically generated by ast/asdl_rs.py.

use super::*;
use crate::common::ascii;

#[pyclass(module = "_ast", name = "Module", base = "AstNode")]
struct NodeModule;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeModule {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("body")),ctx.new_ascii_literal(ascii!("type_ignores"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Interactive", base = "AstNode")]
struct NodeInteractive;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeInteractive {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("body"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Expression", base = "AstNode")]
struct NodeExpression;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeExpression {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("body"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "FunctionType", base = "AstNode")]
struct NodeFunctionType;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeFunctionType {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("argtypes")),ctx.new_ascii_literal(ascii!("returns"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "FunctionDef", base = "AstNode")]
struct NodeFunctionDef;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeFunctionDef {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("name")),ctx.new_ascii_literal(ascii!("args")),ctx.new_ascii_literal(ascii!("body")),ctx.new_ascii_literal(ascii!("decorator_list")),ctx.new_ascii_literal(ascii!("returns")),ctx.new_ascii_literal(ascii!("type_comment"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "AsyncFunctionDef", base = "AstNode")]
struct NodeAsyncFunctionDef;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeAsyncFunctionDef {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("name")),ctx.new_ascii_literal(ascii!("args")),ctx.new_ascii_literal(ascii!("body")),ctx.new_ascii_literal(ascii!("decorator_list")),ctx.new_ascii_literal(ascii!("returns")),ctx.new_ascii_literal(ascii!("type_comment"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "ClassDef", base = "AstNode")]
struct NodeClassDef;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeClassDef {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("name")),ctx.new_ascii_literal(ascii!("bases")),ctx.new_ascii_literal(ascii!("keywords")),ctx.new_ascii_literal(ascii!("body")),ctx.new_ascii_literal(ascii!("decorator_list"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Return", base = "AstNode")]
struct NodeReturn;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeReturn {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("value"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Delete", base = "AstNode")]
struct NodeDelete;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeDelete {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("targets"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Assign", base = "AstNode")]
struct NodeAssign;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeAssign {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("targets")),ctx.new_ascii_literal(ascii!("value")),ctx.new_ascii_literal(ascii!("type_comment"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "AugAssign", base = "AstNode")]
struct NodeAugAssign;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeAugAssign {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("target")),ctx.new_ascii_literal(ascii!("op")),ctx.new_ascii_literal(ascii!("value"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "AnnAssign", base = "AstNode")]
struct NodeAnnAssign;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeAnnAssign {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("target")),ctx.new_ascii_literal(ascii!("annotation")),ctx.new_ascii_literal(ascii!("value")),ctx.new_ascii_literal(ascii!("simple"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "For", base = "AstNode")]
struct NodeFor;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeFor {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("target")),ctx.new_ascii_literal(ascii!("iter")),ctx.new_ascii_literal(ascii!("body")),ctx.new_ascii_literal(ascii!("orelse")),ctx.new_ascii_literal(ascii!("type_comment"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "AsyncFor", base = "AstNode")]
struct NodeAsyncFor;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeAsyncFor {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("target")),ctx.new_ascii_literal(ascii!("iter")),ctx.new_ascii_literal(ascii!("body")),ctx.new_ascii_literal(ascii!("orelse")),ctx.new_ascii_literal(ascii!("type_comment"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "While", base = "AstNode")]
struct NodeWhile;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeWhile {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("test")),ctx.new_ascii_literal(ascii!("body")),ctx.new_ascii_literal(ascii!("orelse"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "If", base = "AstNode")]
struct NodeIf;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeIf {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("test")),ctx.new_ascii_literal(ascii!("body")),ctx.new_ascii_literal(ascii!("orelse"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "With", base = "AstNode")]
struct NodeWith;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeWith {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("items")),ctx.new_ascii_literal(ascii!("body")),ctx.new_ascii_literal(ascii!("type_comment"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "AsyncWith", base = "AstNode")]
struct NodeAsyncWith;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeAsyncWith {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("items")),ctx.new_ascii_literal(ascii!("body")),ctx.new_ascii_literal(ascii!("type_comment"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Raise", base = "AstNode")]
struct NodeRaise;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeRaise {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("exc")),ctx.new_ascii_literal(ascii!("cause"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Try", base = "AstNode")]
struct NodeTry;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeTry {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("body")),ctx.new_ascii_literal(ascii!("handlers")),ctx.new_ascii_literal(ascii!("orelse")),ctx.new_ascii_literal(ascii!("finalbody"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Assert", base = "AstNode")]
struct NodeAssert;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeAssert {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("test")),ctx.new_ascii_literal(ascii!("msg"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Import", base = "AstNode")]
struct NodeImport;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeImport {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("names"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "ImportFrom", base = "AstNode")]
struct NodeImportFrom;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeImportFrom {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("module")),ctx.new_ascii_literal(ascii!("names")),ctx.new_ascii_literal(ascii!("level"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Global", base = "AstNode")]
struct NodeGlobal;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeGlobal {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("names"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Nonlocal", base = "AstNode")]
struct NodeNonlocal;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeNonlocal {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("names"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Expr", base = "AstNode")]
struct NodeExpr;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeExpr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("value"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Pass", base = "AstNode")]
struct NodePass;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodePass {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Break", base = "AstNode")]
struct NodeBreak;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeBreak {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Continue", base = "AstNode")]
struct NodeContinue;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeContinue {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "BoolOp", base = "AstNode")]
struct NodeBoolOp;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeBoolOp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("op")),ctx.new_ascii_literal(ascii!("values"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "NamedExpr", base = "AstNode")]
struct NodeNamedExpr;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeNamedExpr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("target")),ctx.new_ascii_literal(ascii!("value"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "BinOp", base = "AstNode")]
struct NodeBinOp;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeBinOp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("left")),ctx.new_ascii_literal(ascii!("op")),ctx.new_ascii_literal(ascii!("right"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "UnaryOp", base = "AstNode")]
struct NodeUnaryOp;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeUnaryOp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("op")),ctx.new_ascii_literal(ascii!("operand"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Lambda", base = "AstNode")]
struct NodeLambda;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeLambda {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("args")),ctx.new_ascii_literal(ascii!("body"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "IfExp", base = "AstNode")]
struct NodeIfExp;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeIfExp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("test")),ctx.new_ascii_literal(ascii!("body")),ctx.new_ascii_literal(ascii!("orelse"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Dict", base = "AstNode")]
struct NodeDict;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeDict {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("keys")),ctx.new_ascii_literal(ascii!("values"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Set", base = "AstNode")]
struct NodeSet;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeSet {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("elts"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "ListComp", base = "AstNode")]
struct NodeListComp;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeListComp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("elt")),ctx.new_ascii_literal(ascii!("generators"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "SetComp", base = "AstNode")]
struct NodeSetComp;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeSetComp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("elt")),ctx.new_ascii_literal(ascii!("generators"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "DictComp", base = "AstNode")]
struct NodeDictComp;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeDictComp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("key")),ctx.new_ascii_literal(ascii!("value")),ctx.new_ascii_literal(ascii!("generators"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "GeneratorExp", base = "AstNode")]
struct NodeGeneratorExp;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeGeneratorExp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("elt")),ctx.new_ascii_literal(ascii!("generators"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Await", base = "AstNode")]
struct NodeAwait;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeAwait {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("value"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Yield", base = "AstNode")]
struct NodeYield;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeYield {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("value"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "YieldFrom", base = "AstNode")]
struct NodeYieldFrom;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeYieldFrom {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("value"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Compare", base = "AstNode")]
struct NodeCompare;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeCompare {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("left")),ctx.new_ascii_literal(ascii!("ops")),ctx.new_ascii_literal(ascii!("comparators"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Call", base = "AstNode")]
struct NodeCall;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeCall {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("func")),ctx.new_ascii_literal(ascii!("args")),ctx.new_ascii_literal(ascii!("keywords"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "FormattedValue", base = "AstNode")]
struct NodeFormattedValue;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeFormattedValue {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("value")),ctx.new_ascii_literal(ascii!("conversion")),ctx.new_ascii_literal(ascii!("format_spec"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "JoinedStr", base = "AstNode")]
struct NodeJoinedStr;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeJoinedStr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("values"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Constant", base = "AstNode")]
struct NodeConstant;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeConstant {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("value")),ctx.new_ascii_literal(ascii!("kind"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Attribute", base = "AstNode")]
struct NodeAttribute;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeAttribute {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("value")),ctx.new_ascii_literal(ascii!("attr")),ctx.new_ascii_literal(ascii!("ctx"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Subscript", base = "AstNode")]
struct NodeSubscript;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeSubscript {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("value")),ctx.new_ascii_literal(ascii!("slice")),ctx.new_ascii_literal(ascii!("ctx"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Starred", base = "AstNode")]
struct NodeStarred;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeStarred {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("value")),ctx.new_ascii_literal(ascii!("ctx"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Name", base = "AstNode")]
struct NodeName;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeName {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("id")),ctx.new_ascii_literal(ascii!("ctx"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "List", base = "AstNode")]
struct NodeList;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeList {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("elts")),ctx.new_ascii_literal(ascii!("ctx"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Tuple", base = "AstNode")]
struct NodeTuple;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeTuple {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("elts")),ctx.new_ascii_literal(ascii!("ctx"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Slice", base = "AstNode")]
struct NodeSlice;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeSlice {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lower")),ctx.new_ascii_literal(ascii!("upper")),ctx.new_ascii_literal(ascii!("step"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "Load", base = "AstNode")]
struct NodeLoad;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeLoad {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Store", base = "AstNode")]
struct NodeStore;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeStore {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Del", base = "AstNode")]
struct NodeDel;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeDel {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "And", base = "AstNode")]
struct NodeAnd;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeAnd {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Or", base = "AstNode")]
struct NodeOr;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeOr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Add", base = "AstNode")]
struct NodeAdd;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeAdd {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Sub", base = "AstNode")]
struct NodeSub;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeSub {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Mult", base = "AstNode")]
struct NodeMult;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeMult {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "MatMult", base = "AstNode")]
struct NodeMatMult;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeMatMult {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Div", base = "AstNode")]
struct NodeDiv;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeDiv {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Mod", base = "AstNode")]
struct NodeMod;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeMod {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Pow", base = "AstNode")]
struct NodePow;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodePow {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "LShift", base = "AstNode")]
struct NodeLShift;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeLShift {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "RShift", base = "AstNode")]
struct NodeRShift;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeRShift {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "BitOr", base = "AstNode")]
struct NodeBitOr;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeBitOr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "BitXor", base = "AstNode")]
struct NodeBitXor;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeBitXor {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "BitAnd", base = "AstNode")]
struct NodeBitAnd;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeBitAnd {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "FloorDiv", base = "AstNode")]
struct NodeFloorDiv;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeFloorDiv {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Invert", base = "AstNode")]
struct NodeInvert;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeInvert {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Not", base = "AstNode")]
struct NodeNot;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeNot {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "UAdd", base = "AstNode")]
struct NodeUAdd;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeUAdd {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "USub", base = "AstNode")]
struct NodeUSub;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeUSub {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Eq", base = "AstNode")]
struct NodeEq;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeEq {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "NotEq", base = "AstNode")]
struct NodeNotEq;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeNotEq {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Lt", base = "AstNode")]
struct NodeLt;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeLt {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "LtE", base = "AstNode")]
struct NodeLtE;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeLtE {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Gt", base = "AstNode")]
struct NodeGt;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeGt {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "GtE", base = "AstNode")]
struct NodeGtE;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeGtE {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "Is", base = "AstNode")]
struct NodeIs;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeIs {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "IsNot", base = "AstNode")]
struct NodeIsNot;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeIsNot {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "In", base = "AstNode")]
struct NodeIn;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeIn {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "NotIn", base = "AstNode")]
struct NodeNotIn;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeNotIn {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "comprehension", base = "AstNode")]
struct Nodecomprehension;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl Nodecomprehension {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("target")),ctx.new_ascii_literal(ascii!("iter")),ctx.new_ascii_literal(ascii!("ifs")),ctx.new_ascii_literal(ascii!("is_async"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "ExceptHandler", base = "AstNode")]
struct NodeExceptHandler;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeExceptHandler {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("type")),ctx.new_ascii_literal(ascii!("name")),ctx.new_ascii_literal(ascii!("body"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "arguments", base = "AstNode")]
struct Nodearguments;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl Nodearguments {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("posonlyargs")),ctx.new_ascii_literal(ascii!("args")),ctx.new_ascii_literal(ascii!("vararg")),ctx.new_ascii_literal(ascii!("kwonlyargs")),ctx.new_ascii_literal(ascii!("kw_defaults")),ctx.new_ascii_literal(ascii!("kwarg")),ctx.new_ascii_literal(ascii!("defaults"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "arg", base = "AstNode")]
struct Nodearg;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl Nodearg {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("arg")),ctx.new_ascii_literal(ascii!("annotation")),ctx.new_ascii_literal(ascii!("type_comment"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "keyword", base = "AstNode")]
struct Nodekeyword;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl Nodekeyword {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("arg")),ctx.new_ascii_literal(ascii!("value"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("col_offset")),ctx.new_ascii_literal(ascii!("end_lineno")),ctx.new_ascii_literal(ascii!("end_col_offset"))]));
    }
}
#[pyclass(module = "_ast", name = "alias", base = "AstNode")]
struct Nodealias;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl Nodealias {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("name")),ctx.new_ascii_literal(ascii!("asname"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "withitem", base = "AstNode")]
struct Nodewithitem;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl Nodewithitem {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("context_expr")),ctx.new_ascii_literal(ascii!("optional_vars"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}
#[pyclass(module = "_ast", name = "TypeIgnore", base = "AstNode")]
struct NodeTypeIgnore;
#[pyimpl(flags(HAS_DICT, BASETYPE))]
impl NodeTypeIgnore {
    #[extend_class]
    fn extend_class_with_fields(ctx: &PyContext, class: &PyTypeRef) {
        class.set_str_attr("_fields", ctx.new_list(vec![ctx.new_ascii_literal(ascii!("lineno")),ctx.new_ascii_literal(ascii!("tag"))]));
        class.set_str_attr("_attributes", ctx.new_list(vec![]));
    }
}

impl NamedNode for ast::Mod {
    const NAME: &'static str = "mod";
}
impl Node for ast::Mod {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::Mod::Module { body,type_ignores } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeModule::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("type_ignores", type_ignores.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::Mod::Interactive { body } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeInteractive::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::Mod::Expression { body } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeExpression::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::Mod::FunctionType { argtypes,returns } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeFunctionType::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("argtypes", argtypes.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("returns", returns.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(
        if _cls.is(NodeModule::static_type()) {
            ast::Mod::Module {
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "mod")?)?,
                type_ignores: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "type_ignores", "mod")?)?,
            }
        } else
        if _cls.is(NodeInteractive::static_type()) {
            ast::Mod::Interactive {
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "mod")?)?,
            }
        } else
        if _cls.is(NodeExpression::static_type()) {
            ast::Mod::Expression {
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "mod")?)?,
            }
        } else
        if _cls.is(NodeFunctionType::static_type()) {
            ast::Mod::FunctionType {
                argtypes: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "argtypes", "mod")?)?,
                returns: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "returns", "mod")?)?,
            }
        } else
        {
            return Err(_vm.new_type_error(format!("expected some sort of mod, but got {}",_vm.to_repr(&_object)?)));
        })
    }
}
impl NamedNode for ast::StmtKind {
    const NAME: &'static str = "stmt";
}
impl Node for ast::StmtKind {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::StmtKind::FunctionDef { name,args,body,decorator_list,returns,type_comment } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeFunctionDef::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("args", args.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("decorator_list", decorator_list.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("returns", returns.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::AsyncFunctionDef { name,args,body,decorator_list,returns,type_comment } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAsyncFunctionDef::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("args", args.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("decorator_list", decorator_list.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("returns", returns.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::ClassDef { name,bases,keywords,body,decorator_list } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeClassDef::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("bases", bases.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("keywords", keywords.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("decorator_list", decorator_list.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::Return { value } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeReturn::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::Delete { targets } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeDelete::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("targets", targets.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::Assign { targets,value,type_comment } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAssign::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("targets", targets.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::AugAssign { target,op,value } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAugAssign::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("target", target.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("op", op.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::AnnAssign { target,annotation,value,simple } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAnnAssign::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("target", target.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("annotation", annotation.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("simple", simple.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::For { target,iter,body,orelse,type_comment } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeFor::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("target", target.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("iter", iter.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("orelse", orelse.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::AsyncFor { target,iter,body,orelse,type_comment } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAsyncFor::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("target", target.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("iter", iter.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("orelse", orelse.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::While { test,body,orelse } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeWhile::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("test", test.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("orelse", orelse.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::If { test,body,orelse } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeIf::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("test", test.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("orelse", orelse.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::With { items,body,type_comment } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeWith::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("items", items.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::AsyncWith { items,body,type_comment } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAsyncWith::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("items", items.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::Raise { exc,cause } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeRaise::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("exc", exc.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("cause", cause.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::Try { body,handlers,orelse,finalbody } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeTry::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("handlers", handlers.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("orelse", orelse.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("finalbody", finalbody.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::Assert { test,msg } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAssert::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("test", test.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("msg", msg.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::Import { names } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeImport::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("names", names.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::ImportFrom { module,names,level } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeImportFrom::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("module", module.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("names", names.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("level", level.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::Global { names } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeGlobal::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("names", names.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::Nonlocal { names } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeNonlocal::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("names", names.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::Expr { value } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeExpr::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::StmtKind::Pass {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodePass::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::StmtKind::Break {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeBreak::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::StmtKind::Continue {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeContinue::static_type().clone()).unwrap();
                _node.into_object()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _location = ast::Location::new(Node::ast_from_object(_vm, get_node_field(_vm, &_object, "lineno", "stmt")?)?, Node::ast_from_object(_vm, get_node_field(_vm, &_object, "col_offset", "stmt")?)?);
        let _cls = _object.class();
        Ok(
        if _cls.is(NodeFunctionDef::static_type()) {
            ast::StmtKind::FunctionDef {
                name: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "name", "stmt")?)?,
                args: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "args", "stmt")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                decorator_list: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "decorator_list", "stmt")?)?,
                returns: get_node_field_opt(_vm, &_object, "returns")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
                type_comment: get_node_field_opt(_vm, &_object, "type_comment")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
            }
        } else
        if _cls.is(NodeAsyncFunctionDef::static_type()) {
            ast::StmtKind::AsyncFunctionDef {
                name: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "name", "stmt")?)?,
                args: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "args", "stmt")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                decorator_list: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "decorator_list", "stmt")?)?,
                returns: get_node_field_opt(_vm, &_object, "returns")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
                type_comment: get_node_field_opt(_vm, &_object, "type_comment")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
            }
        } else
        if _cls.is(NodeClassDef::static_type()) {
            ast::StmtKind::ClassDef {
                name: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "name", "stmt")?)?,
                bases: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "bases", "stmt")?)?,
                keywords: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "keywords", "stmt")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                decorator_list: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "decorator_list", "stmt")?)?,
            }
        } else
        if _cls.is(NodeReturn::static_type()) {
            ast::StmtKind::Return {
                value: get_node_field_opt(_vm, &_object, "value")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
            }
        } else
        if _cls.is(NodeDelete::static_type()) {
            ast::StmtKind::Delete {
                targets: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "targets", "stmt")?)?,
            }
        } else
        if _cls.is(NodeAssign::static_type()) {
            ast::StmtKind::Assign {
                targets: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "targets", "stmt")?)?,
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "stmt")?)?,
                type_comment: get_node_field_opt(_vm, &_object, "type_comment")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
            }
        } else
        if _cls.is(NodeAugAssign::static_type()) {
            ast::StmtKind::AugAssign {
                target: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "target", "stmt")?)?,
                op: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "op", "stmt")?)?,
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "stmt")?)?,
            }
        } else
        if _cls.is(NodeAnnAssign::static_type()) {
            ast::StmtKind::AnnAssign {
                target: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "target", "stmt")?)?,
                annotation: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "annotation", "stmt")?)?,
                value: get_node_field_opt(_vm, &_object, "value")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
                simple: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "simple", "stmt")?)?,
            }
        } else
        if _cls.is(NodeFor::static_type()) {
            ast::StmtKind::For {
                target: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "target", "stmt")?)?,
                iter: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "iter", "stmt")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                orelse: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "orelse", "stmt")?)?,
                type_comment: get_node_field_opt(_vm, &_object, "type_comment")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
            }
        } else
        if _cls.is(NodeAsyncFor::static_type()) {
            ast::StmtKind::AsyncFor {
                target: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "target", "stmt")?)?,
                iter: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "iter", "stmt")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                orelse: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "orelse", "stmt")?)?,
                type_comment: get_node_field_opt(_vm, &_object, "type_comment")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
            }
        } else
        if _cls.is(NodeWhile::static_type()) {
            ast::StmtKind::While {
                test: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "test", "stmt")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                orelse: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "orelse", "stmt")?)?,
            }
        } else
        if _cls.is(NodeIf::static_type()) {
            ast::StmtKind::If {
                test: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "test", "stmt")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                orelse: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "orelse", "stmt")?)?,
            }
        } else
        if _cls.is(NodeWith::static_type()) {
            ast::StmtKind::With {
                items: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "items", "stmt")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                type_comment: get_node_field_opt(_vm, &_object, "type_comment")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
            }
        } else
        if _cls.is(NodeAsyncWith::static_type()) {
            ast::StmtKind::AsyncWith {
                items: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "items", "stmt")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                type_comment: get_node_field_opt(_vm, &_object, "type_comment")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
            }
        } else
        if _cls.is(NodeRaise::static_type()) {
            ast::StmtKind::Raise {
                exc: get_node_field_opt(_vm, &_object, "exc")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
                cause: get_node_field_opt(_vm, &_object, "cause")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
            }
        } else
        if _cls.is(NodeTry::static_type()) {
            ast::StmtKind::Try {
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "stmt")?)?,
                handlers: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "handlers", "stmt")?)?,
                orelse: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "orelse", "stmt")?)?,
                finalbody: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "finalbody", "stmt")?)?,
            }
        } else
        if _cls.is(NodeAssert::static_type()) {
            ast::StmtKind::Assert {
                test: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "test", "stmt")?)?,
                msg: get_node_field_opt(_vm, &_object, "msg")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
            }
        } else
        if _cls.is(NodeImport::static_type()) {
            ast::StmtKind::Import {
                names: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "names", "stmt")?)?,
            }
        } else
        if _cls.is(NodeImportFrom::static_type()) {
            ast::StmtKind::ImportFrom {
                module: get_node_field_opt(_vm, &_object, "module")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
                names: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "names", "stmt")?)?,
                level: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "level", "stmt")?)?,
            }
        } else
        if _cls.is(NodeGlobal::static_type()) {
            ast::StmtKind::Global {
                names: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "names", "stmt")?)?,
            }
        } else
        if _cls.is(NodeNonlocal::static_type()) {
            ast::StmtKind::Nonlocal {
                names: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "names", "stmt")?)?,
            }
        } else
        if _cls.is(NodeExpr::static_type()) {
            ast::StmtKind::Expr {
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "stmt")?)?,
            }
        } else
        if _cls.is(NodePass::static_type()) {
            ast::StmtKind::Pass {
            }
        } else
        if _cls.is(NodeBreak::static_type()) {
            ast::StmtKind::Break {
            }
        } else
        if _cls.is(NodeContinue::static_type()) {
            ast::StmtKind::Continue {
            }
        } else
        {
            return Err(_vm.new_type_error(format!("expected some sort of stmt, but got {}",_vm.to_repr(&_object)?)));
        })
    }
}
impl NamedNode for ast::ExprKind {
    const NAME: &'static str = "expr";
}
impl Node for ast::ExprKind {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::ExprKind::BoolOp { op,values } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeBoolOp::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("op", op.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("values", values.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::NamedExpr { target,value } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeNamedExpr::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("target", target.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::BinOp { left,op,right } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeBinOp::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("left", left.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("op", op.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("right", right.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::UnaryOp { op,operand } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeUnaryOp::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("op", op.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("operand", operand.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::Lambda { args,body } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeLambda::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("args", args.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::IfExp { test,body,orelse } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeIfExp::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("test", test.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("orelse", orelse.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::Dict { keys,values } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeDict::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("keys", keys.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("values", values.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::Set { elts } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeSet::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("elts", elts.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::ListComp { elt,generators } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeListComp::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("elt", elt.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("generators", generators.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::SetComp { elt,generators } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeSetComp::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("elt", elt.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("generators", generators.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::DictComp { key,value,generators } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeDictComp::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("key", key.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("generators", generators.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::GeneratorExp { elt,generators } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeGeneratorExp::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("elt", elt.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("generators", generators.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::Await { value } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAwait::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::Yield { value } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeYield::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::YieldFrom { value } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeYieldFrom::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::Compare { left,ops,comparators } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeCompare::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("left", left.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("ops", ops.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("comparators", comparators.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::Call { func,args,keywords } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeCall::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("func", func.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("args", args.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("keywords", keywords.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::FormattedValue { value,conversion,format_spec } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeFormattedValue::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("conversion", conversion.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("format_spec", format_spec.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::JoinedStr { values } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeJoinedStr::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("values", values.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::Constant { value,kind } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeConstant::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("kind", kind.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::Attribute { value,attr,ctx } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAttribute::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("attr", attr.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::Subscript { value,slice,ctx } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeSubscript::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("slice", slice.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::Starred { value,ctx } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeStarred::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::Name { id,ctx } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeName::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("id", id.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::List { elts,ctx } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeList::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("elts", elts.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::Tuple { elts,ctx } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeTuple::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("elts", elts.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
            ast::ExprKind::Slice { lower,upper,step } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeSlice::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("lower", lower.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("upper", upper.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("step", step.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _location = ast::Location::new(Node::ast_from_object(_vm, get_node_field(_vm, &_object, "lineno", "expr")?)?, Node::ast_from_object(_vm, get_node_field(_vm, &_object, "col_offset", "expr")?)?);
        let _cls = _object.class();
        Ok(
        if _cls.is(NodeBoolOp::static_type()) {
            ast::ExprKind::BoolOp {
                op: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "op", "expr")?)?,
                values: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "values", "expr")?)?,
            }
        } else
        if _cls.is(NodeNamedExpr::static_type()) {
            ast::ExprKind::NamedExpr {
                target: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "target", "expr")?)?,
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "expr")?)?,
            }
        } else
        if _cls.is(NodeBinOp::static_type()) {
            ast::ExprKind::BinOp {
                left: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "left", "expr")?)?,
                op: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "op", "expr")?)?,
                right: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "right", "expr")?)?,
            }
        } else
        if _cls.is(NodeUnaryOp::static_type()) {
            ast::ExprKind::UnaryOp {
                op: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "op", "expr")?)?,
                operand: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "operand", "expr")?)?,
            }
        } else
        if _cls.is(NodeLambda::static_type()) {
            ast::ExprKind::Lambda {
                args: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "args", "expr")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "expr")?)?,
            }
        } else
        if _cls.is(NodeIfExp::static_type()) {
            ast::ExprKind::IfExp {
                test: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "test", "expr")?)?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "expr")?)?,
                orelse: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "orelse", "expr")?)?,
            }
        } else
        if _cls.is(NodeDict::static_type()) {
            ast::ExprKind::Dict {
                keys: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "keys", "expr")?)?,
                values: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "values", "expr")?)?,
            }
        } else
        if _cls.is(NodeSet::static_type()) {
            ast::ExprKind::Set {
                elts: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "elts", "expr")?)?,
            }
        } else
        if _cls.is(NodeListComp::static_type()) {
            ast::ExprKind::ListComp {
                elt: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "elt", "expr")?)?,
                generators: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "generators", "expr")?)?,
            }
        } else
        if _cls.is(NodeSetComp::static_type()) {
            ast::ExprKind::SetComp {
                elt: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "elt", "expr")?)?,
                generators: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "generators", "expr")?)?,
            }
        } else
        if _cls.is(NodeDictComp::static_type()) {
            ast::ExprKind::DictComp {
                key: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "key", "expr")?)?,
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "expr")?)?,
                generators: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "generators", "expr")?)?,
            }
        } else
        if _cls.is(NodeGeneratorExp::static_type()) {
            ast::ExprKind::GeneratorExp {
                elt: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "elt", "expr")?)?,
                generators: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "generators", "expr")?)?,
            }
        } else
        if _cls.is(NodeAwait::static_type()) {
            ast::ExprKind::Await {
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "expr")?)?,
            }
        } else
        if _cls.is(NodeYield::static_type()) {
            ast::ExprKind::Yield {
                value: get_node_field_opt(_vm, &_object, "value")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
            }
        } else
        if _cls.is(NodeYieldFrom::static_type()) {
            ast::ExprKind::YieldFrom {
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "expr")?)?,
            }
        } else
        if _cls.is(NodeCompare::static_type()) {
            ast::ExprKind::Compare {
                left: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "left", "expr")?)?,
                ops: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ops", "expr")?)?,
                comparators: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "comparators", "expr")?)?,
            }
        } else
        if _cls.is(NodeCall::static_type()) {
            ast::ExprKind::Call {
                func: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "func", "expr")?)?,
                args: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "args", "expr")?)?,
                keywords: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "keywords", "expr")?)?,
            }
        } else
        if _cls.is(NodeFormattedValue::static_type()) {
            ast::ExprKind::FormattedValue {
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "expr")?)?,
                conversion: get_node_field_opt(_vm, &_object, "conversion")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
                format_spec: get_node_field_opt(_vm, &_object, "format_spec")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
            }
        } else
        if _cls.is(NodeJoinedStr::static_type()) {
            ast::ExprKind::JoinedStr {
                values: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "values", "expr")?)?,
            }
        } else
        if _cls.is(NodeConstant::static_type()) {
            ast::ExprKind::Constant {
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "expr")?)?,
                kind: get_node_field_opt(_vm, &_object, "kind")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
            }
        } else
        if _cls.is(NodeAttribute::static_type()) {
            ast::ExprKind::Attribute {
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "expr")?)?,
                attr: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "attr", "expr")?)?,
                ctx: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ctx", "expr")?)?,
            }
        } else
        if _cls.is(NodeSubscript::static_type()) {
            ast::ExprKind::Subscript {
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "expr")?)?,
                slice: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "slice", "expr")?)?,
                ctx: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ctx", "expr")?)?,
            }
        } else
        if _cls.is(NodeStarred::static_type()) {
            ast::ExprKind::Starred {
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "expr")?)?,
                ctx: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ctx", "expr")?)?,
            }
        } else
        if _cls.is(NodeName::static_type()) {
            ast::ExprKind::Name {
                id: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "id", "expr")?)?,
                ctx: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ctx", "expr")?)?,
            }
        } else
        if _cls.is(NodeList::static_type()) {
            ast::ExprKind::List {
                elts: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "elts", "expr")?)?,
                ctx: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ctx", "expr")?)?,
            }
        } else
        if _cls.is(NodeTuple::static_type()) {
            ast::ExprKind::Tuple {
                elts: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "elts", "expr")?)?,
                ctx: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ctx", "expr")?)?,
            }
        } else
        if _cls.is(NodeSlice::static_type()) {
            ast::ExprKind::Slice {
                lower: get_node_field_opt(_vm, &_object, "lower")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
                upper: get_node_field_opt(_vm, &_object, "upper")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
                step: get_node_field_opt(_vm, &_object, "step")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
            }
        } else
        {
            return Err(_vm.new_type_error(format!("expected some sort of expr, but got {}",_vm.to_repr(&_object)?)));
        })
    }
}
impl NamedNode for ast::ExprContext {
    const NAME: &'static str = "expr_context";
}
impl Node for ast::ExprContext {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::ExprContext::Load {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeLoad::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::ExprContext::Store {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeStore::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::ExprContext::Del {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeDel::static_type().clone()).unwrap();
                _node.into_object()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(
        if _cls.is(NodeLoad::static_type()) {
            ast::ExprContext::Load {
            }
        } else
        if _cls.is(NodeStore::static_type()) {
            ast::ExprContext::Store {
            }
        } else
        if _cls.is(NodeDel::static_type()) {
            ast::ExprContext::Del {
            }
        } else
        {
            return Err(_vm.new_type_error(format!("expected some sort of expr_context, but got {}",_vm.to_repr(&_object)?)));
        })
    }
}
impl NamedNode for ast::Boolop {
    const NAME: &'static str = "boolop";
}
impl Node for ast::Boolop {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::Boolop::And {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAnd::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Boolop::Or {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeOr::static_type().clone()).unwrap();
                _node.into_object()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(
        if _cls.is(NodeAnd::static_type()) {
            ast::Boolop::And {
            }
        } else
        if _cls.is(NodeOr::static_type()) {
            ast::Boolop::Or {
            }
        } else
        {
            return Err(_vm.new_type_error(format!("expected some sort of boolop, but got {}",_vm.to_repr(&_object)?)));
        })
    }
}
impl NamedNode for ast::Operator {
    const NAME: &'static str = "operator";
}
impl Node for ast::Operator {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::Operator::Add {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeAdd::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Operator::Sub {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeSub::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Operator::Mult {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeMult::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Operator::MatMult {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeMatMult::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Operator::Div {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeDiv::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Operator::Mod {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeMod::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Operator::Pow {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodePow::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Operator::LShift {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeLShift::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Operator::RShift {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeRShift::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Operator::BitOr {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeBitOr::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Operator::BitXor {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeBitXor::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Operator::BitAnd {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeBitAnd::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Operator::FloorDiv {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeFloorDiv::static_type().clone()).unwrap();
                _node.into_object()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(
        if _cls.is(NodeAdd::static_type()) {
            ast::Operator::Add {
            }
        } else
        if _cls.is(NodeSub::static_type()) {
            ast::Operator::Sub {
            }
        } else
        if _cls.is(NodeMult::static_type()) {
            ast::Operator::Mult {
            }
        } else
        if _cls.is(NodeMatMult::static_type()) {
            ast::Operator::MatMult {
            }
        } else
        if _cls.is(NodeDiv::static_type()) {
            ast::Operator::Div {
            }
        } else
        if _cls.is(NodeMod::static_type()) {
            ast::Operator::Mod {
            }
        } else
        if _cls.is(NodePow::static_type()) {
            ast::Operator::Pow {
            }
        } else
        if _cls.is(NodeLShift::static_type()) {
            ast::Operator::LShift {
            }
        } else
        if _cls.is(NodeRShift::static_type()) {
            ast::Operator::RShift {
            }
        } else
        if _cls.is(NodeBitOr::static_type()) {
            ast::Operator::BitOr {
            }
        } else
        if _cls.is(NodeBitXor::static_type()) {
            ast::Operator::BitXor {
            }
        } else
        if _cls.is(NodeBitAnd::static_type()) {
            ast::Operator::BitAnd {
            }
        } else
        if _cls.is(NodeFloorDiv::static_type()) {
            ast::Operator::FloorDiv {
            }
        } else
        {
            return Err(_vm.new_type_error(format!("expected some sort of operator, but got {}",_vm.to_repr(&_object)?)));
        })
    }
}
impl NamedNode for ast::Unaryop {
    const NAME: &'static str = "unaryop";
}
impl Node for ast::Unaryop {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::Unaryop::Invert {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeInvert::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Unaryop::Not {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeNot::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Unaryop::UAdd {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeUAdd::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Unaryop::USub {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeUSub::static_type().clone()).unwrap();
                _node.into_object()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(
        if _cls.is(NodeInvert::static_type()) {
            ast::Unaryop::Invert {
            }
        } else
        if _cls.is(NodeNot::static_type()) {
            ast::Unaryop::Not {
            }
        } else
        if _cls.is(NodeUAdd::static_type()) {
            ast::Unaryop::UAdd {
            }
        } else
        if _cls.is(NodeUSub::static_type()) {
            ast::Unaryop::USub {
            }
        } else
        {
            return Err(_vm.new_type_error(format!("expected some sort of unaryop, but got {}",_vm.to_repr(&_object)?)));
        })
    }
}
impl NamedNode for ast::Cmpop {
    const NAME: &'static str = "cmpop";
}
impl Node for ast::Cmpop {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::Cmpop::Eq {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeEq::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Cmpop::NotEq {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeNotEq::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Cmpop::Lt {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeLt::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Cmpop::LtE {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeLtE::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Cmpop::Gt {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeGt::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Cmpop::GtE {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeGtE::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Cmpop::Is {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeIs::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Cmpop::IsNot {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeIsNot::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Cmpop::In {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeIn::static_type().clone()).unwrap();
                _node.into_object()
            }
            ast::Cmpop::NotIn {  } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeNotIn::static_type().clone()).unwrap();
                _node.into_object()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(
        if _cls.is(NodeEq::static_type()) {
            ast::Cmpop::Eq {
            }
        } else
        if _cls.is(NodeNotEq::static_type()) {
            ast::Cmpop::NotEq {
            }
        } else
        if _cls.is(NodeLt::static_type()) {
            ast::Cmpop::Lt {
            }
        } else
        if _cls.is(NodeLtE::static_type()) {
            ast::Cmpop::LtE {
            }
        } else
        if _cls.is(NodeGt::static_type()) {
            ast::Cmpop::Gt {
            }
        } else
        if _cls.is(NodeGtE::static_type()) {
            ast::Cmpop::GtE {
            }
        } else
        if _cls.is(NodeIs::static_type()) {
            ast::Cmpop::Is {
            }
        } else
        if _cls.is(NodeIsNot::static_type()) {
            ast::Cmpop::IsNot {
            }
        } else
        if _cls.is(NodeIn::static_type()) {
            ast::Cmpop::In {
            }
        } else
        if _cls.is(NodeNotIn::static_type()) {
            ast::Cmpop::NotIn {
            }
        } else
        {
            return Err(_vm.new_type_error(format!("expected some sort of cmpop, but got {}",_vm.to_repr(&_object)?)));
        })
    }
}
impl NamedNode for ast::Comprehension {
    const NAME: &'static str = "comprehension";
}
impl Node for ast::Comprehension {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::Comprehension { target,iter,ifs,is_async } = self;
        let _node = AstNode.into_ref_with_type(_vm, Nodecomprehension::static_type().clone()).unwrap();
        let _dict = _node.as_object().dict().unwrap();
        _dict.set_item("target", target.ast_to_object(_vm), _vm).unwrap();
        _dict.set_item("iter", iter.ast_to_object(_vm), _vm).unwrap();
        _dict.set_item("ifs", ifs.ast_to_object(_vm), _vm).unwrap();
        _dict.set_item("is_async", is_async.ast_to_object(_vm), _vm).unwrap();
        _node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(
            ast::Comprehension {
                target: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "target", "comprehension")?)?,
                iter: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "iter", "comprehension")?)?,
                ifs: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ifs", "comprehension")?)?,
                is_async: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "is_async", "comprehension")?)?,
            }
        )
    }
}
impl NamedNode for ast::ExcepthandlerKind {
    const NAME: &'static str = "excepthandler";
}
impl Node for ast::ExcepthandlerKind {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::ExcepthandlerKind::ExceptHandler { type_,name,body } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeExceptHandler::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("type", type_.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _location = ast::Location::new(Node::ast_from_object(_vm, get_node_field(_vm, &_object, "lineno", "excepthandler")?)?, Node::ast_from_object(_vm, get_node_field(_vm, &_object, "col_offset", "excepthandler")?)?);
        let _cls = _object.class();
        Ok(
        if _cls.is(NodeExceptHandler::static_type()) {
            ast::ExcepthandlerKind::ExceptHandler {
                type_: get_node_field_opt(_vm, &_object, "type")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
                name: get_node_field_opt(_vm, &_object, "name")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
                body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "excepthandler")?)?,
            }
        } else
        {
            return Err(_vm.new_type_error(format!("expected some sort of excepthandler, but got {}",_vm.to_repr(&_object)?)));
        })
    }
}
impl NamedNode for ast::Arguments {
    const NAME: &'static str = "arguments";
}
impl Node for ast::Arguments {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::Arguments { posonlyargs,args,vararg,kwonlyargs,kw_defaults,kwarg,defaults } = self;
        let _node = AstNode.into_ref_with_type(_vm, Nodearguments::static_type().clone()).unwrap();
        let _dict = _node.as_object().dict().unwrap();
        _dict.set_item("posonlyargs", posonlyargs.ast_to_object(_vm), _vm).unwrap();
        _dict.set_item("args", args.ast_to_object(_vm), _vm).unwrap();
        _dict.set_item("vararg", vararg.ast_to_object(_vm), _vm).unwrap();
        _dict.set_item("kwonlyargs", kwonlyargs.ast_to_object(_vm), _vm).unwrap();
        _dict.set_item("kw_defaults", kw_defaults.ast_to_object(_vm), _vm).unwrap();
        _dict.set_item("kwarg", kwarg.ast_to_object(_vm), _vm).unwrap();
        _dict.set_item("defaults", defaults.ast_to_object(_vm), _vm).unwrap();
        _node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(
            ast::Arguments {
                posonlyargs: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "posonlyargs", "arguments")?)?,
                args: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "args", "arguments")?)?,
                vararg: get_node_field_opt(_vm, &_object, "vararg")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
                kwonlyargs: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "kwonlyargs", "arguments")?)?,
                kw_defaults: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "kw_defaults", "arguments")?)?,
                kwarg: get_node_field_opt(_vm, &_object, "kwarg")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
                defaults: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "defaults", "arguments")?)?,
            }
        )
    }
}
impl NamedNode for ast::ArgData {
    const NAME: &'static str = "arg";
}
impl Node for ast::ArgData {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::ArgData { arg,annotation,type_comment } = self;
        let _node = AstNode.into_ref_with_type(_vm, Nodearg::static_type().clone()).unwrap();
        let _dict = _node.as_object().dict().unwrap();
        _dict.set_item("arg", arg.ast_to_object(_vm), _vm).unwrap();
        _dict.set_item("annotation", annotation.ast_to_object(_vm), _vm).unwrap();
        _dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm).unwrap();
        _node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _location = ast::Location::new(Node::ast_from_object(_vm, get_node_field(_vm, &_object, "lineno", "arg")?)?, Node::ast_from_object(_vm, get_node_field(_vm, &_object, "col_offset", "arg")?)?);
        Ok(
            ast::ArgData {
                arg: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "arg", "arg")?)?,
                annotation: get_node_field_opt(_vm, &_object, "annotation")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
                type_comment: get_node_field_opt(_vm, &_object, "type_comment")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
            }
        )
    }
}
impl NamedNode for ast::KeywordData {
    const NAME: &'static str = "keyword";
}
impl Node for ast::KeywordData {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::KeywordData { arg,value } = self;
        let _node = AstNode.into_ref_with_type(_vm, Nodekeyword::static_type().clone()).unwrap();
        let _dict = _node.as_object().dict().unwrap();
        _dict.set_item("arg", arg.ast_to_object(_vm), _vm).unwrap();
        _dict.set_item("value", value.ast_to_object(_vm), _vm).unwrap();
        _node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _location = ast::Location::new(Node::ast_from_object(_vm, get_node_field(_vm, &_object, "lineno", "keyword")?)?, Node::ast_from_object(_vm, get_node_field(_vm, &_object, "col_offset", "keyword")?)?);
        Ok(
            ast::KeywordData {
                arg: get_node_field_opt(_vm, &_object, "arg")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
                value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "keyword")?)?,
            }
        )
    }
}
impl NamedNode for ast::Alias {
    const NAME: &'static str = "alias";
}
impl Node for ast::Alias {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::Alias { name,asname } = self;
        let _node = AstNode.into_ref_with_type(_vm, Nodealias::static_type().clone()).unwrap();
        let _dict = _node.as_object().dict().unwrap();
        _dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
        _dict.set_item("asname", asname.ast_to_object(_vm), _vm).unwrap();
        _node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(
            ast::Alias {
                name: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "name", "alias")?)?,
                asname: get_node_field_opt(_vm, &_object, "asname")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
            }
        )
    }
}
impl NamedNode for ast::Withitem {
    const NAME: &'static str = "withitem";
}
impl Node for ast::Withitem {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::Withitem { context_expr,optional_vars } = self;
        let _node = AstNode.into_ref_with_type(_vm, Nodewithitem::static_type().clone()).unwrap();
        let _dict = _node.as_object().dict().unwrap();
        _dict.set_item("context_expr", context_expr.ast_to_object(_vm), _vm).unwrap();
        _dict.set_item("optional_vars", optional_vars.ast_to_object(_vm), _vm).unwrap();
        _node.into_object()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(
            ast::Withitem {
                context_expr: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "context_expr", "withitem")?)?,
                optional_vars: get_node_field_opt(_vm, &_object, "optional_vars")?.map(|obj| Node::ast_from_object(_vm, obj)).transpose()?,
            }
        )
    }
}
impl NamedNode for ast::TypeIgnore {
    const NAME: &'static str = "type_ignore";
}
impl Node for ast::TypeIgnore {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::TypeIgnore::TypeIgnore { lineno,tag } => {
                let _node = AstNode.into_ref_with_type(_vm, NodeTypeIgnore::static_type().clone()).unwrap();
                let _dict = _node.as_object().dict().unwrap();
                _dict.set_item("lineno", lineno.ast_to_object(_vm), _vm).unwrap();
                _dict.set_item("tag", tag.ast_to_object(_vm), _vm).unwrap();
                _node.into_object()
            }
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(
        if _cls.is(NodeTypeIgnore::static_type()) {
            ast::TypeIgnore::TypeIgnore {
                lineno: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "lineno", "type_ignore")?)?,
                tag: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "tag", "type_ignore")?)?,
            }
        } else
        {
            return Err(_vm.new_type_error(format!("expected some sort of type_ignore, but got {}",_vm.to_repr(&_object)?)));
        })
    }
}

pub fn extend_module_nodes(vm: &VirtualMachine, module: &PyObjectRef) {
    extend_module!(vm, module, {
        "Module" => NodeModule::make_class(&vm.ctx),
        "Interactive" => NodeInteractive::make_class(&vm.ctx),
        "Expression" => NodeExpression::make_class(&vm.ctx),
        "FunctionType" => NodeFunctionType::make_class(&vm.ctx),
        "FunctionDef" => NodeFunctionDef::make_class(&vm.ctx),
        "AsyncFunctionDef" => NodeAsyncFunctionDef::make_class(&vm.ctx),
        "ClassDef" => NodeClassDef::make_class(&vm.ctx),
        "Return" => NodeReturn::make_class(&vm.ctx),
        "Delete" => NodeDelete::make_class(&vm.ctx),
        "Assign" => NodeAssign::make_class(&vm.ctx),
        "AugAssign" => NodeAugAssign::make_class(&vm.ctx),
        "AnnAssign" => NodeAnnAssign::make_class(&vm.ctx),
        "For" => NodeFor::make_class(&vm.ctx),
        "AsyncFor" => NodeAsyncFor::make_class(&vm.ctx),
        "While" => NodeWhile::make_class(&vm.ctx),
        "If" => NodeIf::make_class(&vm.ctx),
        "With" => NodeWith::make_class(&vm.ctx),
        "AsyncWith" => NodeAsyncWith::make_class(&vm.ctx),
        "Raise" => NodeRaise::make_class(&vm.ctx),
        "Try" => NodeTry::make_class(&vm.ctx),
        "Assert" => NodeAssert::make_class(&vm.ctx),
        "Import" => NodeImport::make_class(&vm.ctx),
        "ImportFrom" => NodeImportFrom::make_class(&vm.ctx),
        "Global" => NodeGlobal::make_class(&vm.ctx),
        "Nonlocal" => NodeNonlocal::make_class(&vm.ctx),
        "Expr" => NodeExpr::make_class(&vm.ctx),
        "Pass" => NodePass::make_class(&vm.ctx),
        "Break" => NodeBreak::make_class(&vm.ctx),
        "Continue" => NodeContinue::make_class(&vm.ctx),
        "BoolOp" => NodeBoolOp::make_class(&vm.ctx),
        "NamedExpr" => NodeNamedExpr::make_class(&vm.ctx),
        "BinOp" => NodeBinOp::make_class(&vm.ctx),
        "UnaryOp" => NodeUnaryOp::make_class(&vm.ctx),
        "Lambda" => NodeLambda::make_class(&vm.ctx),
        "IfExp" => NodeIfExp::make_class(&vm.ctx),
        "Dict" => NodeDict::make_class(&vm.ctx),
        "Set" => NodeSet::make_class(&vm.ctx),
        "ListComp" => NodeListComp::make_class(&vm.ctx),
        "SetComp" => NodeSetComp::make_class(&vm.ctx),
        "DictComp" => NodeDictComp::make_class(&vm.ctx),
        "GeneratorExp" => NodeGeneratorExp::make_class(&vm.ctx),
        "Await" => NodeAwait::make_class(&vm.ctx),
        "Yield" => NodeYield::make_class(&vm.ctx),
        "YieldFrom" => NodeYieldFrom::make_class(&vm.ctx),
        "Compare" => NodeCompare::make_class(&vm.ctx),
        "Call" => NodeCall::make_class(&vm.ctx),
        "FormattedValue" => NodeFormattedValue::make_class(&vm.ctx),
        "JoinedStr" => NodeJoinedStr::make_class(&vm.ctx),
        "Constant" => NodeConstant::make_class(&vm.ctx),
        "Attribute" => NodeAttribute::make_class(&vm.ctx),
        "Subscript" => NodeSubscript::make_class(&vm.ctx),
        "Starred" => NodeStarred::make_class(&vm.ctx),
        "Name" => NodeName::make_class(&vm.ctx),
        "List" => NodeList::make_class(&vm.ctx),
        "Tuple" => NodeTuple::make_class(&vm.ctx),
        "Slice" => NodeSlice::make_class(&vm.ctx),
        "Load" => NodeLoad::make_class(&vm.ctx),
        "Store" => NodeStore::make_class(&vm.ctx),
        "Del" => NodeDel::make_class(&vm.ctx),
        "And" => NodeAnd::make_class(&vm.ctx),
        "Or" => NodeOr::make_class(&vm.ctx),
        "Add" => NodeAdd::make_class(&vm.ctx),
        "Sub" => NodeSub::make_class(&vm.ctx),
        "Mult" => NodeMult::make_class(&vm.ctx),
        "MatMult" => NodeMatMult::make_class(&vm.ctx),
        "Div" => NodeDiv::make_class(&vm.ctx),
        "Mod" => NodeMod::make_class(&vm.ctx),
        "Pow" => NodePow::make_class(&vm.ctx),
        "LShift" => NodeLShift::make_class(&vm.ctx),
        "RShift" => NodeRShift::make_class(&vm.ctx),
        "BitOr" => NodeBitOr::make_class(&vm.ctx),
        "BitXor" => NodeBitXor::make_class(&vm.ctx),
        "BitAnd" => NodeBitAnd::make_class(&vm.ctx),
        "FloorDiv" => NodeFloorDiv::make_class(&vm.ctx),
        "Invert" => NodeInvert::make_class(&vm.ctx),
        "Not" => NodeNot::make_class(&vm.ctx),
        "UAdd" => NodeUAdd::make_class(&vm.ctx),
        "USub" => NodeUSub::make_class(&vm.ctx),
        "Eq" => NodeEq::make_class(&vm.ctx),
        "NotEq" => NodeNotEq::make_class(&vm.ctx),
        "Lt" => NodeLt::make_class(&vm.ctx),
        "LtE" => NodeLtE::make_class(&vm.ctx),
        "Gt" => NodeGt::make_class(&vm.ctx),
        "GtE" => NodeGtE::make_class(&vm.ctx),
        "Is" => NodeIs::make_class(&vm.ctx),
        "IsNot" => NodeIsNot::make_class(&vm.ctx),
        "In" => NodeIn::make_class(&vm.ctx),
        "NotIn" => NodeNotIn::make_class(&vm.ctx),
        "comprehension" => Nodecomprehension::make_class(&vm.ctx),
        "ExceptHandler" => NodeExceptHandler::make_class(&vm.ctx),
        "arguments" => Nodearguments::make_class(&vm.ctx),
        "arg" => Nodearg::make_class(&vm.ctx),
        "keyword" => Nodekeyword::make_class(&vm.ctx),
        "alias" => Nodealias::make_class(&vm.ctx),
        "withitem" => Nodewithitem::make_class(&vm.ctx),
        "TypeIgnore" => NodeTypeIgnore::make_class(&vm.ctx),
    })
}

