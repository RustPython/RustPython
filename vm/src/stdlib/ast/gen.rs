// File automatically generated by ast/asdl_rs.py.

#![allow(clippy::all)]

use super::*;
use crate::common::ascii;
#[pyclass(module = "_ast", name = "mod", base = "NodeAst")]
struct NodeMod;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeMod {}
#[pyclass(module = "_ast", name = "Module", base = "NodeMod")]
struct NodeModModule;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeModModule {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("type_ignores")).into(),
            ])
            .into(),
        );
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Interactive", base = "NodeMod")]
struct NodeModInteractive;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeModInteractive {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("body")).into()])
                .into(),
        );
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Expression", base = "NodeMod")]
struct NodeModExpression;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeModExpression {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("body")).into()])
                .into(),
        );
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "FunctionType", base = "NodeMod")]
struct NodeModFunctionType;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeModFunctionType {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("argtypes")).into(),
                ctx.new_str(ascii!("returns")).into(),
            ])
            .into(),
        );
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "stmt", base = "NodeAst")]
struct NodeStmt;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmt {}
#[pyclass(module = "_ast", name = "FunctionDef", base = "NodeStmt")]
struct NodeStmtFunctionDef;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtFunctionDef {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("name")).into(),
                ctx.new_str(ascii!("args")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("decorator_list")).into(),
                ctx.new_str(ascii!("returns")).into(),
                ctx.new_str(ascii!("type_comment")).into(),
                ctx.new_str(ascii!("type_params")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "AsyncFunctionDef", base = "NodeStmt")]
struct NodeStmtAsyncFunctionDef;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtAsyncFunctionDef {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("name")).into(),
                ctx.new_str(ascii!("args")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("decorator_list")).into(),
                ctx.new_str(ascii!("returns")).into(),
                ctx.new_str(ascii!("type_comment")).into(),
                ctx.new_str(ascii!("type_params")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "ClassDef", base = "NodeStmt")]
struct NodeStmtClassDef;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtClassDef {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("name")).into(),
                ctx.new_str(ascii!("bases")).into(),
                ctx.new_str(ascii!("keywords")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("decorator_list")).into(),
                ctx.new_str(ascii!("type_params")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Return", base = "NodeStmt")]
struct NodeStmtReturn;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtReturn {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("value")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Delete", base = "NodeStmt")]
struct NodeStmtDelete;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtDelete {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("targets")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Assign", base = "NodeStmt")]
struct NodeStmtAssign;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtAssign {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("targets")).into(),
                ctx.new_str(ascii!("value")).into(),
                ctx.new_str(ascii!("type_comment")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "TypeAlias", base = "NodeStmt")]
struct NodeStmtTypeAlias;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtTypeAlias {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("name")).into(),
                ctx.new_str(ascii!("type_params")).into(),
                ctx.new_str(ascii!("value")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "AugAssign", base = "NodeStmt")]
struct NodeStmtAugAssign;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtAugAssign {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("target")).into(),
                ctx.new_str(ascii!("op")).into(),
                ctx.new_str(ascii!("value")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "AnnAssign", base = "NodeStmt")]
struct NodeStmtAnnAssign;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtAnnAssign {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("target")).into(),
                ctx.new_str(ascii!("annotation")).into(),
                ctx.new_str(ascii!("value")).into(),
                ctx.new_str(ascii!("simple")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "For", base = "NodeStmt")]
struct NodeStmtFor;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtFor {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("target")).into(),
                ctx.new_str(ascii!("iter")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("orelse")).into(),
                ctx.new_str(ascii!("type_comment")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "AsyncFor", base = "NodeStmt")]
struct NodeStmtAsyncFor;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtAsyncFor {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("target")).into(),
                ctx.new_str(ascii!("iter")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("orelse")).into(),
                ctx.new_str(ascii!("type_comment")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "While", base = "NodeStmt")]
struct NodeStmtWhile;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtWhile {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("test")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("orelse")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "If", base = "NodeStmt")]
struct NodeStmtIf;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtIf {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("test")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("orelse")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "With", base = "NodeStmt")]
struct NodeStmtWith;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtWith {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("items")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("type_comment")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "AsyncWith", base = "NodeStmt")]
struct NodeStmtAsyncWith;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtAsyncWith {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("items")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("type_comment")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Match", base = "NodeStmt")]
struct NodeStmtMatch;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtMatch {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("subject")).into(),
                ctx.new_str(ascii!("cases")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Raise", base = "NodeStmt")]
struct NodeStmtRaise;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtRaise {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("exc")).into(),
                ctx.new_str(ascii!("cause")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Try", base = "NodeStmt")]
struct NodeStmtTry;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtTry {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("handlers")).into(),
                ctx.new_str(ascii!("orelse")).into(),
                ctx.new_str(ascii!("finalbody")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "TryStar", base = "NodeStmt")]
struct NodeStmtTryStar;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtTryStar {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("handlers")).into(),
                ctx.new_str(ascii!("orelse")).into(),
                ctx.new_str(ascii!("finalbody")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Assert", base = "NodeStmt")]
struct NodeStmtAssert;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtAssert {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("test")).into(),
                ctx.new_str(ascii!("msg")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Import", base = "NodeStmt")]
struct NodeStmtImport;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtImport {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("names")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "ImportFrom", base = "NodeStmt")]
struct NodeStmtImportFrom;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtImportFrom {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("module")).into(),
                ctx.new_str(ascii!("names")).into(),
                ctx.new_str(ascii!("level")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Global", base = "NodeStmt")]
struct NodeStmtGlobal;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtGlobal {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("names")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Nonlocal", base = "NodeStmt")]
struct NodeStmtNonlocal;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtNonlocal {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("names")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Expr", base = "NodeStmt")]
struct NodeStmtExpr;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtExpr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("value")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Pass", base = "NodeStmt")]
struct NodeStmtPass;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtPass {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Break", base = "NodeStmt")]
struct NodeStmtBreak;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtBreak {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Continue", base = "NodeStmt")]
struct NodeStmtContinue;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeStmtContinue {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "expr", base = "NodeAst")]
struct NodeExpr;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExpr {}
#[pyclass(module = "_ast", name = "BoolOp", base = "NodeExpr")]
struct NodeExprBoolOp;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprBoolOp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("op")).into(),
                ctx.new_str(ascii!("values")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "NamedExpr", base = "NodeExpr")]
struct NodeExprNamedExpr;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprNamedExpr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("target")).into(),
                ctx.new_str(ascii!("value")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "BinOp", base = "NodeExpr")]
struct NodeExprBinOp;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprBinOp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("left")).into(),
                ctx.new_str(ascii!("op")).into(),
                ctx.new_str(ascii!("right")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "UnaryOp", base = "NodeExpr")]
struct NodeExprUnaryOp;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprUnaryOp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("op")).into(),
                ctx.new_str(ascii!("operand")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Lambda", base = "NodeExpr")]
struct NodeExprLambda;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprLambda {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("args")).into(),
                ctx.new_str(ascii!("body")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "IfExp", base = "NodeExpr")]
struct NodeExprIfExp;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprIfExp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("test")).into(),
                ctx.new_str(ascii!("body")).into(),
                ctx.new_str(ascii!("orelse")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Dict", base = "NodeExpr")]
struct NodeExprDict;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprDict {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("keys")).into(),
                ctx.new_str(ascii!("values")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Set", base = "NodeExpr")]
struct NodeExprSet;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprSet {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("elts")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "ListComp", base = "NodeExpr")]
struct NodeExprListComp;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprListComp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("elt")).into(),
                ctx.new_str(ascii!("generators")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "SetComp", base = "NodeExpr")]
struct NodeExprSetComp;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprSetComp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("elt")).into(),
                ctx.new_str(ascii!("generators")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "DictComp", base = "NodeExpr")]
struct NodeExprDictComp;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprDictComp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("key")).into(),
                ctx.new_str(ascii!("value")).into(),
                ctx.new_str(ascii!("generators")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "GeneratorExp", base = "NodeExpr")]
struct NodeExprGeneratorExp;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprGeneratorExp {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("elt")).into(),
                ctx.new_str(ascii!("generators")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Await", base = "NodeExpr")]
struct NodeExprAwait;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprAwait {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("value")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Yield", base = "NodeExpr")]
struct NodeExprYield;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprYield {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("value")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "YieldFrom", base = "NodeExpr")]
struct NodeExprYieldFrom;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprYieldFrom {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("value")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Compare", base = "NodeExpr")]
struct NodeExprCompare;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprCompare {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("left")).into(),
                ctx.new_str(ascii!("ops")).into(),
                ctx.new_str(ascii!("comparators")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Call", base = "NodeExpr")]
struct NodeExprCall;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprCall {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("func")).into(),
                ctx.new_str(ascii!("args")).into(),
                ctx.new_str(ascii!("keywords")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "FormattedValue", base = "NodeExpr")]
struct NodeExprFormattedValue;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprFormattedValue {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("value")).into(),
                ctx.new_str(ascii!("conversion")).into(),
                ctx.new_str(ascii!("format_spec")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "JoinedStr", base = "NodeExpr")]
struct NodeExprJoinedStr;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprJoinedStr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("values")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Constant", base = "NodeExpr")]
struct NodeExprConstant;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprConstant {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("value")).into(),
                ctx.new_str(ascii!("kind")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Attribute", base = "NodeExpr")]
struct NodeExprAttribute;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprAttribute {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("value")).into(),
                ctx.new_str(ascii!("attr")).into(),
                ctx.new_str(ascii!("ctx")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Subscript", base = "NodeExpr")]
struct NodeExprSubscript;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprSubscript {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("value")).into(),
                ctx.new_str(ascii!("slice")).into(),
                ctx.new_str(ascii!("ctx")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Starred", base = "NodeExpr")]
struct NodeExprStarred;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprStarred {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("value")).into(),
                ctx.new_str(ascii!("ctx")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Name", base = "NodeExpr")]
struct NodeExprName;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprName {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("id")).into(),
                ctx.new_str(ascii!("ctx")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "List", base = "NodeExpr")]
struct NodeExprList;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprList {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("elts")).into(),
                ctx.new_str(ascii!("ctx")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Tuple", base = "NodeExpr")]
struct NodeExprTuple;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprTuple {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("elts")).into(),
                ctx.new_str(ascii!("ctx")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "Slice", base = "NodeExpr")]
struct NodeExprSlice;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprSlice {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("lower")).into(),
                ctx.new_str(ascii!("upper")).into(),
                ctx.new_str(ascii!("step")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "expr_context", base = "NodeAst")]
struct NodeExprContext;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprContext {}
#[pyclass(module = "_ast", name = "Load", base = "NodeExprContext")]
struct NodeExprContextLoad;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprContextLoad {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Store", base = "NodeExprContext")]
struct NodeExprContextStore;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprContextStore {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Del", base = "NodeExprContext")]
struct NodeExprContextDel;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExprContextDel {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "boolop", base = "NodeAst")]
struct NodeBoolOp;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeBoolOp {}
#[pyclass(module = "_ast", name = "And", base = "NodeBoolOp")]
struct NodeBoolOpAnd;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeBoolOpAnd {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Or", base = "NodeBoolOp")]
struct NodeBoolOpOr;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeBoolOpOr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "operator", base = "NodeAst")]
struct NodeOperator;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeOperator {}
#[pyclass(module = "_ast", name = "Add", base = "NodeOperator")]
struct NodeOperatorAdd;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeOperatorAdd {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Sub", base = "NodeOperator")]
struct NodeOperatorSub;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeOperatorSub {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Mult", base = "NodeOperator")]
struct NodeOperatorMult;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeOperatorMult {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "MatMult", base = "NodeOperator")]
struct NodeOperatorMatMult;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeOperatorMatMult {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Div", base = "NodeOperator")]
struct NodeOperatorDiv;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeOperatorDiv {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Mod", base = "NodeOperator")]
struct NodeOperatorMod;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeOperatorMod {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Pow", base = "NodeOperator")]
struct NodeOperatorPow;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeOperatorPow {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "LShift", base = "NodeOperator")]
struct NodeOperatorLShift;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeOperatorLShift {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "RShift", base = "NodeOperator")]
struct NodeOperatorRShift;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeOperatorRShift {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "BitOr", base = "NodeOperator")]
struct NodeOperatorBitOr;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeOperatorBitOr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "BitXor", base = "NodeOperator")]
struct NodeOperatorBitXor;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeOperatorBitXor {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "BitAnd", base = "NodeOperator")]
struct NodeOperatorBitAnd;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeOperatorBitAnd {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "FloorDiv", base = "NodeOperator")]
struct NodeOperatorFloorDiv;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeOperatorFloorDiv {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "unaryop", base = "NodeAst")]
struct NodeUnaryOp;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeUnaryOp {}
#[pyclass(module = "_ast", name = "Invert", base = "NodeUnaryOp")]
struct NodeUnaryOpInvert;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeUnaryOpInvert {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Not", base = "NodeUnaryOp")]
struct NodeUnaryOpNot;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeUnaryOpNot {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "UAdd", base = "NodeUnaryOp")]
struct NodeUnaryOpUAdd;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeUnaryOpUAdd {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "USub", base = "NodeUnaryOp")]
struct NodeUnaryOpUSub;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeUnaryOpUSub {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "cmpop", base = "NodeAst")]
struct NodeCmpOp;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeCmpOp {}
#[pyclass(module = "_ast", name = "Eq", base = "NodeCmpOp")]
struct NodeCmpOpEq;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeCmpOpEq {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "NotEq", base = "NodeCmpOp")]
struct NodeCmpOpNotEq;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeCmpOpNotEq {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Lt", base = "NodeCmpOp")]
struct NodeCmpOpLt;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeCmpOpLt {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "LtE", base = "NodeCmpOp")]
struct NodeCmpOpLtE;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeCmpOpLtE {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Gt", base = "NodeCmpOp")]
struct NodeCmpOpGt;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeCmpOpGt {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "GtE", base = "NodeCmpOp")]
struct NodeCmpOpGtE;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeCmpOpGtE {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "Is", base = "NodeCmpOp")]
struct NodeCmpOpIs;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeCmpOpIs {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "IsNot", base = "NodeCmpOp")]
struct NodeCmpOpIsNot;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeCmpOpIsNot {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "In", base = "NodeCmpOp")]
struct NodeCmpOpIn;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeCmpOpIn {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "NotIn", base = "NodeCmpOp")]
struct NodeCmpOpNotIn;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeCmpOpNotIn {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(identifier!(ctx, _fields), ctx.new_tuple(vec![]).into());
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "comprehension", base = "NodeAst")]
struct NodeComprehension;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeComprehension {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("target")).into(),
                ctx.new_str(ascii!("iter")).into(),
                ctx.new_str(ascii!("ifs")).into(),
                ctx.new_str(ascii!("is_async")).into(),
            ])
            .into(),
        );
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "excepthandler", base = "NodeAst")]
struct NodeExceptHandler;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExceptHandler {}
#[pyclass(module = "_ast", name = "ExceptHandler", base = "NodeExceptHandler")]
struct NodeExceptHandlerExceptHandler;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeExceptHandlerExceptHandler {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("type")).into(),
                ctx.new_str(ascii!("name")).into(),
                ctx.new_str(ascii!("body")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "arguments", base = "NodeAst")]
struct NodeArguments;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeArguments {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("posonlyargs")).into(),
                ctx.new_str(ascii!("args")).into(),
                ctx.new_str(ascii!("vararg")).into(),
                ctx.new_str(ascii!("kwonlyargs")).into(),
                ctx.new_str(ascii!("kw_defaults")).into(),
                ctx.new_str(ascii!("kwarg")).into(),
                ctx.new_str(ascii!("defaults")).into(),
            ])
            .into(),
        );
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "arg", base = "NodeAst")]
struct NodeArg;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeArg {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("arg")).into(),
                ctx.new_str(ascii!("annotation")).into(),
                ctx.new_str(ascii!("type_comment")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "keyword", base = "NodeAst")]
struct NodeKeyword;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeKeyword {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("arg")).into(),
                ctx.new_str(ascii!("value")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "alias", base = "NodeAst")]
struct NodeAlias;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeAlias {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("name")).into(),
                ctx.new_str(ascii!("asname")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "withitem", base = "NodeAst")]
struct NodeWithItem;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeWithItem {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("context_expr")).into(),
                ctx.new_str(ascii!("optional_vars")).into(),
            ])
            .into(),
        );
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "match_case", base = "NodeAst")]
struct NodeMatchCase;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeMatchCase {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("pattern")).into(),
                ctx.new_str(ascii!("guard")).into(),
                ctx.new_str(ascii!("body")).into(),
            ])
            .into(),
        );
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "pattern", base = "NodeAst")]
struct NodePattern;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodePattern {}
#[pyclass(module = "_ast", name = "MatchValue", base = "NodePattern")]
struct NodePatternMatchValue;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodePatternMatchValue {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("value")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "MatchSingleton", base = "NodePattern")]
struct NodePatternMatchSingleton;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodePatternMatchSingleton {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("value")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "MatchSequence", base = "NodePattern")]
struct NodePatternMatchSequence;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodePatternMatchSequence {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("patterns")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "MatchMapping", base = "NodePattern")]
struct NodePatternMatchMapping;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodePatternMatchMapping {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("keys")).into(),
                ctx.new_str(ascii!("patterns")).into(),
                ctx.new_str(ascii!("rest")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "MatchClass", base = "NodePattern")]
struct NodePatternMatchClass;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodePatternMatchClass {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("cls")).into(),
                ctx.new_str(ascii!("patterns")).into(),
                ctx.new_str(ascii!("kwd_attrs")).into(),
                ctx.new_str(ascii!("kwd_patterns")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "MatchStar", base = "NodePattern")]
struct NodePatternMatchStar;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodePatternMatchStar {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("name")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "MatchAs", base = "NodePattern")]
struct NodePatternMatchAs;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodePatternMatchAs {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("pattern")).into(),
                ctx.new_str(ascii!("name")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "MatchOr", base = "NodePattern")]
struct NodePatternMatchOr;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodePatternMatchOr {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("patterns")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "type_ignore", base = "NodeAst")]
struct NodeTypeIgnore;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeTypeIgnore {}
#[pyclass(module = "_ast", name = "TypeIgnore", base = "NodeTypeIgnore")]
struct NodeTypeIgnoreTypeIgnore;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeTypeIgnoreTypeIgnore {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("tag")).into(),
            ])
            .into(),
        );
        class.set_attr(identifier!(ctx, _attributes), ctx.new_list(vec![]).into());
    }
}
#[pyclass(module = "_ast", name = "type_param", base = "NodeAst")]
struct NodeTypeParam;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeTypeParam {}
#[pyclass(module = "_ast", name = "TypeVar", base = "NodeTypeParam")]
struct NodeTypeParamTypeVar;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeTypeParamTypeVar {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![
                ctx.new_str(ascii!("name")).into(),
                ctx.new_str(ascii!("bound")).into(),
            ])
            .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "ParamSpec", base = "NodeTypeParam")]
struct NodeTypeParamParamSpec;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeTypeParamParamSpec {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("name")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}
#[pyclass(module = "_ast", name = "TypeVarTuple", base = "NodeTypeParam")]
struct NodeTypeParamTypeVarTuple;
#[pyclass(flags(HAS_DICT, BASETYPE))]
impl NodeTypeParamTypeVarTuple {
    #[extend_class]
    fn extend_class_with_fields(ctx: &Context, class: &'static Py<PyType>) {
        class.set_attr(
            identifier!(ctx, _fields),
            ctx.new_tuple(vec![ctx.new_str(ascii!("name")).into()])
                .into(),
        );
        class.set_attr(
            identifier!(ctx, _attributes),
            ctx.new_list(vec![
                ctx.new_str(ascii!("lineno")).into(),
                ctx.new_str(ascii!("col_offset")).into(),
                ctx.new_str(ascii!("end_lineno")).into(),
                ctx.new_str(ascii!("end_col_offset")).into(),
            ])
            .into(),
        );
    }
}

// sum
impl Node for ast::located::Mod {
    fn ast_to_object(self, vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::located::Mod::Module(cons) => cons.ast_to_object(vm),
            ast::located::Mod::Interactive(cons) => cons.ast_to_object(vm),
            ast::located::Mod::Expression(cons) => cons.ast_to_object(vm),
            ast::located::Mod::FunctionType(cons) => cons.ast_to_object(vm),
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(if _cls.is(NodeModModule::static_type()) {
            ast::located::Mod::Module(ast::located::ModModule::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeModInteractive::static_type()) {
            ast::located::Mod::Interactive(ast::located::ModInteractive::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodeModExpression::static_type()) {
            ast::located::Mod::Expression(ast::located::ModExpression::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodeModFunctionType::static_type()) {
            ast::located::Mod::FunctionType(ast::located::ModFunctionType::ast_from_object(
                _vm, _object,
            )?)
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of mod, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
// constructor
impl Node for ast::located::ModModule {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ModModule {
            body,
            type_ignores,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeModModule::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("type_ignores", type_ignores.ast_to_object(_vm), _vm)
            .unwrap();
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ModModule {
            body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "Module")?)?,
            type_ignores: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "type_ignores", "Module")?,
            )?,
            range: Default::default(),
        })
    }
}
// constructor
impl Node for ast::located::ModInteractive {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ModInteractive {
            body,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeModInteractive::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ModInteractive {
            body: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "body", "Interactive")?,
            )?,
            range: Default::default(),
        })
    }
}
// constructor
impl Node for ast::located::ModExpression {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ModExpression {
            body,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeModExpression::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ModExpression {
            body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "Expression")?)?,
            range: Default::default(),
        })
    }
}
// constructor
impl Node for ast::located::ModFunctionType {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ModFunctionType {
            argtypes,
            returns,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeModFunctionType::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("argtypes", argtypes.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("returns", returns.ast_to_object(_vm), _vm)
            .unwrap();
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ModFunctionType {
            argtypes: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "argtypes", "FunctionType")?,
            )?,
            returns: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "returns", "FunctionType")?,
            )?,
            range: Default::default(),
        })
    }
}
// sum
impl Node for ast::located::Stmt {
    fn ast_to_object(self, vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::located::Stmt::FunctionDef(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::AsyncFunctionDef(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::ClassDef(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::Return(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::Delete(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::Assign(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::TypeAlias(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::AugAssign(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::AnnAssign(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::For(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::AsyncFor(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::While(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::If(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::With(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::AsyncWith(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::Match(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::Raise(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::Try(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::TryStar(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::Assert(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::Import(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::ImportFrom(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::Global(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::Nonlocal(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::Expr(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::Pass(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::Break(cons) => cons.ast_to_object(vm),
            ast::located::Stmt::Continue(cons) => cons.ast_to_object(vm),
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(if _cls.is(NodeStmtFunctionDef::static_type()) {
            ast::located::Stmt::FunctionDef(ast::located::StmtFunctionDef::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodeStmtAsyncFunctionDef::static_type()) {
            ast::located::Stmt::AsyncFunctionDef(
                ast::located::StmtAsyncFunctionDef::ast_from_object(_vm, _object)?,
            )
        } else if _cls.is(NodeStmtClassDef::static_type()) {
            ast::located::Stmt::ClassDef(ast::located::StmtClassDef::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtReturn::static_type()) {
            ast::located::Stmt::Return(ast::located::StmtReturn::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtDelete::static_type()) {
            ast::located::Stmt::Delete(ast::located::StmtDelete::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtAssign::static_type()) {
            ast::located::Stmt::Assign(ast::located::StmtAssign::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtTypeAlias::static_type()) {
            ast::located::Stmt::TypeAlias(ast::located::StmtTypeAlias::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodeStmtAugAssign::static_type()) {
            ast::located::Stmt::AugAssign(ast::located::StmtAugAssign::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodeStmtAnnAssign::static_type()) {
            ast::located::Stmt::AnnAssign(ast::located::StmtAnnAssign::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodeStmtFor::static_type()) {
            ast::located::Stmt::For(ast::located::StmtFor::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtAsyncFor::static_type()) {
            ast::located::Stmt::AsyncFor(ast::located::StmtAsyncFor::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtWhile::static_type()) {
            ast::located::Stmt::While(ast::located::StmtWhile::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtIf::static_type()) {
            ast::located::Stmt::If(ast::located::StmtIf::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtWith::static_type()) {
            ast::located::Stmt::With(ast::located::StmtWith::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtAsyncWith::static_type()) {
            ast::located::Stmt::AsyncWith(ast::located::StmtAsyncWith::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodeStmtMatch::static_type()) {
            ast::located::Stmt::Match(ast::located::StmtMatch::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtRaise::static_type()) {
            ast::located::Stmt::Raise(ast::located::StmtRaise::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtTry::static_type()) {
            ast::located::Stmt::Try(ast::located::StmtTry::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtTryStar::static_type()) {
            ast::located::Stmt::TryStar(ast::located::StmtTryStar::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtAssert::static_type()) {
            ast::located::Stmt::Assert(ast::located::StmtAssert::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtImport::static_type()) {
            ast::located::Stmt::Import(ast::located::StmtImport::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtImportFrom::static_type()) {
            ast::located::Stmt::ImportFrom(ast::located::StmtImportFrom::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodeStmtGlobal::static_type()) {
            ast::located::Stmt::Global(ast::located::StmtGlobal::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtNonlocal::static_type()) {
            ast::located::Stmt::Nonlocal(ast::located::StmtNonlocal::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtExpr::static_type()) {
            ast::located::Stmt::Expr(ast::located::StmtExpr::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtPass::static_type()) {
            ast::located::Stmt::Pass(ast::located::StmtPass::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtBreak::static_type()) {
            ast::located::Stmt::Break(ast::located::StmtBreak::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeStmtContinue::static_type()) {
            ast::located::Stmt::Continue(ast::located::StmtContinue::ast_from_object(_vm, _object)?)
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of stmt, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
// constructor
impl Node for ast::located::StmtFunctionDef {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtFunctionDef {
            name,
            args,
            body,
            decorator_list,
            returns,
            type_comment,
            type_params,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtFunctionDef::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("args", args.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("decorator_list", decorator_list.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("returns", returns.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("type_params", type_params.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtFunctionDef {
            name: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "name", "FunctionDef")?,
            )?,
            args: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "args", "FunctionDef")?,
            )?,
            body: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "body", "FunctionDef")?,
            )?,
            decorator_list: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "decorator_list", "FunctionDef")?,
            )?,
            returns: get_node_field_opt(_vm, &_object, "returns")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            type_comment: get_node_field_opt(_vm, &_object, "type_comment")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            type_params: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "type_params", "FunctionDef")?,
            )?,
            range: range_from_object(_vm, _object, "FunctionDef")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtAsyncFunctionDef {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtAsyncFunctionDef {
            name,
            args,
            body,
            decorator_list,
            returns,
            type_comment,
            type_params,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtAsyncFunctionDef::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("args", args.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("decorator_list", decorator_list.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("returns", returns.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("type_params", type_params.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtAsyncFunctionDef {
            name: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "name", "AsyncFunctionDef")?,
            )?,
            args: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "args", "AsyncFunctionDef")?,
            )?,
            body: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "body", "AsyncFunctionDef")?,
            )?,
            decorator_list: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "decorator_list", "AsyncFunctionDef")?,
            )?,
            returns: get_node_field_opt(_vm, &_object, "returns")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            type_comment: get_node_field_opt(_vm, &_object, "type_comment")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            type_params: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "type_params", "AsyncFunctionDef")?,
            )?,
            range: range_from_object(_vm, _object, "AsyncFunctionDef")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtClassDef {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtClassDef {
            name,
            bases,
            keywords,
            body,
            decorator_list,
            type_params,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtClassDef::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("bases", bases.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("keywords", keywords.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("decorator_list", decorator_list.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("type_params", type_params.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtClassDef {
            name: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "name", "ClassDef")?)?,
            bases: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "bases", "ClassDef")?)?,
            keywords: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "keywords", "ClassDef")?,
            )?,
            body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "ClassDef")?)?,
            decorator_list: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "decorator_list", "ClassDef")?,
            )?,
            type_params: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "type_params", "ClassDef")?,
            )?,
            range: range_from_object(_vm, _object, "ClassDef")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtReturn {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtReturn {
            value,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtReturn::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtReturn {
            value: get_node_field_opt(_vm, &_object, "value")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: range_from_object(_vm, _object, "Return")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtDelete {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtDelete {
            targets,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtDelete::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("targets", targets.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtDelete {
            targets: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "targets", "Delete")?,
            )?,
            range: range_from_object(_vm, _object, "Delete")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtAssign {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtAssign {
            targets,
            value,
            type_comment,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtAssign::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("targets", targets.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtAssign {
            targets: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "targets", "Assign")?,
            )?,
            value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "Assign")?)?,
            type_comment: get_node_field_opt(_vm, &_object, "type_comment")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: range_from_object(_vm, _object, "Assign")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtTypeAlias {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtTypeAlias {
            name,
            type_params,
            value,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtTypeAlias::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("type_params", type_params.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtTypeAlias {
            name: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "name", "TypeAlias")?)?,
            type_params: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "type_params", "TypeAlias")?,
            )?,
            value: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "value", "TypeAlias")?,
            )?,
            range: range_from_object(_vm, _object, "TypeAlias")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtAugAssign {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtAugAssign {
            target,
            op,
            value,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtAugAssign::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("target", target.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("op", op.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtAugAssign {
            target: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "target", "AugAssign")?,
            )?,
            op: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "op", "AugAssign")?)?,
            value: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "value", "AugAssign")?,
            )?,
            range: range_from_object(_vm, _object, "AugAssign")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtAnnAssign {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtAnnAssign {
            target,
            annotation,
            value,
            simple,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtAnnAssign::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("target", target.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("annotation", annotation.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("simple", simple.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtAnnAssign {
            target: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "target", "AnnAssign")?,
            )?,
            annotation: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "annotation", "AnnAssign")?,
            )?,
            value: get_node_field_opt(_vm, &_object, "value")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            simple: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "simple", "AnnAssign")?,
            )?,
            range: range_from_object(_vm, _object, "AnnAssign")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtFor {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtFor {
            target,
            iter,
            body,
            orelse,
            type_comment,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtFor::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("target", target.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("iter", iter.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("orelse", orelse.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtFor {
            target: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "target", "For")?)?,
            iter: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "iter", "For")?)?,
            body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "For")?)?,
            orelse: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "orelse", "For")?)?,
            type_comment: get_node_field_opt(_vm, &_object, "type_comment")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: range_from_object(_vm, _object, "For")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtAsyncFor {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtAsyncFor {
            target,
            iter,
            body,
            orelse,
            type_comment,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtAsyncFor::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("target", target.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("iter", iter.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("orelse", orelse.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtAsyncFor {
            target: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "target", "AsyncFor")?,
            )?,
            iter: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "iter", "AsyncFor")?)?,
            body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "AsyncFor")?)?,
            orelse: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "orelse", "AsyncFor")?,
            )?,
            type_comment: get_node_field_opt(_vm, &_object, "type_comment")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: range_from_object(_vm, _object, "AsyncFor")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtWhile {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtWhile {
            test,
            body,
            orelse,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtWhile::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("test", test.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("orelse", orelse.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtWhile {
            test: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "test", "While")?)?,
            body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "While")?)?,
            orelse: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "orelse", "While")?)?,
            range: range_from_object(_vm, _object, "While")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtIf {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtIf {
            test,
            body,
            orelse,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtIf::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("test", test.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("orelse", orelse.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtIf {
            test: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "test", "If")?)?,
            body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "If")?)?,
            orelse: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "orelse", "If")?)?,
            range: range_from_object(_vm, _object, "If")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtWith {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtWith {
            items,
            body,
            type_comment,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtWith::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("items", items.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtWith {
            items: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "items", "With")?)?,
            body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "With")?)?,
            type_comment: get_node_field_opt(_vm, &_object, "type_comment")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: range_from_object(_vm, _object, "With")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtAsyncWith {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtAsyncWith {
            items,
            body,
            type_comment,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtAsyncWith::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("items", items.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtAsyncWith {
            items: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "items", "AsyncWith")?,
            )?,
            body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "AsyncWith")?)?,
            type_comment: get_node_field_opt(_vm, &_object, "type_comment")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: range_from_object(_vm, _object, "AsyncWith")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtMatch {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtMatch {
            subject,
            cases,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtMatch::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("subject", subject.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("cases", cases.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtMatch {
            subject: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "subject", "Match")?,
            )?,
            cases: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "cases", "Match")?)?,
            range: range_from_object(_vm, _object, "Match")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtRaise {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtRaise {
            exc,
            cause,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtRaise::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("exc", exc.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("cause", cause.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtRaise {
            exc: get_node_field_opt(_vm, &_object, "exc")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            cause: get_node_field_opt(_vm, &_object, "cause")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: range_from_object(_vm, _object, "Raise")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtTry {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtTry {
            body,
            handlers,
            orelse,
            finalbody,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtTry::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("handlers", handlers.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("orelse", orelse.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("finalbody", finalbody.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtTry {
            body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "Try")?)?,
            handlers: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "handlers", "Try")?,
            )?,
            orelse: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "orelse", "Try")?)?,
            finalbody: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "finalbody", "Try")?,
            )?,
            range: range_from_object(_vm, _object, "Try")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtTryStar {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtTryStar {
            body,
            handlers,
            orelse,
            finalbody,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtTryStar::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("handlers", handlers.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("orelse", orelse.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("finalbody", finalbody.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtTryStar {
            body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "TryStar")?)?,
            handlers: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "handlers", "TryStar")?,
            )?,
            orelse: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "orelse", "TryStar")?,
            )?,
            finalbody: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "finalbody", "TryStar")?,
            )?,
            range: range_from_object(_vm, _object, "TryStar")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtAssert {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtAssert {
            test,
            msg,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtAssert::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("test", test.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("msg", msg.ast_to_object(_vm), _vm).unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtAssert {
            test: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "test", "Assert")?)?,
            msg: get_node_field_opt(_vm, &_object, "msg")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: range_from_object(_vm, _object, "Assert")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtImport {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtImport {
            names,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtImport::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("names", names.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtImport {
            names: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "names", "Import")?)?,
            range: range_from_object(_vm, _object, "Import")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtImportFrom {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtImportFrom {
            module,
            names,
            level,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtImportFrom::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("module", module.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("names", names.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("level", level.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtImportFrom {
            module: get_node_field_opt(_vm, &_object, "module")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            names: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "names", "ImportFrom")?,
            )?,
            level: get_node_field_opt(_vm, &_object, "level")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: range_from_object(_vm, _object, "ImportFrom")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtGlobal {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtGlobal {
            names,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtGlobal::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("names", names.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtGlobal {
            names: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "names", "Global")?)?,
            range: range_from_object(_vm, _object, "Global")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtNonlocal {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtNonlocal {
            names,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtNonlocal::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("names", names.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtNonlocal {
            names: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "names", "Nonlocal")?)?,
            range: range_from_object(_vm, _object, "Nonlocal")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtExpr {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtExpr {
            value,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtExpr::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtExpr {
            value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "Expr")?)?,
            range: range_from_object(_vm, _object, "Expr")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtPass {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtPass { range: _range } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtPass::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtPass {
            range: range_from_object(_vm, _object, "Pass")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtBreak {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtBreak { range: _range } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtBreak::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtBreak {
            range: range_from_object(_vm, _object, "Break")?,
        })
    }
}
// constructor
impl Node for ast::located::StmtContinue {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::StmtContinue { range: _range } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeStmtContinue::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::StmtContinue {
            range: range_from_object(_vm, _object, "Continue")?,
        })
    }
}
// sum
impl Node for ast::located::Expr {
    fn ast_to_object(self, vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::located::Expr::BoolOp(cons) => cons.ast_to_object(vm),
            ast::located::Expr::NamedExpr(cons) => cons.ast_to_object(vm),
            ast::located::Expr::BinOp(cons) => cons.ast_to_object(vm),
            ast::located::Expr::UnaryOp(cons) => cons.ast_to_object(vm),
            ast::located::Expr::Lambda(cons) => cons.ast_to_object(vm),
            ast::located::Expr::IfExp(cons) => cons.ast_to_object(vm),
            ast::located::Expr::Dict(cons) => cons.ast_to_object(vm),
            ast::located::Expr::Set(cons) => cons.ast_to_object(vm),
            ast::located::Expr::ListComp(cons) => cons.ast_to_object(vm),
            ast::located::Expr::SetComp(cons) => cons.ast_to_object(vm),
            ast::located::Expr::DictComp(cons) => cons.ast_to_object(vm),
            ast::located::Expr::GeneratorExp(cons) => cons.ast_to_object(vm),
            ast::located::Expr::Await(cons) => cons.ast_to_object(vm),
            ast::located::Expr::Yield(cons) => cons.ast_to_object(vm),
            ast::located::Expr::YieldFrom(cons) => cons.ast_to_object(vm),
            ast::located::Expr::Compare(cons) => cons.ast_to_object(vm),
            ast::located::Expr::Call(cons) => cons.ast_to_object(vm),
            ast::located::Expr::FormattedValue(cons) => cons.ast_to_object(vm),
            ast::located::Expr::JoinedStr(cons) => cons.ast_to_object(vm),
            ast::located::Expr::Constant(cons) => cons.ast_to_object(vm),
            ast::located::Expr::Attribute(cons) => cons.ast_to_object(vm),
            ast::located::Expr::Subscript(cons) => cons.ast_to_object(vm),
            ast::located::Expr::Starred(cons) => cons.ast_to_object(vm),
            ast::located::Expr::Name(cons) => cons.ast_to_object(vm),
            ast::located::Expr::List(cons) => cons.ast_to_object(vm),
            ast::located::Expr::Tuple(cons) => cons.ast_to_object(vm),
            ast::located::Expr::Slice(cons) => cons.ast_to_object(vm),
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(if _cls.is(NodeExprBoolOp::static_type()) {
            ast::located::Expr::BoolOp(ast::located::ExprBoolOp::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeExprNamedExpr::static_type()) {
            ast::located::Expr::NamedExpr(ast::located::ExprNamedExpr::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodeExprBinOp::static_type()) {
            ast::located::Expr::BinOp(ast::located::ExprBinOp::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeExprUnaryOp::static_type()) {
            ast::located::Expr::UnaryOp(ast::located::ExprUnaryOp::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeExprLambda::static_type()) {
            ast::located::Expr::Lambda(ast::located::ExprLambda::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeExprIfExp::static_type()) {
            ast::located::Expr::IfExp(ast::located::ExprIfExp::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeExprDict::static_type()) {
            ast::located::Expr::Dict(ast::located::ExprDict::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeExprSet::static_type()) {
            ast::located::Expr::Set(ast::located::ExprSet::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeExprListComp::static_type()) {
            ast::located::Expr::ListComp(ast::located::ExprListComp::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeExprSetComp::static_type()) {
            ast::located::Expr::SetComp(ast::located::ExprSetComp::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeExprDictComp::static_type()) {
            ast::located::Expr::DictComp(ast::located::ExprDictComp::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeExprGeneratorExp::static_type()) {
            ast::located::Expr::GeneratorExp(ast::located::ExprGeneratorExp::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodeExprAwait::static_type()) {
            ast::located::Expr::Await(ast::located::ExprAwait::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeExprYield::static_type()) {
            ast::located::Expr::Yield(ast::located::ExprYield::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeExprYieldFrom::static_type()) {
            ast::located::Expr::YieldFrom(ast::located::ExprYieldFrom::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodeExprCompare::static_type()) {
            ast::located::Expr::Compare(ast::located::ExprCompare::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeExprCall::static_type()) {
            ast::located::Expr::Call(ast::located::ExprCall::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeExprFormattedValue::static_type()) {
            ast::located::Expr::FormattedValue(ast::located::ExprFormattedValue::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodeExprJoinedStr::static_type()) {
            ast::located::Expr::JoinedStr(ast::located::ExprJoinedStr::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodeExprConstant::static_type()) {
            ast::located::Expr::Constant(ast::located::ExprConstant::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeExprAttribute::static_type()) {
            ast::located::Expr::Attribute(ast::located::ExprAttribute::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodeExprSubscript::static_type()) {
            ast::located::Expr::Subscript(ast::located::ExprSubscript::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodeExprStarred::static_type()) {
            ast::located::Expr::Starred(ast::located::ExprStarred::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeExprName::static_type()) {
            ast::located::Expr::Name(ast::located::ExprName::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeExprList::static_type()) {
            ast::located::Expr::List(ast::located::ExprList::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeExprTuple::static_type()) {
            ast::located::Expr::Tuple(ast::located::ExprTuple::ast_from_object(_vm, _object)?)
        } else if _cls.is(NodeExprSlice::static_type()) {
            ast::located::Expr::Slice(ast::located::ExprSlice::ast_from_object(_vm, _object)?)
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of expr, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
// constructor
impl Node for ast::located::ExprBoolOp {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprBoolOp {
            op,
            values,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprBoolOp::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("op", op.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("values", values.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprBoolOp {
            op: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "op", "BoolOp")?)?,
            values: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "values", "BoolOp")?)?,
            range: range_from_object(_vm, _object, "BoolOp")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprNamedExpr {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprNamedExpr {
            target,
            value,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprNamedExpr::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("target", target.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprNamedExpr {
            target: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "target", "NamedExpr")?,
            )?,
            value: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "value", "NamedExpr")?,
            )?,
            range: range_from_object(_vm, _object, "NamedExpr")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprBinOp {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprBinOp {
            left,
            op,
            right,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprBinOp::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("left", left.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("op", op.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("right", right.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprBinOp {
            left: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "left", "BinOp")?)?,
            op: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "op", "BinOp")?)?,
            right: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "right", "BinOp")?)?,
            range: range_from_object(_vm, _object, "BinOp")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprUnaryOp {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprUnaryOp {
            op,
            operand,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprUnaryOp::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("op", op.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("operand", operand.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprUnaryOp {
            op: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "op", "UnaryOp")?)?,
            operand: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "operand", "UnaryOp")?,
            )?,
            range: range_from_object(_vm, _object, "UnaryOp")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprLambda {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprLambda {
            args,
            body,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprLambda::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("args", args.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprLambda {
            args: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "args", "Lambda")?)?,
            body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "Lambda")?)?,
            range: range_from_object(_vm, _object, "Lambda")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprIfExp {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprIfExp {
            test,
            body,
            orelse,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprIfExp::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("test", test.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("orelse", orelse.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprIfExp {
            test: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "test", "IfExp")?)?,
            body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "IfExp")?)?,
            orelse: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "orelse", "IfExp")?)?,
            range: range_from_object(_vm, _object, "IfExp")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprDict {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprDict {
            keys,
            values,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprDict::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("keys", keys.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("values", values.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprDict {
            keys: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "keys", "Dict")?)?,
            values: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "values", "Dict")?)?,
            range: range_from_object(_vm, _object, "Dict")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprSet {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprSet {
            elts,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprSet::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("elts", elts.ast_to_object(_vm), _vm).unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprSet {
            elts: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "elts", "Set")?)?,
            range: range_from_object(_vm, _object, "Set")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprListComp {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprListComp {
            elt,
            generators,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprListComp::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("elt", elt.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("generators", generators.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprListComp {
            elt: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "elt", "ListComp")?)?,
            generators: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "generators", "ListComp")?,
            )?,
            range: range_from_object(_vm, _object, "ListComp")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprSetComp {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprSetComp {
            elt,
            generators,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprSetComp::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("elt", elt.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("generators", generators.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprSetComp {
            elt: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "elt", "SetComp")?)?,
            generators: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "generators", "SetComp")?,
            )?,
            range: range_from_object(_vm, _object, "SetComp")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprDictComp {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprDictComp {
            key,
            value,
            generators,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprDictComp::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("key", key.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("generators", generators.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprDictComp {
            key: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "key", "DictComp")?)?,
            value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "DictComp")?)?,
            generators: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "generators", "DictComp")?,
            )?,
            range: range_from_object(_vm, _object, "DictComp")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprGeneratorExp {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprGeneratorExp {
            elt,
            generators,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprGeneratorExp::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("elt", elt.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("generators", generators.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprGeneratorExp {
            elt: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "elt", "GeneratorExp")?)?,
            generators: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "generators", "GeneratorExp")?,
            )?,
            range: range_from_object(_vm, _object, "GeneratorExp")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprAwait {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprAwait {
            value,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprAwait::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprAwait {
            value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "Await")?)?,
            range: range_from_object(_vm, _object, "Await")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprYield {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprYield {
            value,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprYield::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprYield {
            value: get_node_field_opt(_vm, &_object, "value")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: range_from_object(_vm, _object, "Yield")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprYieldFrom {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprYieldFrom {
            value,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprYieldFrom::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprYieldFrom {
            value: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "value", "YieldFrom")?,
            )?,
            range: range_from_object(_vm, _object, "YieldFrom")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprCompare {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprCompare {
            left,
            ops,
            comparators,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprCompare::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("left", left.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("ops", ops.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("comparators", comparators.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprCompare {
            left: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "left", "Compare")?)?,
            ops: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ops", "Compare")?)?,
            comparators: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "comparators", "Compare")?,
            )?,
            range: range_from_object(_vm, _object, "Compare")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprCall {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprCall {
            func,
            args,
            keywords,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprCall::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("func", func.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("args", args.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("keywords", keywords.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprCall {
            func: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "func", "Call")?)?,
            args: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "args", "Call")?)?,
            keywords: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "keywords", "Call")?,
            )?,
            range: range_from_object(_vm, _object, "Call")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprFormattedValue {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprFormattedValue {
            value,
            conversion,
            format_spec,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprFormattedValue::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("conversion", conversion.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("format_spec", format_spec.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprFormattedValue {
            value: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "value", "FormattedValue")?,
            )?,
            conversion: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "conversion", "FormattedValue")?,
            )?,
            format_spec: get_node_field_opt(_vm, &_object, "format_spec")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: range_from_object(_vm, _object, "FormattedValue")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprJoinedStr {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprJoinedStr {
            values,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprJoinedStr::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("values", values.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprJoinedStr {
            values: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "values", "JoinedStr")?,
            )?,
            range: range_from_object(_vm, _object, "JoinedStr")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprConstant {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprConstant {
            value,
            kind,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprConstant::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("kind", kind.ast_to_object(_vm), _vm).unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprConstant {
            value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "Constant")?)?,
            kind: get_node_field_opt(_vm, &_object, "kind")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: range_from_object(_vm, _object, "Constant")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprAttribute {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprAttribute {
            value,
            attr,
            ctx,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprAttribute::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("attr", attr.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprAttribute {
            value: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "value", "Attribute")?,
            )?,
            attr: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "attr", "Attribute")?)?,
            ctx: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ctx", "Attribute")?)?,
            range: range_from_object(_vm, _object, "Attribute")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprSubscript {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprSubscript {
            value,
            slice,
            ctx,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprSubscript::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("slice", slice.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprSubscript {
            value: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "value", "Subscript")?,
            )?,
            slice: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "slice", "Subscript")?,
            )?,
            ctx: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ctx", "Subscript")?)?,
            range: range_from_object(_vm, _object, "Subscript")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprStarred {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprStarred {
            value,
            ctx,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprStarred::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprStarred {
            value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "Starred")?)?,
            ctx: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ctx", "Starred")?)?,
            range: range_from_object(_vm, _object, "Starred")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprName {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprName {
            id,
            ctx,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprName::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("id", id.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprName {
            id: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "id", "Name")?)?,
            ctx: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ctx", "Name")?)?,
            range: range_from_object(_vm, _object, "Name")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprList {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprList {
            elts,
            ctx,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprList::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("elts", elts.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprList {
            elts: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "elts", "List")?)?,
            ctx: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ctx", "List")?)?,
            range: range_from_object(_vm, _object, "List")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprTuple {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprTuple {
            elts,
            ctx,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprTuple::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("elts", elts.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("ctx", ctx.ast_to_object(_vm), _vm).unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprTuple {
            elts: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "elts", "Tuple")?)?,
            ctx: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "ctx", "Tuple")?)?,
            range: range_from_object(_vm, _object, "Tuple")?,
        })
    }
}
// constructor
impl Node for ast::located::ExprSlice {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExprSlice {
            lower,
            upper,
            step,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeExprSlice::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("lower", lower.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("upper", upper.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("step", step.ast_to_object(_vm), _vm).unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExprSlice {
            lower: get_node_field_opt(_vm, &_object, "lower")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            upper: get_node_field_opt(_vm, &_object, "upper")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            step: get_node_field_opt(_vm, &_object, "step")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: range_from_object(_vm, _object, "Slice")?,
        })
    }
}
// sum
impl Node for ast::located::ExprContext {
    fn ast_to_object(self, vm: &VirtualMachine) -> PyObjectRef {
        let node_type = match self {
            ast::located::ExprContext::Load => NodeExprContextLoad::static_type(),
            ast::located::ExprContext::Store => NodeExprContextStore::static_type(),
            ast::located::ExprContext::Del => NodeExprContextDel::static_type(),
        };
        NodeAst
            .into_ref_with_type(vm, node_type.to_owned())
            .unwrap()
            .into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(if _cls.is(NodeExprContextLoad::static_type()) {
            ast::located::ExprContext::Load
        } else if _cls.is(NodeExprContextStore::static_type()) {
            ast::located::ExprContext::Store
        } else if _cls.is(NodeExprContextDel::static_type()) {
            ast::located::ExprContext::Del
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of expr_context, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
// sum
impl Node for ast::located::BoolOp {
    fn ast_to_object(self, vm: &VirtualMachine) -> PyObjectRef {
        let node_type = match self {
            ast::located::BoolOp::And => NodeBoolOpAnd::static_type(),
            ast::located::BoolOp::Or => NodeBoolOpOr::static_type(),
        };
        NodeAst
            .into_ref_with_type(vm, node_type.to_owned())
            .unwrap()
            .into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(if _cls.is(NodeBoolOpAnd::static_type()) {
            ast::located::BoolOp::And
        } else if _cls.is(NodeBoolOpOr::static_type()) {
            ast::located::BoolOp::Or
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of boolop, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
// sum
impl Node for ast::located::Operator {
    fn ast_to_object(self, vm: &VirtualMachine) -> PyObjectRef {
        let node_type = match self {
            ast::located::Operator::Add => NodeOperatorAdd::static_type(),
            ast::located::Operator::Sub => NodeOperatorSub::static_type(),
            ast::located::Operator::Mult => NodeOperatorMult::static_type(),
            ast::located::Operator::MatMult => NodeOperatorMatMult::static_type(),
            ast::located::Operator::Div => NodeOperatorDiv::static_type(),
            ast::located::Operator::Mod => NodeOperatorMod::static_type(),
            ast::located::Operator::Pow => NodeOperatorPow::static_type(),
            ast::located::Operator::LShift => NodeOperatorLShift::static_type(),
            ast::located::Operator::RShift => NodeOperatorRShift::static_type(),
            ast::located::Operator::BitOr => NodeOperatorBitOr::static_type(),
            ast::located::Operator::BitXor => NodeOperatorBitXor::static_type(),
            ast::located::Operator::BitAnd => NodeOperatorBitAnd::static_type(),
            ast::located::Operator::FloorDiv => NodeOperatorFloorDiv::static_type(),
        };
        NodeAst
            .into_ref_with_type(vm, node_type.to_owned())
            .unwrap()
            .into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(if _cls.is(NodeOperatorAdd::static_type()) {
            ast::located::Operator::Add
        } else if _cls.is(NodeOperatorSub::static_type()) {
            ast::located::Operator::Sub
        } else if _cls.is(NodeOperatorMult::static_type()) {
            ast::located::Operator::Mult
        } else if _cls.is(NodeOperatorMatMult::static_type()) {
            ast::located::Operator::MatMult
        } else if _cls.is(NodeOperatorDiv::static_type()) {
            ast::located::Operator::Div
        } else if _cls.is(NodeOperatorMod::static_type()) {
            ast::located::Operator::Mod
        } else if _cls.is(NodeOperatorPow::static_type()) {
            ast::located::Operator::Pow
        } else if _cls.is(NodeOperatorLShift::static_type()) {
            ast::located::Operator::LShift
        } else if _cls.is(NodeOperatorRShift::static_type()) {
            ast::located::Operator::RShift
        } else if _cls.is(NodeOperatorBitOr::static_type()) {
            ast::located::Operator::BitOr
        } else if _cls.is(NodeOperatorBitXor::static_type()) {
            ast::located::Operator::BitXor
        } else if _cls.is(NodeOperatorBitAnd::static_type()) {
            ast::located::Operator::BitAnd
        } else if _cls.is(NodeOperatorFloorDiv::static_type()) {
            ast::located::Operator::FloorDiv
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of operator, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
// sum
impl Node for ast::located::UnaryOp {
    fn ast_to_object(self, vm: &VirtualMachine) -> PyObjectRef {
        let node_type = match self {
            ast::located::UnaryOp::Invert => NodeUnaryOpInvert::static_type(),
            ast::located::UnaryOp::Not => NodeUnaryOpNot::static_type(),
            ast::located::UnaryOp::UAdd => NodeUnaryOpUAdd::static_type(),
            ast::located::UnaryOp::USub => NodeUnaryOpUSub::static_type(),
        };
        NodeAst
            .into_ref_with_type(vm, node_type.to_owned())
            .unwrap()
            .into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(if _cls.is(NodeUnaryOpInvert::static_type()) {
            ast::located::UnaryOp::Invert
        } else if _cls.is(NodeUnaryOpNot::static_type()) {
            ast::located::UnaryOp::Not
        } else if _cls.is(NodeUnaryOpUAdd::static_type()) {
            ast::located::UnaryOp::UAdd
        } else if _cls.is(NodeUnaryOpUSub::static_type()) {
            ast::located::UnaryOp::USub
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of unaryop, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
// sum
impl Node for ast::located::CmpOp {
    fn ast_to_object(self, vm: &VirtualMachine) -> PyObjectRef {
        let node_type = match self {
            ast::located::CmpOp::Eq => NodeCmpOpEq::static_type(),
            ast::located::CmpOp::NotEq => NodeCmpOpNotEq::static_type(),
            ast::located::CmpOp::Lt => NodeCmpOpLt::static_type(),
            ast::located::CmpOp::LtE => NodeCmpOpLtE::static_type(),
            ast::located::CmpOp::Gt => NodeCmpOpGt::static_type(),
            ast::located::CmpOp::GtE => NodeCmpOpGtE::static_type(),
            ast::located::CmpOp::Is => NodeCmpOpIs::static_type(),
            ast::located::CmpOp::IsNot => NodeCmpOpIsNot::static_type(),
            ast::located::CmpOp::In => NodeCmpOpIn::static_type(),
            ast::located::CmpOp::NotIn => NodeCmpOpNotIn::static_type(),
        };
        NodeAst
            .into_ref_with_type(vm, node_type.to_owned())
            .unwrap()
            .into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(if _cls.is(NodeCmpOpEq::static_type()) {
            ast::located::CmpOp::Eq
        } else if _cls.is(NodeCmpOpNotEq::static_type()) {
            ast::located::CmpOp::NotEq
        } else if _cls.is(NodeCmpOpLt::static_type()) {
            ast::located::CmpOp::Lt
        } else if _cls.is(NodeCmpOpLtE::static_type()) {
            ast::located::CmpOp::LtE
        } else if _cls.is(NodeCmpOpGt::static_type()) {
            ast::located::CmpOp::Gt
        } else if _cls.is(NodeCmpOpGtE::static_type()) {
            ast::located::CmpOp::GtE
        } else if _cls.is(NodeCmpOpIs::static_type()) {
            ast::located::CmpOp::Is
        } else if _cls.is(NodeCmpOpIsNot::static_type()) {
            ast::located::CmpOp::IsNot
        } else if _cls.is(NodeCmpOpIn::static_type()) {
            ast::located::CmpOp::In
        } else if _cls.is(NodeCmpOpNotIn::static_type()) {
            ast::located::CmpOp::NotIn
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of cmpop, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
// product
impl Node for ast::located::Comprehension {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::Comprehension {
            target,
            iter,
            ifs,
            is_async,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeComprehension::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("target", target.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("iter", iter.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("ifs", ifs.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("is_async", is_async.ast_to_object(_vm), _vm)
            .unwrap();
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::Comprehension {
            target: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "target", "comprehension")?,
            )?,
            iter: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "iter", "comprehension")?,
            )?,
            ifs: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "ifs", "comprehension")?,
            )?,
            is_async: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "is_async", "comprehension")?,
            )?,
            range: Default::default(),
        })
    }
}
// sum
impl Node for ast::located::ExceptHandler {
    fn ast_to_object(self, vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::located::ExceptHandler::ExceptHandler(cons) => cons.ast_to_object(vm),
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(if _cls.is(NodeExceptHandlerExceptHandler::static_type()) {
            ast::located::ExceptHandler::ExceptHandler(
                ast::located::ExceptHandlerExceptHandler::ast_from_object(_vm, _object)?,
            )
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of excepthandler, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
// constructor
impl Node for ast::located::ExceptHandlerExceptHandler {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::ExceptHandlerExceptHandler {
            type_,
            name,
            body,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(
                _vm,
                NodeExceptHandlerExceptHandler::static_type().to_owned(),
            )
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("type", type_.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::ExceptHandlerExceptHandler {
            type_: get_node_field_opt(_vm, &_object, "type")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            name: get_node_field_opt(_vm, &_object, "name")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            body: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "body", "ExceptHandler")?,
            )?,
            range: range_from_object(_vm, _object, "ExceptHandler")?,
        })
    }
}
// product
impl Node for ast::located::PythonArguments {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::PythonArguments {
            posonlyargs,
            args,
            vararg,
            kwonlyargs,
            kw_defaults,
            kwarg,
            defaults,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeArguments::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("posonlyargs", posonlyargs.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("args", args.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("vararg", vararg.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("kwonlyargs", kwonlyargs.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("kw_defaults", kw_defaults.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("kwarg", kwarg.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("defaults", defaults.ast_to_object(_vm), _vm)
            .unwrap();
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::PythonArguments {
            posonlyargs: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "posonlyargs", "arguments")?,
            )?,
            args: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "args", "arguments")?)?,
            vararg: get_node_field_opt(_vm, &_object, "vararg")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            kwonlyargs: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "kwonlyargs", "arguments")?,
            )?,
            kw_defaults: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "kw_defaults", "arguments")?,
            )?,
            kwarg: get_node_field_opt(_vm, &_object, "kwarg")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            defaults: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "defaults", "arguments")?,
            )?,
            range: Default::default(),
        })
    }
}
// product
impl Node for ast::located::Arg {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::Arg {
            arg,
            annotation,
            type_comment,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeArg::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("arg", arg.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("annotation", annotation.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("type_comment", type_comment.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::Arg {
            arg: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "arg", "arg")?)?,
            annotation: get_node_field_opt(_vm, &_object, "annotation")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            type_comment: get_node_field_opt(_vm, &_object, "type_comment")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: range_from_object(_vm, _object, "arg")?,
        })
    }
}
// product
impl Node for ast::located::Keyword {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::Keyword {
            arg,
            value,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeKeyword::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("arg", arg.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::Keyword {
            arg: get_node_field_opt(_vm, &_object, "arg")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            value: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "value", "keyword")?)?,
            range: range_from_object(_vm, _object, "keyword")?,
        })
    }
}
// product
impl Node for ast::located::Alias {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::Alias {
            name,
            asname,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeAlias::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("asname", asname.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::Alias {
            name: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "name", "alias")?)?,
            asname: get_node_field_opt(_vm, &_object, "asname")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: range_from_object(_vm, _object, "alias")?,
        })
    }
}
// product
impl Node for ast::located::WithItem {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::WithItem {
            context_expr,
            optional_vars,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeWithItem::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("context_expr", context_expr.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("optional_vars", optional_vars.ast_to_object(_vm), _vm)
            .unwrap();
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::WithItem {
            context_expr: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "context_expr", "withitem")?,
            )?,
            optional_vars: get_node_field_opt(_vm, &_object, "optional_vars")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: Default::default(),
        })
    }
}
// product
impl Node for ast::located::MatchCase {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::MatchCase {
            pattern,
            guard,
            body,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeMatchCase::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("pattern", pattern.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("guard", guard.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("body", body.ast_to_object(_vm), _vm).unwrap();
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::MatchCase {
            pattern: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "pattern", "match_case")?,
            )?,
            guard: get_node_field_opt(_vm, &_object, "guard")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            body: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "body", "match_case")?)?,
            range: Default::default(),
        })
    }
}
// sum
impl Node for ast::located::Pattern {
    fn ast_to_object(self, vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::located::Pattern::MatchValue(cons) => cons.ast_to_object(vm),
            ast::located::Pattern::MatchSingleton(cons) => cons.ast_to_object(vm),
            ast::located::Pattern::MatchSequence(cons) => cons.ast_to_object(vm),
            ast::located::Pattern::MatchMapping(cons) => cons.ast_to_object(vm),
            ast::located::Pattern::MatchClass(cons) => cons.ast_to_object(vm),
            ast::located::Pattern::MatchStar(cons) => cons.ast_to_object(vm),
            ast::located::Pattern::MatchAs(cons) => cons.ast_to_object(vm),
            ast::located::Pattern::MatchOr(cons) => cons.ast_to_object(vm),
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(if _cls.is(NodePatternMatchValue::static_type()) {
            ast::located::Pattern::MatchValue(ast::located::PatternMatchValue::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodePatternMatchSingleton::static_type()) {
            ast::located::Pattern::MatchSingleton(
                ast::located::PatternMatchSingleton::ast_from_object(_vm, _object)?,
            )
        } else if _cls.is(NodePatternMatchSequence::static_type()) {
            ast::located::Pattern::MatchSequence(
                ast::located::PatternMatchSequence::ast_from_object(_vm, _object)?,
            )
        } else if _cls.is(NodePatternMatchMapping::static_type()) {
            ast::located::Pattern::MatchMapping(ast::located::PatternMatchMapping::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodePatternMatchClass::static_type()) {
            ast::located::Pattern::MatchClass(ast::located::PatternMatchClass::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodePatternMatchStar::static_type()) {
            ast::located::Pattern::MatchStar(ast::located::PatternMatchStar::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodePatternMatchAs::static_type()) {
            ast::located::Pattern::MatchAs(ast::located::PatternMatchAs::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodePatternMatchOr::static_type()) {
            ast::located::Pattern::MatchOr(ast::located::PatternMatchOr::ast_from_object(
                _vm, _object,
            )?)
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of pattern, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
// constructor
impl Node for ast::located::PatternMatchValue {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::PatternMatchValue {
            value,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodePatternMatchValue::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::PatternMatchValue {
            value: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "value", "MatchValue")?,
            )?,
            range: range_from_object(_vm, _object, "MatchValue")?,
        })
    }
}
// constructor
impl Node for ast::located::PatternMatchSingleton {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::PatternMatchSingleton {
            value,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodePatternMatchSingleton::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("value", value.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::PatternMatchSingleton {
            value: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "value", "MatchSingleton")?,
            )?,
            range: range_from_object(_vm, _object, "MatchSingleton")?,
        })
    }
}
// constructor
impl Node for ast::located::PatternMatchSequence {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::PatternMatchSequence {
            patterns,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodePatternMatchSequence::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("patterns", patterns.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::PatternMatchSequence {
            patterns: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "patterns", "MatchSequence")?,
            )?,
            range: range_from_object(_vm, _object, "MatchSequence")?,
        })
    }
}
// constructor
impl Node for ast::located::PatternMatchMapping {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::PatternMatchMapping {
            keys,
            patterns,
            rest,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodePatternMatchMapping::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("keys", keys.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("patterns", patterns.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("rest", rest.ast_to_object(_vm), _vm).unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::PatternMatchMapping {
            keys: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "keys", "MatchMapping")?,
            )?,
            patterns: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "patterns", "MatchMapping")?,
            )?,
            rest: get_node_field_opt(_vm, &_object, "rest")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: range_from_object(_vm, _object, "MatchMapping")?,
        })
    }
}
// constructor
impl Node for ast::located::PatternMatchClass {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::PatternMatchClass {
            cls,
            patterns,
            kwd_attrs,
            kwd_patterns,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodePatternMatchClass::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("cls", cls.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("patterns", patterns.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("kwd_attrs", kwd_attrs.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("kwd_patterns", kwd_patterns.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::PatternMatchClass {
            cls: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "cls", "MatchClass")?)?,
            patterns: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "patterns", "MatchClass")?,
            )?,
            kwd_attrs: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "kwd_attrs", "MatchClass")?,
            )?,
            kwd_patterns: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "kwd_patterns", "MatchClass")?,
            )?,
            range: range_from_object(_vm, _object, "MatchClass")?,
        })
    }
}
// constructor
impl Node for ast::located::PatternMatchStar {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::PatternMatchStar {
            name,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodePatternMatchStar::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::PatternMatchStar {
            name: get_node_field_opt(_vm, &_object, "name")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: range_from_object(_vm, _object, "MatchStar")?,
        })
    }
}
// constructor
impl Node for ast::located::PatternMatchAs {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::PatternMatchAs {
            pattern,
            name,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodePatternMatchAs::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("pattern", pattern.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::PatternMatchAs {
            pattern: get_node_field_opt(_vm, &_object, "pattern")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            name: get_node_field_opt(_vm, &_object, "name")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: range_from_object(_vm, _object, "MatchAs")?,
        })
    }
}
// constructor
impl Node for ast::located::PatternMatchOr {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::PatternMatchOr {
            patterns,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodePatternMatchOr::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("patterns", patterns.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::PatternMatchOr {
            patterns: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "patterns", "MatchOr")?,
            )?,
            range: range_from_object(_vm, _object, "MatchOr")?,
        })
    }
}
// sum
impl Node for ast::located::TypeIgnore {
    fn ast_to_object(self, vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::located::TypeIgnore::TypeIgnore(cons) => cons.ast_to_object(vm),
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(if _cls.is(NodeTypeIgnoreTypeIgnore::static_type()) {
            ast::located::TypeIgnore::TypeIgnore(
                ast::located::TypeIgnoreTypeIgnore::ast_from_object(_vm, _object)?,
            )
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of type_ignore, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
// constructor
impl Node for ast::located::TypeIgnoreTypeIgnore {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::TypeIgnoreTypeIgnore {
            lineno,
            tag,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeTypeIgnoreTypeIgnore::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("lineno", lineno.ast_to_object(_vm), _vm)
            .unwrap();
        dict.set_item("tag", tag.ast_to_object(_vm), _vm).unwrap();
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::TypeIgnoreTypeIgnore {
            lineno: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "lineno", "TypeIgnore")?,
            )?,
            tag: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "tag", "TypeIgnore")?)?,
            range: Default::default(),
        })
    }
}
// sum
impl Node for ast::located::TypeParam {
    fn ast_to_object(self, vm: &VirtualMachine) -> PyObjectRef {
        match self {
            ast::located::TypeParam::TypeVar(cons) => cons.ast_to_object(vm),
            ast::located::TypeParam::ParamSpec(cons) => cons.ast_to_object(vm),
            ast::located::TypeParam::TypeVarTuple(cons) => cons.ast_to_object(vm),
        }
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        let _cls = _object.class();
        Ok(if _cls.is(NodeTypeParamTypeVar::static_type()) {
            ast::located::TypeParam::TypeVar(ast::located::TypeParamTypeVar::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodeTypeParamParamSpec::static_type()) {
            ast::located::TypeParam::ParamSpec(ast::located::TypeParamParamSpec::ast_from_object(
                _vm, _object,
            )?)
        } else if _cls.is(NodeTypeParamTypeVarTuple::static_type()) {
            ast::located::TypeParam::TypeVarTuple(
                ast::located::TypeParamTypeVarTuple::ast_from_object(_vm, _object)?,
            )
        } else {
            return Err(_vm.new_type_error(format!(
                "expected some sort of type_param, but got {}",
                _object.repr(_vm)?
            )));
        })
    }
}
// constructor
impl Node for ast::located::TypeParamTypeVar {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::TypeParamTypeVar {
            name,
            bound,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeTypeParamTypeVar::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
        dict.set_item("bound", bound.ast_to_object(_vm), _vm)
            .unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::TypeParamTypeVar {
            name: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "name", "TypeVar")?)?,
            bound: get_node_field_opt(_vm, &_object, "bound")?
                .map(|obj| Node::ast_from_object(_vm, obj))
                .transpose()?,
            range: range_from_object(_vm, _object, "TypeVar")?,
        })
    }
}
// constructor
impl Node for ast::located::TypeParamParamSpec {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::TypeParamParamSpec {
            name,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeTypeParamParamSpec::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::TypeParamParamSpec {
            name: Node::ast_from_object(_vm, get_node_field(_vm, &_object, "name", "ParamSpec")?)?,
            range: range_from_object(_vm, _object, "ParamSpec")?,
        })
    }
}
// constructor
impl Node for ast::located::TypeParamTypeVarTuple {
    fn ast_to_object(self, _vm: &VirtualMachine) -> PyObjectRef {
        let ast::located::TypeParamTypeVarTuple {
            name,
            range: _range,
        } = self;
        let node = NodeAst
            .into_ref_with_type(_vm, NodeTypeParamTypeVarTuple::static_type().to_owned())
            .unwrap();
        let dict = node.as_object().dict().unwrap();
        dict.set_item("name", name.ast_to_object(_vm), _vm).unwrap();
        node_add_location(&dict, _range, _vm);
        node.into()
    }
    fn ast_from_object(_vm: &VirtualMachine, _object: PyObjectRef) -> PyResult<Self> {
        Ok(ast::located::TypeParamTypeVarTuple {
            name: Node::ast_from_object(
                _vm,
                get_node_field(_vm, &_object, "name", "TypeVarTuple")?,
            )?,
            range: range_from_object(_vm, _object, "TypeVarTuple")?,
        })
    }
}

pub fn extend_module_nodes(vm: &VirtualMachine, module: &Py<PyModule>) {
    extend_module!(vm, module, {
        "mod" => NodeMod::make_class(&vm.ctx),
        "Module" => NodeModModule::make_class(&vm.ctx),
        "Interactive" => NodeModInteractive::make_class(&vm.ctx),
        "Expression" => NodeModExpression::make_class(&vm.ctx),
        "FunctionType" => NodeModFunctionType::make_class(&vm.ctx),
        "stmt" => NodeStmt::make_class(&vm.ctx),
        "FunctionDef" => NodeStmtFunctionDef::make_class(&vm.ctx),
        "AsyncFunctionDef" => NodeStmtAsyncFunctionDef::make_class(&vm.ctx),
        "ClassDef" => NodeStmtClassDef::make_class(&vm.ctx),
        "Return" => NodeStmtReturn::make_class(&vm.ctx),
        "Delete" => NodeStmtDelete::make_class(&vm.ctx),
        "Assign" => NodeStmtAssign::make_class(&vm.ctx),
        "TypeAlias" => NodeStmtTypeAlias::make_class(&vm.ctx),
        "AugAssign" => NodeStmtAugAssign::make_class(&vm.ctx),
        "AnnAssign" => NodeStmtAnnAssign::make_class(&vm.ctx),
        "For" => NodeStmtFor::make_class(&vm.ctx),
        "AsyncFor" => NodeStmtAsyncFor::make_class(&vm.ctx),
        "While" => NodeStmtWhile::make_class(&vm.ctx),
        "If" => NodeStmtIf::make_class(&vm.ctx),
        "With" => NodeStmtWith::make_class(&vm.ctx),
        "AsyncWith" => NodeStmtAsyncWith::make_class(&vm.ctx),
        "Match" => NodeStmtMatch::make_class(&vm.ctx),
        "Raise" => NodeStmtRaise::make_class(&vm.ctx),
        "Try" => NodeStmtTry::make_class(&vm.ctx),
        "TryStar" => NodeStmtTryStar::make_class(&vm.ctx),
        "Assert" => NodeStmtAssert::make_class(&vm.ctx),
        "Import" => NodeStmtImport::make_class(&vm.ctx),
        "ImportFrom" => NodeStmtImportFrom::make_class(&vm.ctx),
        "Global" => NodeStmtGlobal::make_class(&vm.ctx),
        "Nonlocal" => NodeStmtNonlocal::make_class(&vm.ctx),
        "Expr" => NodeStmtExpr::make_class(&vm.ctx),
        "Pass" => NodeStmtPass::make_class(&vm.ctx),
        "Break" => NodeStmtBreak::make_class(&vm.ctx),
        "Continue" => NodeStmtContinue::make_class(&vm.ctx),
        "expr" => NodeExpr::make_class(&vm.ctx),
        "BoolOp" => NodeExprBoolOp::make_class(&vm.ctx),
        "NamedExpr" => NodeExprNamedExpr::make_class(&vm.ctx),
        "BinOp" => NodeExprBinOp::make_class(&vm.ctx),
        "UnaryOp" => NodeExprUnaryOp::make_class(&vm.ctx),
        "Lambda" => NodeExprLambda::make_class(&vm.ctx),
        "IfExp" => NodeExprIfExp::make_class(&vm.ctx),
        "Dict" => NodeExprDict::make_class(&vm.ctx),
        "Set" => NodeExprSet::make_class(&vm.ctx),
        "ListComp" => NodeExprListComp::make_class(&vm.ctx),
        "SetComp" => NodeExprSetComp::make_class(&vm.ctx),
        "DictComp" => NodeExprDictComp::make_class(&vm.ctx),
        "GeneratorExp" => NodeExprGeneratorExp::make_class(&vm.ctx),
        "Await" => NodeExprAwait::make_class(&vm.ctx),
        "Yield" => NodeExprYield::make_class(&vm.ctx),
        "YieldFrom" => NodeExprYieldFrom::make_class(&vm.ctx),
        "Compare" => NodeExprCompare::make_class(&vm.ctx),
        "Call" => NodeExprCall::make_class(&vm.ctx),
        "FormattedValue" => NodeExprFormattedValue::make_class(&vm.ctx),
        "JoinedStr" => NodeExprJoinedStr::make_class(&vm.ctx),
        "Constant" => NodeExprConstant::make_class(&vm.ctx),
        "Attribute" => NodeExprAttribute::make_class(&vm.ctx),
        "Subscript" => NodeExprSubscript::make_class(&vm.ctx),
        "Starred" => NodeExprStarred::make_class(&vm.ctx),
        "Name" => NodeExprName::make_class(&vm.ctx),
        "List" => NodeExprList::make_class(&vm.ctx),
        "Tuple" => NodeExprTuple::make_class(&vm.ctx),
        "Slice" => NodeExprSlice::make_class(&vm.ctx),
        "expr_context" => NodeExprContext::make_class(&vm.ctx),
        "Load" => NodeExprContextLoad::make_class(&vm.ctx),
        "Store" => NodeExprContextStore::make_class(&vm.ctx),
        "Del" => NodeExprContextDel::make_class(&vm.ctx),
        "boolop" => NodeBoolOp::make_class(&vm.ctx),
        "And" => NodeBoolOpAnd::make_class(&vm.ctx),
        "Or" => NodeBoolOpOr::make_class(&vm.ctx),
        "operator" => NodeOperator::make_class(&vm.ctx),
        "Add" => NodeOperatorAdd::make_class(&vm.ctx),
        "Sub" => NodeOperatorSub::make_class(&vm.ctx),
        "Mult" => NodeOperatorMult::make_class(&vm.ctx),
        "MatMult" => NodeOperatorMatMult::make_class(&vm.ctx),
        "Div" => NodeOperatorDiv::make_class(&vm.ctx),
        "Mod" => NodeOperatorMod::make_class(&vm.ctx),
        "Pow" => NodeOperatorPow::make_class(&vm.ctx),
        "LShift" => NodeOperatorLShift::make_class(&vm.ctx),
        "RShift" => NodeOperatorRShift::make_class(&vm.ctx),
        "BitOr" => NodeOperatorBitOr::make_class(&vm.ctx),
        "BitXor" => NodeOperatorBitXor::make_class(&vm.ctx),
        "BitAnd" => NodeOperatorBitAnd::make_class(&vm.ctx),
        "FloorDiv" => NodeOperatorFloorDiv::make_class(&vm.ctx),
        "unaryop" => NodeUnaryOp::make_class(&vm.ctx),
        "Invert" => NodeUnaryOpInvert::make_class(&vm.ctx),
        "Not" => NodeUnaryOpNot::make_class(&vm.ctx),
        "UAdd" => NodeUnaryOpUAdd::make_class(&vm.ctx),
        "USub" => NodeUnaryOpUSub::make_class(&vm.ctx),
        "cmpop" => NodeCmpOp::make_class(&vm.ctx),
        "Eq" => NodeCmpOpEq::make_class(&vm.ctx),
        "NotEq" => NodeCmpOpNotEq::make_class(&vm.ctx),
        "Lt" => NodeCmpOpLt::make_class(&vm.ctx),
        "LtE" => NodeCmpOpLtE::make_class(&vm.ctx),
        "Gt" => NodeCmpOpGt::make_class(&vm.ctx),
        "GtE" => NodeCmpOpGtE::make_class(&vm.ctx),
        "Is" => NodeCmpOpIs::make_class(&vm.ctx),
        "IsNot" => NodeCmpOpIsNot::make_class(&vm.ctx),
        "In" => NodeCmpOpIn::make_class(&vm.ctx),
        "NotIn" => NodeCmpOpNotIn::make_class(&vm.ctx),
        "comprehension" => NodeComprehension::make_class(&vm.ctx),
        "excepthandler" => NodeExceptHandler::make_class(&vm.ctx),
        "ExceptHandler" => NodeExceptHandlerExceptHandler::make_class(&vm.ctx),
        "arguments" => NodeArguments::make_class(&vm.ctx),
        "arg" => NodeArg::make_class(&vm.ctx),
        "keyword" => NodeKeyword::make_class(&vm.ctx),
        "alias" => NodeAlias::make_class(&vm.ctx),
        "withitem" => NodeWithItem::make_class(&vm.ctx),
        "match_case" => NodeMatchCase::make_class(&vm.ctx),
        "pattern" => NodePattern::make_class(&vm.ctx),
        "MatchValue" => NodePatternMatchValue::make_class(&vm.ctx),
        "MatchSingleton" => NodePatternMatchSingleton::make_class(&vm.ctx),
        "MatchSequence" => NodePatternMatchSequence::make_class(&vm.ctx),
        "MatchMapping" => NodePatternMatchMapping::make_class(&vm.ctx),
        "MatchClass" => NodePatternMatchClass::make_class(&vm.ctx),
        "MatchStar" => NodePatternMatchStar::make_class(&vm.ctx),
        "MatchAs" => NodePatternMatchAs::make_class(&vm.ctx),
        "MatchOr" => NodePatternMatchOr::make_class(&vm.ctx),
        "type_ignore" => NodeTypeIgnore::make_class(&vm.ctx),
        "TypeIgnore" => NodeTypeIgnoreTypeIgnore::make_class(&vm.ctx),
        "type_param" => NodeTypeParam::make_class(&vm.ctx),
        "TypeVar" => NodeTypeParamTypeVar::make_class(&vm.ctx),
        "ParamSpec" => NodeTypeParamParamSpec::make_class(&vm.ctx),
        "TypeVarTuple" => NodeTypeParamTypeVarTuple::make_class(&vm.ctx),
    })
}
