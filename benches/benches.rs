#![feature(test)]

extern crate test;
use test::Bencher;

use sre_engine::engine;

struct Pattern {
    code: &'static [u32],
}

impl Pattern {
    fn state<'a, S: engine::StrDrive>(
        &self,
        string: S,
    ) -> (engine::Request<'a, S>, engine::State<S>) {
        self.state_range(string, 0..usize::MAX)
    }

    fn state_range<'a, S: engine::StrDrive>(
        &self,
        string: S,
        range: std::ops::Range<usize>,
    ) -> (engine::Request<'a, S>, engine::State<S>) {
        let req = engine::Request::new(string, range.start, range.end, self.code, false);
        let state = engine::State::default();
        (req, state)
    }
}

#[bench]
fn benchmarks(b: &mut Bencher) {
    // # test common prefix
    // pattern p1 = re.compile('Python|Perl') # , 'Perl'),    # Alternation
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p1 = Pattern { code: &[15, 8, 1, 4, 6, 1, 1, 80, 0, 17, 80, 7, 13, 17, 121, 17, 116, 17, 104, 17, 111, 17, 110, 16, 11, 9, 17, 101, 17, 114, 17, 108, 16, 2, 0, 1] };
    // END GENERATED
    // pattern p2 = re.compile('(Python|Perl)') #, 'Perl'),  # Grouped alternation
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p2 = Pattern { code: &[15, 8, 1, 4, 6, 1, 0, 80, 0, 18, 0, 17, 80, 7, 13, 17, 121, 17, 116, 17, 104, 17, 111, 17, 110, 16, 11, 9, 17, 101, 17, 114, 17, 108, 16, 2, 0, 18, 1, 1] };
    // END GENERATED
    // pattern p3 = re.compile('Python|Perl|Tcl') #, 'Perl'),        # Alternation
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p3 = Pattern { code: &[15, 9, 4, 3, 6, 17, 80, 17, 84, 0, 7, 15, 17, 80, 17, 121, 17, 116, 17, 104, 17, 111, 17, 110, 16, 22, 11, 17, 80, 17, 101, 17, 114, 17, 108, 16, 11, 9, 17, 84, 17, 99, 17, 108, 16, 2, 0, 1] };
    // END GENERATED
    // pattern p4 = re.compile('(Python|Perl|Tcl)') #, 'Perl'),      # Grouped alternation
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p4 = Pattern { code: &[15, 9, 4, 3, 6, 17, 80, 17, 84, 0, 18, 0, 7, 15, 17, 80, 17, 121, 17, 116, 17, 104, 17, 111, 17, 110, 16, 22, 11, 17, 80, 17, 101, 17, 114, 17, 108, 16, 11, 9, 17, 84, 17, 99, 17, 108, 16, 2, 0, 18, 1, 1] };
    // END GENERATED
    // pattern p5 = re.compile('(Python)\\1') #, 'PythonPython'),    # Backreference
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p5 = Pattern { code: &[15, 18, 1, 12, 12, 6, 0, 80, 121, 116, 104, 111, 110, 0, 0, 0, 0, 0, 0, 18, 0, 17, 80, 17, 121, 17, 116, 17, 104, 17, 111, 17, 110, 18, 1, 12, 0, 1] };
    // END GENERATED
    // pattern p6 = re.compile('([0a-z][a-z0-9]*,)+') #, 'a5,b7,c9,'), # Disable the fastmap optimization
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p6 = Pattern { code: &[15, 4, 0, 2, 4294967295, 24, 31, 1, 4294967295, 18, 0, 14, 7, 17, 48, 23, 97, 122, 0, 25, 13, 0, 4294967295, 14, 8, 23, 97, 122, 23, 48, 57, 0, 1, 17, 44, 18, 1, 19, 1] };
    // END GENERATED
    // pattern p7 = re.compile('([a-z][a-z0-9]*,)+') #, 'a5,b7,c9,'), # A few sets
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p7 = Pattern { code: &[15, 4, 0, 2, 4294967295, 24, 29, 1, 4294967295, 18, 0, 14, 5, 23, 97, 122, 0, 25, 13, 0, 4294967295, 14, 8, 23, 97, 122, 23, 48, 57, 0, 1, 17, 44, 18, 1, 19, 1] };
    // END GENERATED
    // pattern p8 = re.compile('Python') #, 'Python'),               # Simple text literal
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p8 = Pattern { code: &[15, 18, 3, 6, 6, 6, 6, 80, 121, 116, 104, 111, 110, 0, 0, 0, 0, 0, 0, 17, 80, 17, 121, 17, 116, 17, 104, 17, 111, 17, 110, 1] };
    // END GENERATED
    // pattern p9 = re.compile('.*Python') #, 'Python'),             # Bad text literal
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p9 = Pattern { code: &[15, 4, 0, 6, 4294967295, 25, 5, 0, 4294967295, 2, 1, 17, 80, 17, 121, 17, 116, 17, 104, 17, 111, 17, 110, 1] };
    // END GENERATED
    // pattern p10 = re.compile('.*Python.*') #, 'Python'),           # Worse text literal
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p10 = Pattern { code: &[15, 4, 0, 6, 4294967295, 25, 5, 0, 4294967295, 2, 1, 17, 80, 17, 121, 17, 116, 17, 104, 17, 111, 17, 110, 25, 5, 0, 4294967295, 2, 1, 1] };
    // END GENERATED
    // pattern p11 = re.compile('.*(Python)') #, 'Python'),           # Bad text literal with grouping
    // START GENERATED by generate_tests.py
    #[rustfmt::skip] let p11 = Pattern { code: &[15, 4, 0, 6, 4294967295, 25, 5, 0, 4294967295, 2, 1, 18, 0, 17, 80, 17, 121, 17, 116, 17, 104, 17, 111, 17, 110, 18, 1, 1] };
    // END GENERATED

    let tests = [
        (p1, "Perl"),
        (p2, "Perl"),
        (p3, "Perl"),
        (p4, "Perl"),
        (p5, "PythonPython"),
        (p6, "a5,b7,c9,"),
        (p7, "a5,b7,c9,"),
        (p8, "Python"),
        (p9, "Python"),
        (p10, "Python"),
        (p11, "Python"),
    ];

    b.iter(move || {
        for (p, s) in &tests {
            let (mut req, mut state) = p.state(s.clone());
            state.search(&mut req);
            assert!(state.has_matched);
            let (mut req, mut state) = p.state(s.clone());
            state.pymatch(&mut req);
            assert!(state.has_matched);
            let (mut req, mut state) = p.state(s.clone());
            req.match_all = true;
            state.pymatch(&mut req);
            assert!(state.has_matched);
            let s2 = format!("{}{}{}", " ".repeat(10000), s, " ".repeat(10000));
            let (mut req, mut state) = p.state_range(s2.as_str(), 0..usize::MAX);
            state.search(&mut req);
            assert!(state.has_matched);
            let (mut req, mut state) = p.state_range(s2.as_str(), 10000..usize::MAX);
            state.pymatch(&mut req);
            assert!(state.has_matched);
            let (mut req, mut state) = p.state_range(s2.as_str(), 10000..10000 + s.len());
            state.pymatch(&mut req);
            assert!(state.has_matched);
            let (mut req, mut state) = p.state_range(s2.as_str(), 10000..10000 + s.len());
            req.match_all = true;
            state.pymatch(&mut req);
            assert!(state.has_matched);
        }
    })
}
