---
name: CI-5974
description: "Continuous Integration workflow for GHI 5974."
run-name: Prototyping integration tests ${{ github.ref_name }}
#
# Jobs included:
# - TEST-5974: Tests installation across Python versions and locales
#
# Required Secrets:
# NONE
#
# WORK IN PROGRESS
# search for "TODO" in file for more details on what is still un-implemented


on:  # yamllint disable-line rule:truthy
  push:
    branches: ["**"]  # matches any branch
    tags: ["v*"]

# Declare default permissions as none.
permissions: {}

env:
  # ENVIRONMENT: ${{ (startsWith(github.ref, 'refs/heads/CI-CD-Patch-') }}
  # Define Python versions at the top level -- Expected format: X.Y (e.g., 3.13)
  PYTHON_DEFAULT: "${{ vars.PYTHON_DEFAULT }}"
  PYTHON_OLD_MIN: "${{ vars.PYTHON_OLD_MIN }}"  # For Oldest Python versions
  PYTHON_OLD_EXTRA: "${{ vars.PYTHON_OLD_EXTRA }}"  # For Older Python versions (Extra coverage)
  PYTHON_EXPERIMENTAL: "${{ vars.PYTHON_EXPERIMENTAL }}"  # For future Python versions
  # define how mush time before assuming the test has hung in seconds (parsed by sleep)
  SUBSHELL_TIMEOUT: 30
  # Define the reference files to pull as a file glob pattern
  TEST_MATCH_PATTERN: "Lib/test/*.py Lib/test/**/*.py"
  TEST_IGNORE_LIST: |
    Lib/test/*.pyc

# TODO: cordnate with @arihant2math - to really build out the migration logic

jobs:
  TEST-5974:
    permissions:
      actions: read
      contents: read
      statuses: write
      packages: none
      pull-requests: read
      security-events: none
    if: ${{ !cancelled() }}
    runs-on: ${{ matrix.os }}
    timeout-minutes: 30
    continue-on-error: ${{ matrix.experimental }}
    strategy:
      max-parallel: 3
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-14, macos-15, windows-latest]
        python-version: ["${{ vars.PYTHON_OLD_MIN }}", "${{ vars.PYTHON_OLD_EXTRA }}", "${{ vars.PYTHON_DEFAULT }}", "${{ vars.PYTHON_EXPERIMENTAL }}"]
        experimental: [true]
        include:
          - os: ubuntu-latest
            python-version: "${{ vars.PYTHON_DEFAULT }}"
            experimental: false
          - os: macos-latest
            python-version: "${{ vars.PYTHON_EXPERIMENTAL }}"
            experimental: false
          - os: windows-latest
            python-version: "${{ vars.PYTHON_DEFAULT }}"
            experimental: true
          - os: macos-14
            python-version: "${{ vars.PYTHON_DEFAULT }}"
            experimental: true
          - os: windows-2025
            python-version: "${{ vars.PYTHON_DEFAULT }}"
            experimental: true
    outputs:
      bootstrap_status: ${{ steps.smoke_testing.outcome }}
    env:
      PYTHON_VERSION: ${{ matrix.python-version }}
    # TODO: move to seperate action
    steps:
      - name: pre-checkout repository for actions
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false
          sparse-checkout: |
            '.github/actions/CI-5974-Fetch-RustPython'
            '.github/actions/CI-5974-Fetch-CPython'
            '.github/actions/CI-5974-Integrate-CPython'
        # CI-5974-Test-RustPython-Integration WIP
      - name: Checkout RustPython repository on ${{ matrix.os }}
        id: fetch-rpython
        uses: ./.github/actions/CI-5974-Fetch-RustPython
        with:
          override-path: rustpython
          override-rustpython-path: Lib
          # override-repository: "RustPython/RustPython"
          # override-ref: main
      - name: Fetch Referance Cpython ${{ matrix.python-version }} on ${{ matrix.os }}
        id: fetch-cpython
        uses: ./.github/actions/CI-5974-Fetch-CPython
        with:
          # Define the reference files to pull as a file glob pattern
          match: "Lib/test/*.py Lib/test/**/*.py"
          python-version: ${{ env.PYTHON_VERSION }}
          # override-path: cpython
          override-cpython-lib-path: 'Lib/test'
          # override-rustpython-path: ${{ steps.fetch-rpython.outputs.rustpython-lib-path }}
          # override-repository: "python/cpython"
        # this next part is WIP and needs to be updated with filtering for more control of what parts of the reference lib is used
      - name: "Integrate Cpython Test file"
        id: merge_theirs
        uses: ./.github/actions/CI-5974-Integrate-CPython
        if: ${{ !cancelled() }}
        with:
          from-path: cpython
          to-path: rustpython
          files: |
            ${{ steps.fetch-cpython.outputs.files }}
          python-version: ${{ env.PYTHON_VERSION }}
      - id: output_python
        name: "bootstrap Python"
        if: ${{ !cancelled() }}
        shell: bash
        run: |
          printf "%s\n" "::group::bootstrap-python-env"
          printf "python-version=%s\n" "${{ matrix.python-version }}" >> "$GITHUB_OUTPUT"
          printf "Configured Cpython %s on %s.\n" '${{ matrix.python-version }}' '${{ matrix.os }}' ;
          printf "PYTHON_VERSION=%s\n" "${{ matrix.python-version }}" >> "$GITHUB_ENV"
          printf "%s\n" "::endgroup::"
      - name: Try Smoke Testing
        id: smoke_testing
        shell: bash
        env:
          OS: ${{ runner.os }}
          CONTEXT_PHRASE: 'for Cpython ${{ matrix.python-version }} on ${{ matrix.os }}'
        if: ${{ success() }}
        run: |
          # Custom timeout function (GH-5974 - because ulimit is restricted and windows can't ulimit at all)
          # TODO: clean this up
          run_with_timeout() {
              local timeout=$1
              shift
              "$@" &
              local pid=$!
              ( sleep "$timeout" && kill -HUP "$pid" 2>/dev/null ) & disown
              # Send HUP signal after timeout
              wait "$pid"
              local status=$?
              if [ $status -eq 0 ]; then
                  printf "::debug::%s\n" "Command completed successfully."
                  true ; # force success result
              elif [ $status -eq 143 ]; then
                  printf "::warning title='Timeout'::%s\n" "The command \`$@\` ${CONTEXT_PHRASE} was terminated due to timeout."
                  false ;
              else
                  printf "%s\n" "The command failed with status $status ${CONTEXT_PHRASE}."
                  false ;
              fi ;
          }

          export -f run_with_timeout ;
          # Usage
          # run_with_timeout 360 your_command_here
          cd rustpython || exit 13 ;
          for referance_file in ${{ steps.fetch-cpython.outputs.files }} ; do
            if [[ ( -f "${referance_file}" ) ]] ; then
              # See https://devguide.python.org/testing/run-write-tests
              # Heuristic: "if some module does not have unittest.main(), then most likely it does not support direct invocation."
              if grep -qF "unittest.main()" "${referance_file}" 2>/dev/null ; then
                printf "Now Testing '%s'\n" "${referance_file}"
                # vars for subshell but not for workflow
                export REF_FILE_NAME=$(basename "${referance_file}") ;
                printf "::group::%s\n" "${REF_FILE_NAME}" ;
                # TODO: test with cpython first for baseline
                # TODO: add to list of files that need additional prep due to hanging or unexpected failures that need to be removed
                # Execute the testing command in a subshell
                time (
                  export RUSTPYTHONPATH=Lib ;
                  run_with_timeout ${SUBSHELL_TIMEOUT} cargo run --release -- Lib/test/"${REF_FILE_NAME}" || RAW_COPY_OUTCOME='failing'
                  if [[ ( -n ${RAW_COPY_OUTCOME} ) ]] ; then
                    printf "::warning file='%s',title='test-warning':: Could not copy file %s unmodified, and pass tests %s.\n" "${referance_file}" "${referance_file}" "${CONTEXT_PHRASE}" ;
                    (
                      run_with_timeout ${SUBSHELL_TIMEOUT} cargo run --release -- ./scripts/fix_test.py --path ./Lib/test/"${REF_FILE_NAME}" || FIX_COPY_OUTCOME='unfixed' ;
                    ) ;
                    if [[ ( -n ${FIX_COPY_OUTCOME} ) ]] ; then
                      printf "::error file='%s',title='testing-failure':: Could not copy and auto-fix tests %s.\n" "${referance_file}" "${CONTEXT_PHRASE}" >&2 ;
                      # reset broken integration to last rustpython copy
                      git restore --ignore-unmerged --worktree --staged "${referance_file}" || : ;
                      git checkout -f --ignore-unmerged -- "${referance_file}" || : ;
                      # TODO: validate and conditionally set
                      FIX_COPY_OUTCOME="reverted"
                    else
                      FIX_COPY_OUTCOME="fixed"
                      RAW_COPY_OUTCOME="incompatable"
                    fi ;
                  else
                    FIX_COPY_OUTCOME="skipped"
                    RAW_COPY_OUTCOME="compatable"
                  fi ;
                  printf "\n---\n%s Outcome:\n\tDirectly:%s\n\tAuto-Fix:%s\n\n" "${REF_FILE_NAME}" "${RAW_COPY_OUTCOME}" "${FIX_COPY_OUTCOME}" ;
                  printf "FIX_COPY_%s_OUTCOME=%s\n" "${REF_FILE_NAME}" "${FIX_COPY_OUTCOME}" >> "$GITHUB_ENV" ;
                  printf "RAW_COPY_%s_OUTCOME=%s\n" "${REF_FILE_NAME}" "${RAW_COPY_OUTCOME}" >> "$GITHUB_ENV" ;
                  # should dump a diff or something here
                  printf "\n\n" ;
                  unset RUSTPYTHONPATH 2>/dev/null || : ;
                ) ;
                # cleanup temp env
                unset FIX_COPY_OUTCOME 2>/dev/null || : ;
                unset RAW_COPY_OUTCOME 2>/dev/null || : ;
                unset REF_FILE_NAME 2>/dev/null || : ;
                printf "\n::endgroup::\n" ;
                wait ;
              else
                # TODO: else can not be run directly and needs to be invoked with -m unittest -v test.
                # TODO: cleanup this regular expression for edge-cases
                if grep -qE "^[^cC]*([cC]lass)\s*(.+)(Test)" "${referance_file}" 2>/dev/null ; then
                  printf "Now Testing test-cases in '%s'\n" "${referance_file}"
                  # vars for subshell but not for workflow
                  export REF_TEST_NAME=$(basename -s ".py" "${referance_file}") ;
                  printf "%s\n" "Selected testcase test.${REF_TEST_NAME}"
                  printf "::group::%s\n" "${REF_FILE_NAME}" ;
                  # TODO: test with cpython first for baseline
                  # TODO: add to list of files that need additional prep due to hanging or unexpected failures that need to be removed
                  # Execute the testing command in a subshell
                  time (
                    export RUSTPYTHONPATH=Lib ;
                    run_with_timeout ${SUBSHELL_TIMEOUT} cargo run --release -- -m unittest -v test.${REF_TEST_NAME} || RAW_COPY_OUTCOME='failing'
                    if [[ ( -n ${RAW_COPY_OUTCOME} ) ]] ; then
                      printf "::warning file='%s',title='test-warning':: Could not copy file %s unmodified, and pass tests %s.\n" "${referance_file}" "${referance_file}" "${CONTEXT_PHRASE}" ;
                      (
                        run_with_timeout ${SUBSHELL_TIMEOUT} cargo run --release -- ./scripts/fix_test.py --path ./Lib/test/"${REF_FILE_NAME}".py || FIX_COPY_OUTCOME='unfixed' ;
                      ) ;
                      if [[ ( -n ${FIX_COPY_OUTCOME} ) ]] ; then
                        printf "::error file='%s',title='testing-failure':: Could not copy and auto-fix tests for file.\n" "${referance_file}" >&2 ;
                        # reset broken integration to last rustpython copy
                        git restore --ignore-unmerged --worktree --staged "${referance_file}" || : ;
                        git checkout -f --ignore-unmerged -- "${referance_file}" || : ;
                        # TODO: validate and conditionally set
                        FIX_COPY_OUTCOME="reverted"
                      else
                        FIX_COPY_OUTCOME="fixed"
                        RAW_COPY_OUTCOME="incompatable"
                      fi ;
                    else
                      FIX_COPY_OUTCOME="skipped"
                      RAW_COPY_OUTCOME="compatable"
                    fi ;
                    printf "\n---\n%s Outcome:\n\tDirectly:%s\n\tAuto-Fix:%s\n\n" "${REF_TEST_NAME}" "${RAW_COPY_OUTCOME}" "${FIX_COPY_OUTCOME}" ;
                    wait ; # used to force boundry for std out read/write race in UI
                    printf "FIX_COPY_%s.py_OUTCOME=%s\n" "${REF_TEST_NAME}" "${FIX_COPY_OUTCOME}" >> "$GITHUB_ENV" ;
                    printf "RAW_COPY_%s.py_OUTCOME=%s\n" "${REF_TEST_NAME}" "${RAW_COPY_OUTCOME}" >> "$GITHUB_ENV" ;
                    # should dump a diff or something here
                    printf "\n\n" ;
                    unset RUSTPYTHONPATH 2>/dev/null || : ;
                  ) ;
                  # cleanup temp env
                  unset FIX_COPY_OUTCOME 2>/dev/null || : ;
                  unset RAW_COPY_OUTCOME 2>/dev/null || : ;
                  unset REF_TEST_NAME 2>/dev/null || : ;
                  printf "\n::endgroup::\n" ;
                  wait ;
                else
                  printf "\nNow Skipping '%s'\n\n" "${referance_file}" ;
                  # TODO: record this skip status too
                fi ;
              fi ; # TODO: else can not be run directly and needs to be invoked with -m unittest -v test.
            fi ;
          done
          cd .. ;
      - name: Post-Clean
        id: post-bootstrap
        run: |
          exit 0 ; # don't break CI on regression
        if: ${{ always() }}
        shell: bash
