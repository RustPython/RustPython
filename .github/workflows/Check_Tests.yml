---
name: CI-5974
description: "Continuous Integration workflow for GHI 5974."
run-name: Prototyping integration tests ${{ github.ref_name }}
#
# Jobs included:
# - TEST-5974: Tests installation across Python versions and locales
#
# Required Secrets:
# NONE

on:  # yamllint disable-line rule:truthy
  push:
    branches: ["**"]  # matches any branch
    tags: ["v*"]

# Declare default permissions as none.
permissions: {}

env:
  # ENVIRONMENT: ${{ (startsWith(github.ref, 'refs/heads/CI-CD-Patch-') }}
  # Define Python versions at the top level -- Expected format: X.Y (e.g., 3.13)
  PYTHON_DEFAULT: "${{ vars.PYTHON_DEFAULT }}"
  PYTHON_OLD_MIN: "${{ vars.PYTHON_OLD_MIN }}"  # For Oldest Python versions
  PYTHON_OLD_EXTRA: "${{ vars.PYTHON_OLD_EXTRA }}"  # For Older Python versions (Extra coverage)
  PYTHON_EXPERIMENTAL: "${{ vars.PYTHON_EXPERIMENTAL }}"  # For future Python versions
  # Define the referance files to pull as a file glob pattern
  TEST_MATCH_PATTERN: "Lib/test/*.py"

jobs:
  TEST-5974:
    permissions:
      actions: read
      contents: read
      statuses: write
      packages: none
      pull-requests: read
      security-events: none
    if: ${{ !cancelled() }}
    runs-on: ${{ matrix.os }}
    timeout-minutes: 30
    continue-on-error: ${{ matrix.experimental }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-14, macos-15, windows-latest]
        python-version: ["${{ vars.PYTHON_OLD_MIN }}", "${{ vars.PYTHON_OLD_EXTRA }}", "${{ vars.PYTHON_DEFAULT }}", "${{ vars.PYTHON_EXPERIMENTAL }}"]
        experimental: [true]
        include:
          - os: ubuntu-latest
            python-version: "${{ vars.PYTHON_DEFAULT }}"
            experimental: false
          - os: macos-latest
            python-version: "${{ vars.PYTHON_EXPERIMENTAL }}"
            experimental: false
          - os: windows-latest
            python-version: "${{ vars.PYTHON_DEFAULT }}"
            experimental: false
          - os: macos-14
            python-version: "${{ vars.PYTHON_DEFAULT }}"
            experimental: true
          - os: windows-2025
            python-version: "${{ vars.PYTHON_DEFAULT }}"
            experimental: true
    outputs:
      bootstrap_status: ${{ steps.smoke_testing.outcome }}
    env:
      PYTHON_VERSION: ${{ matrix.python-version }}
      
    steps:
      - name: Checkout RustPython repository
        id: rpython
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false
          path: rustpython
          # ref: 
          sparse-checkout-cone-mode: false
      - name: Pre-Test Build check
        id: build_testing
        shell: bash
        if: ${{ !cancelled() }}
        run: |
          cd rustpython || exit 13 ;
            printf "Now Building '%s'\n" ""
            # Execute the testing command in a subshell
            (
              RUSTPYTHONPATH=Lib cargo run --release -- --version || printf "::error title='build failure':: Could not pass build step for version check.\n" ;
            ) ;
          cd .. ;
      - id: cpython
        name: Fetch Cpython
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false
          fetch-tags: true
          repository: "python/cpython"
          path: cpython
          sparse-checkout: |
            Lib/test
          sparse-checkout-cone-mode: true
          ref: '${{ matrix.python-version }}'
      - name: Enumerate Referance Lib Files
        id: reftestfiles
        shell: bash
        run: |
          cd cpython ;
          ls -lap . ;
          FILES=$(git ls-files --exclude-standard -- ${{ env.TEST_MATCH_PATTERN }} )
          if [ -z "$FILES" ]; then
            printf "%s\n" "::warning file=.github/workflows/Check_Tests.yml:: No Lib/Test Referance files found."
            printf "%s\n" "files=" >> "$GITHUB_OUTPUT"
          else
            printf "%s\n" "Lib/Test Referance files found:"
            printf "%s\n" "$FILES"
            # Replace line breaks with commas for GitHub Action Output
            FILES="${FILES//$'\n'/ }"
            printf "%s\n" "files=$FILES" >> "$GITHUB_OUTPUT"
          fi
          cd .. ;
        if: ${{ success() }}
      - name: "License"
        id: show-cpython-license
        shell: bash
        if: ${{ !cancelled() }}
        run: |
          if [[ -r LICENSE ]] ; then
            printf "\n\n"
            cat <LICENSE ;
            printf "\n\n"
          else
            printf "%s\n" "::warning title=UNLICENSED:: This is an UNLICENSED Build"
          fi
        # this next part is WIP and needs to be updated with filtering for more control of what parts of the referance lib is used
      - name: "Integrate Cpython Test file"
        id: merge_theirs
        shell: bash
        if: ${{ !cancelled() }}
        run: |
          printf "::group:: Copy Referance Implementation Tests"
          for referance_file in ${{ steps.reftestfiles.outputs.files }} ; do
            cp -vf cpython/"${referance_file}" rustpython/"${referance_file}" || printf "::warning file='%s',title='integration failure':: Could not integrate file.\n" "${referance_file}" ;
            # TODO: attempt test with rustpython/scripts/fix_test.py || revert by re-checkout
          done
      - id: output_python
        name: "bootstrap Python"
        if: ${{ !cancelled() }}
        shell: bash
        run: |
          printf "%s\n" "::group::bootstrap-python-env"
          printf "python-version=%s\n" "${{ matrix.python-version }}" >> "$GITHUB_OUTPUT"
          printf "PYTHON_VERSION=%s\n" "${{ matrix.python-version }}" >> "$GITHUB_ENV"
          printf "%s\n" "::endgroup::"
      - name: Try Smoke Testing
        id: smoke_testing
        shell: bash
        env:
          OS: ${{ runner.os }}
        if: ${{ success() }}
        run: |
          cd rustpython || exit 13 ;
          for referance_file in ${{ steps.reftestfiles.outputs.files }} ; do
            # TODO: RustPython workaround Windows timeout for hangs
            printf "Now Testing '%s'\n" "${referance_file}"
            # vars for subshell but not for workflow
            export REF_FILE_NAME=$(basename "${referance_file}") ;
            printf "\n::group::%s\n" "${REF_FILE_NAME}" ;
            # TODO: test with cpython first
            # TODO: add to list of files that need additional prep due to hanging or unexpected failures that need to be removed
            # Execute the testing command in a subshell
            time (
              RUSTPYTHONPATH=Lib cargo run --release -- Lib/test/"${REF_FILE_NAME}" || RAW_COPY_OUTCOME='failing'
              if [[ ( -n ${RAW_COPY_OUTCOME} ) ]] ; then
                printf "::error file='%s',title='testing-failure':: Could not copy and pass tests for file.\n" "${referance_file}" >2 ;
                (
                  RUSTPYTHONPATH=Lib cargo run --release -- ./scripts/fix_test.py --path ./Lib/test/"${REF_FILE_NAME}" || FIX_COPY_OUTCOME='unfixed' ;
                ) ;
                if [[ ( -n ${RAW_COPY_OUTCOME} ) ]] ; then
                  printf "::error file='%s',title='testing-failure':: Could not copy and auto-fix tests for file.\n" "${referance_file}" >2 ;
                  # reset broken integration to last rustpython copy
                  git restore "${referance_file}" || : ;
                  git checkout -- "${referance_file}" || : ;
                  # TODO: validate and set FIX_COPY_OUTCOME="reverted"
                else
                  FIX_COPY_OUTCOME="fixed"
                  RAW_COPY_OUTCOME="incompatable"
                fi ;
              else
                FIX_COPY_OUTCOME="skipped"
                RAW_COPY_OUTCOME="compatable"
              fi ;
              printf "\n---\n%s Outcome:\n\tDirectly:%s\n\tAuto-Fix:%s\n\n" "${REF_FILE_NAME}" "${RAW_COPY_OUTCOME}" "${FIX_COPY_OUTCOME}" ;
              wait ; # used to force boundry for std out read/write race in UI 
              printf "FIX_COPY_%s_OUTCOME=%s\n" "${REF_FILE_NAME}" "${FIX_COPY_OUTCOME}" >> "$GITHUB_ENV" ;
              printf "RAW_COPY_%s_OUTCOME=%s\n" "${REF_FILE_NAME}" "${RAW_COPY_OUTCOME}" >> "$GITHUB_ENV" ;
              # should dump a diff or something here
              printf "\n\n"
            ) ;
            wait ;
            # cleanup temp env
            unset FIX_COPY_OUTCOME 2>/dev/null || : ;
            unset RAW_COPY_OUTCOME 2>/dev/null || : ;
            unset REF_FILE_NAME 2>/dev/null || : ;
            printf "\n::endgroup::\n" ;
          done
          cd .. ;
      - name: Post-Clean
        id: post-bootstrap
        run: |
          exit 0 ; # don't break on regression
        if: ${{ always() }}
        shell: bash
