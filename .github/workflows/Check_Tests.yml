---
name: CI-5974
description: "Continuous Integration workflow for GHI 5974."
run-name: Prototyping integration tests ${{ github.ref_name }}
#
# Jobs included:
# - TEST-5974: Tests installation across Python versions and locales
#
# Required Secrets:
# NONE
#
# WORK IN PROGRESS
# search for "TODO" in file for more details on what is still un-implemented


on:  # yamllint disable-line rule:truthy
  push:
    branches: ["**"]  # matches any branch
    tags: ["v*"]

# Declare default permissions as none.
permissions: {}

env:
  # ENVIRONMENT: ${{ (startsWith(github.ref, 'refs/heads/CI-CD-Patch-') }}
  # Define Python versions at the top level -- Expected format: X.Y (e.g., 3.13)
  PYTHON_DEFAULT: "${{ vars.PYTHON_DEFAULT }}"
  PYTHON_OLD_MIN: "${{ vars.PYTHON_OLD_MIN }}"  # For Oldest Python versions
  PYTHON_OLD_EXTRA: "${{ vars.PYTHON_OLD_EXTRA }}"  # For Older Python versions (Extra coverage)
  PYTHON_EXPERIMENTAL: "${{ vars.PYTHON_EXPERIMENTAL }}"  # For future Python versions
  # define how mush time before assuming the test has hung in seconds (parsed by sleep)
  SUBSHELL_TIMEOUT: 180
  # Define the referance files to pull as a file glob pattern
  TEST_MATCH_PATTERN: "Lib/test/*.py"
  TEST_IGNORE_LIST: |
    Lib/test/test_builtin.py

jobs:
  TEST-5974:
    permissions:
      actions: read
      contents: read
      statuses: write
      packages: none
      pull-requests: read
      security-events: none
    if: ${{ !cancelled() }}
    runs-on: ${{ matrix.os }}
    timeout-minutes: 30
    continue-on-error: ${{ matrix.experimental }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-14, macos-15, windows-latest]
        python-version: ["${{ vars.PYTHON_OLD_MIN }}", "${{ vars.PYTHON_OLD_EXTRA }}", "${{ vars.PYTHON_DEFAULT }}", "${{ vars.PYTHON_EXPERIMENTAL }}"]
        experimental: [true]
        include:
          - os: ubuntu-latest
            python-version: "${{ vars.PYTHON_DEFAULT }}"
            experimental: false
          - os: macos-latest
            python-version: "${{ vars.PYTHON_EXPERIMENTAL }}"
            experimental: false
          - os: windows-latest
            python-version: "${{ vars.PYTHON_DEFAULT }}"
            experimental: true
          - os: macos-14
            python-version: "${{ vars.PYTHON_DEFAULT }}"
            experimental: true
          - os: windows-2025
            python-version: "${{ vars.PYTHON_DEFAULT }}"
            experimental: true
    outputs:
      bootstrap_status: ${{ steps.smoke_testing.outcome }}
    env:
      PYTHON_VERSION: ${{ matrix.python-version }}
    # TODO: move to seperate action
    steps:
      - name: Checkout RustPython repository
        id: rpython
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false
          path: rustpython
          # ref: 
          sparse-checkout-cone-mode: false
      - name: Pre-Test Build check
        id: build_testing
        shell: bash
        if: ${{ !cancelled() }}
        run: |
          cd rustpython || exit 13 ;
            printf "Now Building '%s'\n" ""
            # Execute the testing command in a subshell
            (
              RUSTPYTHONPATH=Lib cargo run --release -- --version || printf "::error title='build failure':: Could not pass build step for version check.\n" ;
            ) ;
          cd .. ;
      - id: cpython
        name: Fetch Cpython
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false
          fetch-tags: true
          repository: "python/cpython"
          path: cpython
          sparse-checkout: |
            Lib/test
          sparse-checkout-cone-mode: true
          ref: '${{ matrix.python-version }}'
      - name: Configure Ignored Referance Lib Files
        id: refignorefiles
        shell: bash
        run: |
          cd cpython || exit 14 ;
          if [[ -w ".git/info/exclude" ]] ; then
            printf "%s\n" ${TEST_IGNORE_LIST:-} >>".git/info/exclude" || : ;
          else
            printf "::debug::%s\n" "Could not find .git/info/exclude" ;
            printf "%s\n" ${TEST_IGNORE_LIST:-} >>".gitignore" || : ;
          fi ;
          cd .. ;
        if: ${{ success() }}
      - name: Enumerate Referance Lib Files
        id: reftestfiles
        shell: bash
        run: |
          cd cpython || exit 14 ;
          FILES=$(git ls-files --exclude-standard -- ${{ env.TEST_MATCH_PATTERN }} )
          if [ -z "$FILES" ]; then
            printf "%s\n" "::warning file=.github/workflows/Check_Tests.yml:: No Lib/Test Referance files found."
            printf "%s\n" "files=" >> "$GITHUB_OUTPUT"
          else
            printf "%s\n" "Lib/Test Referance files found:"
            printf "%s\n" "$FILES"
            # Replace line breaks with commas for GitHub Action Output
            FILES="${FILES//$'\n'/ }"
            printf "%s\n" "files=$FILES" >> "$GITHUB_OUTPUT"
          fi
          cd .. ;
        if: ${{ success() }}
      - name: "License"
        id: show-cpython-license
        shell: bash
        if: ${{ !cancelled() }}
        run: |
          cd cpython || exit 14 ;
          if [[ -r LICENSE ]] ; then
            printf "\n\n"
            cat <LICENSE ;
            printf "\n\n"
          else
            printf "%s\n" "::warning title=UNLICENSED:: This is an UNLICENSED Build"
          fi
          cd .. ;
        # this next part is WIP and needs to be updated with filtering for more control of what parts of the referance lib is used
      - name: "Integrate Cpython Test file"
        id: merge_theirs
        shell: bash
        if: ${{ !cancelled() }}
        run: |
          printf "::group:: Copy Referance Implementation Tests"
          for referance_file in ${{ steps.reftestfiles.outputs.files }} ; do
            cp -vf cpython/"${referance_file}" rustpython/"${referance_file}" || printf "::warning file='%s',title='integration failure':: Could not integrate file.\n" "${referance_file}" ;
            # TODO: attempt test with rustpython/scripts/fix_test.py || revert by re-checkout
          done
      - id: output_python
        name: "bootstrap Python"
        if: ${{ !cancelled() }}
        shell: bash
        run: |
          printf "%s\n" "::group::bootstrap-python-env"
          printf "python-version=%s\n" "${{ matrix.python-version }}" >> "$GITHUB_OUTPUT"
          printf "PYTHON_VERSION=%s\n" "${{ matrix.python-version }}" >> "$GITHUB_ENV"
          printf "%s\n" "::endgroup::"
      - name: Try Smoke Testing
        id: smoke_testing
        shell: bash
        env:
          OS: ${{ runner.os }}
        if: ${{ success() }}
        run: |
          # Custom timeout function (GH-5974 - because ulimit is restricted and windows can't ulimit at all)
          # TODO: clean this up
          run_with_timeout() {
              local timeout=$1
              shift
              "$@" &
              local pid=$!
              ( sleep "$timeout" && kill -HUP "$pid" 2>/dev/null ) &  # Send HUP signal after timeout
              wait "$pid"
              local status=$?
              if [ $status -eq 0 ]; then
                  printf "::debug::%s\n" "Command completed successfully."
              elif [ $status -eq 143 ]; then
                  printf "%s\n" "The command was terminated due to timeout."
              else
                  printf "%s\n" "The command failed with status $status."
              fi
          }

          export -f run_with_timeout ;
          # Usage
          # run_with_timeout 360 your_command_here
          cd rustpython || exit 13 ;
          for referance_file in ${{ steps.reftestfiles.outputs.files }} ; do
            if [[ ( -f "${referance_file}" ) ]] ; then
              # See https://devguide.python.org/testing/run-write-tests
              # Heuristic: "if some module does not have unittest.main(), then most likely it does not support direct invocation."
              if grep -qF "unittest.main()" "${referance_file}" 2>/dev/null ; then
                printf "Now Testing '%s'\n" "${referance_file}"
                # vars for subshell but not for workflow
                export REF_FILE_NAME=$(basename "${referance_file}") ;
                printf "::group::%s\n" "${REF_FILE_NAME}" ;
                # TODO: test with cpython first for baseline
                # TODO: add to list of files that need additional prep due to hanging or unexpected failures that need to be removed
                # Execute the testing command in a subshell
                time (
                  export RUSTPYTHONPATH=Lib ;
                  run_with_timeout ${SUBSHELL_TIMEOUT} cargo run --release -- Lib/test/"${REF_FILE_NAME}" || RAW_COPY_OUTCOME='failing'
                  if [[ ( -n ${RAW_COPY_OUTCOME} ) ]] ; then
                    printf "::warning file='%s',title='test-warning':: Could not copy and pass tests for file.\n" "${referance_file}" ;
                    (
                      run_with_timeout ${SUBSHELL_TIMEOUT} cargo run --release -- ./scripts/fix_test.py --path ./Lib/test/"${REF_FILE_NAME}" || FIX_COPY_OUTCOME='unfixed' ;
                    ) ;
                    if [[ ( -n ${FIX_COPY_OUTCOME} ) ]] ; then
                      printf "::error file='%s',title='testing-failure':: Could not copy and auto-fix tests for file.\n" "${referance_file}" >>2 ;
                      # reset broken integration to last rustpython copy
                      git restore --ignore-unmerged --worktree --staged "${referance_file}" || : ;
                      git checkout -f --ignore-unmerged -- "${referance_file}" || : ;
                      # TODO: validate and conditionally set
                      FIX_COPY_OUTCOME="reverted"
                    else
                      FIX_COPY_OUTCOME="fixed"
                      RAW_COPY_OUTCOME="incompatable"
                    fi ;
                  else
                    FIX_COPY_OUTCOME="skipped"
                    RAW_COPY_OUTCOME="compatable"
                  fi ;
                  printf "\n---\n%s Outcome:\n\tDirectly:%s\n\tAuto-Fix:%s\n\n" "${REF_FILE_NAME}" "${RAW_COPY_OUTCOME}" "${FIX_COPY_OUTCOME}" ;
                  wait ; # used to force boundry for std out read/write race in UI 
                  printf "FIX_COPY_%s_OUTCOME=%s\n" "${REF_FILE_NAME}" "${FIX_COPY_OUTCOME}" >> "$GITHUB_ENV" ;
                  printf "RAW_COPY_%s_OUTCOME=%s\n" "${REF_FILE_NAME}" "${RAW_COPY_OUTCOME}" >> "$GITHUB_ENV" ;
                  # should dump a diff or something here
                  printf "\n\n" ;
                  unset RUSTPYTHONPATH 2>/dev/null || : ;
                ) ;
                wait ;
                # cleanup temp env
                unset FIX_COPY_OUTCOME 2>/dev/null || : ;
                unset RAW_COPY_OUTCOME 2>/dev/null || : ;
                unset REF_FILE_NAME 2>/dev/null || : ;
                printf "\n::endgroup::\n" ;
              else
                # TODO: else can not be run directly and needs to be invoked with -m unittest -v test.
                # TODO: cleanup this regular expression for edge-cases
                if grep -qE "^[^cC]*([cC]lass)\s*(.+)(Test)" "${referance_file}" 2>/dev/null ; then
                  printf "Now Testing test-cases in '%s'\n" "${referance_file}"
                  # vars for subshell but not for workflow
                  export REF_TEST_NAME=$(basename -s "py" "${referance_file}") ;
                  printf "%s\n" "Selected testcase test.${REF_TEST_NAME}"
                  printf "::group::%s\n" "${REF_FILE_NAME}" ;
                  # TODO: test with cpython first for baseline
                  # TODO: add to list of files that need additional prep due to hanging or unexpected failures that need to be removed
                  # Execute the testing command in a subshell
                  time (
                    export RUSTPYTHONPATH=Lib ;
                    run_with_timeout ${SUBSHELL_TIMEOUT} cargo run --release -- -m unittest -v test.${REF_TEST_NAME} || RAW_COPY_OUTCOME='failing'
                    if [[ ( -n ${RAW_COPY_OUTCOME} ) ]] ; then
                      printf "::warning file='%s',title='test-warning':: Could not copy and pass tests for file.\n" "${referance_file}" ;
                      (
                        run_with_timeout ${SUBSHELL_TIMEOUT} cargo run --release -- ./scripts/fix_test.py --test test.${REF_TEST_NAME} --path ./Lib/test/"${REF_FILE_NAME}".py || FIX_COPY_OUTCOME='unfixed' ;
                      ) ;
                      if [[ ( -n ${FIX_COPY_OUTCOME} ) ]] ; then
                        printf "::error file='%s',title='testing-failure':: Could not copy and auto-fix tests for file.\n" "${referance_file}" >>2 ;
                        # reset broken integration to last rustpython copy
                        git restore --ignore-unmerged --worktree --staged "${referance_file}" || : ;
                        git checkout -f --ignore-unmerged -- "${referance_file}" || : ;
                        # TODO: validate and conditionally set
                        FIX_COPY_OUTCOME="reverted"
                      else
                        FIX_COPY_OUTCOME="fixed"
                        RAW_COPY_OUTCOME="incompatable"
                      fi ;
                    else
                      FIX_COPY_OUTCOME="skipped"
                      RAW_COPY_OUTCOME="compatable"
                    fi ;
                    printf "\n---\n%s Outcome:\n\tDirectly:%s\n\tAuto-Fix:%s\n\n" "${REF_TEST_NAME}" "${RAW_COPY_OUTCOME}" "${FIX_COPY_OUTCOME}" ;
                    wait ; # used to force boundry for std out read/write race in UI 
                    printf "FIX_COPY_%s.py_OUTCOME=%s\n" "${REF_TEST_NAME}" "${FIX_COPY_OUTCOME}" >> "$GITHUB_ENV" ;
                    printf "RAW_COPY_%s.py_OUTCOME=%s\n" "${REF_TEST_NAME}" "${RAW_COPY_OUTCOME}" >> "$GITHUB_ENV" ;
                    # should dump a diff or something here
                    printf "\n\n" ;
                    unset RUSTPYTHONPATH 2>/dev/null || : ;
                  ) ;
                  wait ;
                  # cleanup temp env
                  unset FIX_COPY_OUTCOME 2>/dev/null || : ;
                  unset RAW_COPY_OUTCOME 2>/dev/null || : ;
                  unset REF_TEST_NAME 2>/dev/null || : ;
                  printf "\n::endgroup::\n" ;
                else
                  printf "\nNow Skipping '%s'\n\n" "${referance_file}" ;
                fi ;
              fi ; # TODO: else can not be run directly and needs to be invoked with -m unittest -v test.
            fi ;
          done
          cd .. ;
      - name: Post-Clean
        id: post-bootstrap
        run: |
          exit 0 ; # don't break on regression
        if: ${{ always() }}
        shell: bash
