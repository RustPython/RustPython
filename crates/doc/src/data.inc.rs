// This file was auto-generated by `.github/workflows/update-doc-db.yml`.
// CPython version: 3.13.9
// spell-checker: disable

pub static DB: phf::Map<&'static str, &'static str> = phf::phf_map! {
    "_abc" => "Module contains faster C implementation of abc.ABCMeta",
    "_abc._abc_init" => "Internal ABC helper for class set-up. Should be never used outside abc module.",
    "_abc._abc_instancecheck" => "Internal ABC helper for instance checks. Should be never used outside abc module.",
    "_abc._abc_register" => "Internal ABC helper for subclasss registration. Should be never used outside abc module.",
    "_abc._abc_subclasscheck" => "Internal ABC helper for subclasss checks. Should be never used outside abc module.",
    "_abc._get_dump" => "Internal ABC helper for cache and registry debugging.\n\nReturn shallow copies of registry, of both caches, and\nnegative cache version. Don't call this function directly,\ninstead use ABC._dump_registry() for a nice repr.",
    "_abc._reset_caches" => "Internal ABC helper to reset both caches of a given class.\n\nShould be only used by refleak.py",
    "_abc._reset_registry" => "Internal ABC helper to reset registry of a given class.\n\nShould be only used by refleak.py",
    "_abc.get_cache_token" => "Returns the current ABC cache token.\n\nThe token is an opaque object (supporting equality testing) identifying the\ncurrent version of the ABC cache for virtual subclasses. The token changes\nwith every call to register() on any ABC.",
    "_asyncio" => "Accelerator module for asyncio",
    "_asyncio.Future" => "This class is *almost* compatible with concurrent.futures.Future.\n\nDifferences:\n\n- result() and exception() do not take a timeout argument and\n  raise an exception when the future isn't done yet.\n\n- Callbacks registered with add_done_callback() are always called\n  via the event loop's call_soon_threadsafe().\n\n- This class is not compatible with the wait() and as_completed()\n  methods in the concurrent.futures package.",
    "_asyncio.Future.__await__" => "Return an iterator to be used in await expression.",
    "_asyncio.Future.__class_getitem__" => "See PEP 585",
    "_asyncio.Future.__del__" => "Called when the instance is about to be destroyed.",
    "_asyncio.Future.__delattr__" => "Implement delattr(self, name).",
    "_asyncio.Future.__eq__" => "Return self==value.",
    "_asyncio.Future.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_asyncio.Future.__ge__" => "Return self>=value.",
    "_asyncio.Future.__getattribute__" => "Return getattr(self, name).",
    "_asyncio.Future.__getstate__" => "Helper for pickle.",
    "_asyncio.Future.__gt__" => "Return self>value.",
    "_asyncio.Future.__hash__" => "Return hash(self).",
    "_asyncio.Future.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_asyncio.Future.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_asyncio.Future.__iter__" => "Implement iter(self).",
    "_asyncio.Future.__le__" => "Return self<=value.",
    "_asyncio.Future.__lt__" => "Return self<value.",
    "_asyncio.Future.__ne__" => "Return self!=value.",
    "_asyncio.Future.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_asyncio.Future.__reduce__" => "Helper for pickle.",
    "_asyncio.Future.__reduce_ex__" => "Helper for pickle.",
    "_asyncio.Future.__repr__" => "Return repr(self).",
    "_asyncio.Future.__setattr__" => "Implement setattr(self, name, value).",
    "_asyncio.Future.__sizeof__" => "Size of object in memory, in bytes.",
    "_asyncio.Future.__str__" => "Return str(self).",
    "_asyncio.Future.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_asyncio.Future._make_cancelled_error" => "Create the CancelledError to raise if the Future is cancelled.\n\nThis should only be called once when handling a cancellation since\nit erases the context exception value.",
    "_asyncio.Future.add_done_callback" => "Add a callback to be run when the future becomes done.\n\nThe callback is called with a single argument - the future object. If\nthe future is already done when this is called, the callback is\nscheduled with call_soon.",
    "_asyncio.Future.cancel" => "Cancel the future and schedule callbacks.\n\nIf the future is already done or cancelled, return False.  Otherwise,\nchange the future's state to cancelled, schedule the callbacks and\nreturn True.",
    "_asyncio.Future.cancelled" => "Return True if the future was cancelled.",
    "_asyncio.Future.done" => "Return True if the future is done.\n\nDone means either that a result / exception are available, or that the\nfuture was cancelled.",
    "_asyncio.Future.exception" => "Return the exception that was set on this future.\n\nThe exception (or None if no exception was set) is returned only if\nthe future is done.  If the future has been cancelled, raises\nCancelledError.  If the future isn't done yet, raises\nInvalidStateError.",
    "_asyncio.Future.get_loop" => "Return the event loop the Future is bound to.",
    "_asyncio.Future.remove_done_callback" => "Remove all instances of a callback from the \"call when done\" list.\n\nReturns the number of callbacks removed.",
    "_asyncio.Future.result" => "Return the result this future represents.\n\nIf the future has been cancelled, raises CancelledError.  If the\nfuture's result isn't yet available, raises InvalidStateError.  If\nthe future is done and has an exception set, this exception is raised.",
    "_asyncio.Future.set_exception" => "Mark the future done and set an exception.\n\nIf the future is already done when this method is called, raises\nInvalidStateError.",
    "_asyncio.Future.set_result" => "Mark the future done and set its result.\n\nIf the future is already done when this method is called, raises\nInvalidStateError.",
    "_asyncio.Task" => "A coroutine wrapped in a Future.",
    "_asyncio.Task.__await__" => "Return an iterator to be used in await expression.",
    "_asyncio.Task.__class_getitem__" => "See PEP 585",
    "_asyncio.Task.__del__" => "Called when the instance is about to be destroyed.",
    "_asyncio.Task.__delattr__" => "Implement delattr(self, name).",
    "_asyncio.Task.__eq__" => "Return self==value.",
    "_asyncio.Task.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_asyncio.Task.__ge__" => "Return self>=value.",
    "_asyncio.Task.__getattribute__" => "Return getattr(self, name).",
    "_asyncio.Task.__getstate__" => "Helper for pickle.",
    "_asyncio.Task.__gt__" => "Return self>value.",
    "_asyncio.Task.__hash__" => "Return hash(self).",
    "_asyncio.Task.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_asyncio.Task.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_asyncio.Task.__iter__" => "Implement iter(self).",
    "_asyncio.Task.__le__" => "Return self<=value.",
    "_asyncio.Task.__lt__" => "Return self<value.",
    "_asyncio.Task.__ne__" => "Return self!=value.",
    "_asyncio.Task.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_asyncio.Task.__reduce__" => "Helper for pickle.",
    "_asyncio.Task.__reduce_ex__" => "Helper for pickle.",
    "_asyncio.Task.__repr__" => "Return repr(self).",
    "_asyncio.Task.__setattr__" => "Implement setattr(self, name, value).",
    "_asyncio.Task.__sizeof__" => "Size of object in memory, in bytes.",
    "_asyncio.Task.__str__" => "Return str(self).",
    "_asyncio.Task.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_asyncio.Task._make_cancelled_error" => "Create the CancelledError to raise if the Task is cancelled.\n\nThis should only be called once when handling a cancellation since\nit erases the context exception value.",
    "_asyncio.Task.add_done_callback" => "Add a callback to be run when the future becomes done.\n\nThe callback is called with a single argument - the future object. If\nthe future is already done when this is called, the callback is\nscheduled with call_soon.",
    "_asyncio.Task.cancel" => "Request that this task cancel itself.\n\nThis arranges for a CancelledError to be thrown into the\nwrapped coroutine on the next cycle through the event loop.\nThe coroutine then has a chance to clean up or even deny\nthe request using try/except/finally.\n\nUnlike Future.cancel, this does not guarantee that the\ntask will be cancelled: the exception might be caught and\nacted upon, delaying cancellation of the task or preventing\ncancellation completely.  The task may also return a value or\nraise a different exception.\n\nImmediately after this method is called, Task.cancelled() will\nnot return True (unless the task was already cancelled).  A\ntask will be marked as cancelled when the wrapped coroutine\nterminates with a CancelledError exception (even if cancel()\nwas not called).\n\nThis also increases the task's count of cancellation requests.",
    "_asyncio.Task.cancelled" => "Return True if the future was cancelled.",
    "_asyncio.Task.cancelling" => "Return the count of the task's cancellation requests.\n\nThis count is incremented when .cancel() is called\nand may be decremented using .uncancel().",
    "_asyncio.Task.done" => "Return True if the future is done.\n\nDone means either that a result / exception are available, or that the\nfuture was cancelled.",
    "_asyncio.Task.exception" => "Return the exception that was set on this future.\n\nThe exception (or None if no exception was set) is returned only if\nthe future is done.  If the future has been cancelled, raises\nCancelledError.  If the future isn't done yet, raises\nInvalidStateError.",
    "_asyncio.Task.get_loop" => "Return the event loop the Future is bound to.",
    "_asyncio.Task.get_stack" => "Return the list of stack frames for this task's coroutine.\n\nIf the coroutine is not done, this returns the stack where it is\nsuspended.  If the coroutine has completed successfully or was\ncancelled, this returns an empty list.  If the coroutine was\nterminated by an exception, this returns the list of traceback\nframes.\n\nThe frames are always ordered from oldest to newest.\n\nThe optional limit gives the maximum number of frames to\nreturn; by default all available frames are returned.  Its\nmeaning differs depending on whether a stack or a traceback is\nreturned: the newest frames of a stack are returned, but the\noldest frames of a traceback are returned.  (This matches the\nbehavior of the traceback module.)\n\nFor reasons beyond our control, only one stack frame is\nreturned for a suspended coroutine.",
    "_asyncio.Task.print_stack" => "Print the stack or traceback for this task's coroutine.\n\nThis produces output similar to that of the traceback module,\nfor the frames retrieved by get_stack().  The limit argument\nis passed to get_stack().  The file argument is an I/O stream\nto which the output is written; by default output is written\nto sys.stderr.",
    "_asyncio.Task.remove_done_callback" => "Remove all instances of a callback from the \"call when done\" list.\n\nReturns the number of callbacks removed.",
    "_asyncio.Task.result" => "Return the result this future represents.\n\nIf the future has been cancelled, raises CancelledError.  If the\nfuture's result isn't yet available, raises InvalidStateError.  If\nthe future is done and has an exception set, this exception is raised.",
    "_asyncio.Task.uncancel" => "Decrement the task's count of cancellation requests.\n\nThis should be used by tasks that catch CancelledError\nand wish to continue indefinitely until they are cancelled again.\n\nReturns the remaining number of cancellation requests.",
    "_asyncio._enter_task" => "Enter into task execution or resume suspended task.\n\nTask belongs to loop.\n\nReturns None.",
    "_asyncio._get_running_loop" => "Return the running event loop or None.\n\nThis is a low-level function intended to be used by event loops.\nThis function is thread-specific.",
    "_asyncio._leave_task" => "Leave task execution or suspend a task.\n\nTask belongs to loop.\n\nReturns None.",
    "_asyncio._register_eager_task" => "Register a new task in asyncio as executed by loop.\n\nReturns None.",
    "_asyncio._register_task" => "Register a new task in asyncio as executed by loop.\n\nReturns None.",
    "_asyncio._set_running_loop" => "Set the running event loop.\n\nThis is a low-level function intended to be used by event loops.\nThis function is thread-specific.",
    "_asyncio._swap_current_task" => "Temporarily swap in the supplied task and return the original one (or None).\n\nThis is intended for use during eager coroutine execution.",
    "_asyncio._unregister_eager_task" => "Unregister a task.\n\nReturns None.",
    "_asyncio._unregister_task" => "Unregister a task.\n\nReturns None.",
    "_asyncio.current_task" => "Return a currently executed task.",
    "_asyncio.get_event_loop" => "Return an asyncio event loop.\n\nWhen called from a coroutine or a callback (e.g. scheduled with\ncall_soon or similar API), this function will always return the\nrunning event loop.\n\nIf there is no running event loop set, the function will return\nthe result of `get_event_loop_policy().get_event_loop()` call.",
    "_asyncio.get_running_loop" => "Return the running event loop.  Raise a RuntimeError if there is none.\n\nThis function is thread-specific.",
    "_bisect" => "Bisection algorithms.\n\nThis module provides support for maintaining a list in sorted order without\nhaving to sort the list after each insertion. For long lists of items with\nexpensive comparison operations, this can be an improvement over the more\ncommon approach.",
    "_bisect.bisect_left" => "Return the index where to insert item x in list a, assuming a is sorted.\n\nThe return value i is such that all e in a[:i] have e < x, and all e in\na[i:] have e >= x.  So if x already appears in the list, a.insert(i, x) will\ninsert just before the leftmost x already there.\n\nOptional args lo (default 0) and hi (default len(a)) bound the\nslice of a to be searched.\n\nA custom key function can be supplied to customize the sort order.",
    "_bisect.bisect_right" => "Return the index where to insert item x in list a, assuming a is sorted.\n\nThe return value i is such that all e in a[:i] have e <= x, and all e in\na[i:] have e > x.  So if x already appears in the list, a.insert(i, x) will\ninsert just after the rightmost x already there.\n\nOptional args lo (default 0) and hi (default len(a)) bound the\nslice of a to be searched.\n\nA custom key function can be supplied to customize the sort order.",
    "_bisect.insort_left" => "Insert item x in list a, and keep it sorted assuming a is sorted.\n\nIf x is already in a, insert it to the left of the leftmost x.\n\nOptional args lo (default 0) and hi (default len(a)) bound the\nslice of a to be searched.\n\nA custom key function can be supplied to customize the sort order.",
    "_bisect.insort_right" => "Insert item x in list a, and keep it sorted assuming a is sorted.\n\nIf x is already in a, insert it to the right of the rightmost x.\n\nOptional args lo (default 0) and hi (default len(a)) bound the\nslice of a to be searched.\n\nA custom key function can be supplied to customize the sort order.",
    "_blake2" => "_blake2b provides BLAKE2b for hashlib",
    "_blake2.blake2b" => "Return a new BLAKE2b hash object.",
    "_blake2.blake2b.__delattr__" => "Implement delattr(self, name).",
    "_blake2.blake2b.__eq__" => "Return self==value.",
    "_blake2.blake2b.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_blake2.blake2b.__ge__" => "Return self>=value.",
    "_blake2.blake2b.__getattribute__" => "Return getattr(self, name).",
    "_blake2.blake2b.__getstate__" => "Helper for pickle.",
    "_blake2.blake2b.__gt__" => "Return self>value.",
    "_blake2.blake2b.__hash__" => "Return hash(self).",
    "_blake2.blake2b.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_blake2.blake2b.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_blake2.blake2b.__le__" => "Return self<=value.",
    "_blake2.blake2b.__lt__" => "Return self<value.",
    "_blake2.blake2b.__ne__" => "Return self!=value.",
    "_blake2.blake2b.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_blake2.blake2b.__reduce__" => "Helper for pickle.",
    "_blake2.blake2b.__reduce_ex__" => "Helper for pickle.",
    "_blake2.blake2b.__repr__" => "Return repr(self).",
    "_blake2.blake2b.__setattr__" => "Implement setattr(self, name, value).",
    "_blake2.blake2b.__sizeof__" => "Size of object in memory, in bytes.",
    "_blake2.blake2b.__str__" => "Return str(self).",
    "_blake2.blake2b.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_blake2.blake2b.copy" => "Return a copy of the hash object.",
    "_blake2.blake2b.digest" => "Return the digest value as a bytes object.",
    "_blake2.blake2b.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_blake2.blake2b.update" => "Update this hash object's state with the provided bytes-like object.",
    "_blake2.blake2s" => "Return a new BLAKE2s hash object.",
    "_blake2.blake2s.__delattr__" => "Implement delattr(self, name).",
    "_blake2.blake2s.__eq__" => "Return self==value.",
    "_blake2.blake2s.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_blake2.blake2s.__ge__" => "Return self>=value.",
    "_blake2.blake2s.__getattribute__" => "Return getattr(self, name).",
    "_blake2.blake2s.__getstate__" => "Helper for pickle.",
    "_blake2.blake2s.__gt__" => "Return self>value.",
    "_blake2.blake2s.__hash__" => "Return hash(self).",
    "_blake2.blake2s.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_blake2.blake2s.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_blake2.blake2s.__le__" => "Return self<=value.",
    "_blake2.blake2s.__lt__" => "Return self<value.",
    "_blake2.blake2s.__ne__" => "Return self!=value.",
    "_blake2.blake2s.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_blake2.blake2s.__reduce__" => "Helper for pickle.",
    "_blake2.blake2s.__reduce_ex__" => "Helper for pickle.",
    "_blake2.blake2s.__repr__" => "Return repr(self).",
    "_blake2.blake2s.__setattr__" => "Implement setattr(self, name, value).",
    "_blake2.blake2s.__sizeof__" => "Size of object in memory, in bytes.",
    "_blake2.blake2s.__str__" => "Return str(self).",
    "_blake2.blake2s.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_blake2.blake2s.copy" => "Return a copy of the hash object.",
    "_blake2.blake2s.digest" => "Return the digest value as a bytes object.",
    "_blake2.blake2s.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_blake2.blake2s.update" => "Update this hash object's state with the provided bytes-like object.",
    "_bz2.BZ2Compressor" => "Create a compressor object for compressing data incrementally.\n\n  compresslevel\n    Compression level, as a number between 1 and 9.\n\nFor one-shot compression, use the compress() function instead.",
    "_bz2.BZ2Compressor.__delattr__" => "Implement delattr(self, name).",
    "_bz2.BZ2Compressor.__eq__" => "Return self==value.",
    "_bz2.BZ2Compressor.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_bz2.BZ2Compressor.__ge__" => "Return self>=value.",
    "_bz2.BZ2Compressor.__getattribute__" => "Return getattr(self, name).",
    "_bz2.BZ2Compressor.__getstate__" => "Helper for pickle.",
    "_bz2.BZ2Compressor.__gt__" => "Return self>value.",
    "_bz2.BZ2Compressor.__hash__" => "Return hash(self).",
    "_bz2.BZ2Compressor.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_bz2.BZ2Compressor.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_bz2.BZ2Compressor.__le__" => "Return self<=value.",
    "_bz2.BZ2Compressor.__lt__" => "Return self<value.",
    "_bz2.BZ2Compressor.__ne__" => "Return self!=value.",
    "_bz2.BZ2Compressor.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_bz2.BZ2Compressor.__reduce__" => "Helper for pickle.",
    "_bz2.BZ2Compressor.__reduce_ex__" => "Helper for pickle.",
    "_bz2.BZ2Compressor.__repr__" => "Return repr(self).",
    "_bz2.BZ2Compressor.__setattr__" => "Implement setattr(self, name, value).",
    "_bz2.BZ2Compressor.__sizeof__" => "Size of object in memory, in bytes.",
    "_bz2.BZ2Compressor.__str__" => "Return str(self).",
    "_bz2.BZ2Compressor.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_bz2.BZ2Compressor.compress" => "Provide data to the compressor object.\n\nReturns a chunk of compressed data if possible, or b'' otherwise.\n\nWhen you have finished providing data to the compressor, call the\nflush() method to finish the compression process.",
    "_bz2.BZ2Compressor.flush" => "Finish the compression process.\n\nReturns the compressed data left in internal buffers.\n\nThe compressor object may not be used after this method is called.",
    "_bz2.BZ2Decompressor" => "Create a decompressor object for decompressing data incrementally.\n\nFor one-shot decompression, use the decompress() function instead.",
    "_bz2.BZ2Decompressor.__delattr__" => "Implement delattr(self, name).",
    "_bz2.BZ2Decompressor.__eq__" => "Return self==value.",
    "_bz2.BZ2Decompressor.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_bz2.BZ2Decompressor.__ge__" => "Return self>=value.",
    "_bz2.BZ2Decompressor.__getattribute__" => "Return getattr(self, name).",
    "_bz2.BZ2Decompressor.__getstate__" => "Helper for pickle.",
    "_bz2.BZ2Decompressor.__gt__" => "Return self>value.",
    "_bz2.BZ2Decompressor.__hash__" => "Return hash(self).",
    "_bz2.BZ2Decompressor.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_bz2.BZ2Decompressor.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_bz2.BZ2Decompressor.__le__" => "Return self<=value.",
    "_bz2.BZ2Decompressor.__lt__" => "Return self<value.",
    "_bz2.BZ2Decompressor.__ne__" => "Return self!=value.",
    "_bz2.BZ2Decompressor.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_bz2.BZ2Decompressor.__reduce__" => "Helper for pickle.",
    "_bz2.BZ2Decompressor.__reduce_ex__" => "Helper for pickle.",
    "_bz2.BZ2Decompressor.__repr__" => "Return repr(self).",
    "_bz2.BZ2Decompressor.__setattr__" => "Implement setattr(self, name, value).",
    "_bz2.BZ2Decompressor.__sizeof__" => "Size of object in memory, in bytes.",
    "_bz2.BZ2Decompressor.__str__" => "Return str(self).",
    "_bz2.BZ2Decompressor.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_bz2.BZ2Decompressor.decompress" => "Decompress *data*, returning uncompressed data as bytes.\n\nIf *max_length* is nonnegative, returns at most *max_length* bytes of\ndecompressed data. If this limit is reached and further output can be\nproduced, *self.needs_input* will be set to ``False``. In this case, the next\ncall to *decompress()* may provide *data* as b'' to obtain more of the output.\n\nIf all of the input data was decompressed and returned (either because this\nwas less than *max_length* bytes, or because *max_length* was negative),\n*self.needs_input* will be set to True.\n\nAttempting to decompress data after the end of stream is reached raises an\nEOFError.  Any data found after the end of the stream is ignored and saved in\nthe unused_data attribute.",
    "_bz2.BZ2Decompressor.eof" => "True if the end-of-stream marker has been reached.",
    "_bz2.BZ2Decompressor.needs_input" => "True if more input is needed before more decompressed data can be produced.",
    "_bz2.BZ2Decompressor.unused_data" => "Data found after the end of the compressed stream.",
    "_codecs.decode" => "Decodes obj using the codec registered for encoding.\n\nDefault encoding is 'utf-8'.  errors may be given to set a\ndifferent error handling scheme.  Default is 'strict' meaning that encoding\nerrors raise a ValueError.  Other possible values are 'ignore', 'replace'\nand 'backslashreplace' as well as any other name registered with\ncodecs.register_error that can handle ValueErrors.",
    "_codecs.encode" => "Encodes obj using the codec registered for encoding.\n\nThe default encoding is 'utf-8'.  errors may be given to set a\ndifferent error handling scheme.  Default is 'strict' meaning that encoding\nerrors raise a ValueError.  Other possible values are 'ignore', 'replace'\nand 'backslashreplace' as well as any other name registered with\ncodecs.register_error that can handle ValueErrors.",
    "_codecs.lookup" => "Looks up a codec tuple in the Python codec registry and returns a CodecInfo object.",
    "_codecs.lookup_error" => "lookup_error(errors) -> handler\n\nReturn the error handler for the specified error handling name or raise a\nLookupError, if no handler exists under this name.",
    "_codecs.register" => "Register a codec search function.\n\nSearch functions are expected to take one argument, the encoding name in\nall lower case letters, and either return None, or a tuple of functions\n(encoder, decoder, stream_reader, stream_writer) (or a CodecInfo object).",
    "_codecs.register_error" => "Register the specified error handler under the name errors.\n\nhandler must be a callable object, that will be called with an exception\ninstance containing information about the location of the encoding/decoding\nerror and must return a (replacement, new position) tuple.",
    "_codecs.unregister" => "Unregister a codec search function and clear the registry's cache.\n\nIf the search function is not registered, do nothing.",
    "_collections" => "High performance data structures.\n- deque:        ordered collection accessible from endpoints only\n- defaultdict:  dict subclass with a default value factory",
    "_collections._count_elements" => "Count elements in the iterable, updating the mapping",
    "_contextvars" => "Context Variables",
    "_contextvars.Context.__contains__" => "Return bool(key in self).",
    "_contextvars.Context.__delattr__" => "Implement delattr(self, name).",
    "_contextvars.Context.__eq__" => "Return self==value.",
    "_contextvars.Context.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_contextvars.Context.__ge__" => "Return self>=value.",
    "_contextvars.Context.__getattribute__" => "Return getattr(self, name).",
    "_contextvars.Context.__getitem__" => "Return self[key].",
    "_contextvars.Context.__getstate__" => "Helper for pickle.",
    "_contextvars.Context.__gt__" => "Return self>value.",
    "_contextvars.Context.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_contextvars.Context.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_contextvars.Context.__iter__" => "Implement iter(self).",
    "_contextvars.Context.__le__" => "Return self<=value.",
    "_contextvars.Context.__len__" => "Return len(self).",
    "_contextvars.Context.__lt__" => "Return self<value.",
    "_contextvars.Context.__ne__" => "Return self!=value.",
    "_contextvars.Context.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_contextvars.Context.__reduce__" => "Helper for pickle.",
    "_contextvars.Context.__reduce_ex__" => "Helper for pickle.",
    "_contextvars.Context.__repr__" => "Return repr(self).",
    "_contextvars.Context.__setattr__" => "Implement setattr(self, name, value).",
    "_contextvars.Context.__sizeof__" => "Size of object in memory, in bytes.",
    "_contextvars.Context.__str__" => "Return str(self).",
    "_contextvars.Context.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_contextvars.Context.copy" => "Return a shallow copy of the context object.",
    "_contextvars.Context.get" => "Return the value for `key` if `key` has the value in the context object.\n\nIf `key` does not exist, return `default`. If `default` is not given,\nreturn None.",
    "_contextvars.Context.items" => "Return all variables and their values in the context object.\n\nThe result is returned as a list of 2-tuples (variable, value).",
    "_contextvars.Context.keys" => "Return a list of all variables in the context object.",
    "_contextvars.Context.values" => "Return a list of all variables' values in the context object.",
    "_contextvars.ContextVar.__class_getitem__" => "See PEP 585",
    "_contextvars.ContextVar.__delattr__" => "Implement delattr(self, name).",
    "_contextvars.ContextVar.__eq__" => "Return self==value.",
    "_contextvars.ContextVar.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_contextvars.ContextVar.__ge__" => "Return self>=value.",
    "_contextvars.ContextVar.__getattribute__" => "Return getattr(self, name).",
    "_contextvars.ContextVar.__getstate__" => "Helper for pickle.",
    "_contextvars.ContextVar.__gt__" => "Return self>value.",
    "_contextvars.ContextVar.__hash__" => "Return hash(self).",
    "_contextvars.ContextVar.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_contextvars.ContextVar.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_contextvars.ContextVar.__le__" => "Return self<=value.",
    "_contextvars.ContextVar.__lt__" => "Return self<value.",
    "_contextvars.ContextVar.__ne__" => "Return self!=value.",
    "_contextvars.ContextVar.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_contextvars.ContextVar.__reduce__" => "Helper for pickle.",
    "_contextvars.ContextVar.__reduce_ex__" => "Helper for pickle.",
    "_contextvars.ContextVar.__repr__" => "Return repr(self).",
    "_contextvars.ContextVar.__setattr__" => "Implement setattr(self, name, value).",
    "_contextvars.ContextVar.__sizeof__" => "Size of object in memory, in bytes.",
    "_contextvars.ContextVar.__str__" => "Return str(self).",
    "_contextvars.ContextVar.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_contextvars.ContextVar.get" => "Return a value for the context variable for the current context.\n\nIf there is no value for the variable in the current context, the method will:\n * return the value of the default argument of the method, if provided; or\n * return the default value for the context variable, if it was created\n   with one; or\n * raise a LookupError.",
    "_contextvars.ContextVar.reset" => "Reset the context variable.\n\nThe variable is reset to the value it had before the `ContextVar.set()` that\ncreated the token was used.",
    "_contextvars.ContextVar.set" => "Call to set a new value for the context variable in the current context.\n\nThe required value argument is the new value for the context variable.\n\nReturns a Token object that can be used to restore the variable to its previous\nvalue via the `ContextVar.reset()` method.",
    "_contextvars.Token.__class_getitem__" => "See PEP 585",
    "_contextvars.Token.__delattr__" => "Implement delattr(self, name).",
    "_contextvars.Token.__eq__" => "Return self==value.",
    "_contextvars.Token.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_contextvars.Token.__ge__" => "Return self>=value.",
    "_contextvars.Token.__getattribute__" => "Return getattr(self, name).",
    "_contextvars.Token.__getstate__" => "Helper for pickle.",
    "_contextvars.Token.__gt__" => "Return self>value.",
    "_contextvars.Token.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_contextvars.Token.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_contextvars.Token.__le__" => "Return self<=value.",
    "_contextvars.Token.__lt__" => "Return self<value.",
    "_contextvars.Token.__ne__" => "Return self!=value.",
    "_contextvars.Token.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_contextvars.Token.__reduce__" => "Helper for pickle.",
    "_contextvars.Token.__reduce_ex__" => "Helper for pickle.",
    "_contextvars.Token.__repr__" => "Return repr(self).",
    "_contextvars.Token.__setattr__" => "Implement setattr(self, name, value).",
    "_contextvars.Token.__sizeof__" => "Size of object in memory, in bytes.",
    "_contextvars.Token.__str__" => "Return str(self).",
    "_contextvars.Token.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_csv" => "CSV parsing and writing.",
    "_csv.Dialect" => "CSV dialect\n\nThe Dialect type records CSV parsing and generation options.",
    "_csv.Dialect.__delattr__" => "Implement delattr(self, name).",
    "_csv.Dialect.__eq__" => "Return self==value.",
    "_csv.Dialect.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_csv.Dialect.__ge__" => "Return self>=value.",
    "_csv.Dialect.__getattribute__" => "Return getattr(self, name).",
    "_csv.Dialect.__getstate__" => "Helper for pickle.",
    "_csv.Dialect.__gt__" => "Return self>value.",
    "_csv.Dialect.__hash__" => "Return hash(self).",
    "_csv.Dialect.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_csv.Dialect.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_csv.Dialect.__le__" => "Return self<=value.",
    "_csv.Dialect.__lt__" => "Return self<value.",
    "_csv.Dialect.__ne__" => "Return self!=value.",
    "_csv.Dialect.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_csv.Dialect.__reduce__" => "raises an exception to avoid pickling",
    "_csv.Dialect.__reduce_ex__" => "raises an exception to avoid pickling",
    "_csv.Dialect.__repr__" => "Return repr(self).",
    "_csv.Dialect.__setattr__" => "Implement setattr(self, name, value).",
    "_csv.Dialect.__sizeof__" => "Size of object in memory, in bytes.",
    "_csv.Dialect.__str__" => "Return str(self).",
    "_csv.Dialect.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_csv.Error.__cause__" => "exception cause",
    "_csv.Error.__context__" => "exception context",
    "_csv.Error.__delattr__" => "Implement delattr(self, name).",
    "_csv.Error.__eq__" => "Return self==value.",
    "_csv.Error.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_csv.Error.__ge__" => "Return self>=value.",
    "_csv.Error.__getattribute__" => "Return getattr(self, name).",
    "_csv.Error.__getstate__" => "Helper for pickle.",
    "_csv.Error.__gt__" => "Return self>value.",
    "_csv.Error.__hash__" => "Return hash(self).",
    "_csv.Error.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_csv.Error.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_csv.Error.__le__" => "Return self<=value.",
    "_csv.Error.__lt__" => "Return self<value.",
    "_csv.Error.__ne__" => "Return self!=value.",
    "_csv.Error.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_csv.Error.__reduce_ex__" => "Helper for pickle.",
    "_csv.Error.__repr__" => "Return repr(self).",
    "_csv.Error.__setattr__" => "Implement setattr(self, name, value).",
    "_csv.Error.__sizeof__" => "Size of object in memory, in bytes.",
    "_csv.Error.__str__" => "Return str(self).",
    "_csv.Error.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_csv.Error.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_csv.Error.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_csv.Reader" => "CSV reader\n\nReader objects are responsible for reading and parsing tabular data\nin CSV format.",
    "_csv.Reader.__delattr__" => "Implement delattr(self, name).",
    "_csv.Reader.__eq__" => "Return self==value.",
    "_csv.Reader.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_csv.Reader.__ge__" => "Return self>=value.",
    "_csv.Reader.__getattribute__" => "Return getattr(self, name).",
    "_csv.Reader.__getstate__" => "Helper for pickle.",
    "_csv.Reader.__gt__" => "Return self>value.",
    "_csv.Reader.__hash__" => "Return hash(self).",
    "_csv.Reader.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_csv.Reader.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_csv.Reader.__iter__" => "Implement iter(self).",
    "_csv.Reader.__le__" => "Return self<=value.",
    "_csv.Reader.__lt__" => "Return self<value.",
    "_csv.Reader.__ne__" => "Return self!=value.",
    "_csv.Reader.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_csv.Reader.__next__" => "Implement next(self).",
    "_csv.Reader.__reduce__" => "Helper for pickle.",
    "_csv.Reader.__reduce_ex__" => "Helper for pickle.",
    "_csv.Reader.__repr__" => "Return repr(self).",
    "_csv.Reader.__setattr__" => "Implement setattr(self, name, value).",
    "_csv.Reader.__sizeof__" => "Size of object in memory, in bytes.",
    "_csv.Reader.__str__" => "Return str(self).",
    "_csv.Reader.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_csv.Writer" => "CSV writer\n\nWriter objects are responsible for generating tabular data\nin CSV format from sequence input.",
    "_csv.Writer.__delattr__" => "Implement delattr(self, name).",
    "_csv.Writer.__eq__" => "Return self==value.",
    "_csv.Writer.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_csv.Writer.__ge__" => "Return self>=value.",
    "_csv.Writer.__getattribute__" => "Return getattr(self, name).",
    "_csv.Writer.__getstate__" => "Helper for pickle.",
    "_csv.Writer.__gt__" => "Return self>value.",
    "_csv.Writer.__hash__" => "Return hash(self).",
    "_csv.Writer.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_csv.Writer.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_csv.Writer.__le__" => "Return self<=value.",
    "_csv.Writer.__lt__" => "Return self<value.",
    "_csv.Writer.__ne__" => "Return self!=value.",
    "_csv.Writer.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_csv.Writer.__reduce__" => "Helper for pickle.",
    "_csv.Writer.__reduce_ex__" => "Helper for pickle.",
    "_csv.Writer.__repr__" => "Return repr(self).",
    "_csv.Writer.__setattr__" => "Implement setattr(self, name, value).",
    "_csv.Writer.__sizeof__" => "Size of object in memory, in bytes.",
    "_csv.Writer.__str__" => "Return str(self).",
    "_csv.Writer.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_csv.Writer.writerow" => "Construct and write a CSV record from an iterable of fields.\n\nNon-string elements will be converted to string.",
    "_csv.Writer.writerows" => "Construct and write a series of iterables to a csv file.\n\nNon-string elements will be converted to string.",
    "_csv.field_size_limit" => "Sets an upper limit on parsed fields.\n\nReturns old limit. If limit is not given, no new limit is set and\nthe old limit is returned",
    "_csv.get_dialect" => "Return the dialect instance associated with name.",
    "_csv.list_dialects" => "Return a list of all known dialect names.",
    "_csv.reader" => "Return a reader object that will process lines from the given iterable.\n\nThe \"iterable\" argument can be any object that returns a line\nof input for each iteration, such as a file object or a list.  The\noptional \"dialect\" argument defines a CSV dialect.  The function\nalso accepts optional keyword arguments which override settings\nprovided by the dialect.\n\nThe returned object is an iterator.  Each iteration returns a row\nof the CSV file (which can span multiple input lines).",
    "_csv.register_dialect" => "Create a mapping from a string name to a CVS dialect.\n\nThe optional \"dialect\" argument specifies the base dialect instance\nor the name of the registered dialect.  The function also accepts\noptional keyword arguments which override settings provided by the\ndialect.",
    "_csv.unregister_dialect" => "Delete the name/dialect mapping associated with a string name.",
    "_csv.writer" => "Return a writer object that will write user data on the given file object.\n\nThe \"fileobj\" argument can be any object that supports the file API.\nThe optional \"dialect\" argument defines a CSV dialect.  The function\nalso accepts optional keyword arguments which override settings\nprovided by the dialect.",
    "_ctypes" => "Create and manipulate C compatible data types in Python.",
    "_ctypes.Array" => "Abstract base class for arrays.\n\nThe recommended way to create concrete array types is by multiplying any\nctypes data type with a non-negative integer. Alternatively, you can subclass\nthis type and define _length_ and _type_ class variables. Array elements can\nbe read and written using standard subscript and slice accesses for slice\nreads, the resulting object is not itself an Array.",
    "_ctypes.CFuncPtr" => "Function Pointer",
    "_ctypes.COMError" => "Raised when a COM method call failed.",
    "_ctypes.COMError.__cause__" => "exception cause",
    "_ctypes.COMError.__context__" => "exception context",
    "_ctypes.COMError.__delattr__" => "Implement delattr(self, name).",
    "_ctypes.COMError.__eq__" => "Return self==value.",
    "_ctypes.COMError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_ctypes.COMError.__ge__" => "Return self>=value.",
    "_ctypes.COMError.__getattribute__" => "Return getattr(self, name).",
    "_ctypes.COMError.__getstate__" => "Helper for pickle.",
    "_ctypes.COMError.__gt__" => "Return self>value.",
    "_ctypes.COMError.__hash__" => "Return hash(self).",
    "_ctypes.COMError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_ctypes.COMError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_ctypes.COMError.__le__" => "Return self<=value.",
    "_ctypes.COMError.__lt__" => "Return self<value.",
    "_ctypes.COMError.__ne__" => "Return self!=value.",
    "_ctypes.COMError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_ctypes.COMError.__reduce_ex__" => "Helper for pickle.",
    "_ctypes.COMError.__repr__" => "Return repr(self).",
    "_ctypes.COMError.__setattr__" => "Implement setattr(self, name, value).",
    "_ctypes.COMError.__sizeof__" => "Size of object in memory, in bytes.",
    "_ctypes.COMError.__str__" => "Return str(self).",
    "_ctypes.COMError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_ctypes.COMError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_ctypes.COMError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_ctypes.CopyComPointer" => "CopyComPointer(src, dst) -> HRESULT value",
    "_ctypes.FormatError" => "FormatError([integer]) -> string\n\nConvert a win32 error code into a string. If the error code is not\ngiven, the return value of a call to GetLastError() is used.",
    "_ctypes.FreeLibrary" => "FreeLibrary(handle) -> void\n\nFree the handle of an executable previously loaded by LoadLibrary.",
    "_ctypes.LoadLibrary" => "LoadLibrary(name, load_flags) -> handle\n\nLoad an executable (usually a DLL), and return a handle to it.\nThe handle may be used to locate exported functions in this\nmodule. load_flags are as defined for LoadLibraryEx in the\nWindows API.",
    "_ctypes.POINTER" => "Create and return a new ctypes pointer type.\n\n  type\n    A ctypes type.\n\nPointer types are cached and reused internally,\nso calling this function repeatedly is cheap.",
    "_ctypes.Structure" => "Structure base class",
    "_ctypes.Union" => "Union base class",
    "_ctypes._Pointer" => "XXX to be provided",
    "_ctypes._SimpleCData" => "XXX to be provided",
    "_ctypes._dyld_shared_cache_contains_path" => "check if path is in the shared cache",
    "_ctypes.addressof" => "addressof(C instance) -> integer\nReturn the address of the C instance internal buffer",
    "_ctypes.alignment" => "alignment(C type) -> integer\nalignment(C instance) -> integer\nReturn the alignment requirements of a C instance",
    "_ctypes.buffer_info" => "Return buffer interface information",
    "_ctypes.byref" => "byref(C instance[, offset=0]) -> byref-object\nReturn a pointer lookalike to a C instance, only usable\nas function argument",
    "_ctypes.dlclose" => "dlclose a library",
    "_ctypes.dlopen" => "dlopen(name, flag={RTLD_GLOBAL|RTLD_LOCAL}) open a shared library",
    "_ctypes.dlsym" => "find symbol in shared library",
    "_ctypes.pointer" => "Create a new pointer instance, pointing to 'obj'.\n\nThe returned object is of the type POINTER(type(obj)). Note that if you\njust want to pass a pointer to an object to a foreign function call, you\nshould use byref(obj) which is much faster.",
    "_ctypes.resize" => "Resize the memory buffer of a ctypes instance",
    "_ctypes.sizeof" => "sizeof(C type) -> integer\nsizeof(C instance) -> integer\nReturn the size in bytes of a C instance",
    "_curses.baudrate" => "Return the output speed of the terminal in bits per second.",
    "_curses.beep" => "Emit a short attention sound.",
    "_curses.can_change_color" => "Return True if the programmer can change the colors displayed by the terminal.",
    "_curses.cbreak" => "Enter cbreak mode.\n\n  flag\n    If false, the effect is the same as calling nocbreak().\n\nIn cbreak mode (sometimes called \"rare\" mode) normal tty line buffering is\nturned off and characters are available to be read one by one.  However,\nunlike raw mode, special characters (interrupt, quit, suspend, and flow\ncontrol) retain their effects on the tty driver and calling program.\nCalling first raw() then cbreak() leaves the terminal in cbreak mode.",
    "_curses.color_content" => "Return the red, green, and blue (RGB) components of the specified color.\n\n  color_number\n    The number of the color (0 - (COLORS-1)).\n\nA 3-tuple is returned, containing the R, G, B values for the given color,\nwhich will be between 0 (no component) and 1000 (maximum amount of component).",
    "_curses.color_pair" => "Return the attribute value for displaying text in the specified color.\n\n  pair_number\n    The number of the color pair.\n\nThis attribute value can be combined with A_STANDOUT, A_REVERSE, and the\nother A_* attributes.  pair_number() is the counterpart to this function.",
    "_curses.curs_set" => "Set the cursor state.\n\n  visibility\n    0 for invisible, 1 for normal visible, or 2 for very visible.\n\nIf the terminal supports the visibility requested, the previous cursor\nstate is returned; otherwise, an exception is raised.  On many terminals,\nthe \"visible\" mode is an underline cursor and the \"very visible\" mode is\na block cursor.",
    "_curses.def_prog_mode" => "Save the current terminal mode as the \"program\" mode.\n\nThe \"program\" mode is the mode when the running program is using curses.\n\nSubsequent calls to reset_prog_mode() will restore this mode.",
    "_curses.def_shell_mode" => "Save the current terminal mode as the \"shell\" mode.\n\nThe \"shell\" mode is the mode when the running program is not using curses.\n\nSubsequent calls to reset_shell_mode() will restore this mode.",
    "_curses.delay_output" => "Insert a pause in output.\n\nms\n  Duration in milliseconds.",
    "_curses.doupdate" => "Update the physical screen to match the virtual screen.",
    "_curses.echo" => "Enter echo mode.\n\n  flag\n    If false, the effect is the same as calling noecho().\n\nIn echo mode, each character input is echoed to the screen as it is entered.",
    "_curses.endwin" => "De-initialize the library, and return terminal to normal status.",
    "_curses.erasechar" => "Return the user's current erase character.",
    "_curses.error.__cause__" => "exception cause",
    "_curses.error.__context__" => "exception context",
    "_curses.error.__delattr__" => "Implement delattr(self, name).",
    "_curses.error.__eq__" => "Return self==value.",
    "_curses.error.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_curses.error.__ge__" => "Return self>=value.",
    "_curses.error.__getattribute__" => "Return getattr(self, name).",
    "_curses.error.__getstate__" => "Helper for pickle.",
    "_curses.error.__gt__" => "Return self>value.",
    "_curses.error.__hash__" => "Return hash(self).",
    "_curses.error.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_curses.error.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_curses.error.__le__" => "Return self<=value.",
    "_curses.error.__lt__" => "Return self<value.",
    "_curses.error.__ne__" => "Return self!=value.",
    "_curses.error.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_curses.error.__reduce_ex__" => "Helper for pickle.",
    "_curses.error.__repr__" => "Return repr(self).",
    "_curses.error.__setattr__" => "Implement setattr(self, name, value).",
    "_curses.error.__sizeof__" => "Size of object in memory, in bytes.",
    "_curses.error.__str__" => "Return str(self).",
    "_curses.error.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_curses.error.__weakref__" => "list of weak references to the object",
    "_curses.error.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_curses.error.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_curses.flash" => "Flash the screen.\n\nThat is, change it to reverse-video and then change it back in a short interval.",
    "_curses.flushinp" => "Flush all input buffers.\n\nThis throws away any typeahead that has been typed by the user and has not\nyet been processed by the program.",
    "_curses.get_escdelay" => "Gets the curses ESCDELAY setting.\n\nGets the number of milliseconds to wait after reading an escape character,\nto distinguish between an individual escape character entered on the\nkeyboard from escape sequences sent by cursor and function keys.",
    "_curses.get_tabsize" => "Gets the curses TABSIZE setting.\n\nGets the number of columns used by the curses library when converting a tab\ncharacter to spaces as it adds the tab to a window.",
    "_curses.getmouse" => "Retrieve the queued mouse event.\n\nAfter getch() returns KEY_MOUSE to signal a mouse event, this function\nreturns a 5-tuple (id, x, y, z, bstate).",
    "_curses.getsyx" => "Return the current coordinates of the virtual screen cursor.\n\nReturn a (y, x) tuple.  If leaveok is currently true, return (-1, -1).",
    "_curses.getwin" => "Read window related data stored in the file by an earlier putwin() call.\n\nThe routine then creates and initializes a new window using that data,\nreturning the new window object.",
    "_curses.halfdelay" => "Enter half-delay mode.\n\n  tenths\n    Maximal blocking delay in tenths of seconds (1 - 255).\n\nUse nocbreak() to leave half-delay mode.",
    "_curses.has_colors" => "Return True if the terminal can display colors; otherwise, return False.",
    "_curses.has_extended_color_support" => "Return True if the module supports extended colors; otherwise, return False.\n\nExtended color support allows more than 256 color-pairs for terminals\nthat support more than 16 colors (e.g. xterm-256color).",
    "_curses.has_ic" => "Return True if the terminal has insert- and delete-character capabilities.",
    "_curses.has_il" => "Return True if the terminal has insert- and delete-line capabilities.",
    "_curses.has_key" => "Return True if the current terminal type recognizes a key with that value.\n\nkey\n  Key number.",
    "_curses.init_color" => "Change the definition of a color.\n\n  color_number\n    The number of the color to be changed (0 - (COLORS-1)).\n  r\n    Red component (0 - 1000).\n  g\n    Green component (0 - 1000).\n  b\n    Blue component (0 - 1000).\n\nWhen init_color() is used, all occurrences of that color on the screen\nimmediately change to the new definition.  This function is a no-op on\nmost terminals; it is active only if can_change_color() returns true.",
    "_curses.init_pair" => "Change the definition of a color-pair.\n\n  pair_number\n    The number of the color-pair to be changed (1 - (COLOR_PAIRS-1)).\n  fg\n    Foreground color number (-1 - (COLORS-1)).\n  bg\n    Background color number (-1 - (COLORS-1)).\n\nIf the color-pair was previously initialized, the screen is refreshed and\nall occurrences of that color-pair are changed to the new definition.",
    "_curses.initscr" => "Initialize the library.\n\nReturn a WindowObject which represents the whole screen.",
    "_curses.is_term_resized" => "Return True if resize_term() would modify the window structure, False otherwise.\n\nnlines\n  Height.\nncols\n  Width.",
    "_curses.isendwin" => "Return True if endwin() has been called.",
    "_curses.keyname" => "Return the name of specified key.\n\nkey\n  Key number.",
    "_curses.killchar" => "Return the user's current line kill character.",
    "_curses.longname" => "Return the terminfo long name field describing the current terminal.\n\nThe maximum length of a verbose description is 128 characters.  It is defined\nonly after the call to initscr().",
    "_curses.meta" => "Enable/disable meta keys.\n\nIf yes is True, allow 8-bit characters to be input.  If yes is False,\nallow only 7-bit characters.",
    "_curses.mouseinterval" => "Set and retrieve the maximum time between press and release in a click.\n\n  interval\n    Time in milliseconds.\n\nSet the maximum time that can elapse between press and release events in\norder for them to be recognized as a click, and return the previous interval\nvalue.",
    "_curses.mousemask" => "Set the mouse events to be reported, and return a tuple (availmask, oldmask).\n\nReturn a tuple (availmask, oldmask).  availmask indicates which of the\nspecified mouse events can be reported; on complete failure it returns 0.\noldmask is the previous value of the given window's mouse event mask.\nIf this function is never called, no mouse events are ever reported.",
    "_curses.napms" => "Sleep for specified time.\n\nms\n  Duration in milliseconds.",
    "_curses.newpad" => "Create and return a pointer to a new pad data structure.\n\nnlines\n  Height.\nncols\n  Width.",
    "_curses.newwin" => "newwin(nlines, ncols, [begin_y=0, begin_x=0])\nReturn a new window.\n\n  nlines\n    Height.\n  ncols\n    Width.\n  begin_y\n    Top side y-coordinate.\n  begin_x\n    Left side x-coordinate.\n\nBy default, the window will extend from the specified position to the lower\nright corner of the screen.",
    "_curses.nl" => "Enter newline mode.\n\n  flag\n    If false, the effect is the same as calling nonl().\n\nThis mode translates the return key into newline on input, and translates\nnewline into return and line-feed on output.  Newline mode is initially on.",
    "_curses.nocbreak" => "Leave cbreak mode.\n\nReturn to normal \"cooked\" mode with line buffering.",
    "_curses.noecho" => "Leave echo mode.\n\nEchoing of input characters is turned off.",
    "_curses.nonl" => "Leave newline mode.\n\nDisable translation of return into newline on input, and disable low-level\ntranslation of newline into newline/return on output.",
    "_curses.noqiflush" => "Disable queue flushing.\n\nWhen queue flushing is disabled, normal flush of input and output queues\nassociated with the INTR, QUIT and SUSP characters will not be done.",
    "_curses.noraw" => "Leave raw mode.\n\nReturn to normal \"cooked\" mode with line buffering.",
    "_curses.pair_content" => "Return a tuple (fg, bg) containing the colors for the requested color pair.\n\npair_number\n  The number of the color pair (0 - (COLOR_PAIRS-1)).",
    "_curses.pair_number" => "Return the number of the color-pair set by the specified attribute value.\n\ncolor_pair() is the counterpart to this function.",
    "_curses.putp" => "Emit the value of a specified terminfo capability for the current terminal.\n\nNote that the output of putp() always goes to standard output.",
    "_curses.qiflush" => "Enable queue flushing.\n\n  flag\n    If false, the effect is the same as calling noqiflush().\n\nIf queue flushing is enabled, all output in the display driver queue\nwill be flushed when the INTR, QUIT and SUSP characters are read.",
    "_curses.raw" => "Enter raw mode.\n\n  flag\n    If false, the effect is the same as calling noraw().\n\nIn raw mode, normal line buffering and processing of interrupt, quit,\nsuspend, and flow control keys are turned off; characters are presented to\ncurses input functions one by one.",
    "_curses.reset_prog_mode" => "Restore the terminal to \"program\" mode, as previously saved by def_prog_mode().",
    "_curses.reset_shell_mode" => "Restore the terminal to \"shell\" mode, as previously saved by def_shell_mode().",
    "_curses.resetty" => "Restore terminal mode.",
    "_curses.resize_term" => "Backend function used by resizeterm(), performing most of the work.\n\n  nlines\n    Height.\n  ncols\n    Width.\n\nWhen resizing the windows, resize_term() blank-fills the areas that are\nextended.  The calling application should fill in these areas with appropriate\ndata.  The resize_term() function attempts to resize all windows.  However,\ndue to the calling convention of pads, it is not possible to resize these\nwithout additional interaction with the application.",
    "_curses.resizeterm" => "Resize the standard and current windows to the specified dimensions.\n\n  nlines\n    Height.\n  ncols\n    Width.\n\nAdjusts other bookkeeping data used by the curses library that record the\nwindow dimensions (in particular the SIGWINCH handler).",
    "_curses.savetty" => "Save terminal mode.",
    "_curses.set_escdelay" => "Sets the curses ESCDELAY setting.\n\n  ms\n    length of the delay in milliseconds.\n\nSets the number of milliseconds to wait after reading an escape character,\nto distinguish between an individual escape character entered on the\nkeyboard from escape sequences sent by cursor and function keys.",
    "_curses.set_tabsize" => "Sets the curses TABSIZE setting.\n\n  size\n    rendered cell width of a tab character.\n\nSets the number of columns used by the curses library when converting a tab\ncharacter to spaces as it adds the tab to a window.",
    "_curses.setsyx" => "Set the virtual screen cursor.\n\n  y\n    Y-coordinate.\n  x\n    X-coordinate.\n\nIf y and x are both -1, then leaveok is set.",
    "_curses.setupterm" => "Initialize the terminal.\n\nterm\n  Terminal name.\n  If omitted, the value of the TERM environment variable will be used.\nfd\n  File descriptor to which any initialization sequences will be sent.\n  If not supplied, the file descriptor for sys.stdout will be used.",
    "_curses.start_color" => "Initializes eight basic colors and global variables COLORS and COLOR_PAIRS.\n\nMust be called if the programmer wants to use colors, and before any other\ncolor manipulation routine is called.  It is good practice to call this\nroutine right after initscr().\n\nIt also restores the colors on the terminal to the values they had when the\nterminal was just turned on.",
    "_curses.termattrs" => "Return a logical OR of all video attributes supported by the terminal.",
    "_curses.termname" => "Return the value of the environment variable TERM, truncated to 14 characters.",
    "_curses.tigetflag" => "Return the value of the Boolean capability.\n\n  capname\n    The terminfo capability name.\n\nThe value -1 is returned if capname is not a Boolean capability, or 0 if\nit is canceled or absent from the terminal description.",
    "_curses.tigetnum" => "Return the value of the numeric capability.\n\n  capname\n    The terminfo capability name.\n\nThe value -2 is returned if capname is not a numeric capability, or -1 if\nit is canceled or absent from the terminal description.",
    "_curses.tigetstr" => "Return the value of the string capability.\n\n  capname\n    The terminfo capability name.\n\nNone is returned if capname is not a string capability, or is canceled or\nabsent from the terminal description.",
    "_curses.tparm" => "Instantiate the specified byte string with the supplied parameters.\n\nstr\n  Parameterized byte string obtained from the terminfo database.",
    "_curses.typeahead" => "Specify that the file descriptor fd be used for typeahead checking.\n\n  fd\n    File descriptor.\n\nIf fd is -1, then no typeahead checking is done.",
    "_curses.unctrl" => "Return a string which is a printable representation of the character ch.\n\nControl characters are displayed as a caret followed by the character,\nfor example as ^C.  Printing characters are left as they are.",
    "_curses.unget_wch" => "Push ch so the next get_wch() will return it.",
    "_curses.ungetch" => "Push ch so the next getch() will return it.",
    "_curses.ungetmouse" => "Push a KEY_MOUSE event onto the input queue.\n\nThe following getmouse() will return the given state data.",
    "_curses.use_default_colors" => "Allow use of default values for colors on terminals supporting this feature.\n\nUse this to support transparency in your application.  The default color\nis assigned to the color number -1.",
    "_curses.use_env" => "Use environment variables LINES and COLUMNS.\n\nIf used, this function should be called before initscr() or newterm() are\ncalled.\n\nWhen flag is False, the values of lines and columns specified in the terminfo\ndatabase will be used, even if environment variables LINES and COLUMNS (used\nby default) are set, or if curses is running in a window (in which case\ndefault behavior would be to use the window size if LINES and COLUMNS are\nnot set).",
    "_curses.window.__delattr__" => "Implement delattr(self, name).",
    "_curses.window.__eq__" => "Return self==value.",
    "_curses.window.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_curses.window.__ge__" => "Return self>=value.",
    "_curses.window.__getattribute__" => "Return getattr(self, name).",
    "_curses.window.__getstate__" => "Helper for pickle.",
    "_curses.window.__gt__" => "Return self>value.",
    "_curses.window.__hash__" => "Return hash(self).",
    "_curses.window.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_curses.window.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_curses.window.__le__" => "Return self<=value.",
    "_curses.window.__lt__" => "Return self<value.",
    "_curses.window.__ne__" => "Return self!=value.",
    "_curses.window.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_curses.window.__reduce__" => "Helper for pickle.",
    "_curses.window.__reduce_ex__" => "Helper for pickle.",
    "_curses.window.__repr__" => "Return repr(self).",
    "_curses.window.__setattr__" => "Implement setattr(self, name, value).",
    "_curses.window.__sizeof__" => "Size of object in memory, in bytes.",
    "_curses.window.__str__" => "Return str(self).",
    "_curses.window.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_curses.window.addch" => "addch([y, x,] ch, [attr=_curses.A_NORMAL])\nPaint the character.\n\n  y\n    Y-coordinate.\n  x\n    X-coordinate.\n  ch\n    Character to add.\n  attr\n    Attributes for the character.\n\nPaint character ch at (y, x) with attributes attr,\noverwriting any character previously painted at that location.\nBy default, the character position and attributes are the\ncurrent settings for the window object.",
    "_curses.window.addnstr" => "addnstr([y, x,] str, n, [attr])\nPaint at most n characters of the string.\n\n  y\n    Y-coordinate.\n  x\n    X-coordinate.\n  str\n    String to add.\n  n\n    Maximal number of characters.\n  attr\n    Attributes for characters.\n\nPaint at most n characters of the string str at (y, x) with\nattributes attr, overwriting anything previously on the display.\nBy default, the character position and attributes are the\ncurrent settings for the window object.",
    "_curses.window.addstr" => "addstr([y, x,] str, [attr])\nPaint the string.\n\n  y\n    Y-coordinate.\n  x\n    X-coordinate.\n  str\n    String to add.\n  attr\n    Attributes for characters.\n\nPaint the string str at (y, x) with attributes attr,\noverwriting anything previously on the display.\nBy default, the character position and attributes are the\ncurrent settings for the window object.",
    "_curses.window.attroff" => "Remove attribute attr from the \"background\" set.",
    "_curses.window.attron" => "Add attribute attr from the \"background\" set.",
    "_curses.window.attrset" => "Set the \"background\" set of attributes.",
    "_curses.window.bkgd" => "Set the background property of the window.\n\nch\n  Background character.\nattr\n  Background attributes.",
    "_curses.window.bkgdset" => "Set the window's background.\n\nch\n  Background character.\nattr\n  Background attributes.",
    "_curses.window.border" => "Draw a border around the edges of the window.\n\n  ls\n    Left side.\n  rs\n    Right side.\n  ts\n    Top side.\n  bs\n    Bottom side.\n  tl\n    Upper-left corner.\n  tr\n    Upper-right corner.\n  bl\n    Bottom-left corner.\n  br\n    Bottom-right corner.\n\nEach parameter specifies the character to use for a specific part of the\nborder.  The characters can be specified as integers or as one-character\nstrings.  A 0 value for any parameter will cause the default character to be\nused for that parameter.",
    "_curses.window.box" => "box([verch=0, horch=0])\nDraw a border around the edges of the window.\n\n  verch\n    Left and right side.\n  horch\n    Top and bottom side.\n\nSimilar to border(), but both ls and rs are verch and both ts and bs are\nhorch.  The default corner characters are always used by this function.",
    "_curses.window.delch" => "delch([y, x])\nDelete any character at (y, x).\n\n  y\n    Y-coordinate.\n  x\n    X-coordinate.",
    "_curses.window.derwin" => "derwin([nlines=0, ncols=0,] begin_y, begin_x)\nCreate a sub-window (window-relative coordinates).\n\n  nlines\n    Height.\n  ncols\n    Width.\n  begin_y\n    Top side y-coordinate.\n  begin_x\n    Left side x-coordinate.\n\nderwin() is the same as calling subwin(), except that begin_y and begin_x\nare relative to the origin of the window, rather than relative to the entire\nscreen.",
    "_curses.window.echochar" => "Add character ch with attribute attr, and refresh.\n\nch\n  Character to add.\nattr\n  Attributes for the character.",
    "_curses.window.enclose" => "Return True if the screen-relative coordinates are enclosed by the window.\n\ny\n  Y-coordinate.\nx\n  X-coordinate.",
    "_curses.window.encoding" => "the typecode character used to create the array",
    "_curses.window.get_wch" => "get_wch([y, x])\nGet a wide character from terminal keyboard.\n\n  y\n    Y-coordinate.\n  x\n    X-coordinate.\n\nReturn a character for most keys, or an integer for function keys,\nkeypad keys, and other special keys.",
    "_curses.window.getbkgd" => "Return the window's current background character/attribute pair.",
    "_curses.window.getch" => "getch([y, x])\nGet a character code from terminal keyboard.\n\n  y\n    Y-coordinate.\n  x\n    X-coordinate.\n\nThe integer returned does not have to be in ASCII range: function keys,\nkeypad keys and so on return numbers higher than 256.  In no-delay mode, -1\nis returned if there is no input, else getch() waits until a key is pressed.",
    "_curses.window.getkey" => "getkey([y, x])\nGet a character (string) from terminal keyboard.\n\n  y\n    Y-coordinate.\n  x\n    X-coordinate.\n\nReturning a string instead of an integer, as getch() does.  Function keys,\nkeypad keys and other special keys return a multibyte string containing the\nkey name.  In no-delay mode, an exception is raised if there is no input.",
    "_curses.window.hline" => "hline([y, x,] ch, n, [attr=_curses.A_NORMAL])\nDisplay a horizontal line.\n\n  y\n    Starting Y-coordinate.\n  x\n    Starting X-coordinate.\n  ch\n    Character to draw.\n  n\n    Line length.\n  attr\n    Attributes for the characters.",
    "_curses.window.inch" => "inch([y, x])\nReturn the character at the given position in the window.\n\n  y\n    Y-coordinate.\n  x\n    X-coordinate.\n\nThe bottom 8 bits are the character proper, and upper bits are the attributes.",
    "_curses.window.insch" => "insch([y, x,] ch, [attr=_curses.A_NORMAL])\nInsert a character before the current or specified position.\n\n  y\n    Y-coordinate.\n  x\n    X-coordinate.\n  ch\n    Character to insert.\n  attr\n    Attributes for the character.\n\nAll characters to the right of the cursor are shifted one position right, with\nthe rightmost characters on the line being lost.",
    "_curses.window.insnstr" => "insnstr([y, x,] str, n, [attr])\nInsert at most n characters of the string.\n\n  y\n    Y-coordinate.\n  x\n    X-coordinate.\n  str\n    String to insert.\n  n\n    Maximal number of characters.\n  attr\n    Attributes for characters.\n\nInsert a character string (as many characters as will fit on the line)\nbefore the character under the cursor, up to n characters.  If n is zero\nor negative, the entire string is inserted.  All characters to the right\nof the cursor are shifted right, with the rightmost characters on the line\nbeing lost.  The cursor position does not change (after moving to y, x, if\nspecified).",
    "_curses.window.insstr" => "insstr([y, x,] str, [attr])\nInsert the string before the current or specified position.\n\n  y\n    Y-coordinate.\n  x\n    X-coordinate.\n  str\n    String to insert.\n  attr\n    Attributes for characters.\n\nInsert a character string (as many characters as will fit on the line)\nbefore the character under the cursor.  All characters to the right of\nthe cursor are shifted right, with the rightmost characters on the line\nbeing lost.  The cursor position does not change (after moving to y, x,\nif specified).",
    "_curses.window.is_linetouched" => "Return True if the specified line was modified, otherwise return False.\n\n  line\n    Line number.\n\nRaise a curses.error exception if line is not valid for the given window.",
    "_curses.window.noutrefresh" => "noutrefresh([pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol])\nMark for refresh but wait.\n\nThis function updates the data structure representing the desired state of the\nwindow, but does not force an update of the physical screen.  To accomplish\nthat, call doupdate().",
    "_curses.window.overlay" => "overlay(destwin, [sminrow, smincol, dminrow, dmincol, dmaxrow, dmaxcol])\nOverlay the window on top of destwin.\n\nThe windows need not be the same size, only the overlapping region is copied.\nThis copy is non-destructive, which means that the current background\ncharacter does not overwrite the old contents of destwin.\n\nTo get fine-grained control over the copied region, the second form of\noverlay() can be used.  sminrow and smincol are the upper-left coordinates\nof the source window, and the other variables mark a rectangle in the\ndestination window.",
    "_curses.window.overwrite" => "overwrite(destwin, [sminrow, smincol, dminrow, dmincol, dmaxrow,\n          dmaxcol])\nOverwrite the window on top of destwin.\n\nThe windows need not be the same size, in which case only the overlapping\nregion is copied.  This copy is destructive, which means that the current\nbackground character overwrites the old contents of destwin.\n\nTo get fine-grained control over the copied region, the second form of\noverwrite() can be used. sminrow and smincol are the upper-left coordinates\nof the source window, the other variables mark a rectangle in the destination\nwindow.",
    "_curses.window.putwin" => "Write all data associated with the window into the provided file object.\n\nThis information can be later retrieved using the getwin() function.",
    "_curses.window.redrawln" => "Mark the specified lines corrupted.\n\n  beg\n    Starting line number.\n  num\n    The number of lines.\n\nThey should be completely redrawn on the next refresh() call.",
    "_curses.window.refresh" => "refresh([pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol])\nUpdate the display immediately.\n\nSynchronize actual screen with previous drawing/deleting methods.\nThe 6 optional arguments can only be specified when the window is a pad\ncreated with newpad().  The additional parameters are needed to indicate\nwhat part of the pad and screen are involved.  pminrow and pmincol specify\nthe upper left-hand corner of the rectangle to be displayed in the pad.\nsminrow, smincol, smaxrow, and smaxcol specify the edges of the rectangle to\nbe displayed on the screen.  The lower right-hand corner of the rectangle to\nbe displayed in the pad is calculated from the screen coordinates, since the\nrectangles must be the same size.  Both rectangles must be entirely contained\nwithin their respective structures.  Negative values of pminrow, pmincol,\nsminrow, or smincol are treated as if they were zero.",
    "_curses.window.scroll" => "scroll([lines=1])\nScroll the screen or scrolling region.\n\n  lines\n    Number of lines to scroll.\n\nScroll upward if the argument is positive and downward if it is negative.",
    "_curses.window.setscrreg" => "Define a software scrolling region.\n\n  top\n    First line number.\n  bottom\n    Last line number.\n\nAll scrolling actions will take place in this region.",
    "_curses.window.subpad" => "subwin([nlines=0, ncols=0,] begin_y, begin_x)\nCreate a sub-window (screen-relative coordinates).\n\n  nlines\n    Height.\n  ncols\n    Width.\n  begin_y\n    Top side y-coordinate.\n  begin_x\n    Left side x-coordinate.\n\nBy default, the sub-window will extend from the specified position to the\nlower right corner of the window.",
    "_curses.window.subwin" => "subwin([nlines=0, ncols=0,] begin_y, begin_x)\nCreate a sub-window (screen-relative coordinates).\n\n  nlines\n    Height.\n  ncols\n    Width.\n  begin_y\n    Top side y-coordinate.\n  begin_x\n    Left side x-coordinate.\n\nBy default, the sub-window will extend from the specified position to the\nlower right corner of the window.",
    "_curses.window.touchline" => "touchline(start, count, [changed=True])\nPretend count lines have been changed, starting with line start.\n\nIf changed is supplied, it specifies whether the affected lines are marked\nas having been changed (changed=True) or unchanged (changed=False).",
    "_curses.window.vline" => "vline([y, x,] ch, n, [attr=_curses.A_NORMAL])\nDisplay a vertical line.\n\n  y\n    Starting Y-coordinate.\n  x\n    Starting X-coordinate.\n  ch\n    Character to draw.\n  n\n    Line length.\n  attr\n    Attributes for the character.",
    "_curses_panel.bottom_panel" => "Return the bottom panel in the panel stack.",
    "_curses_panel.error.__cause__" => "exception cause",
    "_curses_panel.error.__context__" => "exception context",
    "_curses_panel.error.__delattr__" => "Implement delattr(self, name).",
    "_curses_panel.error.__eq__" => "Return self==value.",
    "_curses_panel.error.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_curses_panel.error.__ge__" => "Return self>=value.",
    "_curses_panel.error.__getattribute__" => "Return getattr(self, name).",
    "_curses_panel.error.__getstate__" => "Helper for pickle.",
    "_curses_panel.error.__gt__" => "Return self>value.",
    "_curses_panel.error.__hash__" => "Return hash(self).",
    "_curses_panel.error.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_curses_panel.error.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_curses_panel.error.__le__" => "Return self<=value.",
    "_curses_panel.error.__lt__" => "Return self<value.",
    "_curses_panel.error.__ne__" => "Return self!=value.",
    "_curses_panel.error.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_curses_panel.error.__reduce_ex__" => "Helper for pickle.",
    "_curses_panel.error.__repr__" => "Return repr(self).",
    "_curses_panel.error.__setattr__" => "Implement setattr(self, name, value).",
    "_curses_panel.error.__sizeof__" => "Size of object in memory, in bytes.",
    "_curses_panel.error.__str__" => "Return str(self).",
    "_curses_panel.error.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_curses_panel.error.__weakref__" => "list of weak references to the object",
    "_curses_panel.error.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_curses_panel.error.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_curses_panel.new_panel" => "Return a panel object, associating it with the given window win.",
    "_curses_panel.panel.__delattr__" => "Implement delattr(self, name).",
    "_curses_panel.panel.__eq__" => "Return self==value.",
    "_curses_panel.panel.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_curses_panel.panel.__ge__" => "Return self>=value.",
    "_curses_panel.panel.__getattribute__" => "Return getattr(self, name).",
    "_curses_panel.panel.__getstate__" => "Helper for pickle.",
    "_curses_panel.panel.__gt__" => "Return self>value.",
    "_curses_panel.panel.__hash__" => "Return hash(self).",
    "_curses_panel.panel.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_curses_panel.panel.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_curses_panel.panel.__le__" => "Return self<=value.",
    "_curses_panel.panel.__lt__" => "Return self<value.",
    "_curses_panel.panel.__ne__" => "Return self!=value.",
    "_curses_panel.panel.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_curses_panel.panel.__reduce__" => "Helper for pickle.",
    "_curses_panel.panel.__reduce_ex__" => "Helper for pickle.",
    "_curses_panel.panel.__repr__" => "Return repr(self).",
    "_curses_panel.panel.__setattr__" => "Implement setattr(self, name, value).",
    "_curses_panel.panel.__sizeof__" => "Size of object in memory, in bytes.",
    "_curses_panel.panel.__str__" => "Return str(self).",
    "_curses_panel.panel.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_curses_panel.panel.above" => "Return the panel above the current panel.",
    "_curses_panel.panel.below" => "Return the panel below the current panel.",
    "_curses_panel.panel.bottom" => "Push the panel to the bottom of the stack.",
    "_curses_panel.panel.hidden" => "Return True if the panel is hidden (not visible), False otherwise.",
    "_curses_panel.panel.hide" => "Hide the panel.\n\nThis does not delete the object, it just makes the window on screen invisible.",
    "_curses_panel.panel.move" => "Move the panel to the screen coordinates (y, x).",
    "_curses_panel.panel.replace" => "Change the window associated with the panel to the window win.",
    "_curses_panel.panel.set_userptr" => "Set the panel's user pointer to obj.",
    "_curses_panel.panel.show" => "Display the panel (which might have been hidden).",
    "_curses_panel.panel.top" => "Push panel to the top of the stack.",
    "_curses_panel.panel.userptr" => "Return the user pointer for the panel.",
    "_curses_panel.panel.window" => "Return the window object associated with the panel.",
    "_curses_panel.top_panel" => "Return the top panel in the panel stack.",
    "_curses_panel.update_panels" => "Updates the virtual screen after changes in the panel stack.\n\nThis does not call curses.doupdate(), so you'll have to do this yourself.",
    "_datetime" => "Fast implementation of the datetime type.",
    "_dbm.error.__cause__" => "exception cause",
    "_dbm.error.__context__" => "exception context",
    "_dbm.error.__delattr__" => "Implement delattr(self, name).",
    "_dbm.error.__eq__" => "Return self==value.",
    "_dbm.error.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_dbm.error.__ge__" => "Return self>=value.",
    "_dbm.error.__getattribute__" => "Return getattr(self, name).",
    "_dbm.error.__getstate__" => "Helper for pickle.",
    "_dbm.error.__gt__" => "Return self>value.",
    "_dbm.error.__hash__" => "Return hash(self).",
    "_dbm.error.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_dbm.error.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_dbm.error.__le__" => "Return self<=value.",
    "_dbm.error.__lt__" => "Return self<value.",
    "_dbm.error.__ne__" => "Return self!=value.",
    "_dbm.error.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_dbm.error.__reduce_ex__" => "Helper for pickle.",
    "_dbm.error.__repr__" => "Return repr(self).",
    "_dbm.error.__setattr__" => "Implement setattr(self, name, value).",
    "_dbm.error.__sizeof__" => "Size of object in memory, in bytes.",
    "_dbm.error.__str__" => "Return str(self).",
    "_dbm.error.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_dbm.error.__weakref__" => "list of weak references to the object",
    "_dbm.error.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_dbm.error.errno" => "POSIX exception code",
    "_dbm.error.filename" => "exception filename",
    "_dbm.error.filename2" => "second exception filename",
    "_dbm.error.strerror" => "exception strerror",
    "_dbm.error.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_dbm.open" => "Return a database object.\n\nfilename\n  The filename to open.\nflags\n  How to open the file.  \"r\" for reading, \"w\" for writing, etc.\nmode\n  If creating a new file, the mode bits for the new file\n  (e.g. os.O_RDWR).",
    "_decimal" => "C decimal arithmetic module",
    "_decimal.getcontext" => "Get the current default context.",
    "_decimal.localcontext" => "Return a context manager that will set the default context to a copy of ctx\non entry to the with-statement and restore the previous default context when\nexiting the with-statement. If no context is specified, a copy of the current\ndefault context is used.",
    "_decimal.setcontext" => "Set a new default context.",
    "_elementtree._set_factories" => "Change the factories used to create comments and processing instructions.\n\nFor internal use only.",
    "_functools" => "Tools that operate on functions.",
    "_functools.cmp_to_key" => "Convert a cmp= function into a key= function.\n\nmycmp\n  Function that compares two objects.",
    "_functools.reduce" => "reduce(function, iterable[, initial], /) -> value\n\nApply a function of two arguments cumulatively to the items of an iterable, from left to right.\n\nThis effectively reduces the iterable to a single value.  If initial is present,\nit is placed before the items of the iterable in the calculation, and serves as\na default when the iterable is empty.\n\nFor example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])\ncalculates ((((1 + 2) + 3) + 4) + 5).",
    "_gdbm" => "This module provides an interface to the GNU DBM (GDBM) library.\n\nThis module is quite similar to the dbm module, but uses GDBM instead to\nprovide some additional functionality.  Please note that the file formats\ncreated by GDBM and dbm are incompatible.\n\nGDBM objects behave like mappings (dictionaries), except that keys and\nvalues are always immutable bytes-like objects or strings.  Printing\na GDBM object doesn't print the keys and values, and the items() and\nvalues() methods are not supported.",
    "_gdbm.error.__cause__" => "exception cause",
    "_gdbm.error.__context__" => "exception context",
    "_gdbm.error.__delattr__" => "Implement delattr(self, name).",
    "_gdbm.error.__eq__" => "Return self==value.",
    "_gdbm.error.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_gdbm.error.__ge__" => "Return self>=value.",
    "_gdbm.error.__getattribute__" => "Return getattr(self, name).",
    "_gdbm.error.__getstate__" => "Helper for pickle.",
    "_gdbm.error.__gt__" => "Return self>value.",
    "_gdbm.error.__hash__" => "Return hash(self).",
    "_gdbm.error.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_gdbm.error.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_gdbm.error.__le__" => "Return self<=value.",
    "_gdbm.error.__lt__" => "Return self<value.",
    "_gdbm.error.__ne__" => "Return self!=value.",
    "_gdbm.error.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_gdbm.error.__reduce_ex__" => "Helper for pickle.",
    "_gdbm.error.__repr__" => "Return repr(self).",
    "_gdbm.error.__setattr__" => "Implement setattr(self, name, value).",
    "_gdbm.error.__sizeof__" => "Size of object in memory, in bytes.",
    "_gdbm.error.__str__" => "Return str(self).",
    "_gdbm.error.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_gdbm.error.__weakref__" => "list of weak references to the object",
    "_gdbm.error.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_gdbm.error.errno" => "POSIX exception code",
    "_gdbm.error.filename" => "exception filename",
    "_gdbm.error.filename2" => "second exception filename",
    "_gdbm.error.strerror" => "exception strerror",
    "_gdbm.error.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_gdbm.open" => "Open a dbm database and return a dbm object.\n\nThe filename argument is the name of the database file.\n\nThe optional flags argument can be 'r' (to open an existing database\nfor reading only -- default), 'w' (to open an existing database for\nreading and writing), 'c' (which creates the database if it doesn't\nexist), or 'n' (which always creates a new empty database).\n\nSome versions of gdbm support additional flags which must be\nappended to one of the flags described above.  The module constant\n'open_flags' is a string of valid additional flags.  The 'f' flag\nopens the database in fast mode; altered data will not automatically\nbe written to the disk after every change.  This results in faster\nwrites to the database, but may result in an inconsistent database\nif the program crashes while the database is still open.  Use the\nsync() method to force any unwritten data to be written to the disk.\nThe 's' flag causes all database operations to be synchronized to\ndisk.  The 'u' flag disables locking of the database file.\n\nThe optional mode argument is the Unix mode of the file, used only\nwhen the database has to be created.  It defaults to octal 0o666.",
    "_hashlib" => "OpenSSL interface for hashlib module",
    "_hashlib.HASH" => "A hash is an object used to calculate a checksum of a string of information.\n\nMethods:\n\nupdate() -- updates the current digest with an additional string\ndigest() -- return the current digest value\nhexdigest() -- return the current digest as a string of hexadecimal digits\ncopy() -- return a copy of the current hash object\n\nAttributes:\n\nname -- the hash algorithm being used by this object\ndigest_size -- number of bytes in this hashes output",
    "_hashlib.HASH.__delattr__" => "Implement delattr(self, name).",
    "_hashlib.HASH.__eq__" => "Return self==value.",
    "_hashlib.HASH.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_hashlib.HASH.__ge__" => "Return self>=value.",
    "_hashlib.HASH.__getattribute__" => "Return getattr(self, name).",
    "_hashlib.HASH.__getstate__" => "Helper for pickle.",
    "_hashlib.HASH.__gt__" => "Return self>value.",
    "_hashlib.HASH.__hash__" => "Return hash(self).",
    "_hashlib.HASH.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_hashlib.HASH.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_hashlib.HASH.__le__" => "Return self<=value.",
    "_hashlib.HASH.__lt__" => "Return self<value.",
    "_hashlib.HASH.__ne__" => "Return self!=value.",
    "_hashlib.HASH.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_hashlib.HASH.__reduce__" => "Helper for pickle.",
    "_hashlib.HASH.__reduce_ex__" => "Helper for pickle.",
    "_hashlib.HASH.__repr__" => "Return repr(self).",
    "_hashlib.HASH.__setattr__" => "Implement setattr(self, name, value).",
    "_hashlib.HASH.__sizeof__" => "Size of object in memory, in bytes.",
    "_hashlib.HASH.__str__" => "Return str(self).",
    "_hashlib.HASH.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_hashlib.HASH.copy" => "Return a copy of the hash object.",
    "_hashlib.HASH.digest" => "Return the digest value as a bytes object.",
    "_hashlib.HASH.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_hashlib.HASH.update" => "Update this hash object's state with the provided string.",
    "_hashlib.HASHXOF" => "A hash is an object used to calculate a checksum of a string of information.\n\nMethods:\n\nupdate() -- updates the current digest with an additional string\ndigest(length) -- return the current digest value\nhexdigest(length) -- return the current digest as a string of hexadecimal digits\ncopy() -- return a copy of the current hash object\n\nAttributes:\n\nname -- the hash algorithm being used by this object\ndigest_size -- number of bytes in this hashes output",
    "_hashlib.HASHXOF.__delattr__" => "Implement delattr(self, name).",
    "_hashlib.HASHXOF.__eq__" => "Return self==value.",
    "_hashlib.HASHXOF.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_hashlib.HASHXOF.__ge__" => "Return self>=value.",
    "_hashlib.HASHXOF.__getattribute__" => "Return getattr(self, name).",
    "_hashlib.HASHXOF.__getstate__" => "Helper for pickle.",
    "_hashlib.HASHXOF.__gt__" => "Return self>value.",
    "_hashlib.HASHXOF.__hash__" => "Return hash(self).",
    "_hashlib.HASHXOF.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_hashlib.HASHXOF.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_hashlib.HASHXOF.__le__" => "Return self<=value.",
    "_hashlib.HASHXOF.__lt__" => "Return self<value.",
    "_hashlib.HASHXOF.__ne__" => "Return self!=value.",
    "_hashlib.HASHXOF.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_hashlib.HASHXOF.__reduce__" => "Helper for pickle.",
    "_hashlib.HASHXOF.__reduce_ex__" => "Helper for pickle.",
    "_hashlib.HASHXOF.__repr__" => "Return repr(self).",
    "_hashlib.HASHXOF.__setattr__" => "Implement setattr(self, name, value).",
    "_hashlib.HASHXOF.__sizeof__" => "Size of object in memory, in bytes.",
    "_hashlib.HASHXOF.__str__" => "Return str(self).",
    "_hashlib.HASHXOF.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_hashlib.HASHXOF.copy" => "Return a copy of the hash object.",
    "_hashlib.HASHXOF.digest" => "Return the digest value as a bytes object.",
    "_hashlib.HASHXOF.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_hashlib.HASHXOF.update" => "Update this hash object's state with the provided string.",
    "_hashlib.HMAC" => "The object used to calculate HMAC of a message.\n\nMethods:\n\nupdate() -- updates the current digest with an additional string\ndigest() -- return the current digest value\nhexdigest() -- return the current digest as a string of hexadecimal digits\ncopy() -- return a copy of the current hash object\n\nAttributes:\n\nname -- the name, including the hash algorithm used by this object\ndigest_size -- number of bytes in digest() output",
    "_hashlib.HMAC.__delattr__" => "Implement delattr(self, name).",
    "_hashlib.HMAC.__eq__" => "Return self==value.",
    "_hashlib.HMAC.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_hashlib.HMAC.__ge__" => "Return self>=value.",
    "_hashlib.HMAC.__getattribute__" => "Return getattr(self, name).",
    "_hashlib.HMAC.__getstate__" => "Helper for pickle.",
    "_hashlib.HMAC.__gt__" => "Return self>value.",
    "_hashlib.HMAC.__hash__" => "Return hash(self).",
    "_hashlib.HMAC.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_hashlib.HMAC.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_hashlib.HMAC.__le__" => "Return self<=value.",
    "_hashlib.HMAC.__lt__" => "Return self<value.",
    "_hashlib.HMAC.__ne__" => "Return self!=value.",
    "_hashlib.HMAC.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_hashlib.HMAC.__reduce__" => "Helper for pickle.",
    "_hashlib.HMAC.__reduce_ex__" => "Helper for pickle.",
    "_hashlib.HMAC.__repr__" => "Return repr(self).",
    "_hashlib.HMAC.__setattr__" => "Implement setattr(self, name, value).",
    "_hashlib.HMAC.__sizeof__" => "Size of object in memory, in bytes.",
    "_hashlib.HMAC.__str__" => "Return str(self).",
    "_hashlib.HMAC.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_hashlib.HMAC.copy" => "Return a copy (\"clone\") of the HMAC object.",
    "_hashlib.HMAC.digest" => "Return the digest of the bytes passed to the update() method so far.",
    "_hashlib.HMAC.hexdigest" => "Return hexadecimal digest of the bytes passed to the update() method so far.\n\nThis may be used to exchange the value safely in email or other non-binary\nenvironments.",
    "_hashlib.HMAC.update" => "Update the HMAC object with msg.",
    "_hashlib.UnsupportedDigestmodError.__cause__" => "exception cause",
    "_hashlib.UnsupportedDigestmodError.__context__" => "exception context",
    "_hashlib.UnsupportedDigestmodError.__delattr__" => "Implement delattr(self, name).",
    "_hashlib.UnsupportedDigestmodError.__eq__" => "Return self==value.",
    "_hashlib.UnsupportedDigestmodError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_hashlib.UnsupportedDigestmodError.__ge__" => "Return self>=value.",
    "_hashlib.UnsupportedDigestmodError.__getattribute__" => "Return getattr(self, name).",
    "_hashlib.UnsupportedDigestmodError.__getstate__" => "Helper for pickle.",
    "_hashlib.UnsupportedDigestmodError.__gt__" => "Return self>value.",
    "_hashlib.UnsupportedDigestmodError.__hash__" => "Return hash(self).",
    "_hashlib.UnsupportedDigestmodError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_hashlib.UnsupportedDigestmodError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_hashlib.UnsupportedDigestmodError.__le__" => "Return self<=value.",
    "_hashlib.UnsupportedDigestmodError.__lt__" => "Return self<value.",
    "_hashlib.UnsupportedDigestmodError.__ne__" => "Return self!=value.",
    "_hashlib.UnsupportedDigestmodError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_hashlib.UnsupportedDigestmodError.__reduce_ex__" => "Helper for pickle.",
    "_hashlib.UnsupportedDigestmodError.__repr__" => "Return repr(self).",
    "_hashlib.UnsupportedDigestmodError.__setattr__" => "Implement setattr(self, name, value).",
    "_hashlib.UnsupportedDigestmodError.__sizeof__" => "Size of object in memory, in bytes.",
    "_hashlib.UnsupportedDigestmodError.__str__" => "Return str(self).",
    "_hashlib.UnsupportedDigestmodError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_hashlib.UnsupportedDigestmodError.__weakref__" => "list of weak references to the object",
    "_hashlib.UnsupportedDigestmodError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_hashlib.UnsupportedDigestmodError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_hashlib.compare_digest" => "Return 'a == b'.\n\nThis function uses an approach designed to prevent\ntiming analysis, making it appropriate for cryptography.\n\na and b must both be of the same type: either str (ASCII only),\nor any bytes-like object.\n\nNote: If a and b are of different lengths, or if an error occurs,\na timing attack could theoretically reveal information about the\ntypes and lengths of a and b--but not their values.",
    "_hashlib.get_fips_mode" => "Determine the OpenSSL FIPS mode of operation.\n\nFor OpenSSL 3.0.0 and newer it returns the state of the default provider\nin the default OSSL context. It's not quite the same as FIPS_mode() but good\nenough for unittests.\n\nEffectively any non-zero return value indicates FIPS mode;\nvalues other than 1 may have additional significance.",
    "_hashlib.hmac_digest" => "Single-shot HMAC.",
    "_hashlib.hmac_new" => "Return a new hmac object.",
    "_hashlib.new" => "Return a new hash object using the named algorithm.\n\nAn optional string argument may be provided and will be\nautomatically hashed.\n\nThe MD5 and SHA1 algorithms are always supported.",
    "_hashlib.openssl_md5" => "Returns a md5 hash object; optionally initialized with a string",
    "_hashlib.openssl_sha1" => "Returns a sha1 hash object; optionally initialized with a string",
    "_hashlib.openssl_sha224" => "Returns a sha224 hash object; optionally initialized with a string",
    "_hashlib.openssl_sha256" => "Returns a sha256 hash object; optionally initialized with a string",
    "_hashlib.openssl_sha384" => "Returns a sha384 hash object; optionally initialized with a string",
    "_hashlib.openssl_sha3_224" => "Returns a sha3-224 hash object; optionally initialized with a string",
    "_hashlib.openssl_sha3_256" => "Returns a sha3-256 hash object; optionally initialized with a string",
    "_hashlib.openssl_sha3_384" => "Returns a sha3-384 hash object; optionally initialized with a string",
    "_hashlib.openssl_sha3_512" => "Returns a sha3-512 hash object; optionally initialized with a string",
    "_hashlib.openssl_sha512" => "Returns a sha512 hash object; optionally initialized with a string",
    "_hashlib.openssl_shake_128" => "Returns a shake-128 variable hash object; optionally initialized with a string",
    "_hashlib.openssl_shake_256" => "Returns a shake-256 variable hash object; optionally initialized with a string",
    "_hashlib.pbkdf2_hmac" => "Password based key derivation function 2 (PKCS #5 v2.0) with HMAC as pseudorandom function.",
    "_hashlib.scrypt" => "scrypt password-based key derivation function.",
    "_heapq" => "Heap queue algorithm (a.k.a. priority queue).\n\nHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\nall k, counting elements from 0.  For the sake of comparison,\nnon-existing elements are considered to be infinite.  The interesting\nproperty of a heap is that a[0] is always its smallest element.\n\nUsage:\n\nheap = []            # creates an empty heap\nheappush(heap, item) # pushes a new item on the heap\nitem = heappop(heap) # pops the smallest item from the heap\nitem = heap[0]       # smallest item on the heap without popping it\nheapify(x)           # transforms list into a heap, in-place, in linear time\nitem = heapreplace(heap, item) # pops and returns smallest item, and adds\n                               # new item; the heap size is unchanged\n\nOur API differs from textbook heap algorithms as follows:\n\n- We use 0-based indexing.  This makes the relationship between the\n  index for a node and the indexes for its children slightly less\n  obvious, but is more suitable since Python uses 0-based indexing.\n\n- Our heappop() method returns the smallest item, not the largest.\n\nThese two make it possible to view the heap as a regular Python list\nwithout surprises: heap[0] is the smallest item, and heap.sort()\nmaintains the heap invariant!",
    "_heapq._heapify_max" => "Maxheap variant of heapify.",
    "_heapq._heappop_max" => "Maxheap variant of heappop.",
    "_heapq._heapreplace_max" => "Maxheap variant of heapreplace.",
    "_heapq.heapify" => "Transform list into a heap, in-place, in O(len(heap)) time.",
    "_heapq.heappop" => "Pop the smallest item off the heap, maintaining the heap invariant.",
    "_heapq.heappush" => "Push item onto heap, maintaining the heap invariant.",
    "_heapq.heappushpop" => "Push item on the heap, then pop and return the smallest item from the heap.\n\nThe combined action runs more efficiently than heappush() followed by\na separate call to heappop().",
    "_heapq.heapreplace" => "Pop and return the current smallest value, and add the new item.\n\nThis is more efficient than heappop() followed by heappush(), and can be\nmore appropriate when using a fixed-size heap.  Note that the value\nreturned may be larger than item!  That constrains reasonable uses of\nthis routine unless written as part of a conditional replacement:\n\n    if item > heap[0]:\n        item = heapreplace(heap, item)",
    "_imp" => "(Extremely) low-level import machinery bits as used by importlib.",
    "_imp._fix_co_filename" => "Changes code.co_filename to specify the passed-in file path.\n\ncode\n  Code object to change.\npath\n  File path to use.",
    "_imp._frozen_module_names" => "Returns the list of available frozen modules.",
    "_imp._override_frozen_modules_for_tests" => "(internal-only) Override PyConfig.use_frozen_modules.\n\n(-1: \"off\", 1: \"on\", 0: no override)\nSee frozen_modules() in Lib/test/support/import_helper.py.",
    "_imp._override_multi_interp_extensions_check" => "(internal-only) Override PyInterpreterConfig.check_multi_interp_extensions.\n\n(-1: \"never\", 1: \"always\", 0: no override)",
    "_imp.acquire_lock" => "Acquires the interpreter's import lock for the current thread.\n\nThis lock should be used by import hooks to ensure thread-safety when importing\nmodules. On platforms without threads, this function does nothing.",
    "_imp.create_builtin" => "Create an extension module.",
    "_imp.create_dynamic" => "Create an extension module.",
    "_imp.exec_builtin" => "Initialize a built-in module.",
    "_imp.exec_dynamic" => "Initialize an extension module.",
    "_imp.extension_suffixes" => "Returns the list of file suffixes used to identify extension modules.",
    "_imp.find_frozen" => "Return info about the corresponding frozen module (if there is one) or None.\n\nThe returned info (a 2-tuple):\n\n * data         the raw marshalled bytes\n * is_package   whether or not it is a package\n * origname     the originally frozen module's name, or None if not\n                a stdlib module (this will usually be the same as\n                the module's current name)",
    "_imp.get_frozen_object" => "Create a code object for a frozen module.",
    "_imp.init_frozen" => "Initializes a frozen module.",
    "_imp.is_builtin" => "Returns True if the module name corresponds to a built-in module.",
    "_imp.is_frozen" => "Returns True if the module name corresponds to a frozen module.",
    "_imp.is_frozen_package" => "Returns True if the module name is of a frozen package.",
    "_imp.lock_held" => "Return True if the import lock is currently held, else False.\n\nOn platforms without threads, return False.",
    "_imp.release_lock" => "Release the interpreter's import lock.\n\nOn platforms without threads, this function does nothing.",
    "_interpchannels" => "This module provides primitive operations to manage Python interpreters.\nThe 'interpreters' module provides a more convenient interface.",
    "_interpchannels.ChannelClosedError.__cause__" => "exception cause",
    "_interpchannels.ChannelClosedError.__context__" => "exception context",
    "_interpchannels.ChannelClosedError.__delattr__" => "Implement delattr(self, name).",
    "_interpchannels.ChannelClosedError.__eq__" => "Return self==value.",
    "_interpchannels.ChannelClosedError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_interpchannels.ChannelClosedError.__ge__" => "Return self>=value.",
    "_interpchannels.ChannelClosedError.__getattribute__" => "Return getattr(self, name).",
    "_interpchannels.ChannelClosedError.__getstate__" => "Helper for pickle.",
    "_interpchannels.ChannelClosedError.__gt__" => "Return self>value.",
    "_interpchannels.ChannelClosedError.__hash__" => "Return hash(self).",
    "_interpchannels.ChannelClosedError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_interpchannels.ChannelClosedError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_interpchannels.ChannelClosedError.__le__" => "Return self<=value.",
    "_interpchannels.ChannelClosedError.__lt__" => "Return self<value.",
    "_interpchannels.ChannelClosedError.__ne__" => "Return self!=value.",
    "_interpchannels.ChannelClosedError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_interpchannels.ChannelClosedError.__reduce_ex__" => "Helper for pickle.",
    "_interpchannels.ChannelClosedError.__repr__" => "Return repr(self).",
    "_interpchannels.ChannelClosedError.__setattr__" => "Implement setattr(self, name, value).",
    "_interpchannels.ChannelClosedError.__sizeof__" => "Size of object in memory, in bytes.",
    "_interpchannels.ChannelClosedError.__str__" => "Return str(self).",
    "_interpchannels.ChannelClosedError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_interpchannels.ChannelClosedError.__weakref__" => "list of weak references to the object",
    "_interpchannels.ChannelClosedError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_interpchannels.ChannelClosedError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_interpchannels.ChannelEmptyError.__cause__" => "exception cause",
    "_interpchannels.ChannelEmptyError.__context__" => "exception context",
    "_interpchannels.ChannelEmptyError.__delattr__" => "Implement delattr(self, name).",
    "_interpchannels.ChannelEmptyError.__eq__" => "Return self==value.",
    "_interpchannels.ChannelEmptyError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_interpchannels.ChannelEmptyError.__ge__" => "Return self>=value.",
    "_interpchannels.ChannelEmptyError.__getattribute__" => "Return getattr(self, name).",
    "_interpchannels.ChannelEmptyError.__getstate__" => "Helper for pickle.",
    "_interpchannels.ChannelEmptyError.__gt__" => "Return self>value.",
    "_interpchannels.ChannelEmptyError.__hash__" => "Return hash(self).",
    "_interpchannels.ChannelEmptyError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_interpchannels.ChannelEmptyError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_interpchannels.ChannelEmptyError.__le__" => "Return self<=value.",
    "_interpchannels.ChannelEmptyError.__lt__" => "Return self<value.",
    "_interpchannels.ChannelEmptyError.__ne__" => "Return self!=value.",
    "_interpchannels.ChannelEmptyError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_interpchannels.ChannelEmptyError.__reduce_ex__" => "Helper for pickle.",
    "_interpchannels.ChannelEmptyError.__repr__" => "Return repr(self).",
    "_interpchannels.ChannelEmptyError.__setattr__" => "Implement setattr(self, name, value).",
    "_interpchannels.ChannelEmptyError.__sizeof__" => "Size of object in memory, in bytes.",
    "_interpchannels.ChannelEmptyError.__str__" => "Return str(self).",
    "_interpchannels.ChannelEmptyError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_interpchannels.ChannelEmptyError.__weakref__" => "list of weak references to the object",
    "_interpchannels.ChannelEmptyError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_interpchannels.ChannelEmptyError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_interpchannels.ChannelError.__cause__" => "exception cause",
    "_interpchannels.ChannelError.__context__" => "exception context",
    "_interpchannels.ChannelError.__delattr__" => "Implement delattr(self, name).",
    "_interpchannels.ChannelError.__eq__" => "Return self==value.",
    "_interpchannels.ChannelError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_interpchannels.ChannelError.__ge__" => "Return self>=value.",
    "_interpchannels.ChannelError.__getattribute__" => "Return getattr(self, name).",
    "_interpchannels.ChannelError.__getstate__" => "Helper for pickle.",
    "_interpchannels.ChannelError.__gt__" => "Return self>value.",
    "_interpchannels.ChannelError.__hash__" => "Return hash(self).",
    "_interpchannels.ChannelError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_interpchannels.ChannelError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_interpchannels.ChannelError.__le__" => "Return self<=value.",
    "_interpchannels.ChannelError.__lt__" => "Return self<value.",
    "_interpchannels.ChannelError.__ne__" => "Return self!=value.",
    "_interpchannels.ChannelError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_interpchannels.ChannelError.__reduce_ex__" => "Helper for pickle.",
    "_interpchannels.ChannelError.__repr__" => "Return repr(self).",
    "_interpchannels.ChannelError.__setattr__" => "Implement setattr(self, name, value).",
    "_interpchannels.ChannelError.__sizeof__" => "Size of object in memory, in bytes.",
    "_interpchannels.ChannelError.__str__" => "Return str(self).",
    "_interpchannels.ChannelError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_interpchannels.ChannelError.__weakref__" => "list of weak references to the object",
    "_interpchannels.ChannelError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_interpchannels.ChannelError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_interpchannels.ChannelID" => "A channel ID identifies a channel and may be used as an int.",
    "_interpchannels.ChannelID.__delattr__" => "Implement delattr(self, name).",
    "_interpchannels.ChannelID.__eq__" => "Return self==value.",
    "_interpchannels.ChannelID.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_interpchannels.ChannelID.__ge__" => "Return self>=value.",
    "_interpchannels.ChannelID.__getattribute__" => "Return getattr(self, name).",
    "_interpchannels.ChannelID.__getstate__" => "Helper for pickle.",
    "_interpchannels.ChannelID.__gt__" => "Return self>value.",
    "_interpchannels.ChannelID.__hash__" => "Return hash(self).",
    "_interpchannels.ChannelID.__index__" => "Return self converted to an integer, if self is suitable for use as an index into a list.",
    "_interpchannels.ChannelID.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_interpchannels.ChannelID.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_interpchannels.ChannelID.__int__" => "int(self)",
    "_interpchannels.ChannelID.__le__" => "Return self<=value.",
    "_interpchannels.ChannelID.__lt__" => "Return self<value.",
    "_interpchannels.ChannelID.__ne__" => "Return self!=value.",
    "_interpchannels.ChannelID.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_interpchannels.ChannelID.__reduce__" => "Helper for pickle.",
    "_interpchannels.ChannelID.__reduce_ex__" => "Helper for pickle.",
    "_interpchannels.ChannelID.__repr__" => "Return repr(self).",
    "_interpchannels.ChannelID.__setattr__" => "Implement setattr(self, name, value).",
    "_interpchannels.ChannelID.__sizeof__" => "Size of object in memory, in bytes.",
    "_interpchannels.ChannelID.__str__" => "Return str(self).",
    "_interpchannels.ChannelID.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_interpchannels.ChannelID.end" => "'send', 'recv', or 'both'",
    "_interpchannels.ChannelID.recv" => "the 'recv' end of the channel",
    "_interpchannels.ChannelID.send" => "the 'send' end of the channel",
    "_interpchannels.ChannelInfo" => "ChannelInfo\n\nA named tuple of a channel's state.",
    "_interpchannels.ChannelInfo.__add__" => "Return self+value.",
    "_interpchannels.ChannelInfo.__class_getitem__" => "See PEP 585",
    "_interpchannels.ChannelInfo.__contains__" => "Return bool(key in self).",
    "_interpchannels.ChannelInfo.__delattr__" => "Implement delattr(self, name).",
    "_interpchannels.ChannelInfo.__eq__" => "Return self==value.",
    "_interpchannels.ChannelInfo.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_interpchannels.ChannelInfo.__ge__" => "Return self>=value.",
    "_interpchannels.ChannelInfo.__getattribute__" => "Return getattr(self, name).",
    "_interpchannels.ChannelInfo.__getitem__" => "Return self[key].",
    "_interpchannels.ChannelInfo.__getstate__" => "Helper for pickle.",
    "_interpchannels.ChannelInfo.__gt__" => "Return self>value.",
    "_interpchannels.ChannelInfo.__hash__" => "Return hash(self).",
    "_interpchannels.ChannelInfo.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_interpchannels.ChannelInfo.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_interpchannels.ChannelInfo.__iter__" => "Implement iter(self).",
    "_interpchannels.ChannelInfo.__le__" => "Return self<=value.",
    "_interpchannels.ChannelInfo.__len__" => "Return len(self).",
    "_interpchannels.ChannelInfo.__lt__" => "Return self<value.",
    "_interpchannels.ChannelInfo.__mul__" => "Return self*value.",
    "_interpchannels.ChannelInfo.__ne__" => "Return self!=value.",
    "_interpchannels.ChannelInfo.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_interpchannels.ChannelInfo.__reduce_ex__" => "Helper for pickle.",
    "_interpchannels.ChannelInfo.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "_interpchannels.ChannelInfo.__repr__" => "Return repr(self).",
    "_interpchannels.ChannelInfo.__rmul__" => "Return value*self.",
    "_interpchannels.ChannelInfo.__setattr__" => "Implement setattr(self, name, value).",
    "_interpchannels.ChannelInfo.__sizeof__" => "Size of object in memory, in bytes.",
    "_interpchannels.ChannelInfo.__str__" => "Return str(self).",
    "_interpchannels.ChannelInfo.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_interpchannels.ChannelInfo.closed" => "both ends are closed",
    "_interpchannels.ChannelInfo.closing" => "send is closed, recv is non-empty",
    "_interpchannels.ChannelInfo.count" => "queued objects",
    "_interpchannels.ChannelInfo.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "_interpchannels.ChannelInfo.num_interp_both" => "interpreters bound to both ends",
    "_interpchannels.ChannelInfo.num_interp_both_recv_released" => "interpreters bound to both ends and released_from_the recv end",
    "_interpchannels.ChannelInfo.num_interp_both_released" => "interpreters bound to both ends and released_from_both",
    "_interpchannels.ChannelInfo.num_interp_both_send_released" => "interpreters bound to both ends and released_from_the send end",
    "_interpchannels.ChannelInfo.num_interp_recv" => "interpreters bound to the send end",
    "_interpchannels.ChannelInfo.num_interp_recv_released" => "interpreters bound to the send end and released",
    "_interpchannels.ChannelInfo.num_interp_send" => "interpreters bound to the send end",
    "_interpchannels.ChannelInfo.num_interp_send_released" => "interpreters bound to the send end and released",
    "_interpchannels.ChannelInfo.open" => "both ends are open",
    "_interpchannels.ChannelInfo.recv_associated" => "current interpreter is bound to the recv end",
    "_interpchannels.ChannelInfo.recv_released" => "current interpreter *was* bound to the recv end",
    "_interpchannels.ChannelInfo.send_associated" => "current interpreter is bound to the send end",
    "_interpchannels.ChannelInfo.send_released" => "current interpreter *was* bound to the send end",
    "_interpchannels.ChannelNotEmptyError.__cause__" => "exception cause",
    "_interpchannels.ChannelNotEmptyError.__context__" => "exception context",
    "_interpchannels.ChannelNotEmptyError.__delattr__" => "Implement delattr(self, name).",
    "_interpchannels.ChannelNotEmptyError.__eq__" => "Return self==value.",
    "_interpchannels.ChannelNotEmptyError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_interpchannels.ChannelNotEmptyError.__ge__" => "Return self>=value.",
    "_interpchannels.ChannelNotEmptyError.__getattribute__" => "Return getattr(self, name).",
    "_interpchannels.ChannelNotEmptyError.__getstate__" => "Helper for pickle.",
    "_interpchannels.ChannelNotEmptyError.__gt__" => "Return self>value.",
    "_interpchannels.ChannelNotEmptyError.__hash__" => "Return hash(self).",
    "_interpchannels.ChannelNotEmptyError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_interpchannels.ChannelNotEmptyError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_interpchannels.ChannelNotEmptyError.__le__" => "Return self<=value.",
    "_interpchannels.ChannelNotEmptyError.__lt__" => "Return self<value.",
    "_interpchannels.ChannelNotEmptyError.__ne__" => "Return self!=value.",
    "_interpchannels.ChannelNotEmptyError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_interpchannels.ChannelNotEmptyError.__reduce_ex__" => "Helper for pickle.",
    "_interpchannels.ChannelNotEmptyError.__repr__" => "Return repr(self).",
    "_interpchannels.ChannelNotEmptyError.__setattr__" => "Implement setattr(self, name, value).",
    "_interpchannels.ChannelNotEmptyError.__sizeof__" => "Size of object in memory, in bytes.",
    "_interpchannels.ChannelNotEmptyError.__str__" => "Return str(self).",
    "_interpchannels.ChannelNotEmptyError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_interpchannels.ChannelNotEmptyError.__weakref__" => "list of weak references to the object",
    "_interpchannels.ChannelNotEmptyError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_interpchannels.ChannelNotEmptyError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_interpchannels.ChannelNotFoundError.__cause__" => "exception cause",
    "_interpchannels.ChannelNotFoundError.__context__" => "exception context",
    "_interpchannels.ChannelNotFoundError.__delattr__" => "Implement delattr(self, name).",
    "_interpchannels.ChannelNotFoundError.__eq__" => "Return self==value.",
    "_interpchannels.ChannelNotFoundError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_interpchannels.ChannelNotFoundError.__ge__" => "Return self>=value.",
    "_interpchannels.ChannelNotFoundError.__getattribute__" => "Return getattr(self, name).",
    "_interpchannels.ChannelNotFoundError.__getstate__" => "Helper for pickle.",
    "_interpchannels.ChannelNotFoundError.__gt__" => "Return self>value.",
    "_interpchannels.ChannelNotFoundError.__hash__" => "Return hash(self).",
    "_interpchannels.ChannelNotFoundError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_interpchannels.ChannelNotFoundError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_interpchannels.ChannelNotFoundError.__le__" => "Return self<=value.",
    "_interpchannels.ChannelNotFoundError.__lt__" => "Return self<value.",
    "_interpchannels.ChannelNotFoundError.__ne__" => "Return self!=value.",
    "_interpchannels.ChannelNotFoundError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_interpchannels.ChannelNotFoundError.__reduce_ex__" => "Helper for pickle.",
    "_interpchannels.ChannelNotFoundError.__repr__" => "Return repr(self).",
    "_interpchannels.ChannelNotFoundError.__setattr__" => "Implement setattr(self, name, value).",
    "_interpchannels.ChannelNotFoundError.__sizeof__" => "Size of object in memory, in bytes.",
    "_interpchannels.ChannelNotFoundError.__str__" => "Return str(self).",
    "_interpchannels.ChannelNotFoundError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_interpchannels.ChannelNotFoundError.__weakref__" => "list of weak references to the object",
    "_interpchannels.ChannelNotFoundError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_interpchannels.ChannelNotFoundError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_interpchannels.close" => "channel_close(cid, *, send=None, recv=None, force=False)\n\nClose the channel for all interpreters.\n\nIf the channel is empty then the keyword args are ignored and both\nends are immediately closed.  Otherwise, if 'force' is True then\nall queued items are released and both ends are immediately\nclosed.\n\nIf the channel is not empty *and* 'force' is False then following\nhappens:\n\n * recv is True (regardless of send):\n   - raise ChannelNotEmptyError\n * recv is None and send is None:\n   - raise ChannelNotEmptyError\n * send is True and recv is not True:\n   - fully close the 'send' end\n   - close the 'recv' end to interpreters not already receiving\n   - fully close it once empty\n\nClosing an already closed channel results in a ChannelClosedError.\n\nOnce the channel's ID has no more ref counts in any interpreter\nthe channel will be destroyed.",
    "_interpchannels.create" => "channel_create(unboundop) -> cid\n\nCreate a new cross-interpreter channel and return a unique generated ID.",
    "_interpchannels.destroy" => "channel_destroy(cid)\n\nClose and finalize the channel.  Afterward attempts to use the channel\nwill behave as though it never existed.",
    "_interpchannels.get_channel_defaults" => "get_channel_defaults(cid)\n\nReturn the channel's default values, set when it was created.",
    "_interpchannels.get_count" => "get_count(cid)\n\nReturn the number of items in the channel.",
    "_interpchannels.get_info" => "get_info(cid)\n\nReturn details about the channel.",
    "_interpchannels.list_all" => "channel_list_all() -> [cid]\n\nReturn the list of all IDs for active channels.",
    "_interpchannels.list_interpreters" => "channel_list_interpreters(cid, *, send) -> [id]\n\nReturn the list of all interpreter IDs associated with an end of the channel.\n\nThe 'send' argument should be a boolean indicating whether to use the send or\nreceive end.",
    "_interpchannels.recv" => "channel_recv(cid, [default]) -> (obj, unboundop)\n\nReturn a new object from the data at the front of the channel's queue.\n\nIf there is nothing to receive then raise ChannelEmptyError, unless\na default value is provided.  In that case return it.",
    "_interpchannels.release" => "channel_release(cid, *, send=None, recv=None, force=True)\n\nClose the channel for the current interpreter.  'send' and 'recv'\n(bool) may be used to indicate the ends to close.  By default both\nends are closed.  Closing an already closed end is a noop.",
    "_interpchannels.send" => "channel_send(cid, obj, *, blocking=True, timeout=None)\n\nAdd the object's data to the channel's queue.\nBy default this waits for the object to be received.",
    "_interpchannels.send_buffer" => "channel_send_buffer(cid, obj, *, blocking=True, timeout=None)\n\nAdd the object's buffer to the channel's queue.\nBy default this waits for the object to be received.",
    "_interpqueues" => "This module provides primitive operations to manage Python interpreters.\nThe 'interpreters' module provides a more convenient interface.",
    "_interpqueues.bind" => "bind(qid)\n\nTake a reference to the identified queue.\nThe queue is not destroyed until there are no references left.",
    "_interpqueues.create" => "create(maxsize, fmt, unboundop) -> qid\n\nCreate a new cross-interpreter queue and return its unique generated ID.\nIt is a new reference as though bind() had been called on the queue.\n\nThe caller is responsible for calling destroy() for the new queue\nbefore the runtime is finalized.",
    "_interpqueues.destroy" => "destroy(qid)\n\nClear and destroy the queue.  Afterward attempts to use the queue\nwill behave as though it never existed.",
    "_interpqueues.get" => "get(qid) -> (obj, fmt)\n\nReturn a new object from the data at the front of the queue.\nThe object's format is also returned.\n\nIf there is nothing to receive then raise QueueEmpty.",
    "_interpqueues.get_count" => "get_count(qid)\n\nReturn the number of items in the queue.",
    "_interpqueues.get_maxsize" => "get_maxsize(qid)\n\nReturn the maximum number of items in the queue.",
    "_interpqueues.get_queue_defaults" => "get_queue_defaults(qid)\n\nReturn the queue's default values, set when it was created.",
    "_interpqueues.is_full" => "is_full(qid)\n\nReturn true if the queue has a maxsize and has reached it.",
    "_interpqueues.list_all" => "list_all() -> [(qid, fmt)]\n\nReturn the list of IDs for all queues.\nEach corresponding default format is also included.",
    "_interpqueues.put" => "put(qid, obj, fmt)\n\nAdd the object's data to the queue.",
    "_interpqueues.release" => "release(qid)\n\nRelease a reference to the queue.\nThe queue is destroyed once there are no references left.",
    "_interpreters" => "This module provides primitive operations to manage Python interpreters.\nThe 'interpreters' module provides a more convenient interface.",
    "_interpreters.CrossInterpreterBufferView.__buffer__" => "Return a buffer object that exposes the underlying memory of the object.",
    "_interpreters.CrossInterpreterBufferView.__delattr__" => "Implement delattr(self, name).",
    "_interpreters.CrossInterpreterBufferView.__eq__" => "Return self==value.",
    "_interpreters.CrossInterpreterBufferView.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_interpreters.CrossInterpreterBufferView.__ge__" => "Return self>=value.",
    "_interpreters.CrossInterpreterBufferView.__getattribute__" => "Return getattr(self, name).",
    "_interpreters.CrossInterpreterBufferView.__getstate__" => "Helper for pickle.",
    "_interpreters.CrossInterpreterBufferView.__gt__" => "Return self>value.",
    "_interpreters.CrossInterpreterBufferView.__hash__" => "Return hash(self).",
    "_interpreters.CrossInterpreterBufferView.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_interpreters.CrossInterpreterBufferView.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_interpreters.CrossInterpreterBufferView.__le__" => "Return self<=value.",
    "_interpreters.CrossInterpreterBufferView.__lt__" => "Return self<value.",
    "_interpreters.CrossInterpreterBufferView.__ne__" => "Return self!=value.",
    "_interpreters.CrossInterpreterBufferView.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_interpreters.CrossInterpreterBufferView.__reduce__" => "Helper for pickle.",
    "_interpreters.CrossInterpreterBufferView.__reduce_ex__" => "Helper for pickle.",
    "_interpreters.CrossInterpreterBufferView.__repr__" => "Return repr(self).",
    "_interpreters.CrossInterpreterBufferView.__setattr__" => "Implement setattr(self, name, value).",
    "_interpreters.CrossInterpreterBufferView.__sizeof__" => "Size of object in memory, in bytes.",
    "_interpreters.CrossInterpreterBufferView.__str__" => "Return str(self).",
    "_interpreters.CrossInterpreterBufferView.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_interpreters.call" => "call(id, callable, args=None, kwargs=None, *, restrict=False)\n\nCall the provided object in the identified interpreter.\nPass the given args and kwargs, if possible.\n\n\"callable\" may be a plain function with no free vars that takes\nno arguments.\n\nThe function's code object is used and all its state\nis ignored, including its __globals__ dict.",
    "_interpreters.capture_exception" => "capture_exception(exc=None) -> types.SimpleNamespace\n\nReturn a snapshot of an exception.  If \"exc\" is None\nthen the current exception, if any, is used (but not cleared).\n\nThe returned snapshot is the same as what _interpreters.exec() returns.",
    "_interpreters.create" => "create([config], *, reqrefs=False) -> ID\n\nCreate a new interpreter and return a unique generated ID.\n\nThe caller is responsible for destroying the interpreter before exiting,\ntypically by using _interpreters.destroy().  This can be managed \nautomatically by passing \"reqrefs=True\" and then using _incref() and\n_decref()` appropriately.\n\n\"config\" must be a valid interpreter config or the name of a\npredefined config (\"isolated\" or \"legacy\").  The default\nis \"isolated\".",
    "_interpreters.destroy" => "destroy(id, *, restrict=False)\n\nDestroy the identified interpreter.\n\nAttempting to destroy the current interpreter raises InterpreterError.\nSo does an unrecognized ID.",
    "_interpreters.exec" => "exec(id, code, shared=None, *, restrict=False)\n\nExecute the provided code in the identified interpreter.\nThis is equivalent to running the builtin exec() under the target\ninterpreter, using the __dict__ of its __main__ module as both\nglobals and locals.\n\n\"code\" may be a string containing the text of a Python script.\n\nFunctions (and code objects) are also supported, with some restrictions.\nThe code/function must not take any arguments or be a closure\n(i.e. have cell vars).  Methods and other callables are not supported.\n\nIf a function is provided, its code object is used and all its state\nis ignored, including its __globals__ dict.",
    "_interpreters.get_config" => "get_config(id, *, restrict=False) -> types.SimpleNamespace\n\nReturn a representation of the config used to initialize the interpreter.",
    "_interpreters.get_current" => "get_current() -> (ID, whence)\n\nReturn the ID of current interpreter.",
    "_interpreters.get_main" => "get_main() -> (ID, whence)\n\nReturn the ID of main interpreter.",
    "_interpreters.is_running" => "is_running(id, *, restrict=False) -> bool\n\nReturn whether or not the identified interpreter is running.",
    "_interpreters.is_shareable" => "is_shareable(obj) -> bool\n\nReturn True if the object's data may be shared between interpreters and\nFalse otherwise.",
    "_interpreters.list_all" => "list_all() -> [(ID, whence)]\n\nReturn a list containing the ID of every existing interpreter.",
    "_interpreters.new_config" => "new_config(name='isolated', /, **overrides) -> type.SimpleNamespace\n\nReturn a representation of a new PyInterpreterConfig.\n\nThe name determines the initial values of the config.  Supported named\nconfigs are: default, isolated, legacy, and empty.\n\nAny keyword arguments are set on the corresponding config fields,\noverriding the initial values.",
    "_interpreters.run_func" => "run_func(id, func, shared=None, *, restrict=False)\n\nExecute the body of the provided function in the identified interpreter.\nCode objects are also supported.  In both cases, closures and args\nare not supported.  Methods and other callables are not supported either.\n\n(See _interpreters.exec().",
    "_interpreters.run_string" => "run_string(id, script, shared=None, *, restrict=False)\n\nExecute the provided string in the identified interpreter.\n\n(See _interpreters.exec().",
    "_interpreters.set___main___attrs" => "set___main___attrs(id, ns, *, restrict=False)\n\nBind the given attributes in the interpreter's __main__ module.",
    "_interpreters.whence" => "whence(id) -> int\n\nReturn an identifier for where the interpreter was created.",
    "_io" => "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to raise an OSError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis an in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.",
    "_io.BufferedRWPair" => "A buffered reader and writer object together.\n\nA buffered reader object and buffered writer object put together to\nform a sequential IO object that can read and write. This is typically\nused with a socket or two-way pipe.\n\nreader and writer are RawIOBase objects that are readable and\nwriteable respectively. If the buffer_size is omitted it defaults to\nDEFAULT_BUFFER_SIZE.",
    "_io.BufferedRWPair.__del__" => "Called when the instance is about to be destroyed.",
    "_io.BufferedRWPair.__delattr__" => "Implement delattr(self, name).",
    "_io.BufferedRWPair.__eq__" => "Return self==value.",
    "_io.BufferedRWPair.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io.BufferedRWPair.__ge__" => "Return self>=value.",
    "_io.BufferedRWPair.__getattribute__" => "Return getattr(self, name).",
    "_io.BufferedRWPair.__getstate__" => "Helper for pickle.",
    "_io.BufferedRWPair.__gt__" => "Return self>value.",
    "_io.BufferedRWPair.__hash__" => "Return hash(self).",
    "_io.BufferedRWPair.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io.BufferedRWPair.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io.BufferedRWPair.__iter__" => "Implement iter(self).",
    "_io.BufferedRWPair.__le__" => "Return self<=value.",
    "_io.BufferedRWPair.__lt__" => "Return self<value.",
    "_io.BufferedRWPair.__ne__" => "Return self!=value.",
    "_io.BufferedRWPair.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io.BufferedRWPair.__next__" => "Implement next(self).",
    "_io.BufferedRWPair.__reduce__" => "Helper for pickle.",
    "_io.BufferedRWPair.__reduce_ex__" => "Helper for pickle.",
    "_io.BufferedRWPair.__repr__" => "Return repr(self).",
    "_io.BufferedRWPair.__setattr__" => "Implement setattr(self, name, value).",
    "_io.BufferedRWPair.__sizeof__" => "Size of object in memory, in bytes.",
    "_io.BufferedRWPair.__str__" => "Return str(self).",
    "_io.BufferedRWPair.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io.BufferedRWPair.detach" => "Disconnect this buffer from its underlying raw stream and return it.\n\nAfter the raw stream has been detached, the buffer is in an unusable\nstate.",
    "_io.BufferedRWPair.fileno" => "Return underlying file descriptor if one exists.\n\nRaise OSError if the IO object does not use a file descriptor.",
    "_io.BufferedRWPair.readline" => "Read and return a line from the stream.\n\nIf size is specified, at most size bytes will be read.\n\nThe line terminator is always b'\\n' for binary files; for text\nfiles, the newlines argument to open can be used to select the line\nterminator(s) recognized.",
    "_io.BufferedRWPair.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io.BufferedRWPair.seek" => "Change the stream position to the given byte offset.\n\n  offset\n    The stream position, relative to 'whence'.\n  whence\n    The relative position to seek from.\n\nThe offset is interpreted relative to the position indicated by whence.\nValues for whence are:\n\n* os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n* os.SEEK_CUR or 1 -- current stream position; offset may be negative\n* os.SEEK_END or 2 -- end of stream; offset is usually negative\n\nReturn the new absolute position.",
    "_io.BufferedRWPair.seekable" => "Return whether object supports random access.\n\nIf False, seek(), tell() and truncate() will raise OSError.\nThis method may need to do a test seek().",
    "_io.BufferedRWPair.tell" => "Return current stream position.",
    "_io.BufferedRWPair.truncate" => "Truncate file to size bytes.\n\nFile pointer is left unchanged. Size defaults to the current IO position\nas reported by tell(). Return the new size.",
    "_io.BufferedRWPair.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io.BufferedRandom" => "A buffered interface to random access streams.\n\nThe constructor creates a reader and writer for a seekable stream,\nraw, given in the first argument. If the buffer_size is omitted it\ndefaults to DEFAULT_BUFFER_SIZE.",
    "_io.BufferedRandom.__del__" => "Called when the instance is about to be destroyed.",
    "_io.BufferedRandom.__delattr__" => "Implement delattr(self, name).",
    "_io.BufferedRandom.__eq__" => "Return self==value.",
    "_io.BufferedRandom.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io.BufferedRandom.__ge__" => "Return self>=value.",
    "_io.BufferedRandom.__getattribute__" => "Return getattr(self, name).",
    "_io.BufferedRandom.__gt__" => "Return self>value.",
    "_io.BufferedRandom.__hash__" => "Return hash(self).",
    "_io.BufferedRandom.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io.BufferedRandom.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io.BufferedRandom.__iter__" => "Implement iter(self).",
    "_io.BufferedRandom.__le__" => "Return self<=value.",
    "_io.BufferedRandom.__lt__" => "Return self<value.",
    "_io.BufferedRandom.__ne__" => "Return self!=value.",
    "_io.BufferedRandom.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io.BufferedRandom.__next__" => "Implement next(self).",
    "_io.BufferedRandom.__reduce__" => "Helper for pickle.",
    "_io.BufferedRandom.__reduce_ex__" => "Helper for pickle.",
    "_io.BufferedRandom.__repr__" => "Return repr(self).",
    "_io.BufferedRandom.__setattr__" => "Implement setattr(self, name, value).",
    "_io.BufferedRandom.__str__" => "Return str(self).",
    "_io.BufferedRandom.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io.BufferedRandom.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io.BufferedRandom.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io.BufferedReader" => "Create a new buffered reader using the given readable raw IO object.",
    "_io.BufferedReader.__del__" => "Called when the instance is about to be destroyed.",
    "_io.BufferedReader.__delattr__" => "Implement delattr(self, name).",
    "_io.BufferedReader.__eq__" => "Return self==value.",
    "_io.BufferedReader.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io.BufferedReader.__ge__" => "Return self>=value.",
    "_io.BufferedReader.__getattribute__" => "Return getattr(self, name).",
    "_io.BufferedReader.__gt__" => "Return self>value.",
    "_io.BufferedReader.__hash__" => "Return hash(self).",
    "_io.BufferedReader.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io.BufferedReader.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io.BufferedReader.__iter__" => "Implement iter(self).",
    "_io.BufferedReader.__le__" => "Return self<=value.",
    "_io.BufferedReader.__lt__" => "Return self<value.",
    "_io.BufferedReader.__ne__" => "Return self!=value.",
    "_io.BufferedReader.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io.BufferedReader.__next__" => "Implement next(self).",
    "_io.BufferedReader.__reduce__" => "Helper for pickle.",
    "_io.BufferedReader.__reduce_ex__" => "Helper for pickle.",
    "_io.BufferedReader.__repr__" => "Return repr(self).",
    "_io.BufferedReader.__setattr__" => "Implement setattr(self, name, value).",
    "_io.BufferedReader.__str__" => "Return str(self).",
    "_io.BufferedReader.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io.BufferedReader.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io.BufferedReader.writable" => "Return whether object was opened for writing.\n\nIf False, write() will raise OSError.",
    "_io.BufferedReader.write" => "Write buffer b to the IO stream.\n\nReturn the number of bytes written, which is always\nthe length of b in bytes.\n\nRaise BlockingIOError if the buffer is full and the\nunderlying raw stream cannot accept more data at the moment.",
    "_io.BufferedReader.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io.BufferedWriter" => "A buffer for a writeable sequential RawIO object.\n\nThe constructor creates a BufferedWriter for the given writeable raw\nstream. If the buffer_size is not given, it defaults to\nDEFAULT_BUFFER_SIZE.",
    "_io.BufferedWriter.__del__" => "Called when the instance is about to be destroyed.",
    "_io.BufferedWriter.__delattr__" => "Implement delattr(self, name).",
    "_io.BufferedWriter.__eq__" => "Return self==value.",
    "_io.BufferedWriter.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io.BufferedWriter.__ge__" => "Return self>=value.",
    "_io.BufferedWriter.__getattribute__" => "Return getattr(self, name).",
    "_io.BufferedWriter.__gt__" => "Return self>value.",
    "_io.BufferedWriter.__hash__" => "Return hash(self).",
    "_io.BufferedWriter.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io.BufferedWriter.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io.BufferedWriter.__iter__" => "Implement iter(self).",
    "_io.BufferedWriter.__le__" => "Return self<=value.",
    "_io.BufferedWriter.__lt__" => "Return self<value.",
    "_io.BufferedWriter.__ne__" => "Return self!=value.",
    "_io.BufferedWriter.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io.BufferedWriter.__next__" => "Implement next(self).",
    "_io.BufferedWriter.__reduce__" => "Helper for pickle.",
    "_io.BufferedWriter.__reduce_ex__" => "Helper for pickle.",
    "_io.BufferedWriter.__repr__" => "Return repr(self).",
    "_io.BufferedWriter.__setattr__" => "Implement setattr(self, name, value).",
    "_io.BufferedWriter.__str__" => "Return str(self).",
    "_io.BufferedWriter.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io.BufferedWriter.read" => "Read and return up to n bytes.\n\nIf the size argument is omitted, None, or negative, read and\nreturn all data until EOF.\n\nIf the size argument is positive, and the underlying raw stream is\nnot 'interactive', multiple raw reads may be issued to satisfy\nthe byte count (unless EOF is reached first).\nHowever, for interactive raw streams (as well as sockets and pipes),\nat most one raw read will be issued, and a short result does not\nimply that EOF is imminent.\n\nReturn an empty bytes object on EOF.\n\nReturn None if the underlying raw stream was open in non-blocking\nmode and no data is available at the moment.",
    "_io.BufferedWriter.read1" => "Read and return up to size bytes, with at most one read() call to the underlying raw stream.\n\nReturn an empty bytes object on EOF.\nA short result does not imply that EOF is imminent.",
    "_io.BufferedWriter.readable" => "Return whether object was opened for reading.\n\nIf False, read() will raise OSError.",
    "_io.BufferedWriter.readline" => "Read and return a line from the stream.\n\nIf size is specified, at most size bytes will be read.\n\nThe line terminator is always b'\\n' for binary files; for text\nfiles, the newlines argument to open can be used to select the line\nterminator(s) recognized.",
    "_io.BufferedWriter.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io.BufferedWriter.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io.BytesIO" => "Buffered I/O implementation using an in-memory bytes buffer.",
    "_io.BytesIO.__del__" => "Called when the instance is about to be destroyed.",
    "_io.BytesIO.__delattr__" => "Implement delattr(self, name).",
    "_io.BytesIO.__eq__" => "Return self==value.",
    "_io.BytesIO.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io.BytesIO.__ge__" => "Return self>=value.",
    "_io.BytesIO.__getattribute__" => "Return getattr(self, name).",
    "_io.BytesIO.__gt__" => "Return self>value.",
    "_io.BytesIO.__hash__" => "Return hash(self).",
    "_io.BytesIO.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io.BytesIO.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io.BytesIO.__iter__" => "Implement iter(self).",
    "_io.BytesIO.__le__" => "Return self<=value.",
    "_io.BytesIO.__lt__" => "Return self<value.",
    "_io.BytesIO.__ne__" => "Return self!=value.",
    "_io.BytesIO.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io.BytesIO.__next__" => "Implement next(self).",
    "_io.BytesIO.__reduce__" => "Helper for pickle.",
    "_io.BytesIO.__reduce_ex__" => "Helper for pickle.",
    "_io.BytesIO.__repr__" => "Return repr(self).",
    "_io.BytesIO.__setattr__" => "Implement setattr(self, name, value).",
    "_io.BytesIO.__str__" => "Return str(self).",
    "_io.BytesIO.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io.BytesIO.close" => "Disable all I/O operations.",
    "_io.BytesIO.closed" => "True if the file is closed.",
    "_io.BytesIO.detach" => "Disconnect this buffer from its underlying raw stream and return it.\n\nAfter the raw stream has been detached, the buffer is in an unusable\nstate.",
    "_io.BytesIO.fileno" => "Return underlying file descriptor if one exists.\n\nRaise OSError if the IO object does not use a file descriptor.",
    "_io.BytesIO.flush" => "Does nothing.",
    "_io.BytesIO.getbuffer" => "Get a read-write view over the contents of the BytesIO object.",
    "_io.BytesIO.getvalue" => "Retrieve the entire contents of the BytesIO object.",
    "_io.BytesIO.isatty" => "Always returns False.\n\nBytesIO objects are not connected to a TTY-like device.",
    "_io.BytesIO.read" => "Read at most size bytes, returned as a bytes object.\n\nIf the size argument is negative, read until EOF is reached.\nReturn an empty bytes object at EOF.",
    "_io.BytesIO.read1" => "Read at most size bytes, returned as a bytes object.\n\nIf the size argument is negative or omitted, read until EOF is reached.\nReturn an empty bytes object at EOF.",
    "_io.BytesIO.readable" => "Returns True if the IO object can be read.",
    "_io.BytesIO.readinto" => "Read bytes into buffer.\n\nReturns number of bytes read (0 for EOF), or None if the object\nis set not to block and has no data to read.",
    "_io.BytesIO.readline" => "Next line from the file, as a bytes object.\n\nRetain newline.  A non-negative size argument limits the maximum\nnumber of bytes to return (an incomplete line may be returned then).\nReturn an empty bytes object at EOF.",
    "_io.BytesIO.readlines" => "List of bytes objects, each a line from the file.\n\nCall readline() repeatedly and return a list of the lines so read.\nThe optional size argument, if given, is an approximate bound on the\ntotal number of bytes in the lines returned.",
    "_io.BytesIO.seek" => "Change stream position.\n\nSeek to byte offset pos relative to position indicated by whence:\n     0  Start of stream (the default).  pos should be >= 0;\n     1  Current position - pos may be negative;\n     2  End of stream - pos usually negative.\nReturns the new absolute position.",
    "_io.BytesIO.seekable" => "Returns True if the IO object can be seeked.",
    "_io.BytesIO.tell" => "Current file position, an integer.",
    "_io.BytesIO.truncate" => "Truncate the file to at most size bytes.\n\nSize defaults to the current file position, as returned by tell().\nThe current file position is unchanged.  Returns the new size.",
    "_io.BytesIO.writable" => "Returns True if the IO object can be written.",
    "_io.BytesIO.write" => "Write bytes to file.\n\nReturn the number of bytes written.",
    "_io.BytesIO.writelines" => "Write lines to the file.\n\nNote that newlines are not added.  lines can be any iterable object\nproducing bytes-like objects. This is equivalent to calling write() for\neach element.",
    "_io.FileIO" => "Open a file.\n\nThe mode can be 'r' (default), 'w', 'x' or 'a' for reading,\nwriting, exclusive creation or appending.  The file will be created if it\ndoesn't exist when opened for writing or appending; it will be truncated\nwhen opened for writing.  A FileExistsError will be raised if it already\nexists when opened for creating. Opening a file for creating implies\nwriting so this mode behaves in a similar way to 'w'.Add a '+' to the mode\nto allow simultaneous reading and writing. A custom opener can be used by\npassing a callable as *opener*. The underlying file descriptor for the file\nobject is then obtained by calling opener with (*name*, *flags*).\n*opener* must return an open file descriptor (passing os.open as *opener*\nresults in functionality similar to passing None).",
    "_io.FileIO.__del__" => "Called when the instance is about to be destroyed.",
    "_io.FileIO.__delattr__" => "Implement delattr(self, name).",
    "_io.FileIO.__eq__" => "Return self==value.",
    "_io.FileIO.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io.FileIO.__ge__" => "Return self>=value.",
    "_io.FileIO.__getattribute__" => "Return getattr(self, name).",
    "_io.FileIO.__gt__" => "Return self>value.",
    "_io.FileIO.__hash__" => "Return hash(self).",
    "_io.FileIO.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io.FileIO.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io.FileIO.__iter__" => "Implement iter(self).",
    "_io.FileIO.__le__" => "Return self<=value.",
    "_io.FileIO.__lt__" => "Return self<value.",
    "_io.FileIO.__ne__" => "Return self!=value.",
    "_io.FileIO.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io.FileIO.__next__" => "Implement next(self).",
    "_io.FileIO.__reduce__" => "Helper for pickle.",
    "_io.FileIO.__reduce_ex__" => "Helper for pickle.",
    "_io.FileIO.__repr__" => "Return repr(self).",
    "_io.FileIO.__setattr__" => "Implement setattr(self, name, value).",
    "_io.FileIO.__sizeof__" => "Size of object in memory, in bytes.",
    "_io.FileIO.__str__" => "Return str(self).",
    "_io.FileIO.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io.FileIO.close" => "Close the file.\n\nA closed file cannot be used for further I/O operations.  close() may be\ncalled more than once without error.",
    "_io.FileIO.closed" => "True if the file is closed",
    "_io.FileIO.closefd" => "True if the file descriptor will be closed by close().",
    "_io.FileIO.fileno" => "Return the underlying file descriptor (an integer).",
    "_io.FileIO.flush" => "Flush write buffers, if applicable.\n\nThis is not implemented for read-only and non-blocking streams.",
    "_io.FileIO.isatty" => "True if the file is connected to a TTY device.",
    "_io.FileIO.mode" => "String giving the file mode",
    "_io.FileIO.read" => "Read at most size bytes, returned as bytes.\n\nOnly makes one system call, so less data may be returned than requested.\nIn non-blocking mode, returns None if no data is available.\nReturn an empty bytes object at EOF.",
    "_io.FileIO.readable" => "True if file was opened in a read mode.",
    "_io.FileIO.readall" => "Read all data from the file, returned as bytes.\n\nIn non-blocking mode, returns as much as is immediately available,\nor None if no data is available.  Return an empty bytes object at EOF.",
    "_io.FileIO.readinto" => "Same as RawIOBase.readinto().",
    "_io.FileIO.readline" => "Read and return a line from the stream.\n\nIf size is specified, at most size bytes will be read.\n\nThe line terminator is always b'\\n' for binary files; for text\nfiles, the newlines argument to open can be used to select the line\nterminator(s) recognized.",
    "_io.FileIO.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io.FileIO.seek" => "Move to new file position and return the file position.\n\nArgument offset is a byte count.  Optional argument whence defaults to\nSEEK_SET or 0 (offset from start of file, offset should be >= 0); other values\nare SEEK_CUR or 1 (move relative to current position, positive or negative),\nand SEEK_END or 2 (move relative to end of file, usually negative, although\nmany platforms allow seeking beyond the end of a file).\n\nNote that not all file objects are seekable.",
    "_io.FileIO.seekable" => "True if file supports random-access.",
    "_io.FileIO.tell" => "Current file position.\n\nCan raise OSError for non seekable files.",
    "_io.FileIO.truncate" => "Truncate the file to at most size bytes and return the truncated size.\n\nSize defaults to the current file position, as returned by tell().\nThe current file position is changed to the value of size.",
    "_io.FileIO.writable" => "True if file was opened in a write mode.",
    "_io.FileIO.write" => "Write buffer b to file, return number of bytes written.\n\nOnly makes one system call, so not all of the data may be written.\nThe number of bytes actually written is returned.  In non-blocking mode,\nreturns None if the write would block.",
    "_io.FileIO.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io.IncrementalNewlineDecoder" => "Codec used when reading a file in universal newlines mode.\n\nIt wraps another incremental decoder, translating \\r\\n and \\r into \\n.\nIt also records the types of newlines encountered.  When used with\ntranslate=False, it ensures that the newline sequence is returned in\none piece. When used with decoder=None, it expects unicode strings as\ndecode input and translates newlines without first invoking an external\ndecoder.",
    "_io.IncrementalNewlineDecoder.__delattr__" => "Implement delattr(self, name).",
    "_io.IncrementalNewlineDecoder.__eq__" => "Return self==value.",
    "_io.IncrementalNewlineDecoder.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io.IncrementalNewlineDecoder.__ge__" => "Return self>=value.",
    "_io.IncrementalNewlineDecoder.__getattribute__" => "Return getattr(self, name).",
    "_io.IncrementalNewlineDecoder.__getstate__" => "Helper for pickle.",
    "_io.IncrementalNewlineDecoder.__gt__" => "Return self>value.",
    "_io.IncrementalNewlineDecoder.__hash__" => "Return hash(self).",
    "_io.IncrementalNewlineDecoder.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io.IncrementalNewlineDecoder.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io.IncrementalNewlineDecoder.__le__" => "Return self<=value.",
    "_io.IncrementalNewlineDecoder.__lt__" => "Return self<value.",
    "_io.IncrementalNewlineDecoder.__ne__" => "Return self!=value.",
    "_io.IncrementalNewlineDecoder.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io.IncrementalNewlineDecoder.__reduce__" => "Helper for pickle.",
    "_io.IncrementalNewlineDecoder.__reduce_ex__" => "Helper for pickle.",
    "_io.IncrementalNewlineDecoder.__repr__" => "Return repr(self).",
    "_io.IncrementalNewlineDecoder.__setattr__" => "Implement setattr(self, name, value).",
    "_io.IncrementalNewlineDecoder.__sizeof__" => "Size of object in memory, in bytes.",
    "_io.IncrementalNewlineDecoder.__str__" => "Return str(self).",
    "_io.IncrementalNewlineDecoder.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io.StringIO" => "Text I/O implementation using an in-memory buffer.\n\nThe initial_value argument sets the value of object.  The newline\nargument is like the one of TextIOWrapper's constructor.",
    "_io.StringIO.__del__" => "Called when the instance is about to be destroyed.",
    "_io.StringIO.__delattr__" => "Implement delattr(self, name).",
    "_io.StringIO.__eq__" => "Return self==value.",
    "_io.StringIO.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io.StringIO.__ge__" => "Return self>=value.",
    "_io.StringIO.__getattribute__" => "Return getattr(self, name).",
    "_io.StringIO.__gt__" => "Return self>value.",
    "_io.StringIO.__hash__" => "Return hash(self).",
    "_io.StringIO.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io.StringIO.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io.StringIO.__iter__" => "Implement iter(self).",
    "_io.StringIO.__le__" => "Return self<=value.",
    "_io.StringIO.__lt__" => "Return self<value.",
    "_io.StringIO.__ne__" => "Return self!=value.",
    "_io.StringIO.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io.StringIO.__next__" => "Implement next(self).",
    "_io.StringIO.__reduce__" => "Helper for pickle.",
    "_io.StringIO.__reduce_ex__" => "Helper for pickle.",
    "_io.StringIO.__repr__" => "Return repr(self).",
    "_io.StringIO.__setattr__" => "Implement setattr(self, name, value).",
    "_io.StringIO.__sizeof__" => "Size of object in memory, in bytes.",
    "_io.StringIO.__str__" => "Return str(self).",
    "_io.StringIO.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io.StringIO.close" => "Close the IO object.\n\nAttempting any further operation after the object is closed\nwill raise a ValueError.\n\nThis method has no effect if the file is already closed.",
    "_io.StringIO.detach" => "Separate the underlying buffer from the TextIOBase and return it.\n\nAfter the underlying buffer has been detached, the TextIO is in an unusable state.",
    "_io.StringIO.encoding" => "Encoding of the text stream.\n\nSubclasses should override.",
    "_io.StringIO.errors" => "The error setting of the decoder or encoder.\n\nSubclasses should override.",
    "_io.StringIO.fileno" => "Return underlying file descriptor if one exists.\n\nRaise OSError if the IO object does not use a file descriptor.",
    "_io.StringIO.flush" => "Flush write buffers, if applicable.\n\nThis is not implemented for read-only and non-blocking streams.",
    "_io.StringIO.getvalue" => "Retrieve the entire contents of the object.",
    "_io.StringIO.isatty" => "Return whether this is an 'interactive' stream.\n\nReturn False if it can't be determined.",
    "_io.StringIO.read" => "Read at most size characters, returned as a string.\n\nIf the argument is negative or omitted, read until EOF\nis reached. Return an empty string at EOF.",
    "_io.StringIO.readable" => "Returns True if the IO object can be read.",
    "_io.StringIO.readline" => "Read until newline or EOF.\n\nReturns an empty string if EOF is hit immediately.",
    "_io.StringIO.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io.StringIO.seek" => "Change stream position.\n\nSeek to character offset pos relative to position indicated by whence:\n    0  Start of stream (the default).  pos should be >= 0;\n    1  Current position - pos must be 0;\n    2  End of stream - pos must be 0.\nReturns the new absolute position.",
    "_io.StringIO.seekable" => "Returns True if the IO object can be seeked.",
    "_io.StringIO.tell" => "Tell the current file position.",
    "_io.StringIO.truncate" => "Truncate size to pos.\n\nThe pos argument defaults to the current file position, as\nreturned by tell().  The current file position is unchanged.\nReturns the new absolute position.",
    "_io.StringIO.writable" => "Returns True if the IO object can be written.",
    "_io.StringIO.write" => "Write string to file.\n\nReturns the number of characters written, which is always equal to\nthe length of the string.",
    "_io.StringIO.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io.TextIOWrapper" => "Character and line based layer over a BufferedIOBase object, buffer.\n\nencoding gives the name of the encoding that the stream will be\ndecoded or encoded with. It defaults to locale.getencoding().\n\nerrors determines the strictness of encoding and decoding (see\nhelp(codecs.Codec) or the documentation for codecs.register) and\ndefaults to \"strict\".\n\nnewline controls how line endings are handled. It can be None, '',\n'\\n', '\\r', and '\\r\\n'.  It works as follows:\n\n* On input, if newline is None, universal newlines mode is\n  enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n  these are translated into '\\n' before being returned to the\n  caller. If it is '', universal newline mode is enabled, but line\n  endings are returned to the caller untranslated. If it has any of\n  the other legal values, input lines are only terminated by the given\n  string, and the line ending is returned to the caller untranslated.\n\n* On output, if newline is None, any '\\n' characters written are\n  translated to the system default line separator, os.linesep. If\n  newline is '' or '\\n', no translation takes place. If newline is any\n  of the other legal values, any '\\n' characters written are translated\n  to the given string.\n\nIf line_buffering is True, a call to flush is implied when a call to\nwrite contains a newline character.",
    "_io.TextIOWrapper.__del__" => "Called when the instance is about to be destroyed.",
    "_io.TextIOWrapper.__delattr__" => "Implement delattr(self, name).",
    "_io.TextIOWrapper.__eq__" => "Return self==value.",
    "_io.TextIOWrapper.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io.TextIOWrapper.__ge__" => "Return self>=value.",
    "_io.TextIOWrapper.__getattribute__" => "Return getattr(self, name).",
    "_io.TextIOWrapper.__gt__" => "Return self>value.",
    "_io.TextIOWrapper.__hash__" => "Return hash(self).",
    "_io.TextIOWrapper.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io.TextIOWrapper.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io.TextIOWrapper.__iter__" => "Implement iter(self).",
    "_io.TextIOWrapper.__le__" => "Return self<=value.",
    "_io.TextIOWrapper.__lt__" => "Return self<value.",
    "_io.TextIOWrapper.__ne__" => "Return self!=value.",
    "_io.TextIOWrapper.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io.TextIOWrapper.__next__" => "Implement next(self).",
    "_io.TextIOWrapper.__reduce__" => "Helper for pickle.",
    "_io.TextIOWrapper.__reduce_ex__" => "Helper for pickle.",
    "_io.TextIOWrapper.__repr__" => "Return repr(self).",
    "_io.TextIOWrapper.__setattr__" => "Implement setattr(self, name, value).",
    "_io.TextIOWrapper.__sizeof__" => "Size of object in memory, in bytes.",
    "_io.TextIOWrapper.__str__" => "Return str(self).",
    "_io.TextIOWrapper.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io.TextIOWrapper.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io.TextIOWrapper.reconfigure" => "Reconfigure the text stream with new parameters.\n\nThis also does an implicit stream flush.",
    "_io.TextIOWrapper.seek" => "Set the stream position, and return the new stream position.\n\n  cookie\n    Zero or an opaque number returned by tell().\n  whence\n    The relative position to seek from.\n\nFour operations are supported, given by the following argument\ncombinations:\n\n- seek(0, SEEK_SET): Rewind to the start of the stream.\n- seek(cookie, SEEK_SET): Restore a previous position;\n  'cookie' must be a number returned by tell().\n- seek(0, SEEK_END): Fast-forward to the end of the stream.\n- seek(0, SEEK_CUR): Leave the current stream position unchanged.\n\nAny other argument combinations are invalid,\nand may raise exceptions.",
    "_io.TextIOWrapper.tell" => "Return the stream position as an opaque number.\n\nThe return value of tell() can be given as input to seek(), to restore a\nprevious stream position.",
    "_io.TextIOWrapper.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io._BufferedIOBase" => "Base class for buffered IO objects.\n\nThe main difference with RawIOBase is that the read() method\nsupports omitting the size argument, and does not have a default\nimplementation that defers to readinto().\n\nIn addition, read(), readinto() and write() may raise\nBlockingIOError if the underlying raw stream is in non-blocking\nmode and not ready; unlike their raw counterparts, they will never\nreturn None.\n\nA typical implementation should not inherit from a RawIOBase\nimplementation, but wrap one.",
    "_io._BufferedIOBase.__del__" => "Called when the instance is about to be destroyed.",
    "_io._BufferedIOBase.__delattr__" => "Implement delattr(self, name).",
    "_io._BufferedIOBase.__eq__" => "Return self==value.",
    "_io._BufferedIOBase.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io._BufferedIOBase.__ge__" => "Return self>=value.",
    "_io._BufferedIOBase.__getattribute__" => "Return getattr(self, name).",
    "_io._BufferedIOBase.__getstate__" => "Helper for pickle.",
    "_io._BufferedIOBase.__gt__" => "Return self>value.",
    "_io._BufferedIOBase.__hash__" => "Return hash(self).",
    "_io._BufferedIOBase.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io._BufferedIOBase.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io._BufferedIOBase.__iter__" => "Implement iter(self).",
    "_io._BufferedIOBase.__le__" => "Return self<=value.",
    "_io._BufferedIOBase.__lt__" => "Return self<value.",
    "_io._BufferedIOBase.__ne__" => "Return self!=value.",
    "_io._BufferedIOBase.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io._BufferedIOBase.__next__" => "Implement next(self).",
    "_io._BufferedIOBase.__reduce__" => "Helper for pickle.",
    "_io._BufferedIOBase.__reduce_ex__" => "Helper for pickle.",
    "_io._BufferedIOBase.__repr__" => "Return repr(self).",
    "_io._BufferedIOBase.__setattr__" => "Implement setattr(self, name, value).",
    "_io._BufferedIOBase.__sizeof__" => "Size of object in memory, in bytes.",
    "_io._BufferedIOBase.__str__" => "Return str(self).",
    "_io._BufferedIOBase.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io._BufferedIOBase.close" => "Flush and close the IO object.\n\nThis method has no effect if the file is already closed.",
    "_io._BufferedIOBase.detach" => "Disconnect this buffer from its underlying raw stream and return it.\n\nAfter the raw stream has been detached, the buffer is in an unusable\nstate.",
    "_io._BufferedIOBase.fileno" => "Return underlying file descriptor if one exists.\n\nRaise OSError if the IO object does not use a file descriptor.",
    "_io._BufferedIOBase.flush" => "Flush write buffers, if applicable.\n\nThis is not implemented for read-only and non-blocking streams.",
    "_io._BufferedIOBase.isatty" => "Return whether this is an 'interactive' stream.\n\nReturn False if it can't be determined.",
    "_io._BufferedIOBase.read" => "Read and return up to n bytes.\n\nIf the size argument is omitted, None, or negative, read and\nreturn all data until EOF.\n\nIf the size argument is positive, and the underlying raw stream is\nnot 'interactive', multiple raw reads may be issued to satisfy\nthe byte count (unless EOF is reached first).\nHowever, for interactive raw streams (as well as sockets and pipes),\nat most one raw read will be issued, and a short result does not\nimply that EOF is imminent.\n\nReturn an empty bytes object on EOF.\n\nReturn None if the underlying raw stream was open in non-blocking\nmode and no data is available at the moment.",
    "_io._BufferedIOBase.read1" => "Read and return up to size bytes, with at most one read() call to the underlying raw stream.\n\nReturn an empty bytes object on EOF.\nA short result does not imply that EOF is imminent.",
    "_io._BufferedIOBase.readable" => "Return whether object was opened for reading.\n\nIf False, read() will raise OSError.",
    "_io._BufferedIOBase.readline" => "Read and return a line from the stream.\n\nIf size is specified, at most size bytes will be read.\n\nThe line terminator is always b'\\n' for binary files; for text\nfiles, the newlines argument to open can be used to select the line\nterminator(s) recognized.",
    "_io._BufferedIOBase.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io._BufferedIOBase.seek" => "Change the stream position to the given byte offset.\n\n  offset\n    The stream position, relative to 'whence'.\n  whence\n    The relative position to seek from.\n\nThe offset is interpreted relative to the position indicated by whence.\nValues for whence are:\n\n* os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n* os.SEEK_CUR or 1 -- current stream position; offset may be negative\n* os.SEEK_END or 2 -- end of stream; offset is usually negative\n\nReturn the new absolute position.",
    "_io._BufferedIOBase.seekable" => "Return whether object supports random access.\n\nIf False, seek(), tell() and truncate() will raise OSError.\nThis method may need to do a test seek().",
    "_io._BufferedIOBase.tell" => "Return current stream position.",
    "_io._BufferedIOBase.truncate" => "Truncate file to size bytes.\n\nFile pointer is left unchanged. Size defaults to the current IO position\nas reported by tell(). Return the new size.",
    "_io._BufferedIOBase.writable" => "Return whether object was opened for writing.\n\nIf False, write() will raise OSError.",
    "_io._BufferedIOBase.write" => "Write buffer b to the IO stream.\n\nReturn the number of bytes written, which is always\nthe length of b in bytes.\n\nRaise BlockingIOError if the buffer is full and the\nunderlying raw stream cannot accept more data at the moment.",
    "_io._BufferedIOBase.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io._BytesIOBuffer.__buffer__" => "Return a buffer object that exposes the underlying memory of the object.",
    "_io._BytesIOBuffer.__delattr__" => "Implement delattr(self, name).",
    "_io._BytesIOBuffer.__eq__" => "Return self==value.",
    "_io._BytesIOBuffer.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io._BytesIOBuffer.__ge__" => "Return self>=value.",
    "_io._BytesIOBuffer.__getattribute__" => "Return getattr(self, name).",
    "_io._BytesIOBuffer.__getstate__" => "Helper for pickle.",
    "_io._BytesIOBuffer.__gt__" => "Return self>value.",
    "_io._BytesIOBuffer.__hash__" => "Return hash(self).",
    "_io._BytesIOBuffer.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io._BytesIOBuffer.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io._BytesIOBuffer.__le__" => "Return self<=value.",
    "_io._BytesIOBuffer.__lt__" => "Return self<value.",
    "_io._BytesIOBuffer.__ne__" => "Return self!=value.",
    "_io._BytesIOBuffer.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io._BytesIOBuffer.__reduce__" => "Helper for pickle.",
    "_io._BytesIOBuffer.__reduce_ex__" => "Helper for pickle.",
    "_io._BytesIOBuffer.__release_buffer__" => "Release the buffer object that exposes the underlying memory of the object.",
    "_io._BytesIOBuffer.__repr__" => "Return repr(self).",
    "_io._BytesIOBuffer.__setattr__" => "Implement setattr(self, name, value).",
    "_io._BytesIOBuffer.__sizeof__" => "Size of object in memory, in bytes.",
    "_io._BytesIOBuffer.__str__" => "Return str(self).",
    "_io._BytesIOBuffer.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io._IOBase" => "The abstract base class for all I/O classes.\n\nThis class provides dummy implementations for many methods that\nderived classes can override selectively; the default implementations\nrepresent a file that cannot be read, written or seeked.\n\nEven though IOBase does not declare read, readinto, or write because\ntheir signatures will vary, implementations and clients should\nconsider those methods part of the interface. Also, implementations\nmay raise UnsupportedOperation when operations they do not support are\ncalled.\n\nThe basic type used for binary data read from or written to a file is\nbytes. Other bytes-like objects are accepted as method arguments too.\nIn some cases (such as readinto), a writable object is required. Text\nI/O classes work with str data.\n\nNote that calling any method (except additional calls to close(),\nwhich are ignored) on a closed stream should raise a ValueError.\n\nIOBase (and its subclasses) support the iterator protocol, meaning\nthat an IOBase object can be iterated over yielding the lines in a\nstream.\n\nIOBase also supports the :keyword:`with` statement. In this example,\nfp is closed after the suite of the with statement is complete:\n\nwith open('spam.txt', 'r') as fp:\n    fp.write('Spam and eggs!')",
    "_io._IOBase.__del__" => "Called when the instance is about to be destroyed.",
    "_io._IOBase.__delattr__" => "Implement delattr(self, name).",
    "_io._IOBase.__eq__" => "Return self==value.",
    "_io._IOBase.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io._IOBase.__ge__" => "Return self>=value.",
    "_io._IOBase.__getattribute__" => "Return getattr(self, name).",
    "_io._IOBase.__getstate__" => "Helper for pickle.",
    "_io._IOBase.__gt__" => "Return self>value.",
    "_io._IOBase.__hash__" => "Return hash(self).",
    "_io._IOBase.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io._IOBase.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io._IOBase.__iter__" => "Implement iter(self).",
    "_io._IOBase.__le__" => "Return self<=value.",
    "_io._IOBase.__lt__" => "Return self<value.",
    "_io._IOBase.__ne__" => "Return self!=value.",
    "_io._IOBase.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io._IOBase.__next__" => "Implement next(self).",
    "_io._IOBase.__reduce__" => "Helper for pickle.",
    "_io._IOBase.__reduce_ex__" => "Helper for pickle.",
    "_io._IOBase.__repr__" => "Return repr(self).",
    "_io._IOBase.__setattr__" => "Implement setattr(self, name, value).",
    "_io._IOBase.__sizeof__" => "Size of object in memory, in bytes.",
    "_io._IOBase.__str__" => "Return str(self).",
    "_io._IOBase.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io._IOBase.close" => "Flush and close the IO object.\n\nThis method has no effect if the file is already closed.",
    "_io._IOBase.fileno" => "Return underlying file descriptor if one exists.\n\nRaise OSError if the IO object does not use a file descriptor.",
    "_io._IOBase.flush" => "Flush write buffers, if applicable.\n\nThis is not implemented for read-only and non-blocking streams.",
    "_io._IOBase.isatty" => "Return whether this is an 'interactive' stream.\n\nReturn False if it can't be determined.",
    "_io._IOBase.readable" => "Return whether object was opened for reading.\n\nIf False, read() will raise OSError.",
    "_io._IOBase.readline" => "Read and return a line from the stream.\n\nIf size is specified, at most size bytes will be read.\n\nThe line terminator is always b'\\n' for binary files; for text\nfiles, the newlines argument to open can be used to select the line\nterminator(s) recognized.",
    "_io._IOBase.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io._IOBase.seek" => "Change the stream position to the given byte offset.\n\n  offset\n    The stream position, relative to 'whence'.\n  whence\n    The relative position to seek from.\n\nThe offset is interpreted relative to the position indicated by whence.\nValues for whence are:\n\n* os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n* os.SEEK_CUR or 1 -- current stream position; offset may be negative\n* os.SEEK_END or 2 -- end of stream; offset is usually negative\n\nReturn the new absolute position.",
    "_io._IOBase.seekable" => "Return whether object supports random access.\n\nIf False, seek(), tell() and truncate() will raise OSError.\nThis method may need to do a test seek().",
    "_io._IOBase.tell" => "Return current stream position.",
    "_io._IOBase.truncate" => "Truncate file to size bytes.\n\nFile pointer is left unchanged. Size defaults to the current IO position\nas reported by tell(). Return the new size.",
    "_io._IOBase.writable" => "Return whether object was opened for writing.\n\nIf False, write() will raise OSError.",
    "_io._IOBase.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io._RawIOBase" => "Base class for raw binary I/O.",
    "_io._RawIOBase.__del__" => "Called when the instance is about to be destroyed.",
    "_io._RawIOBase.__delattr__" => "Implement delattr(self, name).",
    "_io._RawIOBase.__eq__" => "Return self==value.",
    "_io._RawIOBase.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io._RawIOBase.__ge__" => "Return self>=value.",
    "_io._RawIOBase.__getattribute__" => "Return getattr(self, name).",
    "_io._RawIOBase.__getstate__" => "Helper for pickle.",
    "_io._RawIOBase.__gt__" => "Return self>value.",
    "_io._RawIOBase.__hash__" => "Return hash(self).",
    "_io._RawIOBase.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io._RawIOBase.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io._RawIOBase.__iter__" => "Implement iter(self).",
    "_io._RawIOBase.__le__" => "Return self<=value.",
    "_io._RawIOBase.__lt__" => "Return self<value.",
    "_io._RawIOBase.__ne__" => "Return self!=value.",
    "_io._RawIOBase.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io._RawIOBase.__next__" => "Implement next(self).",
    "_io._RawIOBase.__reduce__" => "Helper for pickle.",
    "_io._RawIOBase.__reduce_ex__" => "Helper for pickle.",
    "_io._RawIOBase.__repr__" => "Return repr(self).",
    "_io._RawIOBase.__setattr__" => "Implement setattr(self, name, value).",
    "_io._RawIOBase.__sizeof__" => "Size of object in memory, in bytes.",
    "_io._RawIOBase.__str__" => "Return str(self).",
    "_io._RawIOBase.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io._RawIOBase.close" => "Flush and close the IO object.\n\nThis method has no effect if the file is already closed.",
    "_io._RawIOBase.fileno" => "Return underlying file descriptor if one exists.\n\nRaise OSError if the IO object does not use a file descriptor.",
    "_io._RawIOBase.flush" => "Flush write buffers, if applicable.\n\nThis is not implemented for read-only and non-blocking streams.",
    "_io._RawIOBase.isatty" => "Return whether this is an 'interactive' stream.\n\nReturn False if it can't be determined.",
    "_io._RawIOBase.readable" => "Return whether object was opened for reading.\n\nIf False, read() will raise OSError.",
    "_io._RawIOBase.readall" => "Read until EOF, using multiple read() call.",
    "_io._RawIOBase.readline" => "Read and return a line from the stream.\n\nIf size is specified, at most size bytes will be read.\n\nThe line terminator is always b'\\n' for binary files; for text\nfiles, the newlines argument to open can be used to select the line\nterminator(s) recognized.",
    "_io._RawIOBase.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io._RawIOBase.seek" => "Change the stream position to the given byte offset.\n\n  offset\n    The stream position, relative to 'whence'.\n  whence\n    The relative position to seek from.\n\nThe offset is interpreted relative to the position indicated by whence.\nValues for whence are:\n\n* os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n* os.SEEK_CUR or 1 -- current stream position; offset may be negative\n* os.SEEK_END or 2 -- end of stream; offset is usually negative\n\nReturn the new absolute position.",
    "_io._RawIOBase.seekable" => "Return whether object supports random access.\n\nIf False, seek(), tell() and truncate() will raise OSError.\nThis method may need to do a test seek().",
    "_io._RawIOBase.tell" => "Return current stream position.",
    "_io._RawIOBase.truncate" => "Truncate file to size bytes.\n\nFile pointer is left unchanged. Size defaults to the current IO position\nas reported by tell(). Return the new size.",
    "_io._RawIOBase.writable" => "Return whether object was opened for writing.\n\nIf False, write() will raise OSError.",
    "_io._RawIOBase.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io._TextIOBase" => "Base class for text I/O.\n\nThis class provides a character and line based interface to stream\nI/O. There is no readinto method because Python's character strings\nare immutable.",
    "_io._TextIOBase.__del__" => "Called when the instance is about to be destroyed.",
    "_io._TextIOBase.__delattr__" => "Implement delattr(self, name).",
    "_io._TextIOBase.__eq__" => "Return self==value.",
    "_io._TextIOBase.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io._TextIOBase.__ge__" => "Return self>=value.",
    "_io._TextIOBase.__getattribute__" => "Return getattr(self, name).",
    "_io._TextIOBase.__getstate__" => "Helper for pickle.",
    "_io._TextIOBase.__gt__" => "Return self>value.",
    "_io._TextIOBase.__hash__" => "Return hash(self).",
    "_io._TextIOBase.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io._TextIOBase.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io._TextIOBase.__iter__" => "Implement iter(self).",
    "_io._TextIOBase.__le__" => "Return self<=value.",
    "_io._TextIOBase.__lt__" => "Return self<value.",
    "_io._TextIOBase.__ne__" => "Return self!=value.",
    "_io._TextIOBase.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io._TextIOBase.__next__" => "Implement next(self).",
    "_io._TextIOBase.__reduce__" => "Helper for pickle.",
    "_io._TextIOBase.__reduce_ex__" => "Helper for pickle.",
    "_io._TextIOBase.__repr__" => "Return repr(self).",
    "_io._TextIOBase.__setattr__" => "Implement setattr(self, name, value).",
    "_io._TextIOBase.__sizeof__" => "Size of object in memory, in bytes.",
    "_io._TextIOBase.__str__" => "Return str(self).",
    "_io._TextIOBase.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io._TextIOBase.close" => "Flush and close the IO object.\n\nThis method has no effect if the file is already closed.",
    "_io._TextIOBase.detach" => "Separate the underlying buffer from the TextIOBase and return it.\n\nAfter the underlying buffer has been detached, the TextIO is in an unusable state.",
    "_io._TextIOBase.encoding" => "Encoding of the text stream.\n\nSubclasses should override.",
    "_io._TextIOBase.errors" => "The error setting of the decoder or encoder.\n\nSubclasses should override.",
    "_io._TextIOBase.fileno" => "Return underlying file descriptor if one exists.\n\nRaise OSError if the IO object does not use a file descriptor.",
    "_io._TextIOBase.flush" => "Flush write buffers, if applicable.\n\nThis is not implemented for read-only and non-blocking streams.",
    "_io._TextIOBase.isatty" => "Return whether this is an 'interactive' stream.\n\nReturn False if it can't be determined.",
    "_io._TextIOBase.newlines" => "Line endings translated so far.\n\nOnly line endings translated during reading are considered.\n\nSubclasses should override.",
    "_io._TextIOBase.read" => "Read at most size characters from stream.\n\nRead from underlying buffer until we have size characters or we hit EOF.\nIf size is negative or omitted, read until EOF.",
    "_io._TextIOBase.readable" => "Return whether object was opened for reading.\n\nIf False, read() will raise OSError.",
    "_io._TextIOBase.readline" => "Read until newline or EOF.\n\nReturn an empty string if EOF is hit immediately.\nIf size is specified, at most size characters will be read.",
    "_io._TextIOBase.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io._TextIOBase.seek" => "Change the stream position to the given byte offset.\n\n  offset\n    The stream position, relative to 'whence'.\n  whence\n    The relative position to seek from.\n\nThe offset is interpreted relative to the position indicated by whence.\nValues for whence are:\n\n* os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n* os.SEEK_CUR or 1 -- current stream position; offset may be negative\n* os.SEEK_END or 2 -- end of stream; offset is usually negative\n\nReturn the new absolute position.",
    "_io._TextIOBase.seekable" => "Return whether object supports random access.\n\nIf False, seek(), tell() and truncate() will raise OSError.\nThis method may need to do a test seek().",
    "_io._TextIOBase.tell" => "Return current stream position.",
    "_io._TextIOBase.truncate" => "Truncate file to size bytes.\n\nFile pointer is left unchanged. Size defaults to the current IO position\nas reported by tell(). Return the new size.",
    "_io._TextIOBase.writable" => "Return whether object was opened for writing.\n\nIf False, write() will raise OSError.",
    "_io._TextIOBase.write" => "Write string s to stream.\n\nReturn the number of characters written\n(which is always equal to the length of the string).",
    "_io._TextIOBase.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io._WindowsConsoleIO" => "Open a console buffer by file descriptor.\n\nThe mode can be 'rb' (default), or 'wb' for reading or writing bytes. All\nother mode characters will be ignored. Mode 'b' will be assumed if it is\nomitted. The *opener* parameter is always ignored.",
    "_io._WindowsConsoleIO.__del__" => "Called when the instance is about to be destroyed.",
    "_io._WindowsConsoleIO.__delattr__" => "Implement delattr(self, name).",
    "_io._WindowsConsoleIO.__eq__" => "Return self==value.",
    "_io._WindowsConsoleIO.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io._WindowsConsoleIO.__ge__" => "Return self>=value.",
    "_io._WindowsConsoleIO.__getattribute__" => "Return getattr(self, name).",
    "_io._WindowsConsoleIO.__getstate__" => "Helper for pickle.",
    "_io._WindowsConsoleIO.__gt__" => "Return self>value.",
    "_io._WindowsConsoleIO.__hash__" => "Return hash(self).",
    "_io._WindowsConsoleIO.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io._WindowsConsoleIO.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io._WindowsConsoleIO.__iter__" => "Implement iter(self).",
    "_io._WindowsConsoleIO.__le__" => "Return self<=value.",
    "_io._WindowsConsoleIO.__lt__" => "Return self<value.",
    "_io._WindowsConsoleIO.__ne__" => "Return self!=value.",
    "_io._WindowsConsoleIO.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io._WindowsConsoleIO.__next__" => "Implement next(self).",
    "_io._WindowsConsoleIO.__reduce__" => "Helper for pickle.",
    "_io._WindowsConsoleIO.__reduce_ex__" => "Helper for pickle.",
    "_io._WindowsConsoleIO.__repr__" => "Return repr(self).",
    "_io._WindowsConsoleIO.__setattr__" => "Implement setattr(self, name, value).",
    "_io._WindowsConsoleIO.__sizeof__" => "Size of object in memory, in bytes.",
    "_io._WindowsConsoleIO.__str__" => "Return str(self).",
    "_io._WindowsConsoleIO.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io._WindowsConsoleIO.close" => "Close the console object.\n\nA closed console object cannot be used for further I/O operations.\nclose() may be called more than once without error.",
    "_io._WindowsConsoleIO.closed" => "True if the file is closed",
    "_io._WindowsConsoleIO.closefd" => "True if the file descriptor will be closed by close().",
    "_io._WindowsConsoleIO.fileno" => "Return the underlying file descriptor (an integer).",
    "_io._WindowsConsoleIO.flush" => "Flush write buffers, if applicable.\n\nThis is not implemented for read-only and non-blocking streams.",
    "_io._WindowsConsoleIO.isatty" => "Always True.",
    "_io._WindowsConsoleIO.mode" => "String giving the file mode",
    "_io._WindowsConsoleIO.read" => "Read at most size bytes, returned as bytes.\n\nOnly makes one system call when size is a positive integer,\nso less data may be returned than requested.\nReturn an empty bytes object at EOF.",
    "_io._WindowsConsoleIO.readable" => "True if console is an input buffer.",
    "_io._WindowsConsoleIO.readall" => "Read all data from the console, returned as bytes.\n\nReturn an empty bytes object at EOF.",
    "_io._WindowsConsoleIO.readinto" => "Same as RawIOBase.readinto().",
    "_io._WindowsConsoleIO.readline" => "Read and return a line from the stream.\n\nIf size is specified, at most size bytes will be read.\n\nThe line terminator is always b'\\n' for binary files; for text\nfiles, the newlines argument to open can be used to select the line\nterminator(s) recognized.",
    "_io._WindowsConsoleIO.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io._WindowsConsoleIO.seek" => "Change the stream position to the given byte offset.\n\n  offset\n    The stream position, relative to 'whence'.\n  whence\n    The relative position to seek from.\n\nThe offset is interpreted relative to the position indicated by whence.\nValues for whence are:\n\n* os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n* os.SEEK_CUR or 1 -- current stream position; offset may be negative\n* os.SEEK_END or 2 -- end of stream; offset is usually negative\n\nReturn the new absolute position.",
    "_io._WindowsConsoleIO.seekable" => "Return whether object supports random access.\n\nIf False, seek(), tell() and truncate() will raise OSError.\nThis method may need to do a test seek().",
    "_io._WindowsConsoleIO.tell" => "Return current stream position.",
    "_io._WindowsConsoleIO.truncate" => "Truncate file to size bytes.\n\nFile pointer is left unchanged. Size defaults to the current IO position\nas reported by tell(). Return the new size.",
    "_io._WindowsConsoleIO.writable" => "True if console is an output buffer.",
    "_io._WindowsConsoleIO.write" => "Write buffer b to file, return number of bytes written.\n\nOnly makes one system call, so not all of the data may be written.\nThe number of bytes actually written is returned.",
    "_io._WindowsConsoleIO.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io.open" => "Open file and return a stream.  Raise OSError upon failure.\n\nfile is either a text or byte string giving the name (and the path\nif the file isn't in the current working directory) of the file to\nbe opened or an integer file descriptor of the file to be\nwrapped. (If a file descriptor is given, it is closed when the\nreturned I/O object is closed, unless closefd is set to False.)\n\nmode is an optional string that specifies the mode in which the file\nis opened. It defaults to 'r' which means open for reading in text\nmode.  Other common values are 'w' for writing (truncating the file if\nit already exists), 'x' for creating and writing to a new file, and\n'a' for appending (which on some Unix systems, means that all writes\nappend to the end of the file regardless of the current seek position).\nIn text mode, if encoding is not specified the encoding used is platform\ndependent: locale.getencoding() is called to get the current locale encoding.\n(For reading and writing raw bytes use binary mode and leave encoding\nunspecified.) The available modes are:\n\n========= ===============================================================\nCharacter Meaning\n--------- ---------------------------------------------------------------\n'r'       open for reading (default)\n'w'       open for writing, truncating the file first\n'x'       create a new file and open it for writing\n'a'       open for writing, appending to the end of the file if it exists\n'b'       binary mode\n't'       text mode (default)\n'+'       open a disk file for updating (reading and writing)\n========= ===============================================================\n\nThe default mode is 'rt' (open for reading text). For binary random\naccess, the mode 'w+b' opens and truncates the file to 0 bytes, while\n'r+b' opens the file without truncation. The 'x' mode implies 'w' and\nraises an `FileExistsError` if the file already exists.\n\nPython distinguishes between files opened in binary and text modes,\neven when the underlying operating system doesn't. Files opened in\nbinary mode (appending 'b' to the mode argument) return contents as\nbytes objects without any decoding. In text mode (the default, or when\n't' is appended to the mode argument), the contents of the file are\nreturned as strings, the bytes having been first decoded using a\nplatform-dependent encoding or using the specified encoding if given.\n\nbuffering is an optional integer used to set the buffering policy.\nPass 0 to switch buffering off (only allowed in binary mode), 1 to select\nline buffering (only usable in text mode), and an integer > 1 to indicate\nthe size of a fixed-size chunk buffer.  When no buffering argument is\ngiven, the default buffering policy works as follows:\n\n* Binary files are buffered in fixed-size chunks; the size of the buffer\n  is chosen using a heuristic trying to determine the underlying device's\n  \"block size\" and falling back on `io.DEFAULT_BUFFER_SIZE`.\n  On many systems, the buffer will typically be 4096 or 8192 bytes long.\n\n* \"Interactive\" text files (files for which isatty() returns True)\n  use line buffering.  Other text files use the policy described above\n  for binary files.\n\nencoding is the name of the encoding used to decode or encode the\nfile. This should only be used in text mode. The default encoding is\nplatform dependent, but any encoding supported by Python can be\npassed.  See the codecs module for the list of supported encodings.\n\nerrors is an optional string that specifies how encoding errors are to\nbe handled---this argument should not be used in binary mode. Pass\n'strict' to raise a ValueError exception if there is an encoding error\n(the default of None has the same effect), or pass 'ignore' to ignore\nerrors. (Note that ignoring encoding errors can lead to data loss.)\nSee the documentation for codecs.register or run 'help(codecs.Codec)'\nfor a list of the permitted encoding error strings.\n\nnewline controls how universal newlines works (it only applies to text\nmode). It can be None, '', '\\n', '\\r', and '\\r\\n'.  It works as\nfollows:\n\n* On input, if newline is None, universal newlines mode is\n  enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n  these are translated into '\\n' before being returned to the\n  caller. If it is '', universal newline mode is enabled, but line\n  endings are returned to the caller untranslated. If it has any of\n  the other legal values, input lines are only terminated by the given\n  string, and the line ending is returned to the caller untranslated.\n\n* On output, if newline is None, any '\\n' characters written are\n  translated to the system default line separator, os.linesep. If\n  newline is '' or '\\n', no translation takes place. If newline is any\n  of the other legal values, any '\\n' characters written are translated\n  to the given string.\n\nIf closefd is False, the underlying file descriptor will be kept open\nwhen the file is closed. This does not work when a file name is given\nand must be True in that case.\n\nA custom opener can be used by passing a callable as *opener*. The\nunderlying file descriptor for the file object is then obtained by\ncalling *opener* with (*file*, *flags*). *opener* must return an open\nfile descriptor (passing os.open as *opener* results in functionality\nsimilar to passing None).\n\nopen() returns a file object whose type depends on the mode, and\nthrough which the standard file operations such as reading and writing\nare performed. When open() is used to open a file in a text mode ('w',\n'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open\na file in a binary mode, the returned class varies: in read binary\nmode, it returns a BufferedReader; in write binary and append binary\nmodes, it returns a BufferedWriter, and in read/write mode, it returns\na BufferedRandom.\n\nIt is also possible to use a string or bytearray as a file for both\nreading and writing. For strings StringIO can be used like a file\nopened in a text mode, and for bytes a BytesIO can be used like a file\nopened in a binary mode.",
    "_io.open_code" => "Opens the provided file with the intent to import the contents.\n\nThis may perform extra validation beyond open(), but is otherwise interchangeable\nwith calling open(path, 'rb').",
    "_io.text_encoding" => "A helper function to choose the text encoding.\n\nWhen encoding is not None, this function returns it.\nOtherwise, this function returns the default text encoding\n(i.e. \"locale\" or \"utf-8\" depends on UTF-8 mode).\n\nThis function emits an EncodingWarning if encoding is None and\nsys.flags.warn_default_encoding is true.\n\nThis can be used in APIs with an encoding=None parameter.\nHowever, please consider using encoding=\"utf-8\" for new APIs.",
    "_json" => "json speedups",
    "_json.encode_basestring" => "encode_basestring(string) -> string\n\nReturn a JSON representation of a Python string",
    "_json.encode_basestring_ascii" => "encode_basestring_ascii(string) -> string\n\nReturn an ASCII-only JSON representation of a Python string",
    "_json.make_encoder" => "Encoder(markers, default, encoder, indent, key_separator, item_separator, sort_keys, skipkeys, allow_nan)",
    "_json.make_encoder.__call__" => "Call self as a function.",
    "_json.make_encoder.__delattr__" => "Implement delattr(self, name).",
    "_json.make_encoder.__eq__" => "Return self==value.",
    "_json.make_encoder.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_json.make_encoder.__ge__" => "Return self>=value.",
    "_json.make_encoder.__getattribute__" => "Return getattr(self, name).",
    "_json.make_encoder.__getstate__" => "Helper for pickle.",
    "_json.make_encoder.__gt__" => "Return self>value.",
    "_json.make_encoder.__hash__" => "Return hash(self).",
    "_json.make_encoder.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_json.make_encoder.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_json.make_encoder.__le__" => "Return self<=value.",
    "_json.make_encoder.__lt__" => "Return self<value.",
    "_json.make_encoder.__ne__" => "Return self!=value.",
    "_json.make_encoder.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_json.make_encoder.__reduce__" => "Helper for pickle.",
    "_json.make_encoder.__reduce_ex__" => "Helper for pickle.",
    "_json.make_encoder.__repr__" => "Return repr(self).",
    "_json.make_encoder.__setattr__" => "Implement setattr(self, name, value).",
    "_json.make_encoder.__sizeof__" => "Size of object in memory, in bytes.",
    "_json.make_encoder.__str__" => "Return str(self).",
    "_json.make_encoder.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_json.make_encoder.default" => "default",
    "_json.make_encoder.encoder" => "encoder",
    "_json.make_encoder.indent" => "indent",
    "_json.make_encoder.item_separator" => "item_separator",
    "_json.make_encoder.key_separator" => "key_separator",
    "_json.make_encoder.markers" => "markers",
    "_json.make_encoder.skipkeys" => "skipkeys",
    "_json.make_encoder.sort_keys" => "sort_keys",
    "_json.make_scanner" => "JSON scanner object",
    "_json.make_scanner.__call__" => "Call self as a function.",
    "_json.make_scanner.__delattr__" => "Implement delattr(self, name).",
    "_json.make_scanner.__eq__" => "Return self==value.",
    "_json.make_scanner.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_json.make_scanner.__ge__" => "Return self>=value.",
    "_json.make_scanner.__getattribute__" => "Return getattr(self, name).",
    "_json.make_scanner.__getstate__" => "Helper for pickle.",
    "_json.make_scanner.__gt__" => "Return self>value.",
    "_json.make_scanner.__hash__" => "Return hash(self).",
    "_json.make_scanner.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_json.make_scanner.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_json.make_scanner.__le__" => "Return self<=value.",
    "_json.make_scanner.__lt__" => "Return self<value.",
    "_json.make_scanner.__ne__" => "Return self!=value.",
    "_json.make_scanner.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_json.make_scanner.__reduce__" => "Helper for pickle.",
    "_json.make_scanner.__reduce_ex__" => "Helper for pickle.",
    "_json.make_scanner.__repr__" => "Return repr(self).",
    "_json.make_scanner.__setattr__" => "Implement setattr(self, name, value).",
    "_json.make_scanner.__sizeof__" => "Size of object in memory, in bytes.",
    "_json.make_scanner.__str__" => "Return str(self).",
    "_json.make_scanner.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_json.make_scanner.object_hook" => "object_hook",
    "_json.make_scanner.parse_constant" => "parse_constant",
    "_json.make_scanner.parse_float" => "parse_float",
    "_json.make_scanner.parse_int" => "parse_int",
    "_json.make_scanner.strict" => "strict",
    "_json.scanstring" => "scanstring(string, end, strict=True) -> (string, end)\n\nScan the string s for a JSON string. End is the index of the\ncharacter in s after the quote that started the JSON string.\nUnescapes all valid JSON string escape sequences and raises ValueError\non attempt to decode an invalid string. If strict is False then literal\ncontrol characters are allowed in the string.\n\nReturns a tuple of the decoded string and the index of the character in s\nafter the end quote.",
    "_locale" => "Support for POSIX locales.",
    "_locale.bind_textdomain_codeset" => "Bind the C library's domain to codeset.",
    "_locale.bindtextdomain" => "Bind the C library's domain to dir.",
    "_locale.dcgettext" => "Return translation of msg in domain and category.",
    "_locale.dgettext" => "dgettext(domain, msg) -> string\n\nReturn translation of msg in domain.",
    "_locale.getencoding" => "Get the current locale encoding.",
    "_locale.gettext" => "gettext(msg) -> string\n\nReturn translation of msg.",
    "_locale.localeconv" => "Returns numeric and monetary locale-specific parameters.",
    "_locale.nl_langinfo" => "Return the value for the locale information associated with key.",
    "_locale.setlocale" => "Activates/queries locale processing.",
    "_locale.strcoll" => "Compares two strings according to the locale.",
    "_locale.strxfrm" => "Return a string that can be used as a key for locale-aware comparisons.",
    "_locale.textdomain" => "Set the C library's textdmain to domain, returning the new domain.",
    "_lsprof" => "Fast profiler",
    "_lsprof.Profiler" => "Profiler(timer=None, timeunit=None, subcalls=True, builtins=True)\n\nBuilds a profiler object using the specified timer function.\nThe default timer is a fast built-in one based on real time.\nFor custom timer functions returning integers, timeunit can\nbe a float specifying a scale (i.e. how long each integer unit\nis, in seconds).",
    "_lsprof.Profiler.__delattr__" => "Implement delattr(self, name).",
    "_lsprof.Profiler.__eq__" => "Return self==value.",
    "_lsprof.Profiler.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_lsprof.Profiler.__ge__" => "Return self>=value.",
    "_lsprof.Profiler.__getattribute__" => "Return getattr(self, name).",
    "_lsprof.Profiler.__getstate__" => "Helper for pickle.",
    "_lsprof.Profiler.__gt__" => "Return self>value.",
    "_lsprof.Profiler.__hash__" => "Return hash(self).",
    "_lsprof.Profiler.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_lsprof.Profiler.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_lsprof.Profiler.__le__" => "Return self<=value.",
    "_lsprof.Profiler.__lt__" => "Return self<value.",
    "_lsprof.Profiler.__ne__" => "Return self!=value.",
    "_lsprof.Profiler.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_lsprof.Profiler.__reduce__" => "Helper for pickle.",
    "_lsprof.Profiler.__reduce_ex__" => "Helper for pickle.",
    "_lsprof.Profiler.__repr__" => "Return repr(self).",
    "_lsprof.Profiler.__setattr__" => "Implement setattr(self, name, value).",
    "_lsprof.Profiler.__sizeof__" => "Size of object in memory, in bytes.",
    "_lsprof.Profiler.__str__" => "Return str(self).",
    "_lsprof.Profiler.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_lsprof.Profiler.clear" => "clear()\n\nClear all profiling information collected so far.",
    "_lsprof.Profiler.disable" => "disable()\n\nStop collecting profiling information.",
    "_lsprof.Profiler.enable" => "enable(subcalls=True, builtins=True)\n\nStart collecting profiling information.\nIf 'subcalls' is True, also records for each function\nstatistics separated according to its current caller.\nIf 'builtins' is True, records the time spent in\nbuilt-in functions separately from their caller.",
    "_lsprof.Profiler.getstats" => "list of profiler_entry objects.\n\ngetstats() -> list of profiler_entry objects\n\nReturn all information collected by the profiler.\nEach profiler_entry is a tuple-like object with the\nfollowing attributes:\n\n    code          code object\n    callcount     how many times this was called\n    reccallcount  how many times called recursively\n    totaltime     total time in this entry\n    inlinetime    inline time in this entry (not in subcalls)\n    calls         details of the calls\n\nThe calls attribute is either None or a list of\nprofiler_subentry objects:\n\n    code          called code object\n    callcount     how many times this is called\n    reccallcount  how many times this is called recursively\n    totaltime     total time spent in this call\n    inlinetime    inline time (not in further subcalls)",
    "_lsprof.profiler_entry.__add__" => "Return self+value.",
    "_lsprof.profiler_entry.__class_getitem__" => "See PEP 585",
    "_lsprof.profiler_entry.__contains__" => "Return bool(key in self).",
    "_lsprof.profiler_entry.__delattr__" => "Implement delattr(self, name).",
    "_lsprof.profiler_entry.__eq__" => "Return self==value.",
    "_lsprof.profiler_entry.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_lsprof.profiler_entry.__ge__" => "Return self>=value.",
    "_lsprof.profiler_entry.__getattribute__" => "Return getattr(self, name).",
    "_lsprof.profiler_entry.__getitem__" => "Return self[key].",
    "_lsprof.profiler_entry.__getstate__" => "Helper for pickle.",
    "_lsprof.profiler_entry.__gt__" => "Return self>value.",
    "_lsprof.profiler_entry.__hash__" => "Return hash(self).",
    "_lsprof.profiler_entry.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_lsprof.profiler_entry.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_lsprof.profiler_entry.__iter__" => "Implement iter(self).",
    "_lsprof.profiler_entry.__le__" => "Return self<=value.",
    "_lsprof.profiler_entry.__len__" => "Return len(self).",
    "_lsprof.profiler_entry.__lt__" => "Return self<value.",
    "_lsprof.profiler_entry.__mul__" => "Return self*value.",
    "_lsprof.profiler_entry.__ne__" => "Return self!=value.",
    "_lsprof.profiler_entry.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_lsprof.profiler_entry.__reduce_ex__" => "Helper for pickle.",
    "_lsprof.profiler_entry.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "_lsprof.profiler_entry.__repr__" => "Return repr(self).",
    "_lsprof.profiler_entry.__rmul__" => "Return value*self.",
    "_lsprof.profiler_entry.__setattr__" => "Implement setattr(self, name, value).",
    "_lsprof.profiler_entry.__sizeof__" => "Size of object in memory, in bytes.",
    "_lsprof.profiler_entry.__str__" => "Return str(self).",
    "_lsprof.profiler_entry.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_lsprof.profiler_entry.callcount" => "how many times this was called",
    "_lsprof.profiler_entry.calls" => "details of the calls",
    "_lsprof.profiler_entry.code" => "code object or built-in function name",
    "_lsprof.profiler_entry.count" => "Return number of occurrences of value.",
    "_lsprof.profiler_entry.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "_lsprof.profiler_entry.inlinetime" => "inline time in this entry (not in subcalls)",
    "_lsprof.profiler_entry.reccallcount" => "how many times called recursively",
    "_lsprof.profiler_entry.totaltime" => "total time in this entry",
    "_lsprof.profiler_subentry.__add__" => "Return self+value.",
    "_lsprof.profiler_subentry.__class_getitem__" => "See PEP 585",
    "_lsprof.profiler_subentry.__contains__" => "Return bool(key in self).",
    "_lsprof.profiler_subentry.__delattr__" => "Implement delattr(self, name).",
    "_lsprof.profiler_subentry.__eq__" => "Return self==value.",
    "_lsprof.profiler_subentry.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_lsprof.profiler_subentry.__ge__" => "Return self>=value.",
    "_lsprof.profiler_subentry.__getattribute__" => "Return getattr(self, name).",
    "_lsprof.profiler_subentry.__getitem__" => "Return self[key].",
    "_lsprof.profiler_subentry.__getstate__" => "Helper for pickle.",
    "_lsprof.profiler_subentry.__gt__" => "Return self>value.",
    "_lsprof.profiler_subentry.__hash__" => "Return hash(self).",
    "_lsprof.profiler_subentry.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_lsprof.profiler_subentry.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_lsprof.profiler_subentry.__iter__" => "Implement iter(self).",
    "_lsprof.profiler_subentry.__le__" => "Return self<=value.",
    "_lsprof.profiler_subentry.__len__" => "Return len(self).",
    "_lsprof.profiler_subentry.__lt__" => "Return self<value.",
    "_lsprof.profiler_subentry.__mul__" => "Return self*value.",
    "_lsprof.profiler_subentry.__ne__" => "Return self!=value.",
    "_lsprof.profiler_subentry.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_lsprof.profiler_subentry.__reduce_ex__" => "Helper for pickle.",
    "_lsprof.profiler_subentry.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "_lsprof.profiler_subentry.__repr__" => "Return repr(self).",
    "_lsprof.profiler_subentry.__rmul__" => "Return value*self.",
    "_lsprof.profiler_subentry.__setattr__" => "Implement setattr(self, name, value).",
    "_lsprof.profiler_subentry.__sizeof__" => "Size of object in memory, in bytes.",
    "_lsprof.profiler_subentry.__str__" => "Return str(self).",
    "_lsprof.profiler_subentry.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_lsprof.profiler_subentry.callcount" => "how many times this is called",
    "_lsprof.profiler_subentry.code" => "called code object or built-in function name",
    "_lsprof.profiler_subentry.count" => "Return number of occurrences of value.",
    "_lsprof.profiler_subentry.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "_lsprof.profiler_subentry.inlinetime" => "inline time (not in further subcalls)",
    "_lsprof.profiler_subentry.reccallcount" => "how many times this is called recursively",
    "_lsprof.profiler_subentry.totaltime" => "total time spent in this call",
    "_lzma.LZMACompressor" => "LZMACompressor(format=FORMAT_XZ, check=-1, preset=None, filters=None)\n\nCreate a compressor object for compressing data incrementally.\n\nformat specifies the container format to use for the output. This can\nbe FORMAT_XZ (default), FORMAT_ALONE, or FORMAT_RAW.\n\ncheck specifies the integrity check to use. For FORMAT_XZ, the default\nis CHECK_CRC64. FORMAT_ALONE and FORMAT_RAW do not support integrity\nchecks; for these formats, check must be omitted, or be CHECK_NONE.\n\nThe settings used by the compressor can be specified either as a\npreset compression level (with the 'preset' argument), or in detail\nas a custom filter chain (with the 'filters' argument). For FORMAT_XZ\nand FORMAT_ALONE, the default is to use the PRESET_DEFAULT preset\nlevel. For FORMAT_RAW, the caller must always specify a filter chain;\nthe raw compressor does not support preset compression levels.\n\npreset (if provided) should be an integer in the range 0-9, optionally\nOR-ed with the constant PRESET_EXTREME.\n\nfilters (if provided) should be a sequence of dicts. Each dict should\nhave an entry for \"id\" indicating the ID of the filter, plus\nadditional entries for options to the filter.\n\nFor one-shot compression, use the compress() function instead.",
    "_lzma.LZMACompressor.__delattr__" => "Implement delattr(self, name).",
    "_lzma.LZMACompressor.__eq__" => "Return self==value.",
    "_lzma.LZMACompressor.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_lzma.LZMACompressor.__ge__" => "Return self>=value.",
    "_lzma.LZMACompressor.__getattribute__" => "Return getattr(self, name).",
    "_lzma.LZMACompressor.__getstate__" => "Helper for pickle.",
    "_lzma.LZMACompressor.__gt__" => "Return self>value.",
    "_lzma.LZMACompressor.__hash__" => "Return hash(self).",
    "_lzma.LZMACompressor.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_lzma.LZMACompressor.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_lzma.LZMACompressor.__le__" => "Return self<=value.",
    "_lzma.LZMACompressor.__lt__" => "Return self<value.",
    "_lzma.LZMACompressor.__ne__" => "Return self!=value.",
    "_lzma.LZMACompressor.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_lzma.LZMACompressor.__reduce__" => "Helper for pickle.",
    "_lzma.LZMACompressor.__reduce_ex__" => "Helper for pickle.",
    "_lzma.LZMACompressor.__repr__" => "Return repr(self).",
    "_lzma.LZMACompressor.__setattr__" => "Implement setattr(self, name, value).",
    "_lzma.LZMACompressor.__sizeof__" => "Size of object in memory, in bytes.",
    "_lzma.LZMACompressor.__str__" => "Return str(self).",
    "_lzma.LZMACompressor.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_lzma.LZMACompressor.compress" => "Provide data to the compressor object.\n\nReturns a chunk of compressed data if possible, or b'' otherwise.\n\nWhen you have finished providing data to the compressor, call the\nflush() method to finish the compression process.",
    "_lzma.LZMACompressor.flush" => "Finish the compression process.\n\nReturns the compressed data left in internal buffers.\n\nThe compressor object may not be used after this method is called.",
    "_lzma.LZMADecompressor" => "Create a decompressor object for decompressing data incrementally.\n\n  format\n    Specifies the container format of the input stream.  If this is\n    FORMAT_AUTO (the default), the decompressor will automatically detect\n    whether the input is FORMAT_XZ or FORMAT_ALONE.  Streams created with\n    FORMAT_RAW cannot be autodetected.\n  memlimit\n    Limit the amount of memory used by the decompressor.  This will cause\n    decompression to fail if the input cannot be decompressed within the\n    given limit.\n  filters\n    A custom filter chain.  This argument is required for FORMAT_RAW, and\n    not accepted with any other format.  When provided, this should be a\n    sequence of dicts, each indicating the ID and options for a single\n    filter.\n\nFor one-shot decompression, use the decompress() function instead.",
    "_lzma.LZMADecompressor.__delattr__" => "Implement delattr(self, name).",
    "_lzma.LZMADecompressor.__eq__" => "Return self==value.",
    "_lzma.LZMADecompressor.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_lzma.LZMADecompressor.__ge__" => "Return self>=value.",
    "_lzma.LZMADecompressor.__getattribute__" => "Return getattr(self, name).",
    "_lzma.LZMADecompressor.__getstate__" => "Helper for pickle.",
    "_lzma.LZMADecompressor.__gt__" => "Return self>value.",
    "_lzma.LZMADecompressor.__hash__" => "Return hash(self).",
    "_lzma.LZMADecompressor.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_lzma.LZMADecompressor.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_lzma.LZMADecompressor.__le__" => "Return self<=value.",
    "_lzma.LZMADecompressor.__lt__" => "Return self<value.",
    "_lzma.LZMADecompressor.__ne__" => "Return self!=value.",
    "_lzma.LZMADecompressor.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_lzma.LZMADecompressor.__reduce__" => "Helper for pickle.",
    "_lzma.LZMADecompressor.__reduce_ex__" => "Helper for pickle.",
    "_lzma.LZMADecompressor.__repr__" => "Return repr(self).",
    "_lzma.LZMADecompressor.__setattr__" => "Implement setattr(self, name, value).",
    "_lzma.LZMADecompressor.__sizeof__" => "Size of object in memory, in bytes.",
    "_lzma.LZMADecompressor.__str__" => "Return str(self).",
    "_lzma.LZMADecompressor.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_lzma.LZMADecompressor.check" => "ID of the integrity check used by the input stream.",
    "_lzma.LZMADecompressor.decompress" => "Decompress *data*, returning uncompressed data as bytes.\n\nIf *max_length* is nonnegative, returns at most *max_length* bytes of\ndecompressed data. If this limit is reached and further output can be\nproduced, *self.needs_input* will be set to ``False``. In this case, the next\ncall to *decompress()* may provide *data* as b'' to obtain more of the output.\n\nIf all of the input data was decompressed and returned (either because this\nwas less than *max_length* bytes, or because *max_length* was negative),\n*self.needs_input* will be set to True.\n\nAttempting to decompress data after the end of stream is reached raises an\nEOFError.  Any data found after the end of the stream is ignored and saved in\nthe unused_data attribute.",
    "_lzma.LZMADecompressor.eof" => "True if the end-of-stream marker has been reached.",
    "_lzma.LZMADecompressor.needs_input" => "True if more input is needed before more decompressed data can be produced.",
    "_lzma.LZMADecompressor.unused_data" => "Data found after the end of the compressed stream.",
    "_lzma.LZMAError" => "Call to liblzma failed.",
    "_lzma.LZMAError.__cause__" => "exception cause",
    "_lzma.LZMAError.__context__" => "exception context",
    "_lzma.LZMAError.__delattr__" => "Implement delattr(self, name).",
    "_lzma.LZMAError.__eq__" => "Return self==value.",
    "_lzma.LZMAError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_lzma.LZMAError.__ge__" => "Return self>=value.",
    "_lzma.LZMAError.__getattribute__" => "Return getattr(self, name).",
    "_lzma.LZMAError.__getstate__" => "Helper for pickle.",
    "_lzma.LZMAError.__gt__" => "Return self>value.",
    "_lzma.LZMAError.__hash__" => "Return hash(self).",
    "_lzma.LZMAError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_lzma.LZMAError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_lzma.LZMAError.__le__" => "Return self<=value.",
    "_lzma.LZMAError.__lt__" => "Return self<value.",
    "_lzma.LZMAError.__ne__" => "Return self!=value.",
    "_lzma.LZMAError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_lzma.LZMAError.__reduce_ex__" => "Helper for pickle.",
    "_lzma.LZMAError.__repr__" => "Return repr(self).",
    "_lzma.LZMAError.__setattr__" => "Implement setattr(self, name, value).",
    "_lzma.LZMAError.__sizeof__" => "Size of object in memory, in bytes.",
    "_lzma.LZMAError.__str__" => "Return str(self).",
    "_lzma.LZMAError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_lzma.LZMAError.__weakref__" => "list of weak references to the object",
    "_lzma.LZMAError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_lzma.LZMAError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_lzma._decode_filter_properties" => "Return a bytes object encoding the options (properties) of the filter specified by *filter* (a dict).\n\nThe result does not include the filter ID itself, only the options.",
    "_lzma._encode_filter_properties" => "Return a bytes object encoding the options (properties) of the filter specified by *filter* (a dict).\n\nThe result does not include the filter ID itself, only the options.",
    "_lzma.is_check_supported" => "Test whether the given integrity check is supported.\n\nAlways returns True for CHECK_NONE and CHECK_CRC32.",
    "_md5.MD5Type.__delattr__" => "Implement delattr(self, name).",
    "_md5.MD5Type.__eq__" => "Return self==value.",
    "_md5.MD5Type.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_md5.MD5Type.__ge__" => "Return self>=value.",
    "_md5.MD5Type.__getattribute__" => "Return getattr(self, name).",
    "_md5.MD5Type.__getstate__" => "Helper for pickle.",
    "_md5.MD5Type.__gt__" => "Return self>value.",
    "_md5.MD5Type.__hash__" => "Return hash(self).",
    "_md5.MD5Type.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_md5.MD5Type.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_md5.MD5Type.__le__" => "Return self<=value.",
    "_md5.MD5Type.__lt__" => "Return self<value.",
    "_md5.MD5Type.__ne__" => "Return self!=value.",
    "_md5.MD5Type.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_md5.MD5Type.__reduce__" => "Helper for pickle.",
    "_md5.MD5Type.__reduce_ex__" => "Helper for pickle.",
    "_md5.MD5Type.__repr__" => "Return repr(self).",
    "_md5.MD5Type.__setattr__" => "Implement setattr(self, name, value).",
    "_md5.MD5Type.__sizeof__" => "Size of object in memory, in bytes.",
    "_md5.MD5Type.__str__" => "Return str(self).",
    "_md5.MD5Type.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_md5.MD5Type.copy" => "Return a copy of the hash object.",
    "_md5.MD5Type.digest" => "Return the digest value as a bytes object.",
    "_md5.MD5Type.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_md5.MD5Type.update" => "Update this hash object's state with the provided string.",
    "_md5.md5" => "Return a new MD5 hash object; optionally initialized with a string.",
    "_multibytecodec.MultibyteIncrementalDecoder.__delattr__" => "Implement delattr(self, name).",
    "_multibytecodec.MultibyteIncrementalDecoder.__eq__" => "Return self==value.",
    "_multibytecodec.MultibyteIncrementalDecoder.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_multibytecodec.MultibyteIncrementalDecoder.__ge__" => "Return self>=value.",
    "_multibytecodec.MultibyteIncrementalDecoder.__getattribute__" => "Return getattr(self, name).",
    "_multibytecodec.MultibyteIncrementalDecoder.__getstate__" => "Helper for pickle.",
    "_multibytecodec.MultibyteIncrementalDecoder.__gt__" => "Return self>value.",
    "_multibytecodec.MultibyteIncrementalDecoder.__hash__" => "Return hash(self).",
    "_multibytecodec.MultibyteIncrementalDecoder.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_multibytecodec.MultibyteIncrementalDecoder.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_multibytecodec.MultibyteIncrementalDecoder.__le__" => "Return self<=value.",
    "_multibytecodec.MultibyteIncrementalDecoder.__lt__" => "Return self<value.",
    "_multibytecodec.MultibyteIncrementalDecoder.__ne__" => "Return self!=value.",
    "_multibytecodec.MultibyteIncrementalDecoder.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_multibytecodec.MultibyteIncrementalDecoder.__reduce__" => "Helper for pickle.",
    "_multibytecodec.MultibyteIncrementalDecoder.__reduce_ex__" => "Helper for pickle.",
    "_multibytecodec.MultibyteIncrementalDecoder.__repr__" => "Return repr(self).",
    "_multibytecodec.MultibyteIncrementalDecoder.__setattr__" => "Implement setattr(self, name, value).",
    "_multibytecodec.MultibyteIncrementalDecoder.__sizeof__" => "Size of object in memory, in bytes.",
    "_multibytecodec.MultibyteIncrementalDecoder.__str__" => "Return str(self).",
    "_multibytecodec.MultibyteIncrementalDecoder.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_multibytecodec.MultibyteIncrementalDecoder.errors" => "how to treat errors",
    "_multibytecodec.MultibyteIncrementalEncoder.__delattr__" => "Implement delattr(self, name).",
    "_multibytecodec.MultibyteIncrementalEncoder.__eq__" => "Return self==value.",
    "_multibytecodec.MultibyteIncrementalEncoder.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_multibytecodec.MultibyteIncrementalEncoder.__ge__" => "Return self>=value.",
    "_multibytecodec.MultibyteIncrementalEncoder.__getattribute__" => "Return getattr(self, name).",
    "_multibytecodec.MultibyteIncrementalEncoder.__getstate__" => "Helper for pickle.",
    "_multibytecodec.MultibyteIncrementalEncoder.__gt__" => "Return self>value.",
    "_multibytecodec.MultibyteIncrementalEncoder.__hash__" => "Return hash(self).",
    "_multibytecodec.MultibyteIncrementalEncoder.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_multibytecodec.MultibyteIncrementalEncoder.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_multibytecodec.MultibyteIncrementalEncoder.__le__" => "Return self<=value.",
    "_multibytecodec.MultibyteIncrementalEncoder.__lt__" => "Return self<value.",
    "_multibytecodec.MultibyteIncrementalEncoder.__ne__" => "Return self!=value.",
    "_multibytecodec.MultibyteIncrementalEncoder.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_multibytecodec.MultibyteIncrementalEncoder.__reduce__" => "Helper for pickle.",
    "_multibytecodec.MultibyteIncrementalEncoder.__reduce_ex__" => "Helper for pickle.",
    "_multibytecodec.MultibyteIncrementalEncoder.__repr__" => "Return repr(self).",
    "_multibytecodec.MultibyteIncrementalEncoder.__setattr__" => "Implement setattr(self, name, value).",
    "_multibytecodec.MultibyteIncrementalEncoder.__sizeof__" => "Size of object in memory, in bytes.",
    "_multibytecodec.MultibyteIncrementalEncoder.__str__" => "Return str(self).",
    "_multibytecodec.MultibyteIncrementalEncoder.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_multibytecodec.MultibyteIncrementalEncoder.errors" => "how to treat errors",
    "_multibytecodec.MultibyteStreamReader.__delattr__" => "Implement delattr(self, name).",
    "_multibytecodec.MultibyteStreamReader.__eq__" => "Return self==value.",
    "_multibytecodec.MultibyteStreamReader.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_multibytecodec.MultibyteStreamReader.__ge__" => "Return self>=value.",
    "_multibytecodec.MultibyteStreamReader.__getattribute__" => "Return getattr(self, name).",
    "_multibytecodec.MultibyteStreamReader.__getstate__" => "Helper for pickle.",
    "_multibytecodec.MultibyteStreamReader.__gt__" => "Return self>value.",
    "_multibytecodec.MultibyteStreamReader.__hash__" => "Return hash(self).",
    "_multibytecodec.MultibyteStreamReader.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_multibytecodec.MultibyteStreamReader.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_multibytecodec.MultibyteStreamReader.__le__" => "Return self<=value.",
    "_multibytecodec.MultibyteStreamReader.__lt__" => "Return self<value.",
    "_multibytecodec.MultibyteStreamReader.__ne__" => "Return self!=value.",
    "_multibytecodec.MultibyteStreamReader.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_multibytecodec.MultibyteStreamReader.__reduce__" => "Helper for pickle.",
    "_multibytecodec.MultibyteStreamReader.__reduce_ex__" => "Helper for pickle.",
    "_multibytecodec.MultibyteStreamReader.__repr__" => "Return repr(self).",
    "_multibytecodec.MultibyteStreamReader.__setattr__" => "Implement setattr(self, name, value).",
    "_multibytecodec.MultibyteStreamReader.__sizeof__" => "Size of object in memory, in bytes.",
    "_multibytecodec.MultibyteStreamReader.__str__" => "Return str(self).",
    "_multibytecodec.MultibyteStreamReader.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_multibytecodec.MultibyteStreamReader.errors" => "how to treat errors",
    "_multibytecodec.MultibyteStreamWriter.__delattr__" => "Implement delattr(self, name).",
    "_multibytecodec.MultibyteStreamWriter.__eq__" => "Return self==value.",
    "_multibytecodec.MultibyteStreamWriter.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_multibytecodec.MultibyteStreamWriter.__ge__" => "Return self>=value.",
    "_multibytecodec.MultibyteStreamWriter.__getattribute__" => "Return getattr(self, name).",
    "_multibytecodec.MultibyteStreamWriter.__getstate__" => "Helper for pickle.",
    "_multibytecodec.MultibyteStreamWriter.__gt__" => "Return self>value.",
    "_multibytecodec.MultibyteStreamWriter.__hash__" => "Return hash(self).",
    "_multibytecodec.MultibyteStreamWriter.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_multibytecodec.MultibyteStreamWriter.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_multibytecodec.MultibyteStreamWriter.__le__" => "Return self<=value.",
    "_multibytecodec.MultibyteStreamWriter.__lt__" => "Return self<value.",
    "_multibytecodec.MultibyteStreamWriter.__ne__" => "Return self!=value.",
    "_multibytecodec.MultibyteStreamWriter.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_multibytecodec.MultibyteStreamWriter.__reduce__" => "Helper for pickle.",
    "_multibytecodec.MultibyteStreamWriter.__reduce_ex__" => "Helper for pickle.",
    "_multibytecodec.MultibyteStreamWriter.__repr__" => "Return repr(self).",
    "_multibytecodec.MultibyteStreamWriter.__setattr__" => "Implement setattr(self, name, value).",
    "_multibytecodec.MultibyteStreamWriter.__sizeof__" => "Size of object in memory, in bytes.",
    "_multibytecodec.MultibyteStreamWriter.__str__" => "Return str(self).",
    "_multibytecodec.MultibyteStreamWriter.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_multibytecodec.MultibyteStreamWriter.errors" => "how to treat errors",
    "_multiprocessing.SemLock" => "Semaphore/Mutex type",
    "_multiprocessing.SemLock.__delattr__" => "Implement delattr(self, name).",
    "_multiprocessing.SemLock.__enter__" => "Enter the semaphore/lock.",
    "_multiprocessing.SemLock.__eq__" => "Return self==value.",
    "_multiprocessing.SemLock.__exit__" => "Exit the semaphore/lock.",
    "_multiprocessing.SemLock.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_multiprocessing.SemLock.__ge__" => "Return self>=value.",
    "_multiprocessing.SemLock.__getattribute__" => "Return getattr(self, name).",
    "_multiprocessing.SemLock.__getstate__" => "Helper for pickle.",
    "_multiprocessing.SemLock.__gt__" => "Return self>value.",
    "_multiprocessing.SemLock.__hash__" => "Return hash(self).",
    "_multiprocessing.SemLock.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_multiprocessing.SemLock.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_multiprocessing.SemLock.__le__" => "Return self<=value.",
    "_multiprocessing.SemLock.__lt__" => "Return self<value.",
    "_multiprocessing.SemLock.__ne__" => "Return self!=value.",
    "_multiprocessing.SemLock.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_multiprocessing.SemLock.__reduce__" => "Helper for pickle.",
    "_multiprocessing.SemLock.__reduce_ex__" => "Helper for pickle.",
    "_multiprocessing.SemLock.__repr__" => "Return repr(self).",
    "_multiprocessing.SemLock.__setattr__" => "Implement setattr(self, name, value).",
    "_multiprocessing.SemLock.__sizeof__" => "Size of object in memory, in bytes.",
    "_multiprocessing.SemLock.__str__" => "Return str(self).",
    "_multiprocessing.SemLock.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_multiprocessing.SemLock._after_fork" => "Rezero the net acquisition count after fork().",
    "_multiprocessing.SemLock._count" => "Num of `acquire()`s minus num of `release()`s for this process.",
    "_multiprocessing.SemLock._get_value" => "Get the value of the semaphore.",
    "_multiprocessing.SemLock._is_mine" => "Whether the lock is owned by this thread.",
    "_multiprocessing.SemLock._is_zero" => "Return whether semaphore has value zero.",
    "_multiprocessing.SemLock.acquire" => "Acquire the semaphore/lock.",
    "_multiprocessing.SemLock.handle" => "",
    "_multiprocessing.SemLock.kind" => "",
    "_multiprocessing.SemLock.maxvalue" => "",
    "_multiprocessing.SemLock.name" => "",
    "_multiprocessing.SemLock.release" => "Release the semaphore/lock.",
    "_opcode" => "Opcode support module.",
    "_opcode.get_executor" => "Return the executor object at offset in code if exists, None otherwise.",
    "_opcode.get_intrinsic1_descs" => "Return a list of names of the unary intrinsics.",
    "_opcode.get_intrinsic2_descs" => "Return a list of names of the binary intrinsics.",
    "_opcode.get_nb_ops" => "Return array of symbols of binary ops.\n\nIndexed by the BINARY_OP oparg value.",
    "_opcode.get_specialization_stats" => "Return the specialization stats",
    "_opcode.has_arg" => "Return True if the opcode uses its oparg, False otherwise.",
    "_opcode.has_const" => "Return True if the opcode accesses a constant, False otherwise.",
    "_opcode.has_exc" => "Return True if the opcode sets an exception handler, False otherwise.",
    "_opcode.has_free" => "Return True if the opcode accesses a free variable, False otherwise.\n\nNote that 'free' in this context refers to names in the current scope\nthat are referenced by inner scopes or names in outer scopes that are\nreferenced from this scope. It does not include references to global\nor builtin scopes.",
    "_opcode.has_jump" => "Return True if the opcode has a jump target, False otherwise.",
    "_opcode.has_local" => "Return True if the opcode accesses a local variable, False otherwise.",
    "_opcode.has_name" => "Return True if the opcode accesses an attribute by name, False otherwise.",
    "_opcode.is_valid" => "Return True if opcode is valid, False otherwise.",
    "_opcode.stack_effect" => "Compute the stack effect of the opcode.",
    "_operator" => "Operator interface.\n\nThis module exports a set of functions implemented in C corresponding\nto the intrinsic operators of Python.  For example, operator.add(x, y)\nis equivalent to the expression x+y.  The function names are those\nused for special methods; variants without leading and trailing\n'__' are also provided for convenience.",
    "_operator._compare_digest" => "Return 'a == b'.\n\nThis function uses an approach designed to prevent\ntiming analysis, making it appropriate for cryptography.\n\na and b must both be of the same type: either str (ASCII only),\nor any bytes-like object.\n\nNote: If a and b are of different lengths, or if an error occurs,\na timing attack could theoretically reveal information about the\ntypes and lengths of a and b--but not their values.",
    "_operator.abs" => "Same as abs(a).",
    "_operator.add" => "Same as a + b.",
    "_operator.and_" => "Same as a & b.",
    "_operator.call" => "Same as obj(*args, **kwargs).",
    "_operator.concat" => "Same as a + b, for a and b sequences.",
    "_operator.contains" => "Same as b in a (note reversed operands).",
    "_operator.countOf" => "Return the number of items in a which are, or which equal, b.",
    "_operator.delitem" => "Same as del a[b].",
    "_operator.eq" => "Same as a == b.",
    "_operator.floordiv" => "Same as a // b.",
    "_operator.ge" => "Same as a >= b.",
    "_operator.getitem" => "Same as a[b].",
    "_operator.gt" => "Same as a > b.",
    "_operator.iadd" => "Same as a += b.",
    "_operator.iand" => "Same as a &= b.",
    "_operator.iconcat" => "Same as a += b, for a and b sequences.",
    "_operator.ifloordiv" => "Same as a //= b.",
    "_operator.ilshift" => "Same as a <<= b.",
    "_operator.imatmul" => "Same as a @= b.",
    "_operator.imod" => "Same as a %= b.",
    "_operator.imul" => "Same as a *= b.",
    "_operator.index" => "Same as a.__index__()",
    "_operator.indexOf" => "Return the first index of b in a.",
    "_operator.inv" => "Same as ~a.",
    "_operator.invert" => "Same as ~a.",
    "_operator.ior" => "Same as a |= b.",
    "_operator.ipow" => "Same as a **= b.",
    "_operator.irshift" => "Same as a >>= b.",
    "_operator.is_" => "Same as a is b.",
    "_operator.is_not" => "Same as a is not b.",
    "_operator.isub" => "Same as a -= b.",
    "_operator.itruediv" => "Same as a /= b.",
    "_operator.ixor" => "Same as a ^= b.",
    "_operator.le" => "Same as a <= b.",
    "_operator.length_hint" => "Return an estimate of the number of items in obj.\n\nThis is useful for presizing containers when building from an iterable.\n\nIf the object supports len(), the result will be exact.\nOtherwise, it may over- or under-estimate by an arbitrary amount.\nThe result will be an integer >= 0.",
    "_operator.lshift" => "Same as a << b.",
    "_operator.lt" => "Same as a < b.",
    "_operator.matmul" => "Same as a @ b.",
    "_operator.mod" => "Same as a % b.",
    "_operator.mul" => "Same as a * b.",
    "_operator.ne" => "Same as a != b.",
    "_operator.neg" => "Same as -a.",
    "_operator.not_" => "Same as not a.",
    "_operator.or_" => "Same as a | b.",
    "_operator.pos" => "Same as +a.",
    "_operator.pow" => "Same as a ** b.",
    "_operator.rshift" => "Same as a >> b.",
    "_operator.setitem" => "Same as a[b] = c.",
    "_operator.sub" => "Same as a - b.",
    "_operator.truediv" => "Same as a / b.",
    "_operator.truth" => "Return True if a is true, False otherwise.",
    "_operator.xor" => "Same as a ^ b.",
    "_overlapped.BindLocal" => "Bind a socket handle to an arbitrary local port.\n\nfamily should be AF_INET or AF_INET6.",
    "_overlapped.ConnectPipe" => "Connect to the pipe for asynchronous I/O (overlapped).",
    "_overlapped.CreateEvent" => "Create an event.\n\nEventAttributes must be None.",
    "_overlapped.CreateIoCompletionPort" => "Create a completion port or register a handle with a port.",
    "_overlapped.FormatMessage" => "Return error message for an error code.",
    "_overlapped.GetQueuedCompletionStatus" => "Get a message from completion port.\n\nWait for up to msecs milliseconds.",
    "_overlapped.Overlapped" => "OVERLAPPED structure wrapper.",
    "_overlapped.Overlapped.AcceptEx" => "Start overlapped wait for client to connect.",
    "_overlapped.Overlapped.ConnectEx" => "Start overlapped connect.\n\nclient_handle should be unbound.",
    "_overlapped.Overlapped.ConnectNamedPipe" => "Start overlapped wait for a client to connect.",
    "_overlapped.Overlapped.ReadFile" => "Start overlapped read.",
    "_overlapped.Overlapped.ReadFileInto" => "Start overlapped receive.",
    "_overlapped.Overlapped.TransmitFile" => "Transmit file data over a connected socket.",
    "_overlapped.Overlapped.WSARecv" => "Start overlapped receive.",
    "_overlapped.Overlapped.WSARecvFrom" => "Start overlapped receive.",
    "_overlapped.Overlapped.WSARecvFromInto" => "Start overlapped receive.",
    "_overlapped.Overlapped.WSARecvInto" => "Start overlapped receive.",
    "_overlapped.Overlapped.WSASend" => "Start overlapped send.",
    "_overlapped.Overlapped.WSASendTo" => "Start overlapped sendto over a connectionless (UDP) socket.",
    "_overlapped.Overlapped.WriteFile" => "Start overlapped write.",
    "_overlapped.Overlapped.__delattr__" => "Implement delattr(self, name).",
    "_overlapped.Overlapped.__eq__" => "Return self==value.",
    "_overlapped.Overlapped.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_overlapped.Overlapped.__ge__" => "Return self>=value.",
    "_overlapped.Overlapped.__getattribute__" => "Return getattr(self, name).",
    "_overlapped.Overlapped.__getstate__" => "Helper for pickle.",
    "_overlapped.Overlapped.__gt__" => "Return self>value.",
    "_overlapped.Overlapped.__hash__" => "Return hash(self).",
    "_overlapped.Overlapped.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_overlapped.Overlapped.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_overlapped.Overlapped.__le__" => "Return self<=value.",
    "_overlapped.Overlapped.__lt__" => "Return self<value.",
    "_overlapped.Overlapped.__ne__" => "Return self!=value.",
    "_overlapped.Overlapped.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_overlapped.Overlapped.__reduce__" => "Helper for pickle.",
    "_overlapped.Overlapped.__reduce_ex__" => "Helper for pickle.",
    "_overlapped.Overlapped.__repr__" => "Return repr(self).",
    "_overlapped.Overlapped.__setattr__" => "Implement setattr(self, name, value).",
    "_overlapped.Overlapped.__sizeof__" => "Size of object in memory, in bytes.",
    "_overlapped.Overlapped.__str__" => "Return str(self).",
    "_overlapped.Overlapped.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_overlapped.Overlapped.address" => "Address of overlapped structure",
    "_overlapped.Overlapped.cancel" => "Cancel overlapped operation.",
    "_overlapped.Overlapped.error" => "Error from last operation",
    "_overlapped.Overlapped.event" => "Overlapped event handle",
    "_overlapped.Overlapped.getresult" => "Retrieve result of operation.\n\nIf wait is true then it blocks until the operation is finished.  If wait\nis false and the operation is still pending then an error is raised.",
    "_overlapped.Overlapped.pending" => "Whether the operation is pending",
    "_overlapped.PostQueuedCompletionStatus" => "Post a message to completion port.",
    "_overlapped.RegisterWaitWithQueue" => "Register wait for Object; when complete CompletionPort is notified.",
    "_overlapped.ResetEvent" => "Reset event.",
    "_overlapped.SetEvent" => "Set event.",
    "_overlapped.UnregisterWait" => "Unregister wait handle.",
    "_overlapped.UnregisterWaitEx" => "Unregister wait handle.",
    "_overlapped.WSAConnect" => "Bind a remote address to a connectionless (UDP) socket.",
    "_pickle" => "Optimized C implementation for the Python pickle module.",
    "_pickle.PickleError.__cause__" => "exception cause",
    "_pickle.PickleError.__context__" => "exception context",
    "_pickle.PickleError.__delattr__" => "Implement delattr(self, name).",
    "_pickle.PickleError.__eq__" => "Return self==value.",
    "_pickle.PickleError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_pickle.PickleError.__ge__" => "Return self>=value.",
    "_pickle.PickleError.__getattribute__" => "Return getattr(self, name).",
    "_pickle.PickleError.__getstate__" => "Helper for pickle.",
    "_pickle.PickleError.__gt__" => "Return self>value.",
    "_pickle.PickleError.__hash__" => "Return hash(self).",
    "_pickle.PickleError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_pickle.PickleError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_pickle.PickleError.__le__" => "Return self<=value.",
    "_pickle.PickleError.__lt__" => "Return self<value.",
    "_pickle.PickleError.__ne__" => "Return self!=value.",
    "_pickle.PickleError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_pickle.PickleError.__reduce_ex__" => "Helper for pickle.",
    "_pickle.PickleError.__repr__" => "Return repr(self).",
    "_pickle.PickleError.__setattr__" => "Implement setattr(self, name, value).",
    "_pickle.PickleError.__sizeof__" => "Size of object in memory, in bytes.",
    "_pickle.PickleError.__str__" => "Return str(self).",
    "_pickle.PickleError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_pickle.PickleError.__weakref__" => "list of weak references to the object",
    "_pickle.PickleError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_pickle.PickleError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_pickle.Pickler" => "This takes a binary file for writing a pickle data stream.\n\nThe optional *protocol* argument tells the pickler to use the given\nprotocol; supported protocols are 0, 1, 2, 3, 4 and 5.  The default\nprotocol is 4. It was introduced in Python 3.4, and is incompatible\nwith previous versions.\n\nSpecifying a negative protocol version selects the highest protocol\nversion supported.  The higher the protocol used, the more recent the\nversion of Python needed to read the pickle produced.\n\nThe *file* argument must have a write() method that accepts a single\nbytes argument. It can thus be a file object opened for binary\nwriting, an io.BytesIO instance, or any other custom object that meets\nthis interface.\n\nIf *fix_imports* is True and protocol is less than 3, pickle will try\nto map the new Python 3 names to the old module names used in Python\n2, so that the pickle data stream is readable with Python 2.\n\nIf *buffer_callback* is None (the default), buffer views are\nserialized into *file* as part of the pickle stream.\n\nIf *buffer_callback* is not None, then it can be called any number\nof times with a buffer view.  If the callback returns a false value\n(such as None), the given buffer is out-of-band; otherwise the\nbuffer is serialized in-band, i.e. inside the pickle stream.\n\nIt is an error if *buffer_callback* is not None and *protocol*\nis None or smaller than 5.",
    "_pickle.Pickler.__delattr__" => "Implement delattr(self, name).",
    "_pickle.Pickler.__eq__" => "Return self==value.",
    "_pickle.Pickler.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_pickle.Pickler.__ge__" => "Return self>=value.",
    "_pickle.Pickler.__getattribute__" => "Return getattr(self, name).",
    "_pickle.Pickler.__getstate__" => "Helper for pickle.",
    "_pickle.Pickler.__gt__" => "Return self>value.",
    "_pickle.Pickler.__hash__" => "Return hash(self).",
    "_pickle.Pickler.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_pickle.Pickler.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_pickle.Pickler.__le__" => "Return self<=value.",
    "_pickle.Pickler.__lt__" => "Return self<value.",
    "_pickle.Pickler.__ne__" => "Return self!=value.",
    "_pickle.Pickler.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_pickle.Pickler.__reduce__" => "Helper for pickle.",
    "_pickle.Pickler.__reduce_ex__" => "Helper for pickle.",
    "_pickle.Pickler.__repr__" => "Return repr(self).",
    "_pickle.Pickler.__setattr__" => "Implement setattr(self, name, value).",
    "_pickle.Pickler.__sizeof__" => "Returns size in memory, in bytes.",
    "_pickle.Pickler.__str__" => "Return str(self).",
    "_pickle.Pickler.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_pickle.Pickler.clear_memo" => "Clears the pickler's \"memo\".\n\nThe memo is the data structure that remembers which objects the\npickler has already seen, so that shared or recursive objects are\npickled by reference and not by value.  This method is useful when\nre-using picklers.",
    "_pickle.Pickler.dump" => "Write a pickled representation of the given object to the open file.",
    "_pickle.PicklingError.__cause__" => "exception cause",
    "_pickle.PicklingError.__context__" => "exception context",
    "_pickle.PicklingError.__delattr__" => "Implement delattr(self, name).",
    "_pickle.PicklingError.__eq__" => "Return self==value.",
    "_pickle.PicklingError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_pickle.PicklingError.__ge__" => "Return self>=value.",
    "_pickle.PicklingError.__getattribute__" => "Return getattr(self, name).",
    "_pickle.PicklingError.__getstate__" => "Helper for pickle.",
    "_pickle.PicklingError.__gt__" => "Return self>value.",
    "_pickle.PicklingError.__hash__" => "Return hash(self).",
    "_pickle.PicklingError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_pickle.PicklingError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_pickle.PicklingError.__le__" => "Return self<=value.",
    "_pickle.PicklingError.__lt__" => "Return self<value.",
    "_pickle.PicklingError.__ne__" => "Return self!=value.",
    "_pickle.PicklingError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_pickle.PicklingError.__reduce_ex__" => "Helper for pickle.",
    "_pickle.PicklingError.__repr__" => "Return repr(self).",
    "_pickle.PicklingError.__setattr__" => "Implement setattr(self, name, value).",
    "_pickle.PicklingError.__sizeof__" => "Size of object in memory, in bytes.",
    "_pickle.PicklingError.__str__" => "Return str(self).",
    "_pickle.PicklingError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_pickle.PicklingError.__weakref__" => "list of weak references to the object",
    "_pickle.PicklingError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_pickle.PicklingError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_pickle.Unpickler" => "This takes a binary file for reading a pickle data stream.\n\nThe protocol version of the pickle is detected automatically, so no\nprotocol argument is needed.  Bytes past the pickled object's\nrepresentation are ignored.\n\nThe argument *file* must have two methods, a read() method that takes\nan integer argument, and a readline() method that requires no\narguments.  Both methods should return bytes.  Thus *file* can be a\nbinary file object opened for reading, an io.BytesIO object, or any\nother custom object that meets this interface.\n\nOptional keyword arguments are *fix_imports*, *encoding* and *errors*,\nwhich are used to control compatibility support for pickle stream\ngenerated by Python 2.  If *fix_imports* is True, pickle will try to\nmap the old Python 2 names to the new names used in Python 3.  The\n*encoding* and *errors* tell pickle how to decode 8-bit string\ninstances pickled by Python 2; these default to 'ASCII' and 'strict',\nrespectively.  The *encoding* can be 'bytes' to read these 8-bit\nstring instances as bytes objects.",
    "_pickle.Unpickler.__delattr__" => "Implement delattr(self, name).",
    "_pickle.Unpickler.__eq__" => "Return self==value.",
    "_pickle.Unpickler.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_pickle.Unpickler.__ge__" => "Return self>=value.",
    "_pickle.Unpickler.__getattribute__" => "Return getattr(self, name).",
    "_pickle.Unpickler.__getstate__" => "Helper for pickle.",
    "_pickle.Unpickler.__gt__" => "Return self>value.",
    "_pickle.Unpickler.__hash__" => "Return hash(self).",
    "_pickle.Unpickler.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_pickle.Unpickler.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_pickle.Unpickler.__le__" => "Return self<=value.",
    "_pickle.Unpickler.__lt__" => "Return self<value.",
    "_pickle.Unpickler.__ne__" => "Return self!=value.",
    "_pickle.Unpickler.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_pickle.Unpickler.__reduce__" => "Helper for pickle.",
    "_pickle.Unpickler.__reduce_ex__" => "Helper for pickle.",
    "_pickle.Unpickler.__repr__" => "Return repr(self).",
    "_pickle.Unpickler.__setattr__" => "Implement setattr(self, name, value).",
    "_pickle.Unpickler.__sizeof__" => "Returns size in memory, in bytes.",
    "_pickle.Unpickler.__str__" => "Return str(self).",
    "_pickle.Unpickler.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_pickle.Unpickler.find_class" => "Return an object from a specified module.\n\nIf necessary, the module will be imported. Subclasses may override\nthis method (e.g. to restrict unpickling of arbitrary classes and\nfunctions).\n\nThis method is called whenever a class or a function object is\nneeded.  Both arguments passed are str objects.",
    "_pickle.Unpickler.load" => "Load a pickle.\n\nRead a pickled object representation from the open file object given\nin the constructor, and return the reconstituted object hierarchy\nspecified therein.",
    "_pickle.UnpicklingError.__cause__" => "exception cause",
    "_pickle.UnpicklingError.__context__" => "exception context",
    "_pickle.UnpicklingError.__delattr__" => "Implement delattr(self, name).",
    "_pickle.UnpicklingError.__eq__" => "Return self==value.",
    "_pickle.UnpicklingError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_pickle.UnpicklingError.__ge__" => "Return self>=value.",
    "_pickle.UnpicklingError.__getattribute__" => "Return getattr(self, name).",
    "_pickle.UnpicklingError.__getstate__" => "Helper for pickle.",
    "_pickle.UnpicklingError.__gt__" => "Return self>value.",
    "_pickle.UnpicklingError.__hash__" => "Return hash(self).",
    "_pickle.UnpicklingError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_pickle.UnpicklingError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_pickle.UnpicklingError.__le__" => "Return self<=value.",
    "_pickle.UnpicklingError.__lt__" => "Return self<value.",
    "_pickle.UnpicklingError.__ne__" => "Return self!=value.",
    "_pickle.UnpicklingError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_pickle.UnpicklingError.__reduce_ex__" => "Helper for pickle.",
    "_pickle.UnpicklingError.__repr__" => "Return repr(self).",
    "_pickle.UnpicklingError.__setattr__" => "Implement setattr(self, name, value).",
    "_pickle.UnpicklingError.__sizeof__" => "Size of object in memory, in bytes.",
    "_pickle.UnpicklingError.__str__" => "Return str(self).",
    "_pickle.UnpicklingError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_pickle.UnpicklingError.__weakref__" => "list of weak references to the object",
    "_pickle.UnpicklingError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_pickle.UnpicklingError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_pickle.dump" => "Write a pickled representation of obj to the open file object file.\n\nThis is equivalent to ``Pickler(file, protocol).dump(obj)``, but may\nbe more efficient.\n\nThe optional *protocol* argument tells the pickler to use the given\nprotocol; supported protocols are 0, 1, 2, 3, 4 and 5.  The default\nprotocol is 4. It was introduced in Python 3.4, and is incompatible\nwith previous versions.\n\nSpecifying a negative protocol version selects the highest protocol\nversion supported.  The higher the protocol used, the more recent the\nversion of Python needed to read the pickle produced.\n\nThe *file* argument must have a write() method that accepts a single\nbytes argument.  It can thus be a file object opened for binary\nwriting, an io.BytesIO instance, or any other custom object that meets\nthis interface.\n\nIf *fix_imports* is True and protocol is less than 3, pickle will try\nto map the new Python 3 names to the old module names used in Python\n2, so that the pickle data stream is readable with Python 2.\n\nIf *buffer_callback* is None (the default), buffer views are serialized\ninto *file* as part of the pickle stream.  It is an error if\n*buffer_callback* is not None and *protocol* is None or smaller than 5.",
    "_pickle.dumps" => "Return the pickled representation of the object as a bytes object.\n\nThe optional *protocol* argument tells the pickler to use the given\nprotocol; supported protocols are 0, 1, 2, 3, 4 and 5.  The default\nprotocol is 4. It was introduced in Python 3.4, and is incompatible\nwith previous versions.\n\nSpecifying a negative protocol version selects the highest protocol\nversion supported.  The higher the protocol used, the more recent the\nversion of Python needed to read the pickle produced.\n\nIf *fix_imports* is True and *protocol* is less than 3, pickle will\ntry to map the new Python 3 names to the old module names used in\nPython 2, so that the pickle data stream is readable with Python 2.\n\nIf *buffer_callback* is None (the default), buffer views are serialized\ninto *file* as part of the pickle stream.  It is an error if\n*buffer_callback* is not None and *protocol* is None or smaller than 5.",
    "_pickle.load" => "Read and return an object from the pickle data stored in a file.\n\nThis is equivalent to ``Unpickler(file).load()``, but may be more\nefficient.\n\nThe protocol version of the pickle is detected automatically, so no\nprotocol argument is needed.  Bytes past the pickled object's\nrepresentation are ignored.\n\nThe argument *file* must have two methods, a read() method that takes\nan integer argument, and a readline() method that requires no\narguments.  Both methods should return bytes.  Thus *file* can be a\nbinary file object opened for reading, an io.BytesIO object, or any\nother custom object that meets this interface.\n\nOptional keyword arguments are *fix_imports*, *encoding* and *errors*,\nwhich are used to control compatibility support for pickle stream\ngenerated by Python 2.  If *fix_imports* is True, pickle will try to\nmap the old Python 2 names to the new names used in Python 3.  The\n*encoding* and *errors* tell pickle how to decode 8-bit string\ninstances pickled by Python 2; these default to 'ASCII' and 'strict',\nrespectively.  The *encoding* can be 'bytes' to read these 8-bit\nstring instances as bytes objects.",
    "_pickle.loads" => "Read and return an object from the given pickle data.\n\nThe protocol version of the pickle is detected automatically, so no\nprotocol argument is needed.  Bytes past the pickled object's\nrepresentation are ignored.\n\nOptional keyword arguments are *fix_imports*, *encoding* and *errors*,\nwhich are used to control compatibility support for pickle stream\ngenerated by Python 2.  If *fix_imports* is True, pickle will try to\nmap the old Python 2 names to the new names used in Python 3.  The\n*encoding* and *errors* tell pickle how to decode 8-bit string\ninstances pickled by Python 2; these default to 'ASCII' and 'strict',\nrespectively.  The *encoding* can be 'bytes' to read these 8-bit\nstring instances as bytes objects.",
    "_posixshmem" => "POSIX shared memory module",
    "_posixshmem.shm_open" => "Open a shared memory object.  Returns a file descriptor (integer).",
    "_posixshmem.shm_unlink" => "Remove a shared memory object (similar to unlink()).\n\nRemove a shared memory object name, and, once all processes  have  unmapped\nthe object, de-allocates and destroys the contents of the associated memory\nregion.",
    "_posixsubprocess" => "A POSIX helper for the subprocess module.",
    "_posixsubprocess.fork_exec" => "Spawn a fresh new child process.\n\nFork a child process, close parent file descriptors as appropriate in the\nchild and duplicate the few that are needed before calling exec() in the\nchild process.\n\nIf close_fds is True, close file descriptors 3 and higher, except those listed\nin the sorted tuple pass_fds.\n\nThe preexec_fn, if supplied, will be called immediately before closing file\ndescriptors and exec.\n\nWARNING: preexec_fn is NOT SAFE if your application uses threads.\n         It may trigger infrequent, difficult to debug deadlocks.\n\nIf an error occurs in the child process before the exec, it is\nserialized and written to the errpipe_write fd per subprocess.py.\n\nReturns: the child process's PID.\n\nRaises: Only on an error in the parent process.",
    "_queue" => "C implementation of the Python queue module.\nThis module is an implementation detail, please do not use it directly.",
    "_queue.Empty" => "Exception raised by Queue.get(block=0)/get_nowait().",
    "_queue.Empty.__cause__" => "exception cause",
    "_queue.Empty.__context__" => "exception context",
    "_queue.Empty.__delattr__" => "Implement delattr(self, name).",
    "_queue.Empty.__eq__" => "Return self==value.",
    "_queue.Empty.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_queue.Empty.__ge__" => "Return self>=value.",
    "_queue.Empty.__getattribute__" => "Return getattr(self, name).",
    "_queue.Empty.__getstate__" => "Helper for pickle.",
    "_queue.Empty.__gt__" => "Return self>value.",
    "_queue.Empty.__hash__" => "Return hash(self).",
    "_queue.Empty.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_queue.Empty.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_queue.Empty.__le__" => "Return self<=value.",
    "_queue.Empty.__lt__" => "Return self<value.",
    "_queue.Empty.__ne__" => "Return self!=value.",
    "_queue.Empty.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_queue.Empty.__reduce_ex__" => "Helper for pickle.",
    "_queue.Empty.__repr__" => "Return repr(self).",
    "_queue.Empty.__setattr__" => "Implement setattr(self, name, value).",
    "_queue.Empty.__sizeof__" => "Size of object in memory, in bytes.",
    "_queue.Empty.__str__" => "Return str(self).",
    "_queue.Empty.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_queue.Empty.__weakref__" => "list of weak references to the object",
    "_queue.Empty.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_queue.Empty.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_queue.SimpleQueue" => "Simple, unbounded, reentrant FIFO queue.",
    "_queue.SimpleQueue.__class_getitem__" => "See PEP 585",
    "_queue.SimpleQueue.__delattr__" => "Implement delattr(self, name).",
    "_queue.SimpleQueue.__eq__" => "Return self==value.",
    "_queue.SimpleQueue.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_queue.SimpleQueue.__ge__" => "Return self>=value.",
    "_queue.SimpleQueue.__getattribute__" => "Return getattr(self, name).",
    "_queue.SimpleQueue.__getstate__" => "Helper for pickle.",
    "_queue.SimpleQueue.__gt__" => "Return self>value.",
    "_queue.SimpleQueue.__hash__" => "Return hash(self).",
    "_queue.SimpleQueue.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_queue.SimpleQueue.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_queue.SimpleQueue.__le__" => "Return self<=value.",
    "_queue.SimpleQueue.__lt__" => "Return self<value.",
    "_queue.SimpleQueue.__ne__" => "Return self!=value.",
    "_queue.SimpleQueue.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_queue.SimpleQueue.__reduce__" => "Helper for pickle.",
    "_queue.SimpleQueue.__reduce_ex__" => "Helper for pickle.",
    "_queue.SimpleQueue.__repr__" => "Return repr(self).",
    "_queue.SimpleQueue.__setattr__" => "Implement setattr(self, name, value).",
    "_queue.SimpleQueue.__sizeof__" => "Size of object in memory, in bytes.",
    "_queue.SimpleQueue.__str__" => "Return str(self).",
    "_queue.SimpleQueue.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_queue.SimpleQueue.empty" => "Return True if the queue is empty, False otherwise (not reliable!).",
    "_queue.SimpleQueue.get" => "Remove and return an item from the queue.\n\nIf optional args 'block' is true and 'timeout' is None (the default),\nblock if necessary until an item is available. If 'timeout' is\na non-negative number, it blocks at most 'timeout' seconds and raises\nthe Empty exception if no item was available within that time.\nOtherwise ('block' is false), return an item if one is immediately\navailable, else raise the Empty exception ('timeout' is ignored\nin that case).",
    "_queue.SimpleQueue.get_nowait" => "Remove and return an item from the queue without blocking.\n\nOnly get an item if one is immediately available. Otherwise\nraise the Empty exception.",
    "_queue.SimpleQueue.put" => "Put the item on the queue.\n\nThe optional 'block' and 'timeout' arguments are ignored, as this method\nnever blocks.  They are provided for compatibility with the Queue class.",
    "_queue.SimpleQueue.put_nowait" => "Put an item into the queue without blocking.\n\nThis is exactly equivalent to `put(item)` and is only provided\nfor compatibility with the Queue class.",
    "_queue.SimpleQueue.qsize" => "Return the approximate size of the queue (not reliable!).",
    "_random" => "Module implements the Mersenne Twister random number generator.",
    "_random.Random" => "Random() -> create a random number generator with its own internal state.",
    "_random.Random.__delattr__" => "Implement delattr(self, name).",
    "_random.Random.__eq__" => "Return self==value.",
    "_random.Random.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_random.Random.__ge__" => "Return self>=value.",
    "_random.Random.__getattribute__" => "Return getattr(self, name).",
    "_random.Random.__getstate__" => "Helper for pickle.",
    "_random.Random.__gt__" => "Return self>value.",
    "_random.Random.__hash__" => "Return hash(self).",
    "_random.Random.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_random.Random.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_random.Random.__le__" => "Return self<=value.",
    "_random.Random.__lt__" => "Return self<value.",
    "_random.Random.__ne__" => "Return self!=value.",
    "_random.Random.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_random.Random.__reduce__" => "Helper for pickle.",
    "_random.Random.__reduce_ex__" => "Helper for pickle.",
    "_random.Random.__repr__" => "Return repr(self).",
    "_random.Random.__setattr__" => "Implement setattr(self, name, value).",
    "_random.Random.__sizeof__" => "Size of object in memory, in bytes.",
    "_random.Random.__str__" => "Return str(self).",
    "_random.Random.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_random.Random.getrandbits" => "getrandbits(k) -> x.  Generates an int with k random bits.",
    "_random.Random.getstate" => "getstate() -> tuple containing the current state.",
    "_random.Random.random" => "random() -> x in the interval [0, 1).",
    "_random.Random.seed" => "seed([n]) -> None.\n\nDefaults to use urandom and falls back to a combination\nof the current time and the process identifier.",
    "_random.Random.setstate" => "setstate(state) -> None.  Restores generator state.",
    "_sha1.SHA1Type.__delattr__" => "Implement delattr(self, name).",
    "_sha1.SHA1Type.__eq__" => "Return self==value.",
    "_sha1.SHA1Type.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha1.SHA1Type.__ge__" => "Return self>=value.",
    "_sha1.SHA1Type.__getattribute__" => "Return getattr(self, name).",
    "_sha1.SHA1Type.__getstate__" => "Helper for pickle.",
    "_sha1.SHA1Type.__gt__" => "Return self>value.",
    "_sha1.SHA1Type.__hash__" => "Return hash(self).",
    "_sha1.SHA1Type.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha1.SHA1Type.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha1.SHA1Type.__le__" => "Return self<=value.",
    "_sha1.SHA1Type.__lt__" => "Return self<value.",
    "_sha1.SHA1Type.__ne__" => "Return self!=value.",
    "_sha1.SHA1Type.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha1.SHA1Type.__reduce__" => "Helper for pickle.",
    "_sha1.SHA1Type.__reduce_ex__" => "Helper for pickle.",
    "_sha1.SHA1Type.__repr__" => "Return repr(self).",
    "_sha1.SHA1Type.__setattr__" => "Implement setattr(self, name, value).",
    "_sha1.SHA1Type.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha1.SHA1Type.__str__" => "Return str(self).",
    "_sha1.SHA1Type.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha1.SHA1Type.copy" => "Return a copy of the hash object.",
    "_sha1.SHA1Type.digest" => "Return the digest value as a bytes object.",
    "_sha1.SHA1Type.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha1.SHA1Type.update" => "Update this hash object's state with the provided string.",
    "_sha1.sha1" => "Return a new SHA1 hash object; optionally initialized with a string.",
    "_sha2.SHA224Type.__delattr__" => "Implement delattr(self, name).",
    "_sha2.SHA224Type.__eq__" => "Return self==value.",
    "_sha2.SHA224Type.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha2.SHA224Type.__ge__" => "Return self>=value.",
    "_sha2.SHA224Type.__getattribute__" => "Return getattr(self, name).",
    "_sha2.SHA224Type.__getstate__" => "Helper for pickle.",
    "_sha2.SHA224Type.__gt__" => "Return self>value.",
    "_sha2.SHA224Type.__hash__" => "Return hash(self).",
    "_sha2.SHA224Type.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha2.SHA224Type.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha2.SHA224Type.__le__" => "Return self<=value.",
    "_sha2.SHA224Type.__lt__" => "Return self<value.",
    "_sha2.SHA224Type.__ne__" => "Return self!=value.",
    "_sha2.SHA224Type.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha2.SHA224Type.__reduce__" => "Helper for pickle.",
    "_sha2.SHA224Type.__reduce_ex__" => "Helper for pickle.",
    "_sha2.SHA224Type.__repr__" => "Return repr(self).",
    "_sha2.SHA224Type.__setattr__" => "Implement setattr(self, name, value).",
    "_sha2.SHA224Type.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha2.SHA224Type.__str__" => "Return str(self).",
    "_sha2.SHA224Type.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha2.SHA224Type.copy" => "Return a copy of the hash object.",
    "_sha2.SHA224Type.digest" => "Return the digest value as a bytes object.",
    "_sha2.SHA224Type.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha2.SHA224Type.update" => "Update this hash object's state with the provided string.",
    "_sha2.SHA256Type.__delattr__" => "Implement delattr(self, name).",
    "_sha2.SHA256Type.__eq__" => "Return self==value.",
    "_sha2.SHA256Type.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha2.SHA256Type.__ge__" => "Return self>=value.",
    "_sha2.SHA256Type.__getattribute__" => "Return getattr(self, name).",
    "_sha2.SHA256Type.__getstate__" => "Helper for pickle.",
    "_sha2.SHA256Type.__gt__" => "Return self>value.",
    "_sha2.SHA256Type.__hash__" => "Return hash(self).",
    "_sha2.SHA256Type.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha2.SHA256Type.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha2.SHA256Type.__le__" => "Return self<=value.",
    "_sha2.SHA256Type.__lt__" => "Return self<value.",
    "_sha2.SHA256Type.__ne__" => "Return self!=value.",
    "_sha2.SHA256Type.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha2.SHA256Type.__reduce__" => "Helper for pickle.",
    "_sha2.SHA256Type.__reduce_ex__" => "Helper for pickle.",
    "_sha2.SHA256Type.__repr__" => "Return repr(self).",
    "_sha2.SHA256Type.__setattr__" => "Implement setattr(self, name, value).",
    "_sha2.SHA256Type.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha2.SHA256Type.__str__" => "Return str(self).",
    "_sha2.SHA256Type.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha2.SHA256Type.copy" => "Return a copy of the hash object.",
    "_sha2.SHA256Type.digest" => "Return the digest value as a bytes object.",
    "_sha2.SHA256Type.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha2.SHA256Type.update" => "Update this hash object's state with the provided string.",
    "_sha2.SHA384Type.__delattr__" => "Implement delattr(self, name).",
    "_sha2.SHA384Type.__eq__" => "Return self==value.",
    "_sha2.SHA384Type.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha2.SHA384Type.__ge__" => "Return self>=value.",
    "_sha2.SHA384Type.__getattribute__" => "Return getattr(self, name).",
    "_sha2.SHA384Type.__getstate__" => "Helper for pickle.",
    "_sha2.SHA384Type.__gt__" => "Return self>value.",
    "_sha2.SHA384Type.__hash__" => "Return hash(self).",
    "_sha2.SHA384Type.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha2.SHA384Type.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha2.SHA384Type.__le__" => "Return self<=value.",
    "_sha2.SHA384Type.__lt__" => "Return self<value.",
    "_sha2.SHA384Type.__ne__" => "Return self!=value.",
    "_sha2.SHA384Type.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha2.SHA384Type.__reduce__" => "Helper for pickle.",
    "_sha2.SHA384Type.__reduce_ex__" => "Helper for pickle.",
    "_sha2.SHA384Type.__repr__" => "Return repr(self).",
    "_sha2.SHA384Type.__setattr__" => "Implement setattr(self, name, value).",
    "_sha2.SHA384Type.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha2.SHA384Type.__str__" => "Return str(self).",
    "_sha2.SHA384Type.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha2.SHA384Type.copy" => "Return a copy of the hash object.",
    "_sha2.SHA384Type.digest" => "Return the digest value as a bytes object.",
    "_sha2.SHA384Type.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha2.SHA384Type.update" => "Update this hash object's state with the provided string.",
    "_sha2.SHA512Type.__delattr__" => "Implement delattr(self, name).",
    "_sha2.SHA512Type.__eq__" => "Return self==value.",
    "_sha2.SHA512Type.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha2.SHA512Type.__ge__" => "Return self>=value.",
    "_sha2.SHA512Type.__getattribute__" => "Return getattr(self, name).",
    "_sha2.SHA512Type.__getstate__" => "Helper for pickle.",
    "_sha2.SHA512Type.__gt__" => "Return self>value.",
    "_sha2.SHA512Type.__hash__" => "Return hash(self).",
    "_sha2.SHA512Type.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha2.SHA512Type.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha2.SHA512Type.__le__" => "Return self<=value.",
    "_sha2.SHA512Type.__lt__" => "Return self<value.",
    "_sha2.SHA512Type.__ne__" => "Return self!=value.",
    "_sha2.SHA512Type.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha2.SHA512Type.__reduce__" => "Helper for pickle.",
    "_sha2.SHA512Type.__reduce_ex__" => "Helper for pickle.",
    "_sha2.SHA512Type.__repr__" => "Return repr(self).",
    "_sha2.SHA512Type.__setattr__" => "Implement setattr(self, name, value).",
    "_sha2.SHA512Type.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha2.SHA512Type.__str__" => "Return str(self).",
    "_sha2.SHA512Type.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha2.SHA512Type.copy" => "Return a copy of the hash object.",
    "_sha2.SHA512Type.digest" => "Return the digest value as a bytes object.",
    "_sha2.SHA512Type.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha2.SHA512Type.update" => "Update this hash object's state with the provided string.",
    "_sha2.sha224" => "Return a new SHA-224 hash object; optionally initialized with a string.",
    "_sha2.sha256" => "Return a new SHA-256 hash object; optionally initialized with a string.",
    "_sha2.sha384" => "Return a new SHA-384 hash object; optionally initialized with a string.",
    "_sha2.sha512" => "Return a new SHA-512 hash object; optionally initialized with a string.",
    "_sha3.sha3_224" => "sha3_224([data], *, usedforsecurity=True) -> SHA3 object\n\nReturn a new SHA3 hash object with a hashbit length of 28 bytes.",
    "_sha3.sha3_224.__delattr__" => "Implement delattr(self, name).",
    "_sha3.sha3_224.__eq__" => "Return self==value.",
    "_sha3.sha3_224.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha3.sha3_224.__ge__" => "Return self>=value.",
    "_sha3.sha3_224.__getattribute__" => "Return getattr(self, name).",
    "_sha3.sha3_224.__getstate__" => "Helper for pickle.",
    "_sha3.sha3_224.__gt__" => "Return self>value.",
    "_sha3.sha3_224.__hash__" => "Return hash(self).",
    "_sha3.sha3_224.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha3.sha3_224.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha3.sha3_224.__le__" => "Return self<=value.",
    "_sha3.sha3_224.__lt__" => "Return self<value.",
    "_sha3.sha3_224.__ne__" => "Return self!=value.",
    "_sha3.sha3_224.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha3.sha3_224.__reduce__" => "Helper for pickle.",
    "_sha3.sha3_224.__reduce_ex__" => "Helper for pickle.",
    "_sha3.sha3_224.__repr__" => "Return repr(self).",
    "_sha3.sha3_224.__setattr__" => "Implement setattr(self, name, value).",
    "_sha3.sha3_224.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha3.sha3_224.__str__" => "Return str(self).",
    "_sha3.sha3_224.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha3.sha3_224.copy" => "Return a copy of the hash object.",
    "_sha3.sha3_224.digest" => "Return the digest value as a bytes object.",
    "_sha3.sha3_224.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha3.sha3_224.update" => "Update this hash object's state with the provided bytes-like object.",
    "_sha3.sha3_256" => "sha3_256([data], *, usedforsecurity=True) -> SHA3 object\n\nReturn a new SHA3 hash object with a hashbit length of 32 bytes.",
    "_sha3.sha3_256.__delattr__" => "Implement delattr(self, name).",
    "_sha3.sha3_256.__eq__" => "Return self==value.",
    "_sha3.sha3_256.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha3.sha3_256.__ge__" => "Return self>=value.",
    "_sha3.sha3_256.__getattribute__" => "Return getattr(self, name).",
    "_sha3.sha3_256.__getstate__" => "Helper for pickle.",
    "_sha3.sha3_256.__gt__" => "Return self>value.",
    "_sha3.sha3_256.__hash__" => "Return hash(self).",
    "_sha3.sha3_256.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha3.sha3_256.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha3.sha3_256.__le__" => "Return self<=value.",
    "_sha3.sha3_256.__lt__" => "Return self<value.",
    "_sha3.sha3_256.__ne__" => "Return self!=value.",
    "_sha3.sha3_256.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha3.sha3_256.__reduce__" => "Helper for pickle.",
    "_sha3.sha3_256.__reduce_ex__" => "Helper for pickle.",
    "_sha3.sha3_256.__repr__" => "Return repr(self).",
    "_sha3.sha3_256.__setattr__" => "Implement setattr(self, name, value).",
    "_sha3.sha3_256.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha3.sha3_256.__str__" => "Return str(self).",
    "_sha3.sha3_256.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha3.sha3_256.copy" => "Return a copy of the hash object.",
    "_sha3.sha3_256.digest" => "Return the digest value as a bytes object.",
    "_sha3.sha3_256.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha3.sha3_256.update" => "Update this hash object's state with the provided bytes-like object.",
    "_sha3.sha3_384" => "sha3_384([data], *, usedforsecurity=True) -> SHA3 object\n\nReturn a new SHA3 hash object with a hashbit length of 48 bytes.",
    "_sha3.sha3_384.__delattr__" => "Implement delattr(self, name).",
    "_sha3.sha3_384.__eq__" => "Return self==value.",
    "_sha3.sha3_384.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha3.sha3_384.__ge__" => "Return self>=value.",
    "_sha3.sha3_384.__getattribute__" => "Return getattr(self, name).",
    "_sha3.sha3_384.__getstate__" => "Helper for pickle.",
    "_sha3.sha3_384.__gt__" => "Return self>value.",
    "_sha3.sha3_384.__hash__" => "Return hash(self).",
    "_sha3.sha3_384.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha3.sha3_384.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha3.sha3_384.__le__" => "Return self<=value.",
    "_sha3.sha3_384.__lt__" => "Return self<value.",
    "_sha3.sha3_384.__ne__" => "Return self!=value.",
    "_sha3.sha3_384.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha3.sha3_384.__reduce__" => "Helper for pickle.",
    "_sha3.sha3_384.__reduce_ex__" => "Helper for pickle.",
    "_sha3.sha3_384.__repr__" => "Return repr(self).",
    "_sha3.sha3_384.__setattr__" => "Implement setattr(self, name, value).",
    "_sha3.sha3_384.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha3.sha3_384.__str__" => "Return str(self).",
    "_sha3.sha3_384.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha3.sha3_384.copy" => "Return a copy of the hash object.",
    "_sha3.sha3_384.digest" => "Return the digest value as a bytes object.",
    "_sha3.sha3_384.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha3.sha3_384.update" => "Update this hash object's state with the provided bytes-like object.",
    "_sha3.sha3_512" => "sha3_512([data], *, usedforsecurity=True) -> SHA3 object\n\nReturn a new SHA3 hash object with a hashbit length of 64 bytes.",
    "_sha3.sha3_512.__delattr__" => "Implement delattr(self, name).",
    "_sha3.sha3_512.__eq__" => "Return self==value.",
    "_sha3.sha3_512.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha3.sha3_512.__ge__" => "Return self>=value.",
    "_sha3.sha3_512.__getattribute__" => "Return getattr(self, name).",
    "_sha3.sha3_512.__getstate__" => "Helper for pickle.",
    "_sha3.sha3_512.__gt__" => "Return self>value.",
    "_sha3.sha3_512.__hash__" => "Return hash(self).",
    "_sha3.sha3_512.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha3.sha3_512.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha3.sha3_512.__le__" => "Return self<=value.",
    "_sha3.sha3_512.__lt__" => "Return self<value.",
    "_sha3.sha3_512.__ne__" => "Return self!=value.",
    "_sha3.sha3_512.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha3.sha3_512.__reduce__" => "Helper for pickle.",
    "_sha3.sha3_512.__reduce_ex__" => "Helper for pickle.",
    "_sha3.sha3_512.__repr__" => "Return repr(self).",
    "_sha3.sha3_512.__setattr__" => "Implement setattr(self, name, value).",
    "_sha3.sha3_512.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha3.sha3_512.__str__" => "Return str(self).",
    "_sha3.sha3_512.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha3.sha3_512.copy" => "Return a copy of the hash object.",
    "_sha3.sha3_512.digest" => "Return the digest value as a bytes object.",
    "_sha3.sha3_512.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha3.sha3_512.update" => "Update this hash object's state with the provided bytes-like object.",
    "_sha3.shake_128" => "shake_128([data], *, usedforsecurity=True) -> SHAKE object\n\nReturn a new SHAKE hash object.",
    "_sha3.shake_128.__delattr__" => "Implement delattr(self, name).",
    "_sha3.shake_128.__eq__" => "Return self==value.",
    "_sha3.shake_128.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha3.shake_128.__ge__" => "Return self>=value.",
    "_sha3.shake_128.__getattribute__" => "Return getattr(self, name).",
    "_sha3.shake_128.__getstate__" => "Helper for pickle.",
    "_sha3.shake_128.__gt__" => "Return self>value.",
    "_sha3.shake_128.__hash__" => "Return hash(self).",
    "_sha3.shake_128.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha3.shake_128.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha3.shake_128.__le__" => "Return self<=value.",
    "_sha3.shake_128.__lt__" => "Return self<value.",
    "_sha3.shake_128.__ne__" => "Return self!=value.",
    "_sha3.shake_128.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha3.shake_128.__reduce__" => "Helper for pickle.",
    "_sha3.shake_128.__reduce_ex__" => "Helper for pickle.",
    "_sha3.shake_128.__repr__" => "Return repr(self).",
    "_sha3.shake_128.__setattr__" => "Implement setattr(self, name, value).",
    "_sha3.shake_128.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha3.shake_128.__str__" => "Return str(self).",
    "_sha3.shake_128.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha3.shake_128.copy" => "Return a copy of the hash object.",
    "_sha3.shake_128.digest" => "Return the digest value as a bytes object.",
    "_sha3.shake_128.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha3.shake_128.update" => "Update this hash object's state with the provided bytes-like object.",
    "_sha3.shake_256" => "shake_256([data], *, usedforsecurity=True) -> SHAKE object\n\nReturn a new SHAKE hash object.",
    "_sha3.shake_256.__delattr__" => "Implement delattr(self, name).",
    "_sha3.shake_256.__eq__" => "Return self==value.",
    "_sha3.shake_256.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha3.shake_256.__ge__" => "Return self>=value.",
    "_sha3.shake_256.__getattribute__" => "Return getattr(self, name).",
    "_sha3.shake_256.__getstate__" => "Helper for pickle.",
    "_sha3.shake_256.__gt__" => "Return self>value.",
    "_sha3.shake_256.__hash__" => "Return hash(self).",
    "_sha3.shake_256.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha3.shake_256.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha3.shake_256.__le__" => "Return self<=value.",
    "_sha3.shake_256.__lt__" => "Return self<value.",
    "_sha3.shake_256.__ne__" => "Return self!=value.",
    "_sha3.shake_256.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha3.shake_256.__reduce__" => "Helper for pickle.",
    "_sha3.shake_256.__reduce_ex__" => "Helper for pickle.",
    "_sha3.shake_256.__repr__" => "Return repr(self).",
    "_sha3.shake_256.__setattr__" => "Implement setattr(self, name, value).",
    "_sha3.shake_256.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha3.shake_256.__str__" => "Return str(self).",
    "_sha3.shake_256.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha3.shake_256.copy" => "Return a copy of the hash object.",
    "_sha3.shake_256.digest" => "Return the digest value as a bytes object.",
    "_sha3.shake_256.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha3.shake_256.update" => "Update this hash object's state with the provided bytes-like object.",
    "_signal" => "This module provides mechanisms to use signal handlers in Python.\n\nFunctions:\n\nalarm() -- cause SIGALRM after a specified time [Unix only]\nsetitimer() -- cause a signal (described below) after a specified\n               float time and the timer may restart then [Unix only]\ngetitimer() -- get current value of timer [Unix only]\nsignal() -- set the action for a given signal\ngetsignal() -- get the signal action for a given signal\npause() -- wait until a signal arrives [Unix only]\ndefault_int_handler() -- default SIGINT handler\n\nsignal constants:\nSIG_DFL -- used to refer to the system default handler\nSIG_IGN -- used to ignore the signal\nNSIG -- number of defined signals\nSIGINT, SIGTERM, etc. -- signal numbers\n\nitimer constants:\nITIMER_REAL -- decrements in real time, and delivers SIGALRM upon\n               expiration\nITIMER_VIRTUAL -- decrements only when the process is executing,\n               and delivers SIGVTALRM upon expiration\nITIMER_PROF -- decrements both when the process is executing and\n               when the system is executing on behalf of the process.\n               Coupled with ITIMER_VIRTUAL, this timer is usually\n               used to profile the time spent by the application\n               in user and kernel space. SIGPROF is delivered upon\n               expiration.\n\n\n*** IMPORTANT NOTICE ***\nA signal handler function is called with two arguments:\nthe first is the signal number, the second is the interrupted stack frame.",
    "_signal.alarm" => "Arrange for SIGALRM to arrive after the given number of seconds.",
    "_signal.default_int_handler" => "The default handler for SIGINT installed by Python.\n\nIt raises KeyboardInterrupt.",
    "_signal.getitimer" => "Returns current value of given itimer.",
    "_signal.getsignal" => "Return the current action for the given signal.\n\nThe return value can be:\n  SIG_IGN -- if the signal is being ignored\n  SIG_DFL -- if the default action for the signal is in effect\n  None    -- if an unknown handler is in effect\n  anything else -- the callable Python object used as a handler",
    "_signal.pause" => "Wait until a signal arrives.",
    "_signal.pidfd_send_signal" => "Send a signal to a process referred to by a pid file descriptor.",
    "_signal.pthread_kill" => "Send a signal to a thread.",
    "_signal.pthread_sigmask" => "Fetch and/or change the signal mask of the calling thread.",
    "_signal.raise_signal" => "Send a signal to the executing process.",
    "_signal.set_wakeup_fd" => "Sets the fd to be written to (with the signal number) when a signal comes in.\n\nA library can use this to wakeup select or poll.\nThe previous fd or -1 is returned.\n\nThe fd must be non-blocking.",
    "_signal.setitimer" => "Sets given itimer (one of ITIMER_REAL, ITIMER_VIRTUAL or ITIMER_PROF).\n\nThe timer will fire after value seconds and after that every interval seconds.\nThe itimer can be cleared by setting seconds to zero.\n\nReturns old values as a tuple: (delay, interval).",
    "_signal.siginterrupt" => "Change system call restart behaviour.\n\nIf flag is False, system calls will be restarted when interrupted by\nsignal sig, else system calls will be interrupted.",
    "_signal.signal" => "Set the action for the given signal.\n\nThe action can be SIG_DFL, SIG_IGN, or a callable Python object.\nThe previous action is returned.  See getsignal() for possible return values.\n\n*** IMPORTANT NOTICE ***\nA signal handler function is called with two arguments:\nthe first is the signal number, the second is the interrupted stack frame.",
    "_signal.sigpending" => "Examine pending signals.\n\nReturns a set of signal numbers that are pending for delivery to\nthe calling thread.",
    "_signal.sigtimedwait" => "Like sigwaitinfo(), but with a timeout.\n\nThe timeout is specified in seconds, with floating-point numbers allowed.",
    "_signal.sigwait" => "Wait for a signal.\n\nSuspend execution of the calling thread until the delivery of one of the\nsignals specified in the signal set sigset.  The function accepts the signal\nand returns the signal number.",
    "_signal.sigwaitinfo" => "Wait synchronously until one of the signals in *sigset* is delivered.\n\nReturns a struct_siginfo containing information about the signal.",
    "_signal.strsignal" => "Return the system description of the given signal.\n\nReturns the description of signal *signalnum*, such as \"Interrupt\"\nfor :const:`SIGINT`. Returns :const:`None` if *signalnum* has no\ndescription. Raises :exc:`ValueError` if *signalnum* is invalid.",
    "_signal.valid_signals" => "Return a set of valid signal numbers on this platform.\n\nThe signal numbers returned by this function can be safely passed to\nfunctions like `pthread_sigmask`.",
    "_socket" => "Implementation module for socket operations.\n\nSee the socket module for documentation.",
    "_socket.CMSG_LEN" => "CMSG_LEN(length) -> control message length\n\nReturn the total length, without trailing padding, of an ancillary\ndata item with associated data of the given length.  This value can\noften be used as the buffer size for recvmsg() to receive a single\nitem of ancillary data, but RFC 3542 requires portable applications to\nuse CMSG_SPACE() and thus include space for padding, even when the\nitem will be the last in the buffer.  Raises OverflowError if length\nis outside the permissible range of values.",
    "_socket.CMSG_SPACE" => "CMSG_SPACE(length) -> buffer size\n\nReturn the buffer size needed for recvmsg() to receive an ancillary\ndata item with associated data of the given length, along with any\ntrailing padding.  The buffer space needed to receive multiple items\nis the sum of the CMSG_SPACE() values for their associated data\nlengths.  Raises OverflowError if length is outside the permissible\nrange of values.",
    "_socket.SocketType" => "socket(family=AF_INET, type=SOCK_STREAM, proto=0) -> socket object\nsocket(family=-1, type=-1, proto=-1, fileno=None) -> socket object\n\nOpen a socket of the given type.  The family argument specifies the\naddress family; it defaults to AF_INET.  The type argument specifies\nwhether this is a stream (SOCK_STREAM, this is the default)\nor datagram (SOCK_DGRAM) socket.  The protocol argument defaults to 0,\nspecifying the default protocol.  Keyword arguments are accepted.\nThe socket is created as non-inheritable.\n\nWhen a fileno is passed in, family, type and proto are auto-detected,\nunless they are explicitly set.\n\nA socket object represents one endpoint of a network connection.\n\nMethods of socket objects (keyword arguments not allowed):\n\n_accept() -- accept connection, returning new socket fd and client address\nbind(addr) -- bind the socket to a local address\nclose() -- close the socket\nconnect(addr) -- connect the socket to a remote address\nconnect_ex(addr) -- connect, return an error code instead of an exception\ndup() -- return a new socket fd duplicated from fileno()\nfileno() -- return underlying file descriptor\ngetpeername() -- return remote address [*]\ngetsockname() -- return local address\ngetsockopt(level, optname[, buflen]) -- get socket options\ngettimeout() -- return timeout or None\nlisten([n]) -- start listening for incoming connections\nrecv(buflen[, flags]) -- receive data\nrecv_into(buffer[, nbytes[, flags]]) -- receive data (into a buffer)\nrecvfrom(buflen[, flags]) -- receive data and sender's address\nrecvfrom_into(buffer[, nbytes, [, flags])\n  -- receive data and sender's address (into a buffer)\nsendall(data[, flags]) -- send all data\nsend(data[, flags]) -- send data, may not send all of it\nsendto(data[, flags], addr) -- send data to a given address\nsetblocking(bool) -- set or clear the blocking I/O flag\ngetblocking() -- return True if socket is blocking, False if non-blocking\nsetsockopt(level, optname, value[, optlen]) -- set socket options\nsettimeout(None | float) -- set or clear the timeout\nshutdown(how) -- shut down traffic in one or both directions\n\n [*] not available on all platforms!",
    "_socket.SocketType.__del__" => "Called when the instance is about to be destroyed.",
    "_socket.SocketType.__delattr__" => "Implement delattr(self, name).",
    "_socket.SocketType.__eq__" => "Return self==value.",
    "_socket.SocketType.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_socket.SocketType.__ge__" => "Return self>=value.",
    "_socket.SocketType.__getattribute__" => "Return getattr(self, name).",
    "_socket.SocketType.__getstate__" => "Helper for pickle.",
    "_socket.SocketType.__gt__" => "Return self>value.",
    "_socket.SocketType.__hash__" => "Return hash(self).",
    "_socket.SocketType.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_socket.SocketType.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_socket.SocketType.__le__" => "Return self<=value.",
    "_socket.SocketType.__lt__" => "Return self<value.",
    "_socket.SocketType.__ne__" => "Return self!=value.",
    "_socket.SocketType.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_socket.SocketType.__reduce__" => "Helper for pickle.",
    "_socket.SocketType.__reduce_ex__" => "Helper for pickle.",
    "_socket.SocketType.__repr__" => "Return repr(self).",
    "_socket.SocketType.__setattr__" => "Implement setattr(self, name, value).",
    "_socket.SocketType.__sizeof__" => "Size of object in memory, in bytes.",
    "_socket.SocketType.__str__" => "Return str(self).",
    "_socket.SocketType.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_socket.SocketType._accept" => "_accept() -> (integer, address info)\n\nWait for an incoming connection.  Return a new socket file descriptor\nrepresenting the connection, and the address of the client.\nFor IP sockets, the address info is a pair (hostaddr, port).",
    "_socket.SocketType.bind" => "bind(address)\n\nBind the socket to a local address.  For IP sockets, the address is a\npair (host, port); the host must refer to the local host. For raw packet\nsockets the address is a tuple (ifname, proto [,pkttype [,hatype [,addr]]])",
    "_socket.SocketType.close" => "close()\n\nClose the socket.  It cannot be used after this call.",
    "_socket.SocketType.connect" => "connect(address)\n\nConnect the socket to a remote address.  For IP sockets, the address\nis a pair (host, port).",
    "_socket.SocketType.connect_ex" => "connect_ex(address) -> errno\n\nThis is like connect(address), but returns an error code (the errno value)\ninstead of raising an exception when an error occurs.",
    "_socket.SocketType.detach" => "detach()\n\nClose the socket object without closing the underlying file descriptor.\nThe object cannot be used after this call, but the file descriptor\ncan be reused for other purposes.  The file descriptor is returned.",
    "_socket.SocketType.family" => "the socket family",
    "_socket.SocketType.fileno" => "fileno() -> integer\n\nReturn the integer file descriptor of the socket.",
    "_socket.SocketType.getblocking" => "getblocking()\n\nReturns True if socket is in blocking mode, or False if it\nis in non-blocking mode.",
    "_socket.SocketType.getpeername" => "getpeername() -> address info\n\nReturn the address of the remote endpoint.  For IP sockets, the address\ninfo is a pair (hostaddr, port).",
    "_socket.SocketType.getsockname" => "getsockname() -> address info\n\nReturn the address of the local endpoint. The format depends on the\naddress family. For IPv4 sockets, the address info is a pair\n(hostaddr, port). For IPv6 sockets, the address info is a 4-tuple\n(hostaddr, port, flowinfo, scope_id).",
    "_socket.SocketType.getsockopt" => "getsockopt(level, option[, buffersize]) -> value\n\nGet a socket option.  See the Unix manual for level and option.\nIf a nonzero buffersize argument is given, the return value is a\nstring of that length; otherwise it is an integer.",
    "_socket.SocketType.gettimeout" => "gettimeout() -> timeout\n\nReturns the timeout in seconds (float) associated with socket\noperations. A timeout of None indicates that timeouts on socket\noperations are disabled.",
    "_socket.SocketType.ioctl" => "ioctl(cmd, option) -> long\n\nControl the socket with WSAIoctl syscall. Currently supported 'cmd' values are\nSIO_RCVALL:  'option' must be one of the socket.RCVALL_* constants.\nSIO_KEEPALIVE_VALS:  'option' is a tuple of (onoff, timeout, interval).\nSIO_LOOPBACK_FAST_PATH: 'option' is a boolean value, and is disabled by default",
    "_socket.SocketType.listen" => "listen([backlog])\n\nEnable a server to accept connections.  If backlog is specified, it must be\nat least 0 (if it is lower, it is set to 0); it specifies the number of\nunaccepted connections that the system will allow before refusing new\nconnections. If not specified, a default reasonable value is chosen.",
    "_socket.SocketType.proto" => "the socket protocol",
    "_socket.SocketType.recv" => "recv(buffersize[, flags]) -> data\n\nReceive up to buffersize bytes from the socket.  For the optional flags\nargument, see the Unix manual.  When no data is available, block until\nat least one byte is available or until the remote end is closed.  When\nthe remote end is closed and all data is read, return the empty string.",
    "_socket.SocketType.recv_into" => "recv_into(buffer, [nbytes[, flags]]) -> nbytes_read\n\nA version of recv() that stores its data into a buffer rather than creating\na new string.  Receive up to buffersize bytes from the socket.  If buffersize\nis not specified (or 0), receive up to the size available in the given buffer.\n\nSee recv() for documentation about the flags.",
    "_socket.SocketType.recvfrom" => "recvfrom(buffersize[, flags]) -> (data, address info)\n\nLike recv(buffersize, flags) but also return the sender's address info.",
    "_socket.SocketType.recvfrom_into" => "recvfrom_into(buffer[, nbytes[, flags]]) -> (nbytes, address info)\n\nLike recv_into(buffer[, nbytes[, flags]]) but also return the sender's address info.",
    "_socket.SocketType.recvmsg" => "recvmsg(bufsize[, ancbufsize[, flags]]) -> (data, ancdata, msg_flags, address)\n\nReceive normal data (up to bufsize bytes) and ancillary data from the\nsocket.  The ancbufsize argument sets the size in bytes of the\ninternal buffer used to receive the ancillary data; it defaults to 0,\nmeaning that no ancillary data will be received.  Appropriate buffer\nsizes for ancillary data can be calculated using CMSG_SPACE() or\nCMSG_LEN(), and items which do not fit into the buffer might be\ntruncated or discarded.  The flags argument defaults to 0 and has the\nsame meaning as for recv().\n\nThe return value is a 4-tuple: (data, ancdata, msg_flags, address).\nThe data item is a bytes object holding the non-ancillary data\nreceived.  The ancdata item is a list of zero or more tuples\n(cmsg_level, cmsg_type, cmsg_data) representing the ancillary data\n(control messages) received: cmsg_level and cmsg_type are integers\nspecifying the protocol level and protocol-specific type respectively,\nand cmsg_data is a bytes object holding the associated data.  The\nmsg_flags item is the bitwise OR of various flags indicating\nconditions on the received message; see your system documentation for\ndetails.  If the receiving socket is unconnected, address is the\naddress of the sending socket, if available; otherwise, its value is\nunspecified.\n\nIf recvmsg() raises an exception after the system call returns, it\nwill first attempt to close any file descriptors received via the\nSCM_RIGHTS mechanism.",
    "_socket.SocketType.recvmsg_into" => "recvmsg_into(buffers[, ancbufsize[, flags]]) -> (nbytes, ancdata, msg_flags, address)\n\nReceive normal data and ancillary data from the socket, scattering the\nnon-ancillary data into a series of buffers.  The buffers argument\nmust be an iterable of objects that export writable buffers\n(e.g. bytearray objects); these will be filled with successive chunks\nof the non-ancillary data until it has all been written or there are\nno more buffers.  The ancbufsize argument sets the size in bytes of\nthe internal buffer used to receive the ancillary data; it defaults to\n0, meaning that no ancillary data will be received.  Appropriate\nbuffer sizes for ancillary data can be calculated using CMSG_SPACE()\nor CMSG_LEN(), and items which do not fit into the buffer might be\ntruncated or discarded.  The flags argument defaults to 0 and has the\nsame meaning as for recv().\n\nThe return value is a 4-tuple: (nbytes, ancdata, msg_flags, address).\nThe nbytes item is the total number of bytes of non-ancillary data\nwritten into the buffers.  The ancdata item is a list of zero or more\ntuples (cmsg_level, cmsg_type, cmsg_data) representing the ancillary\ndata (control messages) received: cmsg_level and cmsg_type are\nintegers specifying the protocol level and protocol-specific type\nrespectively, and cmsg_data is a bytes object holding the associated\ndata.  The msg_flags item is the bitwise OR of various flags\nindicating conditions on the received message; see your system\ndocumentation for details.  If the receiving socket is unconnected,\naddress is the address of the sending socket, if available; otherwise,\nits value is unspecified.\n\nIf recvmsg_into() raises an exception after the system call returns,\nit will first attempt to close any file descriptors received via the\nSCM_RIGHTS mechanism.",
    "_socket.SocketType.send" => "send(data[, flags]) -> count\n\nSend a data string to the socket.  For the optional flags\nargument, see the Unix manual.  Return the number of bytes\nsent; this may be less than len(data) if the network is busy.",
    "_socket.SocketType.sendall" => "sendall(data[, flags])\n\nSend a data string to the socket.  For the optional flags\nargument, see the Unix manual.  This calls send() repeatedly\nuntil all data is sent.  If an error occurs, it's impossible\nto tell how much data has been sent.",
    "_socket.SocketType.sendmsg" => "sendmsg(buffers[, ancdata[, flags[, address]]]) -> count\n\nSend normal and ancillary data to the socket, gathering the\nnon-ancillary data from a series of buffers and concatenating it into\na single message.  The buffers argument specifies the non-ancillary\ndata as an iterable of bytes-like objects (e.g. bytes objects).\nThe ancdata argument specifies the ancillary data (control messages)\nas an iterable of zero or more tuples (cmsg_level, cmsg_type,\ncmsg_data), where cmsg_level and cmsg_type are integers specifying the\nprotocol level and protocol-specific type respectively, and cmsg_data\nis a bytes-like object holding the associated data.  The flags\nargument defaults to 0 and has the same meaning as for send().  If\naddress is supplied and not None, it sets a destination address for\nthe message.  The return value is the number of bytes of non-ancillary\ndata sent.",
    "_socket.SocketType.sendmsg_afalg" => "sendmsg_afalg([msg], *, op[, iv[, assoclen[, flags=MSG_MORE]]])\n\nSet operation mode, IV and length of associated data for an AF_ALG\noperation socket.",
    "_socket.SocketType.sendto" => "sendto(data[, flags], address) -> count\n\nLike send(data, flags) but allows specifying the destination address.\nFor IP sockets, the address is a pair (hostaddr, port).",
    "_socket.SocketType.setblocking" => "setblocking(flag)\n\nSet the socket to blocking (flag is true) or non-blocking (false).\nsetblocking(True) is equivalent to settimeout(None);\nsetblocking(False) is equivalent to settimeout(0.0).",
    "_socket.SocketType.setsockopt" => "setsockopt(level, option, value: int)\nsetsockopt(level, option, value: buffer)\nsetsockopt(level, option, None, optlen: int)\n\nSet a socket option.  See the Unix manual for level and option.\nThe value argument can either be an integer, a string buffer, or\nNone, optlen.",
    "_socket.SocketType.settimeout" => "settimeout(timeout)\n\nSet a timeout on socket operations.  'timeout' can be a float,\ngiving in seconds, or None.  Setting a timeout of None disables\nthe timeout feature and is equivalent to setblocking(1).\nSetting a timeout of zero is the same as setblocking(0).",
    "_socket.SocketType.share" => "share(process_id) -> bytes\n\nShare the socket with another process.  The target process id\nmust be provided and the resulting bytes object passed to the target\nprocess.  There the shared socket can be instantiated by calling\nsocket.fromshare().",
    "_socket.SocketType.shutdown" => "shutdown(flag)\n\nShut down the reading side of the socket (flag == SHUT_RD), the writing side\nof the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).",
    "_socket.SocketType.timeout" => "the socket timeout",
    "_socket.SocketType.type" => "the socket type",
    "_socket.close" => "close(integer) -> None\n\nClose an integer socket file descriptor.  This is like os.close(), but for\nsockets; on some platforms os.close() won't work for socket file descriptors.",
    "_socket.dup" => "dup(integer) -> integer\n\nDuplicate an integer socket file descriptor.  This is like os.dup(), but for\nsockets; on some platforms os.dup() won't work for socket file descriptors.",
    "_socket.getaddrinfo" => "getaddrinfo(host, port [, family, type, proto, flags])\n    -> list of (family, type, proto, canonname, sockaddr)\n\nResolve host and port into addrinfo struct.",
    "_socket.getdefaulttimeout" => "getdefaulttimeout() -> timeout\n\nReturns the default timeout in seconds (float) for new socket objects.\nA value of None indicates that new socket objects have no timeout.\nWhen the socket module is first imported, the default is None.",
    "_socket.gethostbyaddr" => "gethostbyaddr(host) -> (name, aliaslist, addresslist)\n\nReturn the true host name, a list of aliases, and a list of IP addresses,\nfor a host.  The host argument is a string giving a host name or IP number.",
    "_socket.gethostbyname" => "gethostbyname(host) -> address\n\nReturn the IP address (a string of the form '255.255.255.255') for a host.",
    "_socket.gethostbyname_ex" => "gethostbyname_ex(host) -> (name, aliaslist, addresslist)\n\nReturn the true host name, a list of aliases, and a list of IP addresses,\nfor a host.  The host argument is a string giving a host name or IP number.",
    "_socket.gethostname" => "gethostname() -> string\n\nReturn the current host name.",
    "_socket.getnameinfo" => "getnameinfo(sockaddr, flags) --> (host, port)\n\nGet host and port for a sockaddr.",
    "_socket.getprotobyname" => "getprotobyname(name) -> integer\n\nReturn the protocol number for the named protocol.  (Rarely used.)",
    "_socket.getservbyname" => "getservbyname(servicename[, protocolname]) -> integer\n\nReturn a port number from a service name and protocol name.\nThe optional protocol name, if given, should be 'tcp' or 'udp',\notherwise any protocol will match.",
    "_socket.getservbyport" => "getservbyport(port[, protocolname]) -> string\n\nReturn the service name from a port number and protocol name.\nThe optional protocol name, if given, should be 'tcp' or 'udp',\notherwise any protocol will match.",
    "_socket.htonl" => "htonl(integer) -> integer\n\nConvert a 32-bit integer from host to network byte order.",
    "_socket.htons" => "Convert a 16-bit unsigned integer from host to network byte order.",
    "_socket.if_indextoname" => "if_indextoname(if_index)\n\nReturns the interface name corresponding to the interface index if_index.",
    "_socket.if_nameindex" => "if_nameindex()\n\nReturns a list of network interface information (index, name) tuples.",
    "_socket.if_nametoindex" => "Returns the interface index corresponding to the interface name if_name.",
    "_socket.inet_aton" => "Convert an IP address in string format (123.45.67.89) to the 32-bit packed binary format used in low-level network functions.",
    "_socket.inet_ntoa" => "Convert an IP address from 32-bit packed binary format to string format.",
    "_socket.inet_ntop" => "inet_ntop(af, packed_ip) -> string formatted IP address\n\nConvert a packed IP address of the given family to string format.",
    "_socket.inet_pton" => "inet_pton(af, ip) -> packed IP address string\n\nConvert an IP address from string format to a packed string suitable\nfor use with low-level network functions.",
    "_socket.ntohl" => "ntohl(integer) -> integer\n\nConvert a 32-bit integer from network to host byte order.",
    "_socket.ntohs" => "Convert a 16-bit unsigned integer from network to host byte order.",
    "_socket.setdefaulttimeout" => "setdefaulttimeout(timeout)\n\nSet the default timeout in seconds (float) for new socket objects.\nA value of None indicates that new socket objects have no timeout.\nWhen the socket module is first imported, the default is None.",
    "_socket.sethostname" => "sethostname(name)\n\nSets the hostname to name.",
    "_socket.socket" => "socket(family=AF_INET, type=SOCK_STREAM, proto=0) -> socket object\nsocket(family=-1, type=-1, proto=-1, fileno=None) -> socket object\n\nOpen a socket of the given type.  The family argument specifies the\naddress family; it defaults to AF_INET.  The type argument specifies\nwhether this is a stream (SOCK_STREAM, this is the default)\nor datagram (SOCK_DGRAM) socket.  The protocol argument defaults to 0,\nspecifying the default protocol.  Keyword arguments are accepted.\nThe socket is created as non-inheritable.\n\nWhen a fileno is passed in, family, type and proto are auto-detected,\nunless they are explicitly set.\n\nA socket object represents one endpoint of a network connection.\n\nMethods of socket objects (keyword arguments not allowed):\n\n_accept() -- accept connection, returning new socket fd and client address\nbind(addr) -- bind the socket to a local address\nclose() -- close the socket\nconnect(addr) -- connect the socket to a remote address\nconnect_ex(addr) -- connect, return an error code instead of an exception\ndup() -- return a new socket fd duplicated from fileno()\nfileno() -- return underlying file descriptor\ngetpeername() -- return remote address [*]\ngetsockname() -- return local address\ngetsockopt(level, optname[, buflen]) -- get socket options\ngettimeout() -- return timeout or None\nlisten([n]) -- start listening for incoming connections\nrecv(buflen[, flags]) -- receive data\nrecv_into(buffer[, nbytes[, flags]]) -- receive data (into a buffer)\nrecvfrom(buflen[, flags]) -- receive data and sender's address\nrecvfrom_into(buffer[, nbytes, [, flags])\n  -- receive data and sender's address (into a buffer)\nsendall(data[, flags]) -- send all data\nsend(data[, flags]) -- send data, may not send all of it\nsendto(data[, flags], addr) -- send data to a given address\nsetblocking(bool) -- set or clear the blocking I/O flag\ngetblocking() -- return True if socket is blocking, False if non-blocking\nsetsockopt(level, optname, value[, optlen]) -- set socket options\nsettimeout(None | float) -- set or clear the timeout\nshutdown(how) -- shut down traffic in one or both directions\n\n [*] not available on all platforms!",
    "_socket.socket.__del__" => "Called when the instance is about to be destroyed.",
    "_socket.socket.__delattr__" => "Implement delattr(self, name).",
    "_socket.socket.__eq__" => "Return self==value.",
    "_socket.socket.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_socket.socket.__ge__" => "Return self>=value.",
    "_socket.socket.__getattribute__" => "Return getattr(self, name).",
    "_socket.socket.__getstate__" => "Helper for pickle.",
    "_socket.socket.__gt__" => "Return self>value.",
    "_socket.socket.__hash__" => "Return hash(self).",
    "_socket.socket.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_socket.socket.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_socket.socket.__le__" => "Return self<=value.",
    "_socket.socket.__lt__" => "Return self<value.",
    "_socket.socket.__ne__" => "Return self!=value.",
    "_socket.socket.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_socket.socket.__reduce__" => "Helper for pickle.",
    "_socket.socket.__reduce_ex__" => "Helper for pickle.",
    "_socket.socket.__repr__" => "Return repr(self).",
    "_socket.socket.__setattr__" => "Implement setattr(self, name, value).",
    "_socket.socket.__sizeof__" => "Size of object in memory, in bytes.",
    "_socket.socket.__str__" => "Return str(self).",
    "_socket.socket.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_socket.socket._accept" => "_accept() -> (integer, address info)\n\nWait for an incoming connection.  Return a new socket file descriptor\nrepresenting the connection, and the address of the client.\nFor IP sockets, the address info is a pair (hostaddr, port).",
    "_socket.socket.bind" => "bind(address)\n\nBind the socket to a local address.  For IP sockets, the address is a\npair (host, port); the host must refer to the local host. For raw packet\nsockets the address is a tuple (ifname, proto [,pkttype [,hatype [,addr]]])",
    "_socket.socket.close" => "close()\n\nClose the socket.  It cannot be used after this call.",
    "_socket.socket.connect" => "connect(address)\n\nConnect the socket to a remote address.  For IP sockets, the address\nis a pair (host, port).",
    "_socket.socket.connect_ex" => "connect_ex(address) -> errno\n\nThis is like connect(address), but returns an error code (the errno value)\ninstead of raising an exception when an error occurs.",
    "_socket.socket.detach" => "detach()\n\nClose the socket object without closing the underlying file descriptor.\nThe object cannot be used after this call, but the file descriptor\ncan be reused for other purposes.  The file descriptor is returned.",
    "_socket.socket.family" => "the socket family",
    "_socket.socket.fileno" => "fileno() -> integer\n\nReturn the integer file descriptor of the socket.",
    "_socket.socket.getblocking" => "getblocking()\n\nReturns True if socket is in blocking mode, or False if it\nis in non-blocking mode.",
    "_socket.socket.getpeername" => "getpeername() -> address info\n\nReturn the address of the remote endpoint.  For IP sockets, the address\ninfo is a pair (hostaddr, port).",
    "_socket.socket.getsockname" => "getsockname() -> address info\n\nReturn the address of the local endpoint. The format depends on the\naddress family. For IPv4 sockets, the address info is a pair\n(hostaddr, port). For IPv6 sockets, the address info is a 4-tuple\n(hostaddr, port, flowinfo, scope_id).",
    "_socket.socket.getsockopt" => "getsockopt(level, option[, buffersize]) -> value\n\nGet a socket option.  See the Unix manual for level and option.\nIf a nonzero buffersize argument is given, the return value is a\nstring of that length; otherwise it is an integer.",
    "_socket.socket.gettimeout" => "gettimeout() -> timeout\n\nReturns the timeout in seconds (float) associated with socket\noperations. A timeout of None indicates that timeouts on socket\noperations are disabled.",
    "_socket.socket.ioctl" => "ioctl(cmd, option) -> long\n\nControl the socket with WSAIoctl syscall. Currently supported 'cmd' values are\nSIO_RCVALL:  'option' must be one of the socket.RCVALL_* constants.\nSIO_KEEPALIVE_VALS:  'option' is a tuple of (onoff, timeout, interval).\nSIO_LOOPBACK_FAST_PATH: 'option' is a boolean value, and is disabled by default",
    "_socket.socket.listen" => "listen([backlog])\n\nEnable a server to accept connections.  If backlog is specified, it must be\nat least 0 (if it is lower, it is set to 0); it specifies the number of\nunaccepted connections that the system will allow before refusing new\nconnections. If not specified, a default reasonable value is chosen.",
    "_socket.socket.proto" => "the socket protocol",
    "_socket.socket.recv" => "recv(buffersize[, flags]) -> data\n\nReceive up to buffersize bytes from the socket.  For the optional flags\nargument, see the Unix manual.  When no data is available, block until\nat least one byte is available or until the remote end is closed.  When\nthe remote end is closed and all data is read, return the empty string.",
    "_socket.socket.recv_into" => "recv_into(buffer, [nbytes[, flags]]) -> nbytes_read\n\nA version of recv() that stores its data into a buffer rather than creating\na new string.  Receive up to buffersize bytes from the socket.  If buffersize\nis not specified (or 0), receive up to the size available in the given buffer.\n\nSee recv() for documentation about the flags.",
    "_socket.socket.recvfrom" => "recvfrom(buffersize[, flags]) -> (data, address info)\n\nLike recv(buffersize, flags) but also return the sender's address info.",
    "_socket.socket.recvfrom_into" => "recvfrom_into(buffer[, nbytes[, flags]]) -> (nbytes, address info)\n\nLike recv_into(buffer[, nbytes[, flags]]) but also return the sender's address info.",
    "_socket.socket.recvmsg" => "recvmsg(bufsize[, ancbufsize[, flags]]) -> (data, ancdata, msg_flags, address)\n\nReceive normal data (up to bufsize bytes) and ancillary data from the\nsocket.  The ancbufsize argument sets the size in bytes of the\ninternal buffer used to receive the ancillary data; it defaults to 0,\nmeaning that no ancillary data will be received.  Appropriate buffer\nsizes for ancillary data can be calculated using CMSG_SPACE() or\nCMSG_LEN(), and items which do not fit into the buffer might be\ntruncated or discarded.  The flags argument defaults to 0 and has the\nsame meaning as for recv().\n\nThe return value is a 4-tuple: (data, ancdata, msg_flags, address).\nThe data item is a bytes object holding the non-ancillary data\nreceived.  The ancdata item is a list of zero or more tuples\n(cmsg_level, cmsg_type, cmsg_data) representing the ancillary data\n(control messages) received: cmsg_level and cmsg_type are integers\nspecifying the protocol level and protocol-specific type respectively,\nand cmsg_data is a bytes object holding the associated data.  The\nmsg_flags item is the bitwise OR of various flags indicating\nconditions on the received message; see your system documentation for\ndetails.  If the receiving socket is unconnected, address is the\naddress of the sending socket, if available; otherwise, its value is\nunspecified.\n\nIf recvmsg() raises an exception after the system call returns, it\nwill first attempt to close any file descriptors received via the\nSCM_RIGHTS mechanism.",
    "_socket.socket.recvmsg_into" => "recvmsg_into(buffers[, ancbufsize[, flags]]) -> (nbytes, ancdata, msg_flags, address)\n\nReceive normal data and ancillary data from the socket, scattering the\nnon-ancillary data into a series of buffers.  The buffers argument\nmust be an iterable of objects that export writable buffers\n(e.g. bytearray objects); these will be filled with successive chunks\nof the non-ancillary data until it has all been written or there are\nno more buffers.  The ancbufsize argument sets the size in bytes of\nthe internal buffer used to receive the ancillary data; it defaults to\n0, meaning that no ancillary data will be received.  Appropriate\nbuffer sizes for ancillary data can be calculated using CMSG_SPACE()\nor CMSG_LEN(), and items which do not fit into the buffer might be\ntruncated or discarded.  The flags argument defaults to 0 and has the\nsame meaning as for recv().\n\nThe return value is a 4-tuple: (nbytes, ancdata, msg_flags, address).\nThe nbytes item is the total number of bytes of non-ancillary data\nwritten into the buffers.  The ancdata item is a list of zero or more\ntuples (cmsg_level, cmsg_type, cmsg_data) representing the ancillary\ndata (control messages) received: cmsg_level and cmsg_type are\nintegers specifying the protocol level and protocol-specific type\nrespectively, and cmsg_data is a bytes object holding the associated\ndata.  The msg_flags item is the bitwise OR of various flags\nindicating conditions on the received message; see your system\ndocumentation for details.  If the receiving socket is unconnected,\naddress is the address of the sending socket, if available; otherwise,\nits value is unspecified.\n\nIf recvmsg_into() raises an exception after the system call returns,\nit will first attempt to close any file descriptors received via the\nSCM_RIGHTS mechanism.",
    "_socket.socket.send" => "send(data[, flags]) -> count\n\nSend a data string to the socket.  For the optional flags\nargument, see the Unix manual.  Return the number of bytes\nsent; this may be less than len(data) if the network is busy.",
    "_socket.socket.sendall" => "sendall(data[, flags])\n\nSend a data string to the socket.  For the optional flags\nargument, see the Unix manual.  This calls send() repeatedly\nuntil all data is sent.  If an error occurs, it's impossible\nto tell how much data has been sent.",
    "_socket.socket.sendmsg" => "sendmsg(buffers[, ancdata[, flags[, address]]]) -> count\n\nSend normal and ancillary data to the socket, gathering the\nnon-ancillary data from a series of buffers and concatenating it into\na single message.  The buffers argument specifies the non-ancillary\ndata as an iterable of bytes-like objects (e.g. bytes objects).\nThe ancdata argument specifies the ancillary data (control messages)\nas an iterable of zero or more tuples (cmsg_level, cmsg_type,\ncmsg_data), where cmsg_level and cmsg_type are integers specifying the\nprotocol level and protocol-specific type respectively, and cmsg_data\nis a bytes-like object holding the associated data.  The flags\nargument defaults to 0 and has the same meaning as for send().  If\naddress is supplied and not None, it sets a destination address for\nthe message.  The return value is the number of bytes of non-ancillary\ndata sent.",
    "_socket.socket.sendmsg_afalg" => "sendmsg_afalg([msg], *, op[, iv[, assoclen[, flags=MSG_MORE]]])\n\nSet operation mode, IV and length of associated data for an AF_ALG\noperation socket.",
    "_socket.socket.sendto" => "sendto(data[, flags], address) -> count\n\nLike send(data, flags) but allows specifying the destination address.\nFor IP sockets, the address is a pair (hostaddr, port).",
    "_socket.socket.setblocking" => "setblocking(flag)\n\nSet the socket to blocking (flag is true) or non-blocking (false).\nsetblocking(True) is equivalent to settimeout(None);\nsetblocking(False) is equivalent to settimeout(0.0).",
    "_socket.socket.setsockopt" => "setsockopt(level, option, value: int)\nsetsockopt(level, option, value: buffer)\nsetsockopt(level, option, None, optlen: int)\n\nSet a socket option.  See the Unix manual for level and option.\nThe value argument can either be an integer, a string buffer, or\nNone, optlen.",
    "_socket.socket.settimeout" => "settimeout(timeout)\n\nSet a timeout on socket operations.  'timeout' can be a float,\ngiving in seconds, or None.  Setting a timeout of None disables\nthe timeout feature and is equivalent to setblocking(1).\nSetting a timeout of zero is the same as setblocking(0).",
    "_socket.socket.share" => "share(process_id) -> bytes\n\nShare the socket with another process.  The target process id\nmust be provided and the resulting bytes object passed to the target\nprocess.  There the shared socket can be instantiated by calling\nsocket.fromshare().",
    "_socket.socket.shutdown" => "shutdown(flag)\n\nShut down the reading side of the socket (flag == SHUT_RD), the writing side\nof the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).",
    "_socket.socket.timeout" => "the socket timeout",
    "_socket.socket.type" => "the socket type",
    "_socket.socketpair" => "socketpair([family[, type [, proto]]]) -> (socket object, socket object)\n\nCreate a pair of socket objects from the sockets returned by the platform\nsocketpair() function.\nThe arguments are the same as for socket() except the default family is\nAF_UNIX if defined on the platform; otherwise, the default is AF_INET.",
    "_sqlite3.adapt" => "Adapt given object to given protocol.",
    "_sqlite3.complete_statement" => "Checks if a string contains a complete SQL statement.",
    "_sqlite3.connect" => "Open a connection to the SQLite database file 'database'.\n\nYou can use \":memory:\" to open a database connection to a database that\nresides in RAM instead of on disk.\n\nNote: Passing more than 1 positional argument to _sqlite3.connect() is\ndeprecated. Parameters 'timeout', 'detect_types', 'isolation_level',\n'check_same_thread', 'factory', 'cached_statements' and 'uri' will\nbecome keyword-only parameters in Python 3.15.",
    "_sqlite3.enable_callback_tracebacks" => "Enable or disable callback functions throwing errors to stderr.",
    "_sqlite3.register_adapter" => "Register a function to adapt Python objects to SQLite values.",
    "_sqlite3.register_converter" => "Register a function to convert SQLite values to Python objects.",
    "_sre.template" => "template\n  A list containing interleaved literal strings (str or bytes) and group\n  indices (int), as returned by re._parser.parse_template():\n      [literal1, group1, ..., literalN, groupN]",
    "_ssl" => "Implementation module for SSL socket operations.  See the socket module\nfor documentation.",
    "_ssl.Certificate.__delattr__" => "Implement delattr(self, name).",
    "_ssl.Certificate.__eq__" => "Return self==value.",
    "_ssl.Certificate.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_ssl.Certificate.__ge__" => "Return self>=value.",
    "_ssl.Certificate.__getattribute__" => "Return getattr(self, name).",
    "_ssl.Certificate.__getstate__" => "Helper for pickle.",
    "_ssl.Certificate.__gt__" => "Return self>value.",
    "_ssl.Certificate.__hash__" => "Return hash(self).",
    "_ssl.Certificate.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_ssl.Certificate.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_ssl.Certificate.__le__" => "Return self<=value.",
    "_ssl.Certificate.__lt__" => "Return self<value.",
    "_ssl.Certificate.__ne__" => "Return self!=value.",
    "_ssl.Certificate.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_ssl.Certificate.__reduce__" => "Helper for pickle.",
    "_ssl.Certificate.__reduce_ex__" => "Helper for pickle.",
    "_ssl.Certificate.__repr__" => "Return repr(self).",
    "_ssl.Certificate.__setattr__" => "Implement setattr(self, name, value).",
    "_ssl.Certificate.__sizeof__" => "Size of object in memory, in bytes.",
    "_ssl.Certificate.__str__" => "Return str(self).",
    "_ssl.Certificate.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_ssl.MemoryBIO.__delattr__" => "Implement delattr(self, name).",
    "_ssl.MemoryBIO.__eq__" => "Return self==value.",
    "_ssl.MemoryBIO.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_ssl.MemoryBIO.__ge__" => "Return self>=value.",
    "_ssl.MemoryBIO.__getattribute__" => "Return getattr(self, name).",
    "_ssl.MemoryBIO.__getstate__" => "Helper for pickle.",
    "_ssl.MemoryBIO.__gt__" => "Return self>value.",
    "_ssl.MemoryBIO.__hash__" => "Return hash(self).",
    "_ssl.MemoryBIO.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_ssl.MemoryBIO.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_ssl.MemoryBIO.__le__" => "Return self<=value.",
    "_ssl.MemoryBIO.__lt__" => "Return self<value.",
    "_ssl.MemoryBIO.__ne__" => "Return self!=value.",
    "_ssl.MemoryBIO.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_ssl.MemoryBIO.__reduce__" => "Helper for pickle.",
    "_ssl.MemoryBIO.__reduce_ex__" => "Helper for pickle.",
    "_ssl.MemoryBIO.__repr__" => "Return repr(self).",
    "_ssl.MemoryBIO.__setattr__" => "Implement setattr(self, name, value).",
    "_ssl.MemoryBIO.__sizeof__" => "Size of object in memory, in bytes.",
    "_ssl.MemoryBIO.__str__" => "Return str(self).",
    "_ssl.MemoryBIO.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_ssl.MemoryBIO.eof" => "Whether the memory BIO is at EOF.",
    "_ssl.MemoryBIO.pending" => "The number of bytes pending in the memory BIO.",
    "_ssl.MemoryBIO.read" => "Read up to size bytes from the memory BIO.\n\nIf size is not specified, read the entire buffer.\nIf the return value is an empty bytes instance, this means either\nEOF or that no data is available. Use the \"eof\" property to\ndistinguish between the two.",
    "_ssl.MemoryBIO.write" => "Writes the bytes b into the memory BIO.\n\nReturns the number of bytes written.",
    "_ssl.MemoryBIO.write_eof" => "Write an EOF marker to the memory BIO.\n\nWhen all data has been read, the \"eof\" property will be True.",
    "_ssl.RAND_add" => "Mix string into the OpenSSL PRNG state.\n\nentropy (a float) is a lower bound on the entropy contained in\nstring.  See RFC 4086.",
    "_ssl.RAND_bytes" => "Generate n cryptographically strong pseudo-random bytes.",
    "_ssl.RAND_status" => "Returns True if the OpenSSL PRNG has been seeded with enough data and False if not.\n\nIt is necessary to seed the PRNG with RAND_add() on some platforms before\nusing the ssl() function.",
    "_ssl.SSLSession.__delattr__" => "Implement delattr(self, name).",
    "_ssl.SSLSession.__eq__" => "Return self==value.",
    "_ssl.SSLSession.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_ssl.SSLSession.__ge__" => "Return self>=value.",
    "_ssl.SSLSession.__getattribute__" => "Return getattr(self, name).",
    "_ssl.SSLSession.__getstate__" => "Helper for pickle.",
    "_ssl.SSLSession.__gt__" => "Return self>value.",
    "_ssl.SSLSession.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_ssl.SSLSession.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_ssl.SSLSession.__le__" => "Return self<=value.",
    "_ssl.SSLSession.__lt__" => "Return self<value.",
    "_ssl.SSLSession.__ne__" => "Return self!=value.",
    "_ssl.SSLSession.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_ssl.SSLSession.__reduce__" => "Helper for pickle.",
    "_ssl.SSLSession.__reduce_ex__" => "Helper for pickle.",
    "_ssl.SSLSession.__repr__" => "Return repr(self).",
    "_ssl.SSLSession.__setattr__" => "Implement setattr(self, name, value).",
    "_ssl.SSLSession.__sizeof__" => "Size of object in memory, in bytes.",
    "_ssl.SSLSession.__str__" => "Return str(self).",
    "_ssl.SSLSession.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_ssl.SSLSession.has_ticket" => "Does the session contain a ticket?",
    "_ssl.SSLSession.id" => "Session ID.",
    "_ssl.SSLSession.ticket_lifetime_hint" => "Ticket life time hint.",
    "_ssl.SSLSession.time" => "Session creation time (seconds since epoch).",
    "_ssl.SSLSession.timeout" => "Session timeout (delta in seconds).",
    "_ssl._SSLContext.__delattr__" => "Implement delattr(self, name).",
    "_ssl._SSLContext.__eq__" => "Return self==value.",
    "_ssl._SSLContext.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_ssl._SSLContext.__ge__" => "Return self>=value.",
    "_ssl._SSLContext.__getattribute__" => "Return getattr(self, name).",
    "_ssl._SSLContext.__getstate__" => "Helper for pickle.",
    "_ssl._SSLContext.__gt__" => "Return self>value.",
    "_ssl._SSLContext.__hash__" => "Return hash(self).",
    "_ssl._SSLContext.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_ssl._SSLContext.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_ssl._SSLContext.__le__" => "Return self<=value.",
    "_ssl._SSLContext.__lt__" => "Return self<value.",
    "_ssl._SSLContext.__ne__" => "Return self!=value.",
    "_ssl._SSLContext.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_ssl._SSLContext.__reduce__" => "Helper for pickle.",
    "_ssl._SSLContext.__reduce_ex__" => "Helper for pickle.",
    "_ssl._SSLContext.__repr__" => "Return repr(self).",
    "_ssl._SSLContext.__setattr__" => "Implement setattr(self, name, value).",
    "_ssl._SSLContext.__sizeof__" => "Size of object in memory, in bytes.",
    "_ssl._SSLContext.__str__" => "Return str(self).",
    "_ssl._SSLContext.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_ssl._SSLContext.cert_store_stats" => "Returns quantities of loaded X.509 certificates.\n\nX.509 certificates with a CA extension and certificate revocation lists\ninside the context's cert store.\n\nNOTE: Certificates in a capath directory aren't loaded unless they have\nbeen used at least once.",
    "_ssl._SSLContext.get_ca_certs" => "Returns a list of dicts with information of loaded CA certs.\n\nIf the optional argument is True, returns a DER-encoded copy of the CA\ncertificate.\n\nNOTE: Certificates in a capath directory aren't loaded unless they have\nbeen used at least once.",
    "_ssl._SSLContext.num_tickets" => "Control the number of TLSv1.3 session tickets.",
    "_ssl._SSLContext.security_level" => "The current security level.",
    "_ssl._SSLContext.sni_callback" => "Set a callback that will be called when a server name is provided by the SSL/TLS client in the SNI extension.\n\nIf the argument is None then the callback is disabled. The method is called\nwith the SSLSocket, the server name as a string, and the SSLContext object.\n\nSee RFC 6066 for details of the SNI extension.",
    "_ssl._SSLSocket.__delattr__" => "Implement delattr(self, name).",
    "_ssl._SSLSocket.__eq__" => "Return self==value.",
    "_ssl._SSLSocket.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_ssl._SSLSocket.__ge__" => "Return self>=value.",
    "_ssl._SSLSocket.__getattribute__" => "Return getattr(self, name).",
    "_ssl._SSLSocket.__getstate__" => "Helper for pickle.",
    "_ssl._SSLSocket.__gt__" => "Return self>value.",
    "_ssl._SSLSocket.__hash__" => "Return hash(self).",
    "_ssl._SSLSocket.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_ssl._SSLSocket.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_ssl._SSLSocket.__le__" => "Return self<=value.",
    "_ssl._SSLSocket.__lt__" => "Return self<value.",
    "_ssl._SSLSocket.__ne__" => "Return self!=value.",
    "_ssl._SSLSocket.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_ssl._SSLSocket.__reduce__" => "Helper for pickle.",
    "_ssl._SSLSocket.__reduce_ex__" => "Helper for pickle.",
    "_ssl._SSLSocket.__repr__" => "Return repr(self).",
    "_ssl._SSLSocket.__setattr__" => "Implement setattr(self, name, value).",
    "_ssl._SSLSocket.__sizeof__" => "Size of object in memory, in bytes.",
    "_ssl._SSLSocket.__str__" => "Return str(self).",
    "_ssl._SSLSocket.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_ssl._SSLSocket.context" => "This changes the context associated with the SSLSocket.\n\nThis is typically used from within a callback function set by the sni_callback\non the SSLContext to change the certificate information associated with the\nSSLSocket before the cryptographic exchange handshake messages.",
    "_ssl._SSLSocket.get_channel_binding" => "Get channel binding data for current connection.\n\nRaise ValueError if the requested `cb_type` is not supported.  Return bytes\nof the data or None if the data is not available (e.g. before the handshake).\nOnly 'tls-unique' channel binding data from RFC 5929 is supported.",
    "_ssl._SSLSocket.getpeercert" => "Returns the certificate for the peer.\n\nIf no certificate was provided, returns None.  If a certificate was\nprovided, but not validated, returns an empty dictionary.  Otherwise\nreturns a dict containing information about the peer certificate.\n\nIf the optional argument is True, returns a DER-encoded copy of the\npeer certificate, or None if no certificate was provided.  This will\nreturn the certificate even if it wasn't validated.",
    "_ssl._SSLSocket.owner" => "The Python-level owner of this object.\n\nPassed as \"self\" in servername callback.",
    "_ssl._SSLSocket.pending" => "Returns the number of already decrypted bytes available for read, pending on the connection.",
    "_ssl._SSLSocket.read" => "read(size, [buffer])\nRead up to size bytes from the SSL socket.",
    "_ssl._SSLSocket.server_hostname" => "The currently set server hostname (for SNI).",
    "_ssl._SSLSocket.server_side" => "Whether this is a server-side socket.",
    "_ssl._SSLSocket.session" => "The underlying SSLSession object.",
    "_ssl._SSLSocket.session_reused" => "Was the client session reused during handshake?",
    "_ssl._SSLSocket.shutdown" => "Does the SSL shutdown handshake with the remote end.",
    "_ssl._SSLSocket.verify_client_post_handshake" => "Initiate TLS 1.3 post-handshake authentication",
    "_ssl._SSLSocket.write" => "Writes the bytes-like object b into the SSL object.\n\nReturns the number of bytes written.",
    "_ssl.enum_certificates" => "Retrieve certificates from Windows' cert store.\n\nstore_name may be one of 'CA', 'ROOT' or 'MY'.  The system may provide\nmore cert storages, too.  The function returns a list of (bytes,\nencoding_type, trust) tuples.  The encoding_type flag can be interpreted\nwith X509_ASN_ENCODING or PKCS_7_ASN_ENCODING. The trust setting is either\na set of OIDs or the boolean True.",
    "_ssl.enum_crls" => "Retrieve CRLs from Windows' cert store.\n\nstore_name may be one of 'CA', 'ROOT' or 'MY'.  The system may provide\nmore cert storages, too.  The function returns a list of (bytes,\nencoding_type) tuples.  The encoding_type flag can be interpreted with\nX509_ASN_ENCODING or PKCS_7_ASN_ENCODING.",
    "_ssl.get_default_verify_paths" => "Return search paths and environment vars that are used by SSLContext's set_default_verify_paths() to load default CAs.\n\nThe values are 'cert_file_env', 'cert_file', 'cert_dir_env', 'cert_dir'.",
    "_ssl.nid2obj" => "Lookup NID, short name, long name and OID of an ASN1_OBJECT by NID.",
    "_ssl.txt2obj" => "Lookup NID, short name, long name and OID of an ASN1_OBJECT.\n\nBy default objects are looked up by OID. With name=True short and\nlong name are also matched.",
    "_stat" => "S_IFMT_: file type bits\nS_IFDIR: directory\nS_IFCHR: character device\nS_IFBLK: block device\nS_IFREG: regular file\nS_IFIFO: fifo (named pipe)\nS_IFLNK: symbolic link\nS_IFSOCK: socket file\nS_IFDOOR: door\nS_IFPORT: event port\nS_IFWHT: whiteout\n\nS_ISUID: set UID bit\nS_ISGID: set GID bit\nS_ENFMT: file locking enforcement\nS_ISVTX: sticky bit\nS_IREAD: Unix V7 synonym for S_IRUSR\nS_IWRITE: Unix V7 synonym for S_IWUSR\nS_IEXEC: Unix V7 synonym for S_IXUSR\nS_IRWXU: mask for owner permissions\nS_IRUSR: read by owner\nS_IWUSR: write by owner\nS_IXUSR: execute by owner\nS_IRWXG: mask for group permissions\nS_IRGRP: read by group\nS_IWGRP: write by group\nS_IXGRP: execute by group\nS_IRWXO: mask for others (not in group) permissions\nS_IROTH: read by others\nS_IWOTH: write by others\nS_IXOTH: execute by others\n\nUF_SETTABLE: mask of owner changable flags\nUF_NODUMP: do not dump file\nUF_IMMUTABLE: file may not be changed\nUF_APPEND: file may only be appended to\nUF_OPAQUE: directory is opaque when viewed through a union stack\nUF_NOUNLINK: file may not be renamed or deleted\nUF_COMPRESSED: macOS: file is hfs-compressed\nUF_TRACKED: used for dealing with document IDs\nUF_DATAVAULT: entitlement required for reading and writing\nUF_HIDDEN: macOS: file should not be displayed\nSF_SETTABLE: mask of super user changeable flags\nSF_ARCHIVED: file may be archived\nSF_IMMUTABLE: file may not be changed\nSF_APPEND: file may only be appended to\nSF_RESTRICTED: entitlement required for writing\nSF_NOUNLINK: file may not be renamed or deleted\nSF_SNAPSHOT: file is a snapshot file\nSF_FIRMLINK: file is a firmlink\nSF_DATALESS: file is a dataless object\n\nOn macOS:\nSF_SUPPORTED: mask of super user supported flags\nSF_SYNTHETIC: mask of read-only synthetic flags\n\nST_MODE\nST_INO\nST_DEV\nST_NLINK\nST_UID\nST_GID\nST_SIZE\nST_ATIME\nST_MTIME\nST_CTIME\n\nFILE_ATTRIBUTE_*: Windows file attribute constants\n                   (only present on Windows)",
    "_stat.S_IFMT" => "Return the portion of the file's mode that describes the file type.",
    "_stat.S_IMODE" => "Return the portion of the file's mode that can be set by os.chmod().",
    "_stat.S_ISBLK" => "S_ISBLK(mode) -> bool\n\nReturn True if mode is from a block special device file.",
    "_stat.S_ISCHR" => "S_ISCHR(mode) -> bool\n\nReturn True if mode is from a character special device file.",
    "_stat.S_ISDIR" => "S_ISDIR(mode) -> bool\n\nReturn True if mode is from a directory.",
    "_stat.S_ISDOOR" => "S_ISDOOR(mode) -> bool\n\nReturn True if mode is from a door.",
    "_stat.S_ISFIFO" => "S_ISFIFO(mode) -> bool\n\nReturn True if mode is from a FIFO (named pipe).",
    "_stat.S_ISLNK" => "S_ISLNK(mode) -> bool\n\nReturn True if mode is from a symbolic link.",
    "_stat.S_ISPORT" => "S_ISPORT(mode) -> bool\n\nReturn True if mode is from an event port.",
    "_stat.S_ISREG" => "S_ISREG(mode) -> bool\n\nReturn True if mode is from a regular file.",
    "_stat.S_ISSOCK" => "S_ISSOCK(mode) -> bool\n\nReturn True if mode is from a socket.",
    "_stat.S_ISWHT" => "S_ISWHT(mode) -> bool\n\nReturn True if mode is from a whiteout.",
    "_stat.filemode" => "Convert a file's mode to a string of the form '-rwxrwxrwx'",
    "_statistics" => "Accelerators for the statistics module.",
    "_string" => "string helper module",
    "_string.formatter_field_name_split" => "split the argument as a field name",
    "_string.formatter_parser" => "parse the argument as a format string",
    "_struct" => "Functions to convert between Python values and C structs.\nPython bytes objects are used to hold the data representing the C struct\nand also as format strings (explained below) to describe the layout of data\nin the C struct.\n\nThe optional first format char indicates byte order, size and alignment:\n  @: native order, size & alignment (default)\n  =: native order, std. size & alignment\n  <: little-endian, std. size & alignment\n  >: big-endian, std. size & alignment\n  !: same as >\n\nThe remaining chars indicate types of args and must match exactly;\nthese can be preceded by a decimal repeat count:\n  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;\n  ?: _Bool (requires C99; if not available, char is used instead)\n  h:short; H:unsigned short; i:int; I:unsigned int;\n  l:long; L:unsigned long; f:float; d:double; e:half-float.\nSpecial cases (preceding decimal count indicates length):\n  s:string (array of char); p: pascal string (with count byte).\nSpecial cases (only available in native format):\n  n:ssize_t; N:size_t;\n  P:an integer type that is wide enough to hold a pointer.\nSpecial case (not in native mode unless 'long long' in platform C):\n  q:long long; Q:unsigned long long\nWhitespace between formats is ignored.\n\nThe variable struct.error is an exception raised on errors.",
    "_struct.Struct" => "Struct(fmt) --> compiled struct object",
    "_struct.Struct.__delattr__" => "Implement delattr(self, name).",
    "_struct.Struct.__eq__" => "Return self==value.",
    "_struct.Struct.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_struct.Struct.__ge__" => "Return self>=value.",
    "_struct.Struct.__getattribute__" => "Return getattr(self, name).",
    "_struct.Struct.__getstate__" => "Helper for pickle.",
    "_struct.Struct.__gt__" => "Return self>value.",
    "_struct.Struct.__hash__" => "Return hash(self).",
    "_struct.Struct.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_struct.Struct.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_struct.Struct.__le__" => "Return self<=value.",
    "_struct.Struct.__lt__" => "Return self<value.",
    "_struct.Struct.__ne__" => "Return self!=value.",
    "_struct.Struct.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_struct.Struct.__reduce__" => "Helper for pickle.",
    "_struct.Struct.__reduce_ex__" => "Helper for pickle.",
    "_struct.Struct.__repr__" => "Return repr(self).",
    "_struct.Struct.__setattr__" => "Implement setattr(self, name, value).",
    "_struct.Struct.__sizeof__" => "S.__sizeof__() -> size of S in memory, in bytes",
    "_struct.Struct.__str__" => "Return str(self).",
    "_struct.Struct.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_struct.Struct.format" => "struct format string",
    "_struct.Struct.iter_unpack" => "Return an iterator yielding tuples.\n\nTuples are unpacked from the given bytes source, like a repeated\ninvocation of unpack_from().\n\nRequires that the bytes length be a multiple of the struct size.",
    "_struct.Struct.pack" => "S.pack(v1, v2, ...) -> bytes\n\nReturn a bytes object containing values v1, v2, ... packed according\nto the format string S.format.  See help(struct) for more on format\nstrings.",
    "_struct.Struct.pack_into" => "S.pack_into(buffer, offset, v1, v2, ...)\n\nPack the values v1, v2, ... according to the format string S.format\nand write the packed bytes into the writable buffer buf starting at\noffset.  Note that the offset is a required argument.  See\nhelp(struct) for more on format strings.",
    "_struct.Struct.size" => "struct size in bytes",
    "_struct.Struct.unpack" => "Return a tuple containing unpacked values.\n\nUnpack according to the format string Struct.format. The buffer's size\nin bytes must be Struct.size.\n\nSee help(struct) for more on format strings.",
    "_struct.Struct.unpack_from" => "Return a tuple containing unpacked values.\n\nValues are unpacked according to the format string Struct.format.\n\nThe buffer's size in bytes, starting at position offset, must be\nat least Struct.size.\n\nSee help(struct) for more on format strings.",
    "_struct._clearcache" => "Clear the internal cache.",
    "_struct.calcsize" => "Return size in bytes of the struct described by the format string.",
    "_struct.iter_unpack" => "Return an iterator yielding tuples unpacked from the given bytes.\n\nThe bytes are unpacked according to the format string, like\na repeated invocation of unpack_from().\n\nRequires that the bytes length be a multiple of the format struct size.",
    "_struct.pack" => "pack(format, v1, v2, ...) -> bytes\n\nReturn a bytes object containing the values v1, v2, ... packed according\nto the format string.  See help(struct) for more on format strings.",
    "_struct.pack_into" => "pack_into(format, buffer, offset, v1, v2, ...)\n\nPack the values v1, v2, ... according to the format string and write\nthe packed bytes into the writable buffer buf starting at offset.  Note\nthat the offset is a required argument.  See help(struct) for more\non format strings.",
    "_struct.unpack" => "Return a tuple containing values unpacked according to the format string.\n\nThe buffer's size in bytes must be calcsize(format).\n\nSee help(struct) for more on format strings.",
    "_struct.unpack_from" => "Return a tuple containing values unpacked according to the format string.\n\nThe buffer's size, minus offset, must be at least calcsize(format).\n\nSee help(struct) for more on format strings.",
    "_suggestions._generate_suggestions" => "Returns the candidate in candidates that's closest to item",
    "_symtable.symtable" => "Return symbol and scope dictionaries used internally by compiler.",
    "_sysconfig" => "A helper for the sysconfig module.",
    "_sysconfig.config_vars" => "Returns a dictionary containing build variables intended to be exposed by sysconfig.",
    "_thread" => "This module provides primitive operations to write multi-threaded programs.\nThe 'threading' module provides a more convenient interface.",
    "_thread.LockType" => "A lock object is a synchronization primitive.  To create a lock,\ncall threading.Lock().  Methods are:\n\nacquire() -- lock the lock, possibly blocking until it can be obtained\nrelease() -- unlock of the lock\nlocked() -- test whether the lock is currently locked\n\nA lock is not owned by the thread that locked it; another thread may\nunlock it.  A thread attempting to lock a lock that it has already locked\nwill block until another thread unlocks it.  Deadlocks may ensue.",
    "_thread.LockType.__delattr__" => "Implement delattr(self, name).",
    "_thread.LockType.__enter__" => "Lock the lock.",
    "_thread.LockType.__eq__" => "Return self==value.",
    "_thread.LockType.__exit__" => "Release the lock.",
    "_thread.LockType.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_thread.LockType.__ge__" => "Return self>=value.",
    "_thread.LockType.__getattribute__" => "Return getattr(self, name).",
    "_thread.LockType.__getstate__" => "Helper for pickle.",
    "_thread.LockType.__gt__" => "Return self>value.",
    "_thread.LockType.__hash__" => "Return hash(self).",
    "_thread.LockType.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_thread.LockType.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_thread.LockType.__le__" => "Return self<=value.",
    "_thread.LockType.__lt__" => "Return self<value.",
    "_thread.LockType.__ne__" => "Return self!=value.",
    "_thread.LockType.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_thread.LockType.__reduce__" => "Helper for pickle.",
    "_thread.LockType.__reduce_ex__" => "Helper for pickle.",
    "_thread.LockType.__repr__" => "Return repr(self).",
    "_thread.LockType.__setattr__" => "Implement setattr(self, name, value).",
    "_thread.LockType.__sizeof__" => "Size of object in memory, in bytes.",
    "_thread.LockType.__str__" => "Return str(self).",
    "_thread.LockType.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_thread.LockType.acquire" => "Lock the lock.  Without argument, this blocks if the lock is already\nlocked (even by the same thread), waiting for another thread to release\nthe lock, and return True once the lock is acquired.\nWith an argument, this will only block if the argument is true,\nand the return value reflects whether the lock is acquired.\nThe blocking operation is interruptible.",
    "_thread.LockType.acquire_lock" => "An obsolete synonym of acquire().",
    "_thread.LockType.locked" => "Return whether the lock is in the locked state.",
    "_thread.LockType.locked_lock" => "An obsolete synonym of locked().",
    "_thread.LockType.release" => "Release the lock, allowing another thread that is blocked waiting for\nthe lock to acquire the lock.  The lock must be in the locked state,\nbut it needn't be locked by the same thread that unlocks it.",
    "_thread.LockType.release_lock" => "An obsolete synonym of release().",
    "_thread.RLock.__delattr__" => "Implement delattr(self, name).",
    "_thread.RLock.__enter__" => "Lock the lock.",
    "_thread.RLock.__eq__" => "Return self==value.",
    "_thread.RLock.__exit__" => "Release the lock.",
    "_thread.RLock.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_thread.RLock.__ge__" => "Return self>=value.",
    "_thread.RLock.__getattribute__" => "Return getattr(self, name).",
    "_thread.RLock.__getstate__" => "Helper for pickle.",
    "_thread.RLock.__gt__" => "Return self>value.",
    "_thread.RLock.__hash__" => "Return hash(self).",
    "_thread.RLock.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_thread.RLock.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_thread.RLock.__le__" => "Return self<=value.",
    "_thread.RLock.__lt__" => "Return self<value.",
    "_thread.RLock.__ne__" => "Return self!=value.",
    "_thread.RLock.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_thread.RLock.__reduce__" => "Helper for pickle.",
    "_thread.RLock.__reduce_ex__" => "Helper for pickle.",
    "_thread.RLock.__repr__" => "Return repr(self).",
    "_thread.RLock.__setattr__" => "Implement setattr(self, name, value).",
    "_thread.RLock.__sizeof__" => "Size of object in memory, in bytes.",
    "_thread.RLock.__str__" => "Return str(self).",
    "_thread.RLock.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_thread.RLock._acquire_restore" => "For internal use by `threading.Condition`.",
    "_thread.RLock._is_owned" => "For internal use by `threading.Condition`.",
    "_thread.RLock._recursion_count" => "For internal use by reentrancy checks.",
    "_thread.RLock._release_save" => "For internal use by `threading.Condition`.",
    "_thread.RLock.acquire" => "Lock the lock.  `blocking` indicates whether we should wait\nfor the lock to be available or not.  If `blocking` is False\nand another thread holds the lock, the method will return False\nimmediately.  If `blocking` is True and another thread holds\nthe lock, the method will wait for the lock to be released,\ntake it and then return True.\n(note: the blocking operation is interruptible.)\n\nIn all other cases, the method will return True immediately.\nPrecisely, if the current thread already holds the lock, its\ninternal counter is simply incremented. If nobody holds the lock,\nthe lock is taken and its internal counter initialized to 1.",
    "_thread.RLock.release" => "Release the lock, allowing another thread that is blocked waiting for\nthe lock to acquire the lock.  The lock must be in the locked state,\nand must be locked by the same thread that unlocks it; otherwise a\n`RuntimeError` is raised.\n\nDo note that if the lock was acquire()d several times in a row by the\ncurrent thread, release() needs to be called as many times for the lock\nto be available for other threads.",
    "_thread._ExceptHookArgs" => "ExceptHookArgs\n\nType used to pass arguments to threading.excepthook.",
    "_thread._ExceptHookArgs.__add__" => "Return self+value.",
    "_thread._ExceptHookArgs.__class_getitem__" => "See PEP 585",
    "_thread._ExceptHookArgs.__contains__" => "Return bool(key in self).",
    "_thread._ExceptHookArgs.__delattr__" => "Implement delattr(self, name).",
    "_thread._ExceptHookArgs.__eq__" => "Return self==value.",
    "_thread._ExceptHookArgs.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_thread._ExceptHookArgs.__ge__" => "Return self>=value.",
    "_thread._ExceptHookArgs.__getattribute__" => "Return getattr(self, name).",
    "_thread._ExceptHookArgs.__getitem__" => "Return self[key].",
    "_thread._ExceptHookArgs.__getstate__" => "Helper for pickle.",
    "_thread._ExceptHookArgs.__gt__" => "Return self>value.",
    "_thread._ExceptHookArgs.__hash__" => "Return hash(self).",
    "_thread._ExceptHookArgs.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_thread._ExceptHookArgs.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_thread._ExceptHookArgs.__iter__" => "Implement iter(self).",
    "_thread._ExceptHookArgs.__le__" => "Return self<=value.",
    "_thread._ExceptHookArgs.__len__" => "Return len(self).",
    "_thread._ExceptHookArgs.__lt__" => "Return self<value.",
    "_thread._ExceptHookArgs.__mul__" => "Return self*value.",
    "_thread._ExceptHookArgs.__ne__" => "Return self!=value.",
    "_thread._ExceptHookArgs.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_thread._ExceptHookArgs.__reduce_ex__" => "Helper for pickle.",
    "_thread._ExceptHookArgs.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "_thread._ExceptHookArgs.__repr__" => "Return repr(self).",
    "_thread._ExceptHookArgs.__rmul__" => "Return value*self.",
    "_thread._ExceptHookArgs.__setattr__" => "Implement setattr(self, name, value).",
    "_thread._ExceptHookArgs.__sizeof__" => "Size of object in memory, in bytes.",
    "_thread._ExceptHookArgs.__str__" => "Return str(self).",
    "_thread._ExceptHookArgs.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_thread._ExceptHookArgs.count" => "Return number of occurrences of value.",
    "_thread._ExceptHookArgs.exc_traceback" => "Exception traceback",
    "_thread._ExceptHookArgs.exc_type" => "Exception type",
    "_thread._ExceptHookArgs.exc_value" => "Exception value",
    "_thread._ExceptHookArgs.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "_thread._ExceptHookArgs.thread" => "Thread",
    "_thread._ThreadHandle.__delattr__" => "Implement delattr(self, name).",
    "_thread._ThreadHandle.__eq__" => "Return self==value.",
    "_thread._ThreadHandle.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_thread._ThreadHandle.__ge__" => "Return self>=value.",
    "_thread._ThreadHandle.__getattribute__" => "Return getattr(self, name).",
    "_thread._ThreadHandle.__getstate__" => "Helper for pickle.",
    "_thread._ThreadHandle.__gt__" => "Return self>value.",
    "_thread._ThreadHandle.__hash__" => "Return hash(self).",
    "_thread._ThreadHandle.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_thread._ThreadHandle.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_thread._ThreadHandle.__le__" => "Return self<=value.",
    "_thread._ThreadHandle.__lt__" => "Return self<value.",
    "_thread._ThreadHandle.__ne__" => "Return self!=value.",
    "_thread._ThreadHandle.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_thread._ThreadHandle.__reduce__" => "Helper for pickle.",
    "_thread._ThreadHandle.__reduce_ex__" => "Helper for pickle.",
    "_thread._ThreadHandle.__repr__" => "Return repr(self).",
    "_thread._ThreadHandle.__setattr__" => "Implement setattr(self, name, value).",
    "_thread._ThreadHandle.__sizeof__" => "Size of object in memory, in bytes.",
    "_thread._ThreadHandle.__str__" => "Return str(self).",
    "_thread._ThreadHandle.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_thread._count" => "Return the number of currently running Python threads, excluding\nthe main thread. The returned number comprises all threads created\nthrough `start_new_thread()` as well as `threading.Thread`, and not\nyet finished.\n\nThis function is meant for internal and specialized purposes only.\nIn most applications `threading.enumerate()` should be used instead.",
    "_thread._excepthook" => "Handle uncaught Thread.run() exception.",
    "_thread._get_main_thread_ident" => "Internal only. Return a non-zero integer that uniquely identifies the main thread\nof the main interpreter.",
    "_thread._is_main_interpreter" => "Return True if the current interpreter is the main Python interpreter.",
    "_thread._local" => "Thread-local data",
    "_thread._local.__delattr__" => "Implement delattr(self, name).",
    "_thread._local.__eq__" => "Return self==value.",
    "_thread._local.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_thread._local.__ge__" => "Return self>=value.",
    "_thread._local.__getattribute__" => "Return getattr(self, name).",
    "_thread._local.__getstate__" => "Helper for pickle.",
    "_thread._local.__gt__" => "Return self>value.",
    "_thread._local.__hash__" => "Return hash(self).",
    "_thread._local.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_thread._local.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_thread._local.__le__" => "Return self<=value.",
    "_thread._local.__lt__" => "Return self<value.",
    "_thread._local.__ne__" => "Return self!=value.",
    "_thread._local.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_thread._local.__reduce__" => "Helper for pickle.",
    "_thread._local.__reduce_ex__" => "Helper for pickle.",
    "_thread._local.__repr__" => "Return repr(self).",
    "_thread._local.__setattr__" => "Implement setattr(self, name, value).",
    "_thread._local.__sizeof__" => "Size of object in memory, in bytes.",
    "_thread._local.__str__" => "Return str(self).",
    "_thread._local.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_thread._make_thread_handle" => "Internal only. Make a thread handle for threads not spawned\nby the _thread or threading module.",
    "_thread._shutdown" => "Wait for all non-daemon threads (other than the calling thread) to stop.",
    "_thread.allocate" => "An obsolete synonym of allocate_lock().",
    "_thread.allocate_lock" => "Create a new lock object. See help(type(threading.Lock())) for\ninformation about locks.",
    "_thread.daemon_threads_allowed" => "Return True if daemon threads are allowed in the current interpreter,\nand False otherwise.",
    "_thread.exit" => "This is synonymous to ``raise SystemExit''.  It will cause the current\nthread to exit silently unless the exception is caught.",
    "_thread.exit_thread" => "An obsolete synonym of exit().",
    "_thread.get_ident" => "Return a non-zero integer that uniquely identifies the current thread\namongst other threads that exist simultaneously.\nThis may be used to identify per-thread resources.\nEven though on some platforms threads identities may appear to be\nallocated consecutive numbers starting at 1, this behavior should not\nbe relied upon, and the number should be seen purely as a magic cookie.\nA thread's identity may be reused for another thread after it exits.",
    "_thread.get_native_id" => "Return a non-negative integer identifying the thread as reported\nby the OS (kernel). This may be used to uniquely identify a\nparticular thread within a system.",
    "_thread.interrupt_main" => "Simulate the arrival of the given signal in the main thread,\nwhere the corresponding signal handler will be executed.\nIf *signum* is omitted, SIGINT is assumed.\nA subthread can use this function to interrupt the main thread.\n\nNote: the default signal handler for SIGINT raises ``KeyboardInterrupt``.",
    "_thread.lock" => "A lock object is a synchronization primitive.  To create a lock,\ncall threading.Lock().  Methods are:\n\nacquire() -- lock the lock, possibly blocking until it can be obtained\nrelease() -- unlock of the lock\nlocked() -- test whether the lock is currently locked\n\nA lock is not owned by the thread that locked it; another thread may\nunlock it.  A thread attempting to lock a lock that it has already locked\nwill block until another thread unlocks it.  Deadlocks may ensue.",
    "_thread.lock.__delattr__" => "Implement delattr(self, name).",
    "_thread.lock.__enter__" => "Lock the lock.",
    "_thread.lock.__eq__" => "Return self==value.",
    "_thread.lock.__exit__" => "Release the lock.",
    "_thread.lock.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_thread.lock.__ge__" => "Return self>=value.",
    "_thread.lock.__getattribute__" => "Return getattr(self, name).",
    "_thread.lock.__getstate__" => "Helper for pickle.",
    "_thread.lock.__gt__" => "Return self>value.",
    "_thread.lock.__hash__" => "Return hash(self).",
    "_thread.lock.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_thread.lock.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_thread.lock.__le__" => "Return self<=value.",
    "_thread.lock.__lt__" => "Return self<value.",
    "_thread.lock.__ne__" => "Return self!=value.",
    "_thread.lock.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_thread.lock.__reduce__" => "Helper for pickle.",
    "_thread.lock.__reduce_ex__" => "Helper for pickle.",
    "_thread.lock.__repr__" => "Return repr(self).",
    "_thread.lock.__setattr__" => "Implement setattr(self, name, value).",
    "_thread.lock.__sizeof__" => "Size of object in memory, in bytes.",
    "_thread.lock.__str__" => "Return str(self).",
    "_thread.lock.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_thread.lock.acquire" => "Lock the lock.  Without argument, this blocks if the lock is already\nlocked (even by the same thread), waiting for another thread to release\nthe lock, and return True once the lock is acquired.\nWith an argument, this will only block if the argument is true,\nand the return value reflects whether the lock is acquired.\nThe blocking operation is interruptible.",
    "_thread.lock.acquire_lock" => "An obsolete synonym of acquire().",
    "_thread.lock.locked" => "Return whether the lock is in the locked state.",
    "_thread.lock.locked_lock" => "An obsolete synonym of locked().",
    "_thread.lock.release" => "Release the lock, allowing another thread that is blocked waiting for\nthe lock to acquire the lock.  The lock must be in the locked state,\nbut it needn't be locked by the same thread that unlocks it.",
    "_thread.lock.release_lock" => "An obsolete synonym of release().",
    "_thread.stack_size" => "Return the thread stack size used when creating new threads.  The\noptional size argument specifies the stack size (in bytes) to be used\nfor subsequently created threads, and must be 0 (use platform or\nconfigured default) or a positive integer value of at least 32,768 (32k).\nIf changing the thread stack size is unsupported, a ThreadError\nexception is raised.  If the specified size is invalid, a ValueError\nexception is raised, and the stack size is unmodified.  32k bytes\n currently the minimum supported stack size value to guarantee\nsufficient stack space for the interpreter itself.\n\nNote that some platforms may have particular restrictions on values for\nthe stack size, such as requiring a minimum stack size larger than 32 KiB or\nrequiring allocation in multiples of the system memory page size\n- platform documentation should be referred to for more information\n(4 KiB pages are common; using multiples of 4096 for the stack size is\nthe suggested approach in the absence of more specific information).",
    "_thread.start_joinable_thread" => "*For internal use only*: start a new thread.\n\nLike start_new_thread(), this starts a new thread calling the given function.\nUnlike start_new_thread(), this returns a handle object with methods to join\nor detach the given thread.\nThis function is not for third-party code, please use the\n`threading` module instead. During finalization the runtime will not wait for\nthe thread to exit if daemon is True. If handle is provided it must be a\nnewly created thread._ThreadHandle instance.",
    "_thread.start_new" => "An obsolete synonym of start_new_thread().",
    "_thread.start_new_thread" => "Start a new thread and return its identifier.\n\nThe thread will call the function with positional arguments from the\ntuple args and keyword arguments taken from the optional dictionary\nkwargs.  The thread exits when the function returns; the return value\nis ignored.  The thread will also exit when the function raises an\nunhandled exception; a stack trace will be printed unless the exception\nis SystemExit.",
    "_tkinter.TclError.__cause__" => "exception cause",
    "_tkinter.TclError.__context__" => "exception context",
    "_tkinter.TclError.__delattr__" => "Implement delattr(self, name).",
    "_tkinter.TclError.__eq__" => "Return self==value.",
    "_tkinter.TclError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_tkinter.TclError.__ge__" => "Return self>=value.",
    "_tkinter.TclError.__getattribute__" => "Return getattr(self, name).",
    "_tkinter.TclError.__getstate__" => "Helper for pickle.",
    "_tkinter.TclError.__gt__" => "Return self>value.",
    "_tkinter.TclError.__hash__" => "Return hash(self).",
    "_tkinter.TclError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_tkinter.TclError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_tkinter.TclError.__le__" => "Return self<=value.",
    "_tkinter.TclError.__lt__" => "Return self<value.",
    "_tkinter.TclError.__ne__" => "Return self!=value.",
    "_tkinter.TclError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_tkinter.TclError.__reduce_ex__" => "Helper for pickle.",
    "_tkinter.TclError.__repr__" => "Return repr(self).",
    "_tkinter.TclError.__setattr__" => "Implement setattr(self, name, value).",
    "_tkinter.TclError.__sizeof__" => "Size of object in memory, in bytes.",
    "_tkinter.TclError.__str__" => "Return str(self).",
    "_tkinter.TclError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_tkinter.TclError.__weakref__" => "list of weak references to the object",
    "_tkinter.TclError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_tkinter.TclError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_tkinter.Tcl_Obj.__delattr__" => "Implement delattr(self, name).",
    "_tkinter.Tcl_Obj.__eq__" => "Return self==value.",
    "_tkinter.Tcl_Obj.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_tkinter.Tcl_Obj.__ge__" => "Return self>=value.",
    "_tkinter.Tcl_Obj.__getattribute__" => "Return getattr(self, name).",
    "_tkinter.Tcl_Obj.__getstate__" => "Helper for pickle.",
    "_tkinter.Tcl_Obj.__gt__" => "Return self>value.",
    "_tkinter.Tcl_Obj.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_tkinter.Tcl_Obj.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_tkinter.Tcl_Obj.__le__" => "Return self<=value.",
    "_tkinter.Tcl_Obj.__lt__" => "Return self<value.",
    "_tkinter.Tcl_Obj.__ne__" => "Return self!=value.",
    "_tkinter.Tcl_Obj.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_tkinter.Tcl_Obj.__reduce__" => "Helper for pickle.",
    "_tkinter.Tcl_Obj.__reduce_ex__" => "Helper for pickle.",
    "_tkinter.Tcl_Obj.__repr__" => "Return repr(self).",
    "_tkinter.Tcl_Obj.__setattr__" => "Implement setattr(self, name, value).",
    "_tkinter.Tcl_Obj.__sizeof__" => "Size of object in memory, in bytes.",
    "_tkinter.Tcl_Obj.__str__" => "Return str(self).",
    "_tkinter.Tcl_Obj.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_tkinter.Tcl_Obj.string" => "the string representation of this object, either as str or bytes",
    "_tkinter.Tcl_Obj.typename" => "name of the Tcl type",
    "_tkinter.TkappType.__delattr__" => "Implement delattr(self, name).",
    "_tkinter.TkappType.__eq__" => "Return self==value.",
    "_tkinter.TkappType.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_tkinter.TkappType.__ge__" => "Return self>=value.",
    "_tkinter.TkappType.__getattribute__" => "Return getattr(self, name).",
    "_tkinter.TkappType.__getstate__" => "Helper for pickle.",
    "_tkinter.TkappType.__gt__" => "Return self>value.",
    "_tkinter.TkappType.__hash__" => "Return hash(self).",
    "_tkinter.TkappType.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_tkinter.TkappType.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_tkinter.TkappType.__le__" => "Return self<=value.",
    "_tkinter.TkappType.__lt__" => "Return self<value.",
    "_tkinter.TkappType.__ne__" => "Return self!=value.",
    "_tkinter.TkappType.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_tkinter.TkappType.__reduce__" => "Helper for pickle.",
    "_tkinter.TkappType.__reduce_ex__" => "Helper for pickle.",
    "_tkinter.TkappType.__repr__" => "Return repr(self).",
    "_tkinter.TkappType.__setattr__" => "Implement setattr(self, name, value).",
    "_tkinter.TkappType.__sizeof__" => "Size of object in memory, in bytes.",
    "_tkinter.TkappType.__str__" => "Return str(self).",
    "_tkinter.TkappType.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_tkinter.TkappType.gettrace" => "Get the tracing function.",
    "_tkinter.TkappType.settrace" => "Set the tracing function.",
    "_tkinter.TkttType.__delattr__" => "Implement delattr(self, name).",
    "_tkinter.TkttType.__eq__" => "Return self==value.",
    "_tkinter.TkttType.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_tkinter.TkttType.__ge__" => "Return self>=value.",
    "_tkinter.TkttType.__getattribute__" => "Return getattr(self, name).",
    "_tkinter.TkttType.__getstate__" => "Helper for pickle.",
    "_tkinter.TkttType.__gt__" => "Return self>value.",
    "_tkinter.TkttType.__hash__" => "Return hash(self).",
    "_tkinter.TkttType.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_tkinter.TkttType.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_tkinter.TkttType.__le__" => "Return self<=value.",
    "_tkinter.TkttType.__lt__" => "Return self<value.",
    "_tkinter.TkttType.__ne__" => "Return self!=value.",
    "_tkinter.TkttType.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_tkinter.TkttType.__reduce__" => "Helper for pickle.",
    "_tkinter.TkttType.__reduce_ex__" => "Helper for pickle.",
    "_tkinter.TkttType.__repr__" => "Return repr(self).",
    "_tkinter.TkttType.__setattr__" => "Implement setattr(self, name, value).",
    "_tkinter.TkttType.__sizeof__" => "Size of object in memory, in bytes.",
    "_tkinter.TkttType.__str__" => "Return str(self).",
    "_tkinter.TkttType.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_tkinter.create" => "wantTk\n  if false, then Tk_Init() doesn't get called\nsync\n  if true, then pass -sync to wish\nuse\n  if not None, then pass -use to wish",
    "_tkinter.getbusywaitinterval" => "Return the current busy-wait interval between successive calls to Tcl_DoOneEvent in a threaded Python interpreter.",
    "_tkinter.setbusywaitinterval" => "Set the busy-wait interval in milliseconds between successive calls to Tcl_DoOneEvent in a threaded Python interpreter.\n\nIt should be set to a divisor of the maximum time between frames in an animation.",
    "_tokenize.TokenizerIter.__delattr__" => "Implement delattr(self, name).",
    "_tokenize.TokenizerIter.__eq__" => "Return self==value.",
    "_tokenize.TokenizerIter.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_tokenize.TokenizerIter.__ge__" => "Return self>=value.",
    "_tokenize.TokenizerIter.__getattribute__" => "Return getattr(self, name).",
    "_tokenize.TokenizerIter.__getstate__" => "Helper for pickle.",
    "_tokenize.TokenizerIter.__gt__" => "Return self>value.",
    "_tokenize.TokenizerIter.__hash__" => "Return hash(self).",
    "_tokenize.TokenizerIter.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_tokenize.TokenizerIter.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_tokenize.TokenizerIter.__iter__" => "Implement iter(self).",
    "_tokenize.TokenizerIter.__le__" => "Return self<=value.",
    "_tokenize.TokenizerIter.__lt__" => "Return self<value.",
    "_tokenize.TokenizerIter.__ne__" => "Return self!=value.",
    "_tokenize.TokenizerIter.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_tokenize.TokenizerIter.__next__" => "Implement next(self).",
    "_tokenize.TokenizerIter.__reduce__" => "Helper for pickle.",
    "_tokenize.TokenizerIter.__reduce_ex__" => "Helper for pickle.",
    "_tokenize.TokenizerIter.__repr__" => "Return repr(self).",
    "_tokenize.TokenizerIter.__setattr__" => "Implement setattr(self, name, value).",
    "_tokenize.TokenizerIter.__sizeof__" => "Size of object in memory, in bytes.",
    "_tokenize.TokenizerIter.__str__" => "Return str(self).",
    "_tokenize.TokenizerIter.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_tracemalloc" => "Debug module to trace memory blocks allocated by Python.",
    "_tracemalloc._get_object_traceback" => "Get the traceback where the Python object obj was allocated.\n\nReturn a tuple of (filename: str, lineno: int) tuples.\nReturn None if the tracemalloc module is disabled or did not\ntrace the allocation of the object.",
    "_tracemalloc._get_traces" => "Get traces of all memory blocks allocated by Python.\n\nReturn a list of (size: int, traceback: tuple) tuples.\ntraceback is a tuple of (filename: str, lineno: int) tuples.\n\nReturn an empty list if the tracemalloc module is disabled.",
    "_tracemalloc.clear_traces" => "Clear traces of memory blocks allocated by Python.",
    "_tracemalloc.get_traceback_limit" => "Get the maximum number of frames stored in the traceback of a trace.\n\nBy default, a trace of an allocated memory block only stores\nthe most recent frame: the limit is 1.",
    "_tracemalloc.get_traced_memory" => "Get the current size and peak size of memory blocks traced by tracemalloc.\n\nReturns a tuple: (current: int, peak: int).",
    "_tracemalloc.get_tracemalloc_memory" => "Get the memory usage in bytes of the tracemalloc module.\n\nThis memory is used internally to trace memory allocations.",
    "_tracemalloc.is_tracing" => "Return True if the tracemalloc module is tracing Python memory allocations.",
    "_tracemalloc.reset_peak" => "Set the peak size of memory blocks traced by tracemalloc to the current size.\n\nDo nothing if the tracemalloc module is not tracing memory allocations.",
    "_tracemalloc.start" => "Start tracing Python memory allocations.\n\nAlso set the maximum number of frames stored in the traceback of a\ntrace to nframe.",
    "_tracemalloc.stop" => "Stop tracing Python memory allocations.\n\nAlso clear traces of memory blocks allocated by Python.",
    "_typing" => "Primitives and accelerators for the typing module.",
    "_warnings" => "_warnings provides basic warning filtering support.\nIt is a helper module to speed up interpreter start-up.",
    "_warnings.warn" => "Issue a warning, or maybe ignore it or raise an exception.\n\nmessage\n  Text of the warning message.\ncategory\n  The Warning category subclass. Defaults to UserWarning.\nstacklevel\n  How far up the call stack to make this warning appear. A value of 2 for\n  example attributes the warning to the caller of the code calling warn().\nsource\n  If supplied, the destroyed object which emitted a ResourceWarning\nskip_file_prefixes\n  An optional tuple of module filename prefixes indicating frames to skip\n  during stacklevel computations for stack frame attribution.",
    "_warnings.warn_explicit" => "Issue a warning, or maybe ignore it or raise an exception.",
    "_weakref" => "Weak-reference support module.",
    "_weakref._remove_dead_weakref" => "Atomically remove key from dict if it points to a dead weakref.",
    "_weakref.getweakrefcount" => "Return the number of weak references to 'object'.",
    "_weakref.getweakrefs" => "Return a list of all weak reference objects pointing to 'object'.",
    "_weakref.proxy" => "Create a proxy object that weakly references 'object'.\n\n'callback', if given, is called with a reference to the\nproxy when 'object' is about to be finalized.",
    "_winapi.BatchedWaitForMultipleObjects" => "Supports a larger number of handles than WaitForMultipleObjects\n\nNote that the handles may be waited on other threads, which could cause\nissues for objects like mutexes that become associated with the thread\nthat was waiting for them. Objects may also be left signalled, even if\nthe wait fails.\n\nIt is recommended to use WaitForMultipleObjects whenever possible, and\nonly switch to BatchedWaitForMultipleObjects for scenarios where you\ncontrol all the handles involved, such as your own thread pool or\nfiles, and all wait objects are left unmodified by a wait (for example,\nmanual reset events, threads, and files/pipes).\n\nOverlapped handles returned from this module use manual reset events.",
    "_winapi.CloseHandle" => "Close handle.",
    "_winapi.CopyFile2" => "Copies a file from one name to a new name.\n\nThis is implemented using the CopyFile2 API, which preserves all stat\nand metadata information apart from security attributes.\n\nprogress_routine is reserved for future use, but is currently not\nimplemented. Its value is ignored.",
    "_winapi.CreatePipe" => "Create an anonymous pipe.\n\n  pipe_attrs\n    Ignored internally, can be None.\n\nReturns a 2-tuple of handles, to the read and write ends of the pipe.",
    "_winapi.CreateProcess" => "Create a new process and its primary thread.\n\n  command_line\n    Can be str or None\n  proc_attrs\n    Ignored internally, can be None.\n  thread_attrs\n    Ignored internally, can be None.\n\nThe return value is a tuple of the process handle, thread handle,\nprocess ID, and thread ID.",
    "_winapi.DuplicateHandle" => "Return a duplicate handle object.\n\nThe duplicate handle refers to the same object as the original\nhandle. Therefore, any changes to the object are reflected\nthrough both handles.",
    "_winapi.GetACP" => "Get the current Windows ANSI code page identifier.",
    "_winapi.GetCurrentProcess" => "Return a handle object for the current process.",
    "_winapi.GetExitCodeProcess" => "Return the termination status of the specified process.",
    "_winapi.GetLongPathName" => "Return the long version of the provided path.\n\nIf the path is already in its long form, returns the same value.\n\nThe path must already be a 'str'. If the type is not known, use\nos.fsdecode before calling this function.",
    "_winapi.GetModuleFileName" => "Return the fully-qualified path for the file that contains module.\n\nThe module must have been loaded by the current process.\n\nThe module parameter should be a handle to the loaded module\nwhose path is being requested. If this parameter is 0,\nGetModuleFileName retrieves the path of the executable file\nof the current process.",
    "_winapi.GetShortPathName" => "Return the short version of the provided path.\n\nIf the path is already in its short form, returns the same value.\n\nThe path must already be a 'str'. If the type is not known, use\nos.fsdecode before calling this function.",
    "_winapi.GetStdHandle" => "Return a handle to the specified standard device.\n\n  std_handle\n    One of STD_INPUT_HANDLE, STD_OUTPUT_HANDLE, or STD_ERROR_HANDLE.\n\nThe integer associated with the handle object is returned.",
    "_winapi.GetVersion" => "Return the version number of the current operating system.",
    "_winapi.Overlapped" => "OVERLAPPED structure wrapper",
    "_winapi.Overlapped.__delattr__" => "Implement delattr(self, name).",
    "_winapi.Overlapped.__eq__" => "Return self==value.",
    "_winapi.Overlapped.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_winapi.Overlapped.__ge__" => "Return self>=value.",
    "_winapi.Overlapped.__getattribute__" => "Return getattr(self, name).",
    "_winapi.Overlapped.__getstate__" => "Helper for pickle.",
    "_winapi.Overlapped.__gt__" => "Return self>value.",
    "_winapi.Overlapped.__hash__" => "Return hash(self).",
    "_winapi.Overlapped.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_winapi.Overlapped.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_winapi.Overlapped.__le__" => "Return self<=value.",
    "_winapi.Overlapped.__lt__" => "Return self<value.",
    "_winapi.Overlapped.__ne__" => "Return self!=value.",
    "_winapi.Overlapped.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_winapi.Overlapped.__reduce__" => "Helper for pickle.",
    "_winapi.Overlapped.__reduce_ex__" => "Helper for pickle.",
    "_winapi.Overlapped.__repr__" => "Return repr(self).",
    "_winapi.Overlapped.__setattr__" => "Implement setattr(self, name, value).",
    "_winapi.Overlapped.__sizeof__" => "Size of object in memory, in bytes.",
    "_winapi.Overlapped.__str__" => "Return str(self).",
    "_winapi.Overlapped.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_winapi.Overlapped.event" => "overlapped event handle",
    "_winapi.TerminateProcess" => "Terminate the specified process and all of its threads.",
    "_winapi.WaitForSingleObject" => "Wait for a single object.\n\nWait until the specified object is in the signaled state or\nthe time-out interval elapses. The timeout value is specified\nin milliseconds.",
    "_winapi._mimetypes_read_windows_registry" => "Optimized function for reading all known MIME types from the registry.\n\n*on_type_read* is a callable taking *type* and *ext* arguments, as for\nMimeTypes.add_type.",
    "_wmi.exec_query" => "Runs a WMI query against the local machine.\n\nThis returns a single string with 'name=value' pairs in a flat array separated\nby null characters.",
    "_zoneinfo" => "C implementation of the zoneinfo module",
    "array" => "This module defines an object type which can efficiently represent\nan array of basic values: characters, integers, floating-point\nnumbers.  Arrays are sequence types and behave very much like lists,\nexcept that the type of objects stored in them is constrained.",
    "array.ArrayType" => "array(typecode [, initializer]) -> array\n\nReturn a new array whose items are restricted by typecode, and\ninitialized from the optional initializer value, which must be a list,\nstring or iterable over elements of the appropriate type.\n\nArrays represent basic values and behave very much like lists, except\nthe type of objects stored in them is constrained. The type is specified\nat object creation time by using a type code, which is a single character.\nThe following type codes are defined:\n\n    Type code   C Type             Minimum size in bytes\n    'b'         signed integer     1\n    'B'         unsigned integer   1\n    'u'         Unicode character  2 (see note)\n    'h'         signed integer     2\n    'H'         unsigned integer   2\n    'i'         signed integer     2\n    'I'         unsigned integer   2\n    'l'         signed integer     4\n    'L'         unsigned integer   4\n    'q'         signed integer     8 (see note)\n    'Q'         unsigned integer   8 (see note)\n    'f'         floating-point     4\n    'd'         floating-point     8\n\nNOTE: The 'u' typecode corresponds to Python's unicode character. On\nnarrow builds this is 2-bytes on wide builds this is 4-bytes.\n\nNOTE: The 'q' and 'Q' type codes are only available if the platform\nC compiler used to build Python supports 'long long', or, on Windows,\n'__int64'.\n\nMethods:\n\nappend() -- append a new item to the end of the array\nbuffer_info() -- return information giving the current memory info\nbyteswap() -- byteswap all the items of the array\ncount() -- return number of occurrences of an object\nextend() -- extend array by appending multiple elements from an iterable\nfromfile() -- read items from a file object\nfromlist() -- append items from the list\nfrombytes() -- append items from the string\nindex() -- return index of first occurrence of an object\ninsert() -- insert a new item into the array at a provided position\npop() -- remove and return item (default last)\nremove() -- remove first occurrence of an object\nreverse() -- reverse the order of the items in the array\ntofile() -- write all items to a file object\ntolist() -- return the array converted to an ordinary list\ntobytes() -- return the array converted to a string\n\nAttributes:\n\ntypecode -- the typecode character used to create the array\nitemsize -- the length in bytes of one array item",
    "array.ArrayType.__add__" => "Return self+value.",
    "array.ArrayType.__buffer__" => "Return a buffer object that exposes the underlying memory of the object.",
    "array.ArrayType.__class_getitem__" => "See PEP 585",
    "array.ArrayType.__contains__" => "Return bool(key in self).",
    "array.ArrayType.__copy__" => "Return a copy of the array.",
    "array.ArrayType.__deepcopy__" => "Return a copy of the array.",
    "array.ArrayType.__delattr__" => "Implement delattr(self, name).",
    "array.ArrayType.__delitem__" => "Delete self[key].",
    "array.ArrayType.__eq__" => "Return self==value.",
    "array.ArrayType.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "array.ArrayType.__ge__" => "Return self>=value.",
    "array.ArrayType.__getattribute__" => "Return getattr(self, name).",
    "array.ArrayType.__getitem__" => "Return self[key].",
    "array.ArrayType.__getstate__" => "Helper for pickle.",
    "array.ArrayType.__gt__" => "Return self>value.",
    "array.ArrayType.__iadd__" => "Implement self+=value.",
    "array.ArrayType.__imul__" => "Implement self*=value.",
    "array.ArrayType.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "array.ArrayType.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "array.ArrayType.__iter__" => "Implement iter(self).",
    "array.ArrayType.__le__" => "Return self<=value.",
    "array.ArrayType.__len__" => "Return len(self).",
    "array.ArrayType.__lt__" => "Return self<value.",
    "array.ArrayType.__mul__" => "Return self*value.",
    "array.ArrayType.__ne__" => "Return self!=value.",
    "array.ArrayType.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "array.ArrayType.__reduce__" => "Helper for pickle.",
    "array.ArrayType.__reduce_ex__" => "Return state information for pickling.",
    "array.ArrayType.__release_buffer__" => "Release the buffer object that exposes the underlying memory of the object.",
    "array.ArrayType.__repr__" => "Return repr(self).",
    "array.ArrayType.__rmul__" => "Return value*self.",
    "array.ArrayType.__setattr__" => "Implement setattr(self, name, value).",
    "array.ArrayType.__setitem__" => "Set self[key] to value.",
    "array.ArrayType.__sizeof__" => "Size of the array in memory, in bytes.",
    "array.ArrayType.__str__" => "Return str(self).",
    "array.ArrayType.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "array.ArrayType.append" => "Append new value v to the end of the array.",
    "array.ArrayType.buffer_info" => "Return a tuple (address, length) giving the current memory address and the length in items of the buffer used to hold array's contents.\n\nThe length should be multiplied by the itemsize attribute to calculate\nthe buffer length in bytes.",
    "array.ArrayType.byteswap" => "Byteswap all items of the array.\n\nIf the items in the array are not 1, 2, 4, or 8 bytes in size, RuntimeError is\nraised.",
    "array.ArrayType.clear" => "Remove all items from the array.",
    "array.ArrayType.count" => "Return number of occurrences of v in the array.",
    "array.ArrayType.extend" => "Append items to the end of the array.",
    "array.ArrayType.frombytes" => "Appends items from the string, interpreting it as an array of machine values, as if it had been read from a file using the fromfile() method.",
    "array.ArrayType.fromfile" => "Read n objects from the file object f and append them to the end of the array.",
    "array.ArrayType.fromlist" => "Append items to array from list.",
    "array.ArrayType.fromunicode" => "Extends this array with data from the unicode string ustr.\n\nThe array must be a unicode type array; otherwise a ValueError is raised.\nUse array.frombytes(ustr.encode(...)) to append Unicode data to an array of\nsome other type.",
    "array.ArrayType.index" => "Return index of first occurrence of v in the array.\n\nRaise ValueError if the value is not present.",
    "array.ArrayType.insert" => "Insert a new item v into the array before position i.",
    "array.ArrayType.itemsize" => "the size, in bytes, of one array item",
    "array.ArrayType.pop" => "Return the i-th element and delete it from the array.\n\ni defaults to -1.",
    "array.ArrayType.remove" => "Remove the first occurrence of v in the array.",
    "array.ArrayType.reverse" => "Reverse the order of the items in the array.",
    "array.ArrayType.tobytes" => "Convert the array to an array of machine values and return the bytes representation.",
    "array.ArrayType.tofile" => "Write all items (as machine values) to the file object f.",
    "array.ArrayType.tolist" => "Convert array to an ordinary list with the same items.",
    "array.ArrayType.tounicode" => "Extends this array with data from the unicode string ustr.\n\nConvert the array to a unicode string.  The array must be a unicode type array;\notherwise a ValueError is raised.  Use array.tobytes().decode() to obtain a\nunicode string from an array of some other type.",
    "array.ArrayType.typecode" => "the typecode character used to create the array",
    "array._array_reconstructor" => "Internal. Used for pickling support.",
    "array.array" => "array(typecode [, initializer]) -> array\n\nReturn a new array whose items are restricted by typecode, and\ninitialized from the optional initializer value, which must be a list,\nstring or iterable over elements of the appropriate type.\n\nArrays represent basic values and behave very much like lists, except\nthe type of objects stored in them is constrained. The type is specified\nat object creation time by using a type code, which is a single character.\nThe following type codes are defined:\n\n    Type code   C Type             Minimum size in bytes\n    'b'         signed integer     1\n    'B'         unsigned integer   1\n    'u'         Unicode character  2 (see note)\n    'h'         signed integer     2\n    'H'         unsigned integer   2\n    'i'         signed integer     2\n    'I'         unsigned integer   2\n    'l'         signed integer     4\n    'L'         unsigned integer   4\n    'q'         signed integer     8 (see note)\n    'Q'         unsigned integer   8 (see note)\n    'f'         floating-point     4\n    'd'         floating-point     8\n\nNOTE: The 'u' typecode corresponds to Python's unicode character. On\nnarrow builds this is 2-bytes on wide builds this is 4-bytes.\n\nNOTE: The 'q' and 'Q' type codes are only available if the platform\nC compiler used to build Python supports 'long long', or, on Windows,\n'__int64'.\n\nMethods:\n\nappend() -- append a new item to the end of the array\nbuffer_info() -- return information giving the current memory info\nbyteswap() -- byteswap all the items of the array\ncount() -- return number of occurrences of an object\nextend() -- extend array by appending multiple elements from an iterable\nfromfile() -- read items from a file object\nfromlist() -- append items from the list\nfrombytes() -- append items from the string\nindex() -- return index of first occurrence of an object\ninsert() -- insert a new item into the array at a provided position\npop() -- remove and return item (default last)\nremove() -- remove first occurrence of an object\nreverse() -- reverse the order of the items in the array\ntofile() -- write all items to a file object\ntolist() -- return the array converted to an ordinary list\ntobytes() -- return the array converted to a string\n\nAttributes:\n\ntypecode -- the typecode character used to create the array\nitemsize -- the length in bytes of one array item",
    "array.array.__add__" => "Return self+value.",
    "array.array.__buffer__" => "Return a buffer object that exposes the underlying memory of the object.",
    "array.array.__class_getitem__" => "See PEP 585",
    "array.array.__contains__" => "Return bool(key in self).",
    "array.array.__copy__" => "Return a copy of the array.",
    "array.array.__deepcopy__" => "Return a copy of the array.",
    "array.array.__delattr__" => "Implement delattr(self, name).",
    "array.array.__delitem__" => "Delete self[key].",
    "array.array.__eq__" => "Return self==value.",
    "array.array.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "array.array.__ge__" => "Return self>=value.",
    "array.array.__getattribute__" => "Return getattr(self, name).",
    "array.array.__getitem__" => "Return self[key].",
    "array.array.__getstate__" => "Helper for pickle.",
    "array.array.__gt__" => "Return self>value.",
    "array.array.__iadd__" => "Implement self+=value.",
    "array.array.__imul__" => "Implement self*=value.",
    "array.array.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "array.array.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "array.array.__iter__" => "Implement iter(self).",
    "array.array.__le__" => "Return self<=value.",
    "array.array.__len__" => "Return len(self).",
    "array.array.__lt__" => "Return self<value.",
    "array.array.__mul__" => "Return self*value.",
    "array.array.__ne__" => "Return self!=value.",
    "array.array.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "array.array.__reduce__" => "Helper for pickle.",
    "array.array.__reduce_ex__" => "Return state information for pickling.",
    "array.array.__release_buffer__" => "Release the buffer object that exposes the underlying memory of the object.",
    "array.array.__repr__" => "Return repr(self).",
    "array.array.__rmul__" => "Return value*self.",
    "array.array.__setattr__" => "Implement setattr(self, name, value).",
    "array.array.__setitem__" => "Set self[key] to value.",
    "array.array.__sizeof__" => "Size of the array in memory, in bytes.",
    "array.array.__str__" => "Return str(self).",
    "array.array.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "array.array.append" => "Append new value v to the end of the array.",
    "array.array.buffer_info" => "Return a tuple (address, length) giving the current memory address and the length in items of the buffer used to hold array's contents.\n\nThe length should be multiplied by the itemsize attribute to calculate\nthe buffer length in bytes.",
    "array.array.byteswap" => "Byteswap all items of the array.\n\nIf the items in the array are not 1, 2, 4, or 8 bytes in size, RuntimeError is\nraised.",
    "array.array.clear" => "Remove all items from the array.",
    "array.array.count" => "Return number of occurrences of v in the array.",
    "array.array.extend" => "Append items to the end of the array.",
    "array.array.frombytes" => "Appends items from the string, interpreting it as an array of machine values, as if it had been read from a file using the fromfile() method.",
    "array.array.fromfile" => "Read n objects from the file object f and append them to the end of the array.",
    "array.array.fromlist" => "Append items to array from list.",
    "array.array.fromunicode" => "Extends this array with data from the unicode string ustr.\n\nThe array must be a unicode type array; otherwise a ValueError is raised.\nUse array.frombytes(ustr.encode(...)) to append Unicode data to an array of\nsome other type.",
    "array.array.index" => "Return index of first occurrence of v in the array.\n\nRaise ValueError if the value is not present.",
    "array.array.insert" => "Insert a new item v into the array before position i.",
    "array.array.itemsize" => "the size, in bytes, of one array item",
    "array.array.pop" => "Return the i-th element and delete it from the array.\n\ni defaults to -1.",
    "array.array.remove" => "Remove the first occurrence of v in the array.",
    "array.array.reverse" => "Reverse the order of the items in the array.",
    "array.array.tobytes" => "Convert the array to an array of machine values and return the bytes representation.",
    "array.array.tofile" => "Write all items (as machine values) to the file object f.",
    "array.array.tolist" => "Convert array to an ordinary list with the same items.",
    "array.array.tounicode" => "Extends this array with data from the unicode string ustr.\n\nConvert the array to a unicode string.  The array must be a unicode type array;\notherwise a ValueError is raised.  Use array.tobytes().decode() to obtain a\nunicode string from an array of some other type.",
    "array.array.typecode" => "the typecode character used to create the array",
    "atexit" => "allow programmer to define multiple exit functions to be executed\nupon normal program termination.\n\nTwo public functions, register and unregister, are defined.",
    "atexit._clear" => "Clear the list of previously registered exit functions.",
    "atexit._ncallbacks" => "Return the number of registered exit functions.",
    "atexit._run_exitfuncs" => "Run all registered exit functions.\n\nIf a callback raises an exception, it is logged with sys.unraisablehook.",
    "atexit.register" => "Register a function to be executed upon normal program termination\n\nfunc - function to be called at exit\nargs - optional arguments to pass to func\nkwargs - optional keyword arguments to pass to func\n\nfunc is returned to facilitate usage as a decorator.",
    "atexit.unregister" => "Unregister an exit function which was previously registered using\natexit.register\n\n    func - function to be unregistered",
    "binascii" => "Conversion between binary data and ASCII",
    "binascii.Error.__cause__" => "exception cause",
    "binascii.Error.__context__" => "exception context",
    "binascii.Error.__delattr__" => "Implement delattr(self, name).",
    "binascii.Error.__eq__" => "Return self==value.",
    "binascii.Error.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "binascii.Error.__ge__" => "Return self>=value.",
    "binascii.Error.__getattribute__" => "Return getattr(self, name).",
    "binascii.Error.__getstate__" => "Helper for pickle.",
    "binascii.Error.__gt__" => "Return self>value.",
    "binascii.Error.__hash__" => "Return hash(self).",
    "binascii.Error.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "binascii.Error.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "binascii.Error.__le__" => "Return self<=value.",
    "binascii.Error.__lt__" => "Return self<value.",
    "binascii.Error.__ne__" => "Return self!=value.",
    "binascii.Error.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "binascii.Error.__reduce_ex__" => "Helper for pickle.",
    "binascii.Error.__repr__" => "Return repr(self).",
    "binascii.Error.__setattr__" => "Implement setattr(self, name, value).",
    "binascii.Error.__sizeof__" => "Size of object in memory, in bytes.",
    "binascii.Error.__str__" => "Return str(self).",
    "binascii.Error.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "binascii.Error.__weakref__" => "list of weak references to the object",
    "binascii.Error.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "binascii.Error.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "binascii.Incomplete.__cause__" => "exception cause",
    "binascii.Incomplete.__context__" => "exception context",
    "binascii.Incomplete.__delattr__" => "Implement delattr(self, name).",
    "binascii.Incomplete.__eq__" => "Return self==value.",
    "binascii.Incomplete.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "binascii.Incomplete.__ge__" => "Return self>=value.",
    "binascii.Incomplete.__getattribute__" => "Return getattr(self, name).",
    "binascii.Incomplete.__getstate__" => "Helper for pickle.",
    "binascii.Incomplete.__gt__" => "Return self>value.",
    "binascii.Incomplete.__hash__" => "Return hash(self).",
    "binascii.Incomplete.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "binascii.Incomplete.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "binascii.Incomplete.__le__" => "Return self<=value.",
    "binascii.Incomplete.__lt__" => "Return self<value.",
    "binascii.Incomplete.__ne__" => "Return self!=value.",
    "binascii.Incomplete.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "binascii.Incomplete.__reduce_ex__" => "Helper for pickle.",
    "binascii.Incomplete.__repr__" => "Return repr(self).",
    "binascii.Incomplete.__setattr__" => "Implement setattr(self, name, value).",
    "binascii.Incomplete.__sizeof__" => "Size of object in memory, in bytes.",
    "binascii.Incomplete.__str__" => "Return str(self).",
    "binascii.Incomplete.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "binascii.Incomplete.__weakref__" => "list of weak references to the object",
    "binascii.Incomplete.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "binascii.Incomplete.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "binascii.a2b_base64" => "Decode a line of base64 data.\n\nstrict_mode\n  When set to True, bytes that are not part of the base64 standard are not allowed.\n  The same applies to excess data after padding (= / ==).",
    "binascii.a2b_hex" => "Binary data of hexadecimal representation.\n\nhexstr must contain an even number of hex digits (upper or lower case).\nThis function is also available as \"unhexlify()\".",
    "binascii.a2b_qp" => "Decode a string of qp-encoded data.",
    "binascii.a2b_uu" => "Decode a line of uuencoded data.",
    "binascii.b2a_base64" => "Base64-code line of data.",
    "binascii.b2a_hex" => "Hexadecimal representation of binary data.\n\n  sep\n    An optional single character or byte to separate hex bytes.\n  bytes_per_sep\n    How many bytes between separators.  Positive values count from the\n    right, negative values count from the left.\n\nThe return value is a bytes object.  This function is also\navailable as \"hexlify()\".\n\nExample:\n>>> binascii.b2a_hex(b'\\xb9\\x01\\xef')\nb'b901ef'\n>>> binascii.hexlify(b'\\xb9\\x01\\xef', ':')\nb'b9:01:ef'\n>>> binascii.b2a_hex(b'\\xb9\\x01\\xef', b'_', 2)\nb'b9_01ef'",
    "binascii.b2a_qp" => "Encode a string using quoted-printable encoding.\n\nOn encoding, when istext is set, newlines are not encoded, and white\nspace at end of lines is.  When istext is not set, \\r and \\n (CR/LF)\nare both encoded.  When quotetabs is set, space and tabs are encoded.",
    "binascii.b2a_uu" => "Uuencode line of data.",
    "binascii.crc32" => "Compute CRC-32 incrementally.",
    "binascii.crc_hqx" => "Compute CRC-CCITT incrementally.",
    "binascii.hexlify" => "Hexadecimal representation of binary data.\n\n  sep\n    An optional single character or byte to separate hex bytes.\n  bytes_per_sep\n    How many bytes between separators.  Positive values count from the\n    right, negative values count from the left.\n\nThe return value is a bytes object.  This function is also\navailable as \"b2a_hex()\".",
    "binascii.unhexlify" => "Binary data of hexadecimal representation.\n\nhexstr must contain an even number of hex digits (upper or lower case).",
    "builtins" => "Built-in functions, types, exceptions, and other objects.\n\nThis module provides direct access to all 'built-in'\nidentifiers of Python; for example, builtins.len is\nthe full name for the built-in function len().\n\nThis module is not normally accessed explicitly by most\napplications, but can be useful in modules that provide\nobjects with the same name as a built-in value, but in\nwhich the built-in of that name is also needed.",
    "builtins.ArithmeticError" => "Base class for arithmetic errors.",
    "builtins.ArithmeticError.__cause__" => "exception cause",
    "builtins.ArithmeticError.__context__" => "exception context",
    "builtins.ArithmeticError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ArithmeticError.__eq__" => "Return self==value.",
    "builtins.ArithmeticError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ArithmeticError.__ge__" => "Return self>=value.",
    "builtins.ArithmeticError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ArithmeticError.__getstate__" => "Helper for pickle.",
    "builtins.ArithmeticError.__gt__" => "Return self>value.",
    "builtins.ArithmeticError.__hash__" => "Return hash(self).",
    "builtins.ArithmeticError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ArithmeticError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ArithmeticError.__le__" => "Return self<=value.",
    "builtins.ArithmeticError.__lt__" => "Return self<value.",
    "builtins.ArithmeticError.__ne__" => "Return self!=value.",
    "builtins.ArithmeticError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ArithmeticError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ArithmeticError.__repr__" => "Return repr(self).",
    "builtins.ArithmeticError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ArithmeticError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ArithmeticError.__str__" => "Return str(self).",
    "builtins.ArithmeticError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ArithmeticError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ArithmeticError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.AssertionError" => "Assertion failed.",
    "builtins.AssertionError.__cause__" => "exception cause",
    "builtins.AssertionError.__context__" => "exception context",
    "builtins.AssertionError.__delattr__" => "Implement delattr(self, name).",
    "builtins.AssertionError.__eq__" => "Return self==value.",
    "builtins.AssertionError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.AssertionError.__ge__" => "Return self>=value.",
    "builtins.AssertionError.__getattribute__" => "Return getattr(self, name).",
    "builtins.AssertionError.__getstate__" => "Helper for pickle.",
    "builtins.AssertionError.__gt__" => "Return self>value.",
    "builtins.AssertionError.__hash__" => "Return hash(self).",
    "builtins.AssertionError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.AssertionError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.AssertionError.__le__" => "Return self<=value.",
    "builtins.AssertionError.__lt__" => "Return self<value.",
    "builtins.AssertionError.__ne__" => "Return self!=value.",
    "builtins.AssertionError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.AssertionError.__reduce_ex__" => "Helper for pickle.",
    "builtins.AssertionError.__repr__" => "Return repr(self).",
    "builtins.AssertionError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.AssertionError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.AssertionError.__str__" => "Return str(self).",
    "builtins.AssertionError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.AssertionError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.AssertionError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.AttributeError" => "Attribute not found.",
    "builtins.AttributeError.__cause__" => "exception cause",
    "builtins.AttributeError.__context__" => "exception context",
    "builtins.AttributeError.__delattr__" => "Implement delattr(self, name).",
    "builtins.AttributeError.__eq__" => "Return self==value.",
    "builtins.AttributeError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.AttributeError.__ge__" => "Return self>=value.",
    "builtins.AttributeError.__getattribute__" => "Return getattr(self, name).",
    "builtins.AttributeError.__gt__" => "Return self>value.",
    "builtins.AttributeError.__hash__" => "Return hash(self).",
    "builtins.AttributeError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.AttributeError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.AttributeError.__le__" => "Return self<=value.",
    "builtins.AttributeError.__lt__" => "Return self<value.",
    "builtins.AttributeError.__ne__" => "Return self!=value.",
    "builtins.AttributeError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.AttributeError.__reduce_ex__" => "Helper for pickle.",
    "builtins.AttributeError.__repr__" => "Return repr(self).",
    "builtins.AttributeError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.AttributeError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.AttributeError.__str__" => "Return str(self).",
    "builtins.AttributeError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.AttributeError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.AttributeError.name" => "attribute name",
    "builtins.AttributeError.obj" => "object",
    "builtins.AttributeError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.BaseException" => "Common base class for all exceptions",
    "builtins.BaseException.__cause__" => "exception cause",
    "builtins.BaseException.__context__" => "exception context",
    "builtins.BaseException.__delattr__" => "Implement delattr(self, name).",
    "builtins.BaseException.__eq__" => "Return self==value.",
    "builtins.BaseException.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.BaseException.__ge__" => "Return self>=value.",
    "builtins.BaseException.__getattribute__" => "Return getattr(self, name).",
    "builtins.BaseException.__getstate__" => "Helper for pickle.",
    "builtins.BaseException.__gt__" => "Return self>value.",
    "builtins.BaseException.__hash__" => "Return hash(self).",
    "builtins.BaseException.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.BaseException.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.BaseException.__le__" => "Return self<=value.",
    "builtins.BaseException.__lt__" => "Return self<value.",
    "builtins.BaseException.__ne__" => "Return self!=value.",
    "builtins.BaseException.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.BaseException.__reduce_ex__" => "Helper for pickle.",
    "builtins.BaseException.__repr__" => "Return repr(self).",
    "builtins.BaseException.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.BaseException.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.BaseException.__str__" => "Return str(self).",
    "builtins.BaseException.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.BaseException.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.BaseException.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.BaseExceptionGroup" => "A combination of multiple unrelated exceptions.",
    "builtins.BaseExceptionGroup.__cause__" => "exception cause",
    "builtins.BaseExceptionGroup.__class_getitem__" => "See PEP 585",
    "builtins.BaseExceptionGroup.__context__" => "exception context",
    "builtins.BaseExceptionGroup.__delattr__" => "Implement delattr(self, name).",
    "builtins.BaseExceptionGroup.__eq__" => "Return self==value.",
    "builtins.BaseExceptionGroup.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.BaseExceptionGroup.__ge__" => "Return self>=value.",
    "builtins.BaseExceptionGroup.__getattribute__" => "Return getattr(self, name).",
    "builtins.BaseExceptionGroup.__getstate__" => "Helper for pickle.",
    "builtins.BaseExceptionGroup.__gt__" => "Return self>value.",
    "builtins.BaseExceptionGroup.__hash__" => "Return hash(self).",
    "builtins.BaseExceptionGroup.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.BaseExceptionGroup.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.BaseExceptionGroup.__le__" => "Return self<=value.",
    "builtins.BaseExceptionGroup.__lt__" => "Return self<value.",
    "builtins.BaseExceptionGroup.__ne__" => "Return self!=value.",
    "builtins.BaseExceptionGroup.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.BaseExceptionGroup.__reduce_ex__" => "Helper for pickle.",
    "builtins.BaseExceptionGroup.__repr__" => "Return repr(self).",
    "builtins.BaseExceptionGroup.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.BaseExceptionGroup.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.BaseExceptionGroup.__str__" => "Return str(self).",
    "builtins.BaseExceptionGroup.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.BaseExceptionGroup.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.BaseExceptionGroup.exceptions" => "nested exceptions",
    "builtins.BaseExceptionGroup.message" => "exception message",
    "builtins.BaseExceptionGroup.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.BlockingIOError" => "I/O operation would block.",
    "builtins.BlockingIOError.__cause__" => "exception cause",
    "builtins.BlockingIOError.__context__" => "exception context",
    "builtins.BlockingIOError.__delattr__" => "Implement delattr(self, name).",
    "builtins.BlockingIOError.__eq__" => "Return self==value.",
    "builtins.BlockingIOError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.BlockingIOError.__ge__" => "Return self>=value.",
    "builtins.BlockingIOError.__getattribute__" => "Return getattr(self, name).",
    "builtins.BlockingIOError.__getstate__" => "Helper for pickle.",
    "builtins.BlockingIOError.__gt__" => "Return self>value.",
    "builtins.BlockingIOError.__hash__" => "Return hash(self).",
    "builtins.BlockingIOError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.BlockingIOError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.BlockingIOError.__le__" => "Return self<=value.",
    "builtins.BlockingIOError.__lt__" => "Return self<value.",
    "builtins.BlockingIOError.__ne__" => "Return self!=value.",
    "builtins.BlockingIOError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.BlockingIOError.__reduce_ex__" => "Helper for pickle.",
    "builtins.BlockingIOError.__repr__" => "Return repr(self).",
    "builtins.BlockingIOError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.BlockingIOError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.BlockingIOError.__str__" => "Return str(self).",
    "builtins.BlockingIOError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.BlockingIOError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.BlockingIOError.errno" => "POSIX exception code",
    "builtins.BlockingIOError.filename" => "exception filename",
    "builtins.BlockingIOError.filename2" => "second exception filename",
    "builtins.BlockingIOError.strerror" => "exception strerror",
    "builtins.BlockingIOError.winerror" => "Win32 exception code",
    "builtins.BlockingIOError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.BrokenPipeError" => "Broken pipe.",
    "builtins.BrokenPipeError.__cause__" => "exception cause",
    "builtins.BrokenPipeError.__context__" => "exception context",
    "builtins.BrokenPipeError.__delattr__" => "Implement delattr(self, name).",
    "builtins.BrokenPipeError.__eq__" => "Return self==value.",
    "builtins.BrokenPipeError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.BrokenPipeError.__ge__" => "Return self>=value.",
    "builtins.BrokenPipeError.__getattribute__" => "Return getattr(self, name).",
    "builtins.BrokenPipeError.__getstate__" => "Helper for pickle.",
    "builtins.BrokenPipeError.__gt__" => "Return self>value.",
    "builtins.BrokenPipeError.__hash__" => "Return hash(self).",
    "builtins.BrokenPipeError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.BrokenPipeError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.BrokenPipeError.__le__" => "Return self<=value.",
    "builtins.BrokenPipeError.__lt__" => "Return self<value.",
    "builtins.BrokenPipeError.__ne__" => "Return self!=value.",
    "builtins.BrokenPipeError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.BrokenPipeError.__reduce_ex__" => "Helper for pickle.",
    "builtins.BrokenPipeError.__repr__" => "Return repr(self).",
    "builtins.BrokenPipeError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.BrokenPipeError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.BrokenPipeError.__str__" => "Return str(self).",
    "builtins.BrokenPipeError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.BrokenPipeError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.BrokenPipeError.errno" => "POSIX exception code",
    "builtins.BrokenPipeError.filename" => "exception filename",
    "builtins.BrokenPipeError.filename2" => "second exception filename",
    "builtins.BrokenPipeError.strerror" => "exception strerror",
    "builtins.BrokenPipeError.winerror" => "Win32 exception code",
    "builtins.BrokenPipeError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.BufferError" => "Buffer error.",
    "builtins.BufferError.__cause__" => "exception cause",
    "builtins.BufferError.__context__" => "exception context",
    "builtins.BufferError.__delattr__" => "Implement delattr(self, name).",
    "builtins.BufferError.__eq__" => "Return self==value.",
    "builtins.BufferError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.BufferError.__ge__" => "Return self>=value.",
    "builtins.BufferError.__getattribute__" => "Return getattr(self, name).",
    "builtins.BufferError.__getstate__" => "Helper for pickle.",
    "builtins.BufferError.__gt__" => "Return self>value.",
    "builtins.BufferError.__hash__" => "Return hash(self).",
    "builtins.BufferError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.BufferError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.BufferError.__le__" => "Return self<=value.",
    "builtins.BufferError.__lt__" => "Return self<value.",
    "builtins.BufferError.__ne__" => "Return self!=value.",
    "builtins.BufferError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.BufferError.__reduce_ex__" => "Helper for pickle.",
    "builtins.BufferError.__repr__" => "Return repr(self).",
    "builtins.BufferError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.BufferError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.BufferError.__str__" => "Return str(self).",
    "builtins.BufferError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.BufferError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.BufferError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.BytesWarning" => "Base class for warnings about bytes and buffer related problems, mostly\nrelated to conversion from str or comparing to str.",
    "builtins.BytesWarning.__cause__" => "exception cause",
    "builtins.BytesWarning.__context__" => "exception context",
    "builtins.BytesWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.BytesWarning.__eq__" => "Return self==value.",
    "builtins.BytesWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.BytesWarning.__ge__" => "Return self>=value.",
    "builtins.BytesWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.BytesWarning.__getstate__" => "Helper for pickle.",
    "builtins.BytesWarning.__gt__" => "Return self>value.",
    "builtins.BytesWarning.__hash__" => "Return hash(self).",
    "builtins.BytesWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.BytesWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.BytesWarning.__le__" => "Return self<=value.",
    "builtins.BytesWarning.__lt__" => "Return self<value.",
    "builtins.BytesWarning.__ne__" => "Return self!=value.",
    "builtins.BytesWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.BytesWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.BytesWarning.__repr__" => "Return repr(self).",
    "builtins.BytesWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.BytesWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.BytesWarning.__str__" => "Return str(self).",
    "builtins.BytesWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.BytesWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.BytesWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ChildProcessError" => "Child process error.",
    "builtins.ChildProcessError.__cause__" => "exception cause",
    "builtins.ChildProcessError.__context__" => "exception context",
    "builtins.ChildProcessError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ChildProcessError.__eq__" => "Return self==value.",
    "builtins.ChildProcessError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ChildProcessError.__ge__" => "Return self>=value.",
    "builtins.ChildProcessError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ChildProcessError.__getstate__" => "Helper for pickle.",
    "builtins.ChildProcessError.__gt__" => "Return self>value.",
    "builtins.ChildProcessError.__hash__" => "Return hash(self).",
    "builtins.ChildProcessError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ChildProcessError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ChildProcessError.__le__" => "Return self<=value.",
    "builtins.ChildProcessError.__lt__" => "Return self<value.",
    "builtins.ChildProcessError.__ne__" => "Return self!=value.",
    "builtins.ChildProcessError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ChildProcessError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ChildProcessError.__repr__" => "Return repr(self).",
    "builtins.ChildProcessError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ChildProcessError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ChildProcessError.__str__" => "Return str(self).",
    "builtins.ChildProcessError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ChildProcessError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ChildProcessError.errno" => "POSIX exception code",
    "builtins.ChildProcessError.filename" => "exception filename",
    "builtins.ChildProcessError.filename2" => "second exception filename",
    "builtins.ChildProcessError.strerror" => "exception strerror",
    "builtins.ChildProcessError.winerror" => "Win32 exception code",
    "builtins.ChildProcessError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ConnectionAbortedError" => "Connection aborted.",
    "builtins.ConnectionAbortedError.__cause__" => "exception cause",
    "builtins.ConnectionAbortedError.__context__" => "exception context",
    "builtins.ConnectionAbortedError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ConnectionAbortedError.__eq__" => "Return self==value.",
    "builtins.ConnectionAbortedError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ConnectionAbortedError.__ge__" => "Return self>=value.",
    "builtins.ConnectionAbortedError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ConnectionAbortedError.__getstate__" => "Helper for pickle.",
    "builtins.ConnectionAbortedError.__gt__" => "Return self>value.",
    "builtins.ConnectionAbortedError.__hash__" => "Return hash(self).",
    "builtins.ConnectionAbortedError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ConnectionAbortedError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ConnectionAbortedError.__le__" => "Return self<=value.",
    "builtins.ConnectionAbortedError.__lt__" => "Return self<value.",
    "builtins.ConnectionAbortedError.__ne__" => "Return self!=value.",
    "builtins.ConnectionAbortedError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ConnectionAbortedError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ConnectionAbortedError.__repr__" => "Return repr(self).",
    "builtins.ConnectionAbortedError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ConnectionAbortedError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ConnectionAbortedError.__str__" => "Return str(self).",
    "builtins.ConnectionAbortedError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ConnectionAbortedError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ConnectionAbortedError.errno" => "POSIX exception code",
    "builtins.ConnectionAbortedError.filename" => "exception filename",
    "builtins.ConnectionAbortedError.filename2" => "second exception filename",
    "builtins.ConnectionAbortedError.strerror" => "exception strerror",
    "builtins.ConnectionAbortedError.winerror" => "Win32 exception code",
    "builtins.ConnectionAbortedError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ConnectionError" => "Connection error.",
    "builtins.ConnectionError.__cause__" => "exception cause",
    "builtins.ConnectionError.__context__" => "exception context",
    "builtins.ConnectionError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ConnectionError.__eq__" => "Return self==value.",
    "builtins.ConnectionError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ConnectionError.__ge__" => "Return self>=value.",
    "builtins.ConnectionError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ConnectionError.__getstate__" => "Helper for pickle.",
    "builtins.ConnectionError.__gt__" => "Return self>value.",
    "builtins.ConnectionError.__hash__" => "Return hash(self).",
    "builtins.ConnectionError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ConnectionError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ConnectionError.__le__" => "Return self<=value.",
    "builtins.ConnectionError.__lt__" => "Return self<value.",
    "builtins.ConnectionError.__ne__" => "Return self!=value.",
    "builtins.ConnectionError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ConnectionError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ConnectionError.__repr__" => "Return repr(self).",
    "builtins.ConnectionError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ConnectionError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ConnectionError.__str__" => "Return str(self).",
    "builtins.ConnectionError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ConnectionError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ConnectionError.errno" => "POSIX exception code",
    "builtins.ConnectionError.filename" => "exception filename",
    "builtins.ConnectionError.filename2" => "second exception filename",
    "builtins.ConnectionError.strerror" => "exception strerror",
    "builtins.ConnectionError.winerror" => "Win32 exception code",
    "builtins.ConnectionError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ConnectionRefusedError" => "Connection refused.",
    "builtins.ConnectionRefusedError.__cause__" => "exception cause",
    "builtins.ConnectionRefusedError.__context__" => "exception context",
    "builtins.ConnectionRefusedError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ConnectionRefusedError.__eq__" => "Return self==value.",
    "builtins.ConnectionRefusedError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ConnectionRefusedError.__ge__" => "Return self>=value.",
    "builtins.ConnectionRefusedError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ConnectionRefusedError.__getstate__" => "Helper for pickle.",
    "builtins.ConnectionRefusedError.__gt__" => "Return self>value.",
    "builtins.ConnectionRefusedError.__hash__" => "Return hash(self).",
    "builtins.ConnectionRefusedError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ConnectionRefusedError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ConnectionRefusedError.__le__" => "Return self<=value.",
    "builtins.ConnectionRefusedError.__lt__" => "Return self<value.",
    "builtins.ConnectionRefusedError.__ne__" => "Return self!=value.",
    "builtins.ConnectionRefusedError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ConnectionRefusedError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ConnectionRefusedError.__repr__" => "Return repr(self).",
    "builtins.ConnectionRefusedError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ConnectionRefusedError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ConnectionRefusedError.__str__" => "Return str(self).",
    "builtins.ConnectionRefusedError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ConnectionRefusedError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ConnectionRefusedError.errno" => "POSIX exception code",
    "builtins.ConnectionRefusedError.filename" => "exception filename",
    "builtins.ConnectionRefusedError.filename2" => "second exception filename",
    "builtins.ConnectionRefusedError.strerror" => "exception strerror",
    "builtins.ConnectionRefusedError.winerror" => "Win32 exception code",
    "builtins.ConnectionRefusedError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ConnectionResetError" => "Connection reset.",
    "builtins.ConnectionResetError.__cause__" => "exception cause",
    "builtins.ConnectionResetError.__context__" => "exception context",
    "builtins.ConnectionResetError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ConnectionResetError.__eq__" => "Return self==value.",
    "builtins.ConnectionResetError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ConnectionResetError.__ge__" => "Return self>=value.",
    "builtins.ConnectionResetError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ConnectionResetError.__getstate__" => "Helper for pickle.",
    "builtins.ConnectionResetError.__gt__" => "Return self>value.",
    "builtins.ConnectionResetError.__hash__" => "Return hash(self).",
    "builtins.ConnectionResetError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ConnectionResetError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ConnectionResetError.__le__" => "Return self<=value.",
    "builtins.ConnectionResetError.__lt__" => "Return self<value.",
    "builtins.ConnectionResetError.__ne__" => "Return self!=value.",
    "builtins.ConnectionResetError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ConnectionResetError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ConnectionResetError.__repr__" => "Return repr(self).",
    "builtins.ConnectionResetError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ConnectionResetError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ConnectionResetError.__str__" => "Return str(self).",
    "builtins.ConnectionResetError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ConnectionResetError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ConnectionResetError.errno" => "POSIX exception code",
    "builtins.ConnectionResetError.filename" => "exception filename",
    "builtins.ConnectionResetError.filename2" => "second exception filename",
    "builtins.ConnectionResetError.strerror" => "exception strerror",
    "builtins.ConnectionResetError.winerror" => "Win32 exception code",
    "builtins.ConnectionResetError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.DeprecationWarning" => "Base class for warnings about deprecated features.",
    "builtins.DeprecationWarning.__cause__" => "exception cause",
    "builtins.DeprecationWarning.__context__" => "exception context",
    "builtins.DeprecationWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.DeprecationWarning.__eq__" => "Return self==value.",
    "builtins.DeprecationWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.DeprecationWarning.__ge__" => "Return self>=value.",
    "builtins.DeprecationWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.DeprecationWarning.__getstate__" => "Helper for pickle.",
    "builtins.DeprecationWarning.__gt__" => "Return self>value.",
    "builtins.DeprecationWarning.__hash__" => "Return hash(self).",
    "builtins.DeprecationWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.DeprecationWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.DeprecationWarning.__le__" => "Return self<=value.",
    "builtins.DeprecationWarning.__lt__" => "Return self<value.",
    "builtins.DeprecationWarning.__ne__" => "Return self!=value.",
    "builtins.DeprecationWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.DeprecationWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.DeprecationWarning.__repr__" => "Return repr(self).",
    "builtins.DeprecationWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.DeprecationWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.DeprecationWarning.__str__" => "Return str(self).",
    "builtins.DeprecationWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.DeprecationWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.DeprecationWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.EOFError" => "Read beyond end of file.",
    "builtins.EOFError.__cause__" => "exception cause",
    "builtins.EOFError.__context__" => "exception context",
    "builtins.EOFError.__delattr__" => "Implement delattr(self, name).",
    "builtins.EOFError.__eq__" => "Return self==value.",
    "builtins.EOFError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.EOFError.__ge__" => "Return self>=value.",
    "builtins.EOFError.__getattribute__" => "Return getattr(self, name).",
    "builtins.EOFError.__getstate__" => "Helper for pickle.",
    "builtins.EOFError.__gt__" => "Return self>value.",
    "builtins.EOFError.__hash__" => "Return hash(self).",
    "builtins.EOFError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.EOFError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.EOFError.__le__" => "Return self<=value.",
    "builtins.EOFError.__lt__" => "Return self<value.",
    "builtins.EOFError.__ne__" => "Return self!=value.",
    "builtins.EOFError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.EOFError.__reduce_ex__" => "Helper for pickle.",
    "builtins.EOFError.__repr__" => "Return repr(self).",
    "builtins.EOFError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.EOFError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.EOFError.__str__" => "Return str(self).",
    "builtins.EOFError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.EOFError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.EOFError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.EncodingWarning" => "Base class for warnings about encodings.",
    "builtins.EncodingWarning.__cause__" => "exception cause",
    "builtins.EncodingWarning.__context__" => "exception context",
    "builtins.EncodingWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.EncodingWarning.__eq__" => "Return self==value.",
    "builtins.EncodingWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.EncodingWarning.__ge__" => "Return self>=value.",
    "builtins.EncodingWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.EncodingWarning.__getstate__" => "Helper for pickle.",
    "builtins.EncodingWarning.__gt__" => "Return self>value.",
    "builtins.EncodingWarning.__hash__" => "Return hash(self).",
    "builtins.EncodingWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.EncodingWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.EncodingWarning.__le__" => "Return self<=value.",
    "builtins.EncodingWarning.__lt__" => "Return self<value.",
    "builtins.EncodingWarning.__ne__" => "Return self!=value.",
    "builtins.EncodingWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.EncodingWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.EncodingWarning.__repr__" => "Return repr(self).",
    "builtins.EncodingWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.EncodingWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.EncodingWarning.__str__" => "Return str(self).",
    "builtins.EncodingWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.EncodingWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.EncodingWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.EnvironmentError" => "Base class for I/O related errors.",
    "builtins.EnvironmentError.__cause__" => "exception cause",
    "builtins.EnvironmentError.__context__" => "exception context",
    "builtins.EnvironmentError.__delattr__" => "Implement delattr(self, name).",
    "builtins.EnvironmentError.__eq__" => "Return self==value.",
    "builtins.EnvironmentError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.EnvironmentError.__ge__" => "Return self>=value.",
    "builtins.EnvironmentError.__getattribute__" => "Return getattr(self, name).",
    "builtins.EnvironmentError.__getstate__" => "Helper for pickle.",
    "builtins.EnvironmentError.__gt__" => "Return self>value.",
    "builtins.EnvironmentError.__hash__" => "Return hash(self).",
    "builtins.EnvironmentError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.EnvironmentError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.EnvironmentError.__le__" => "Return self<=value.",
    "builtins.EnvironmentError.__lt__" => "Return self<value.",
    "builtins.EnvironmentError.__ne__" => "Return self!=value.",
    "builtins.EnvironmentError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.EnvironmentError.__reduce_ex__" => "Helper for pickle.",
    "builtins.EnvironmentError.__repr__" => "Return repr(self).",
    "builtins.EnvironmentError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.EnvironmentError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.EnvironmentError.__str__" => "Return str(self).",
    "builtins.EnvironmentError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.EnvironmentError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.EnvironmentError.errno" => "POSIX exception code",
    "builtins.EnvironmentError.filename" => "exception filename",
    "builtins.EnvironmentError.filename2" => "second exception filename",
    "builtins.EnvironmentError.strerror" => "exception strerror",
    "builtins.EnvironmentError.winerror" => "Win32 exception code",
    "builtins.EnvironmentError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.Exception" => "Common base class for all non-exit exceptions.",
    "builtins.Exception.__cause__" => "exception cause",
    "builtins.Exception.__context__" => "exception context",
    "builtins.Exception.__delattr__" => "Implement delattr(self, name).",
    "builtins.Exception.__eq__" => "Return self==value.",
    "builtins.Exception.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.Exception.__ge__" => "Return self>=value.",
    "builtins.Exception.__getattribute__" => "Return getattr(self, name).",
    "builtins.Exception.__getstate__" => "Helper for pickle.",
    "builtins.Exception.__gt__" => "Return self>value.",
    "builtins.Exception.__hash__" => "Return hash(self).",
    "builtins.Exception.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.Exception.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.Exception.__le__" => "Return self<=value.",
    "builtins.Exception.__lt__" => "Return self<value.",
    "builtins.Exception.__ne__" => "Return self!=value.",
    "builtins.Exception.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.Exception.__reduce_ex__" => "Helper for pickle.",
    "builtins.Exception.__repr__" => "Return repr(self).",
    "builtins.Exception.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.Exception.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.Exception.__str__" => "Return str(self).",
    "builtins.Exception.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.Exception.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.Exception.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ExceptionGroup.__cause__" => "exception cause",
    "builtins.ExceptionGroup.__class_getitem__" => "See PEP 585",
    "builtins.ExceptionGroup.__context__" => "exception context",
    "builtins.ExceptionGroup.__delattr__" => "Implement delattr(self, name).",
    "builtins.ExceptionGroup.__eq__" => "Return self==value.",
    "builtins.ExceptionGroup.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ExceptionGroup.__ge__" => "Return self>=value.",
    "builtins.ExceptionGroup.__getattribute__" => "Return getattr(self, name).",
    "builtins.ExceptionGroup.__getstate__" => "Helper for pickle.",
    "builtins.ExceptionGroup.__gt__" => "Return self>value.",
    "builtins.ExceptionGroup.__hash__" => "Return hash(self).",
    "builtins.ExceptionGroup.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ExceptionGroup.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ExceptionGroup.__le__" => "Return self<=value.",
    "builtins.ExceptionGroup.__lt__" => "Return self<value.",
    "builtins.ExceptionGroup.__ne__" => "Return self!=value.",
    "builtins.ExceptionGroup.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ExceptionGroup.__reduce_ex__" => "Helper for pickle.",
    "builtins.ExceptionGroup.__repr__" => "Return repr(self).",
    "builtins.ExceptionGroup.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ExceptionGroup.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ExceptionGroup.__str__" => "Return str(self).",
    "builtins.ExceptionGroup.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ExceptionGroup.__weakref__" => "list of weak references to the object",
    "builtins.ExceptionGroup.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ExceptionGroup.exceptions" => "nested exceptions",
    "builtins.ExceptionGroup.message" => "exception message",
    "builtins.ExceptionGroup.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.FileExistsError" => "File already exists.",
    "builtins.FileExistsError.__cause__" => "exception cause",
    "builtins.FileExistsError.__context__" => "exception context",
    "builtins.FileExistsError.__delattr__" => "Implement delattr(self, name).",
    "builtins.FileExistsError.__eq__" => "Return self==value.",
    "builtins.FileExistsError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.FileExistsError.__ge__" => "Return self>=value.",
    "builtins.FileExistsError.__getattribute__" => "Return getattr(self, name).",
    "builtins.FileExistsError.__getstate__" => "Helper for pickle.",
    "builtins.FileExistsError.__gt__" => "Return self>value.",
    "builtins.FileExistsError.__hash__" => "Return hash(self).",
    "builtins.FileExistsError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.FileExistsError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.FileExistsError.__le__" => "Return self<=value.",
    "builtins.FileExistsError.__lt__" => "Return self<value.",
    "builtins.FileExistsError.__ne__" => "Return self!=value.",
    "builtins.FileExistsError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.FileExistsError.__reduce_ex__" => "Helper for pickle.",
    "builtins.FileExistsError.__repr__" => "Return repr(self).",
    "builtins.FileExistsError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.FileExistsError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.FileExistsError.__str__" => "Return str(self).",
    "builtins.FileExistsError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.FileExistsError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.FileExistsError.errno" => "POSIX exception code",
    "builtins.FileExistsError.filename" => "exception filename",
    "builtins.FileExistsError.filename2" => "second exception filename",
    "builtins.FileExistsError.strerror" => "exception strerror",
    "builtins.FileExistsError.winerror" => "Win32 exception code",
    "builtins.FileExistsError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.FileNotFoundError" => "File not found.",
    "builtins.FileNotFoundError.__cause__" => "exception cause",
    "builtins.FileNotFoundError.__context__" => "exception context",
    "builtins.FileNotFoundError.__delattr__" => "Implement delattr(self, name).",
    "builtins.FileNotFoundError.__eq__" => "Return self==value.",
    "builtins.FileNotFoundError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.FileNotFoundError.__ge__" => "Return self>=value.",
    "builtins.FileNotFoundError.__getattribute__" => "Return getattr(self, name).",
    "builtins.FileNotFoundError.__getstate__" => "Helper for pickle.",
    "builtins.FileNotFoundError.__gt__" => "Return self>value.",
    "builtins.FileNotFoundError.__hash__" => "Return hash(self).",
    "builtins.FileNotFoundError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.FileNotFoundError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.FileNotFoundError.__le__" => "Return self<=value.",
    "builtins.FileNotFoundError.__lt__" => "Return self<value.",
    "builtins.FileNotFoundError.__ne__" => "Return self!=value.",
    "builtins.FileNotFoundError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.FileNotFoundError.__reduce_ex__" => "Helper for pickle.",
    "builtins.FileNotFoundError.__repr__" => "Return repr(self).",
    "builtins.FileNotFoundError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.FileNotFoundError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.FileNotFoundError.__str__" => "Return str(self).",
    "builtins.FileNotFoundError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.FileNotFoundError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.FileNotFoundError.errno" => "POSIX exception code",
    "builtins.FileNotFoundError.filename" => "exception filename",
    "builtins.FileNotFoundError.filename2" => "second exception filename",
    "builtins.FileNotFoundError.strerror" => "exception strerror",
    "builtins.FileNotFoundError.winerror" => "Win32 exception code",
    "builtins.FileNotFoundError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.FloatingPointError" => "Floating-point operation failed.",
    "builtins.FloatingPointError.__cause__" => "exception cause",
    "builtins.FloatingPointError.__context__" => "exception context",
    "builtins.FloatingPointError.__delattr__" => "Implement delattr(self, name).",
    "builtins.FloatingPointError.__eq__" => "Return self==value.",
    "builtins.FloatingPointError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.FloatingPointError.__ge__" => "Return self>=value.",
    "builtins.FloatingPointError.__getattribute__" => "Return getattr(self, name).",
    "builtins.FloatingPointError.__getstate__" => "Helper for pickle.",
    "builtins.FloatingPointError.__gt__" => "Return self>value.",
    "builtins.FloatingPointError.__hash__" => "Return hash(self).",
    "builtins.FloatingPointError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.FloatingPointError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.FloatingPointError.__le__" => "Return self<=value.",
    "builtins.FloatingPointError.__lt__" => "Return self<value.",
    "builtins.FloatingPointError.__ne__" => "Return self!=value.",
    "builtins.FloatingPointError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.FloatingPointError.__reduce_ex__" => "Helper for pickle.",
    "builtins.FloatingPointError.__repr__" => "Return repr(self).",
    "builtins.FloatingPointError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.FloatingPointError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.FloatingPointError.__str__" => "Return str(self).",
    "builtins.FloatingPointError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.FloatingPointError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.FloatingPointError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.FutureWarning" => "Base class for warnings about constructs that will change semantically\nin the future.",
    "builtins.FutureWarning.__cause__" => "exception cause",
    "builtins.FutureWarning.__context__" => "exception context",
    "builtins.FutureWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.FutureWarning.__eq__" => "Return self==value.",
    "builtins.FutureWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.FutureWarning.__ge__" => "Return self>=value.",
    "builtins.FutureWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.FutureWarning.__getstate__" => "Helper for pickle.",
    "builtins.FutureWarning.__gt__" => "Return self>value.",
    "builtins.FutureWarning.__hash__" => "Return hash(self).",
    "builtins.FutureWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.FutureWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.FutureWarning.__le__" => "Return self<=value.",
    "builtins.FutureWarning.__lt__" => "Return self<value.",
    "builtins.FutureWarning.__ne__" => "Return self!=value.",
    "builtins.FutureWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.FutureWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.FutureWarning.__repr__" => "Return repr(self).",
    "builtins.FutureWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.FutureWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.FutureWarning.__str__" => "Return str(self).",
    "builtins.FutureWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.FutureWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.FutureWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.GeneratorExit" => "Request that a generator exit.",
    "builtins.GeneratorExit.__cause__" => "exception cause",
    "builtins.GeneratorExit.__context__" => "exception context",
    "builtins.GeneratorExit.__delattr__" => "Implement delattr(self, name).",
    "builtins.GeneratorExit.__eq__" => "Return self==value.",
    "builtins.GeneratorExit.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.GeneratorExit.__ge__" => "Return self>=value.",
    "builtins.GeneratorExit.__getattribute__" => "Return getattr(self, name).",
    "builtins.GeneratorExit.__getstate__" => "Helper for pickle.",
    "builtins.GeneratorExit.__gt__" => "Return self>value.",
    "builtins.GeneratorExit.__hash__" => "Return hash(self).",
    "builtins.GeneratorExit.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.GeneratorExit.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.GeneratorExit.__le__" => "Return self<=value.",
    "builtins.GeneratorExit.__lt__" => "Return self<value.",
    "builtins.GeneratorExit.__ne__" => "Return self!=value.",
    "builtins.GeneratorExit.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.GeneratorExit.__reduce_ex__" => "Helper for pickle.",
    "builtins.GeneratorExit.__repr__" => "Return repr(self).",
    "builtins.GeneratorExit.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.GeneratorExit.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.GeneratorExit.__str__" => "Return str(self).",
    "builtins.GeneratorExit.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.GeneratorExit.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.GeneratorExit.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.IOError" => "Base class for I/O related errors.",
    "builtins.IOError.__cause__" => "exception cause",
    "builtins.IOError.__context__" => "exception context",
    "builtins.IOError.__delattr__" => "Implement delattr(self, name).",
    "builtins.IOError.__eq__" => "Return self==value.",
    "builtins.IOError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.IOError.__ge__" => "Return self>=value.",
    "builtins.IOError.__getattribute__" => "Return getattr(self, name).",
    "builtins.IOError.__getstate__" => "Helper for pickle.",
    "builtins.IOError.__gt__" => "Return self>value.",
    "builtins.IOError.__hash__" => "Return hash(self).",
    "builtins.IOError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.IOError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.IOError.__le__" => "Return self<=value.",
    "builtins.IOError.__lt__" => "Return self<value.",
    "builtins.IOError.__ne__" => "Return self!=value.",
    "builtins.IOError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.IOError.__reduce_ex__" => "Helper for pickle.",
    "builtins.IOError.__repr__" => "Return repr(self).",
    "builtins.IOError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.IOError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.IOError.__str__" => "Return str(self).",
    "builtins.IOError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.IOError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.IOError.errno" => "POSIX exception code",
    "builtins.IOError.filename" => "exception filename",
    "builtins.IOError.filename2" => "second exception filename",
    "builtins.IOError.strerror" => "exception strerror",
    "builtins.IOError.winerror" => "Win32 exception code",
    "builtins.IOError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ImportError" => "Import can't find module, or can't find name in module.",
    "builtins.ImportError.__cause__" => "exception cause",
    "builtins.ImportError.__context__" => "exception context",
    "builtins.ImportError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ImportError.__eq__" => "Return self==value.",
    "builtins.ImportError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ImportError.__ge__" => "Return self>=value.",
    "builtins.ImportError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ImportError.__getstate__" => "Helper for pickle.",
    "builtins.ImportError.__gt__" => "Return self>value.",
    "builtins.ImportError.__hash__" => "Return hash(self).",
    "builtins.ImportError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ImportError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ImportError.__le__" => "Return self<=value.",
    "builtins.ImportError.__lt__" => "Return self<value.",
    "builtins.ImportError.__ne__" => "Return self!=value.",
    "builtins.ImportError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ImportError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ImportError.__repr__" => "Return repr(self).",
    "builtins.ImportError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ImportError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ImportError.__str__" => "Return str(self).",
    "builtins.ImportError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ImportError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ImportError.msg" => "exception message",
    "builtins.ImportError.name" => "module name",
    "builtins.ImportError.name_from" => "name imported from module",
    "builtins.ImportError.path" => "module path",
    "builtins.ImportError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ImportWarning" => "Base class for warnings about probable mistakes in module imports",
    "builtins.ImportWarning.__cause__" => "exception cause",
    "builtins.ImportWarning.__context__" => "exception context",
    "builtins.ImportWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.ImportWarning.__eq__" => "Return self==value.",
    "builtins.ImportWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ImportWarning.__ge__" => "Return self>=value.",
    "builtins.ImportWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.ImportWarning.__getstate__" => "Helper for pickle.",
    "builtins.ImportWarning.__gt__" => "Return self>value.",
    "builtins.ImportWarning.__hash__" => "Return hash(self).",
    "builtins.ImportWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ImportWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ImportWarning.__le__" => "Return self<=value.",
    "builtins.ImportWarning.__lt__" => "Return self<value.",
    "builtins.ImportWarning.__ne__" => "Return self!=value.",
    "builtins.ImportWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ImportWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.ImportWarning.__repr__" => "Return repr(self).",
    "builtins.ImportWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ImportWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ImportWarning.__str__" => "Return str(self).",
    "builtins.ImportWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ImportWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ImportWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.IndentationError" => "Improper indentation.",
    "builtins.IndentationError.__cause__" => "exception cause",
    "builtins.IndentationError.__context__" => "exception context",
    "builtins.IndentationError.__delattr__" => "Implement delattr(self, name).",
    "builtins.IndentationError.__eq__" => "Return self==value.",
    "builtins.IndentationError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.IndentationError.__ge__" => "Return self>=value.",
    "builtins.IndentationError.__getattribute__" => "Return getattr(self, name).",
    "builtins.IndentationError.__getstate__" => "Helper for pickle.",
    "builtins.IndentationError.__gt__" => "Return self>value.",
    "builtins.IndentationError.__hash__" => "Return hash(self).",
    "builtins.IndentationError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.IndentationError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.IndentationError.__le__" => "Return self<=value.",
    "builtins.IndentationError.__lt__" => "Return self<value.",
    "builtins.IndentationError.__ne__" => "Return self!=value.",
    "builtins.IndentationError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.IndentationError.__reduce_ex__" => "Helper for pickle.",
    "builtins.IndentationError.__repr__" => "Return repr(self).",
    "builtins.IndentationError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.IndentationError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.IndentationError.__str__" => "Return str(self).",
    "builtins.IndentationError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.IndentationError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.IndentationError.end_lineno" => "exception end lineno",
    "builtins.IndentationError.end_offset" => "exception end offset",
    "builtins.IndentationError.filename" => "exception filename",
    "builtins.IndentationError.lineno" => "exception lineno",
    "builtins.IndentationError.msg" => "exception msg",
    "builtins.IndentationError.offset" => "exception offset",
    "builtins.IndentationError.print_file_and_line" => "exception print_file_and_line",
    "builtins.IndentationError.text" => "exception text",
    "builtins.IndentationError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.IndexError" => "Sequence index out of range.",
    "builtins.IndexError.__cause__" => "exception cause",
    "builtins.IndexError.__context__" => "exception context",
    "builtins.IndexError.__delattr__" => "Implement delattr(self, name).",
    "builtins.IndexError.__eq__" => "Return self==value.",
    "builtins.IndexError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.IndexError.__ge__" => "Return self>=value.",
    "builtins.IndexError.__getattribute__" => "Return getattr(self, name).",
    "builtins.IndexError.__getstate__" => "Helper for pickle.",
    "builtins.IndexError.__gt__" => "Return self>value.",
    "builtins.IndexError.__hash__" => "Return hash(self).",
    "builtins.IndexError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.IndexError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.IndexError.__le__" => "Return self<=value.",
    "builtins.IndexError.__lt__" => "Return self<value.",
    "builtins.IndexError.__ne__" => "Return self!=value.",
    "builtins.IndexError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.IndexError.__reduce_ex__" => "Helper for pickle.",
    "builtins.IndexError.__repr__" => "Return repr(self).",
    "builtins.IndexError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.IndexError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.IndexError.__str__" => "Return str(self).",
    "builtins.IndexError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.IndexError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.IndexError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.InterruptedError" => "Interrupted by signal.",
    "builtins.InterruptedError.__cause__" => "exception cause",
    "builtins.InterruptedError.__context__" => "exception context",
    "builtins.InterruptedError.__delattr__" => "Implement delattr(self, name).",
    "builtins.InterruptedError.__eq__" => "Return self==value.",
    "builtins.InterruptedError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.InterruptedError.__ge__" => "Return self>=value.",
    "builtins.InterruptedError.__getattribute__" => "Return getattr(self, name).",
    "builtins.InterruptedError.__getstate__" => "Helper for pickle.",
    "builtins.InterruptedError.__gt__" => "Return self>value.",
    "builtins.InterruptedError.__hash__" => "Return hash(self).",
    "builtins.InterruptedError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.InterruptedError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.InterruptedError.__le__" => "Return self<=value.",
    "builtins.InterruptedError.__lt__" => "Return self<value.",
    "builtins.InterruptedError.__ne__" => "Return self!=value.",
    "builtins.InterruptedError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.InterruptedError.__reduce_ex__" => "Helper for pickle.",
    "builtins.InterruptedError.__repr__" => "Return repr(self).",
    "builtins.InterruptedError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.InterruptedError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.InterruptedError.__str__" => "Return str(self).",
    "builtins.InterruptedError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.InterruptedError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.InterruptedError.errno" => "POSIX exception code",
    "builtins.InterruptedError.filename" => "exception filename",
    "builtins.InterruptedError.filename2" => "second exception filename",
    "builtins.InterruptedError.strerror" => "exception strerror",
    "builtins.InterruptedError.winerror" => "Win32 exception code",
    "builtins.InterruptedError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.IsADirectoryError" => "Operation doesn't work on directories.",
    "builtins.IsADirectoryError.__cause__" => "exception cause",
    "builtins.IsADirectoryError.__context__" => "exception context",
    "builtins.IsADirectoryError.__delattr__" => "Implement delattr(self, name).",
    "builtins.IsADirectoryError.__eq__" => "Return self==value.",
    "builtins.IsADirectoryError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.IsADirectoryError.__ge__" => "Return self>=value.",
    "builtins.IsADirectoryError.__getattribute__" => "Return getattr(self, name).",
    "builtins.IsADirectoryError.__getstate__" => "Helper for pickle.",
    "builtins.IsADirectoryError.__gt__" => "Return self>value.",
    "builtins.IsADirectoryError.__hash__" => "Return hash(self).",
    "builtins.IsADirectoryError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.IsADirectoryError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.IsADirectoryError.__le__" => "Return self<=value.",
    "builtins.IsADirectoryError.__lt__" => "Return self<value.",
    "builtins.IsADirectoryError.__ne__" => "Return self!=value.",
    "builtins.IsADirectoryError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.IsADirectoryError.__reduce_ex__" => "Helper for pickle.",
    "builtins.IsADirectoryError.__repr__" => "Return repr(self).",
    "builtins.IsADirectoryError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.IsADirectoryError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.IsADirectoryError.__str__" => "Return str(self).",
    "builtins.IsADirectoryError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.IsADirectoryError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.IsADirectoryError.errno" => "POSIX exception code",
    "builtins.IsADirectoryError.filename" => "exception filename",
    "builtins.IsADirectoryError.filename2" => "second exception filename",
    "builtins.IsADirectoryError.strerror" => "exception strerror",
    "builtins.IsADirectoryError.winerror" => "Win32 exception code",
    "builtins.IsADirectoryError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.KeyError" => "Mapping key not found.",
    "builtins.KeyError.__cause__" => "exception cause",
    "builtins.KeyError.__context__" => "exception context",
    "builtins.KeyError.__delattr__" => "Implement delattr(self, name).",
    "builtins.KeyError.__eq__" => "Return self==value.",
    "builtins.KeyError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.KeyError.__ge__" => "Return self>=value.",
    "builtins.KeyError.__getattribute__" => "Return getattr(self, name).",
    "builtins.KeyError.__getstate__" => "Helper for pickle.",
    "builtins.KeyError.__gt__" => "Return self>value.",
    "builtins.KeyError.__hash__" => "Return hash(self).",
    "builtins.KeyError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.KeyError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.KeyError.__le__" => "Return self<=value.",
    "builtins.KeyError.__lt__" => "Return self<value.",
    "builtins.KeyError.__ne__" => "Return self!=value.",
    "builtins.KeyError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.KeyError.__reduce_ex__" => "Helper for pickle.",
    "builtins.KeyError.__repr__" => "Return repr(self).",
    "builtins.KeyError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.KeyError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.KeyError.__str__" => "Return str(self).",
    "builtins.KeyError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.KeyError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.KeyError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.KeyboardInterrupt" => "Program interrupted by user.",
    "builtins.KeyboardInterrupt.__cause__" => "exception cause",
    "builtins.KeyboardInterrupt.__context__" => "exception context",
    "builtins.KeyboardInterrupt.__delattr__" => "Implement delattr(self, name).",
    "builtins.KeyboardInterrupt.__eq__" => "Return self==value.",
    "builtins.KeyboardInterrupt.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.KeyboardInterrupt.__ge__" => "Return self>=value.",
    "builtins.KeyboardInterrupt.__getattribute__" => "Return getattr(self, name).",
    "builtins.KeyboardInterrupt.__getstate__" => "Helper for pickle.",
    "builtins.KeyboardInterrupt.__gt__" => "Return self>value.",
    "builtins.KeyboardInterrupt.__hash__" => "Return hash(self).",
    "builtins.KeyboardInterrupt.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.KeyboardInterrupt.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.KeyboardInterrupt.__le__" => "Return self<=value.",
    "builtins.KeyboardInterrupt.__lt__" => "Return self<value.",
    "builtins.KeyboardInterrupt.__ne__" => "Return self!=value.",
    "builtins.KeyboardInterrupt.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.KeyboardInterrupt.__reduce_ex__" => "Helper for pickle.",
    "builtins.KeyboardInterrupt.__repr__" => "Return repr(self).",
    "builtins.KeyboardInterrupt.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.KeyboardInterrupt.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.KeyboardInterrupt.__str__" => "Return str(self).",
    "builtins.KeyboardInterrupt.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.KeyboardInterrupt.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.KeyboardInterrupt.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.LookupError" => "Base class for lookup errors.",
    "builtins.LookupError.__cause__" => "exception cause",
    "builtins.LookupError.__context__" => "exception context",
    "builtins.LookupError.__delattr__" => "Implement delattr(self, name).",
    "builtins.LookupError.__eq__" => "Return self==value.",
    "builtins.LookupError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.LookupError.__ge__" => "Return self>=value.",
    "builtins.LookupError.__getattribute__" => "Return getattr(self, name).",
    "builtins.LookupError.__getstate__" => "Helper for pickle.",
    "builtins.LookupError.__gt__" => "Return self>value.",
    "builtins.LookupError.__hash__" => "Return hash(self).",
    "builtins.LookupError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.LookupError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.LookupError.__le__" => "Return self<=value.",
    "builtins.LookupError.__lt__" => "Return self<value.",
    "builtins.LookupError.__ne__" => "Return self!=value.",
    "builtins.LookupError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.LookupError.__reduce_ex__" => "Helper for pickle.",
    "builtins.LookupError.__repr__" => "Return repr(self).",
    "builtins.LookupError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.LookupError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.LookupError.__str__" => "Return str(self).",
    "builtins.LookupError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.LookupError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.LookupError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.MemoryError" => "Out of memory.",
    "builtins.MemoryError.__cause__" => "exception cause",
    "builtins.MemoryError.__context__" => "exception context",
    "builtins.MemoryError.__delattr__" => "Implement delattr(self, name).",
    "builtins.MemoryError.__eq__" => "Return self==value.",
    "builtins.MemoryError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.MemoryError.__ge__" => "Return self>=value.",
    "builtins.MemoryError.__getattribute__" => "Return getattr(self, name).",
    "builtins.MemoryError.__getstate__" => "Helper for pickle.",
    "builtins.MemoryError.__gt__" => "Return self>value.",
    "builtins.MemoryError.__hash__" => "Return hash(self).",
    "builtins.MemoryError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.MemoryError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.MemoryError.__le__" => "Return self<=value.",
    "builtins.MemoryError.__lt__" => "Return self<value.",
    "builtins.MemoryError.__ne__" => "Return self!=value.",
    "builtins.MemoryError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.MemoryError.__reduce_ex__" => "Helper for pickle.",
    "builtins.MemoryError.__repr__" => "Return repr(self).",
    "builtins.MemoryError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.MemoryError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.MemoryError.__str__" => "Return str(self).",
    "builtins.MemoryError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.MemoryError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.MemoryError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ModuleNotFoundError" => "Module not found.",
    "builtins.ModuleNotFoundError.__cause__" => "exception cause",
    "builtins.ModuleNotFoundError.__context__" => "exception context",
    "builtins.ModuleNotFoundError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ModuleNotFoundError.__eq__" => "Return self==value.",
    "builtins.ModuleNotFoundError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ModuleNotFoundError.__ge__" => "Return self>=value.",
    "builtins.ModuleNotFoundError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ModuleNotFoundError.__getstate__" => "Helper for pickle.",
    "builtins.ModuleNotFoundError.__gt__" => "Return self>value.",
    "builtins.ModuleNotFoundError.__hash__" => "Return hash(self).",
    "builtins.ModuleNotFoundError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ModuleNotFoundError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ModuleNotFoundError.__le__" => "Return self<=value.",
    "builtins.ModuleNotFoundError.__lt__" => "Return self<value.",
    "builtins.ModuleNotFoundError.__ne__" => "Return self!=value.",
    "builtins.ModuleNotFoundError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ModuleNotFoundError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ModuleNotFoundError.__repr__" => "Return repr(self).",
    "builtins.ModuleNotFoundError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ModuleNotFoundError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ModuleNotFoundError.__str__" => "Return str(self).",
    "builtins.ModuleNotFoundError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ModuleNotFoundError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ModuleNotFoundError.msg" => "exception message",
    "builtins.ModuleNotFoundError.name" => "module name",
    "builtins.ModuleNotFoundError.name_from" => "name imported from module",
    "builtins.ModuleNotFoundError.path" => "module path",
    "builtins.ModuleNotFoundError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.NameError" => "Name not found globally.",
    "builtins.NameError.__cause__" => "exception cause",
    "builtins.NameError.__context__" => "exception context",
    "builtins.NameError.__delattr__" => "Implement delattr(self, name).",
    "builtins.NameError.__eq__" => "Return self==value.",
    "builtins.NameError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.NameError.__ge__" => "Return self>=value.",
    "builtins.NameError.__getattribute__" => "Return getattr(self, name).",
    "builtins.NameError.__getstate__" => "Helper for pickle.",
    "builtins.NameError.__gt__" => "Return self>value.",
    "builtins.NameError.__hash__" => "Return hash(self).",
    "builtins.NameError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.NameError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.NameError.__le__" => "Return self<=value.",
    "builtins.NameError.__lt__" => "Return self<value.",
    "builtins.NameError.__ne__" => "Return self!=value.",
    "builtins.NameError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.NameError.__reduce_ex__" => "Helper for pickle.",
    "builtins.NameError.__repr__" => "Return repr(self).",
    "builtins.NameError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.NameError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.NameError.__str__" => "Return str(self).",
    "builtins.NameError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.NameError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.NameError.name" => "name",
    "builtins.NameError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.NoneType" => "The type of the None singleton.",
    "builtins.NoneType.__bool__" => "True if self else False",
    "builtins.NoneType.__delattr__" => "Implement delattr(self, name).",
    "builtins.NoneType.__eq__" => "Return self==value.",
    "builtins.NoneType.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.NoneType.__ge__" => "Return self>=value.",
    "builtins.NoneType.__getattribute__" => "Return getattr(self, name).",
    "builtins.NoneType.__getstate__" => "Helper for pickle.",
    "builtins.NoneType.__gt__" => "Return self>value.",
    "builtins.NoneType.__hash__" => "Return hash(self).",
    "builtins.NoneType.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.NoneType.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.NoneType.__le__" => "Return self<=value.",
    "builtins.NoneType.__lt__" => "Return self<value.",
    "builtins.NoneType.__ne__" => "Return self!=value.",
    "builtins.NoneType.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.NoneType.__reduce__" => "Helper for pickle.",
    "builtins.NoneType.__reduce_ex__" => "Helper for pickle.",
    "builtins.NoneType.__repr__" => "Return repr(self).",
    "builtins.NoneType.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.NoneType.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.NoneType.__str__" => "Return str(self).",
    "builtins.NoneType.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.NotADirectoryError" => "Operation only works on directories.",
    "builtins.NotADirectoryError.__cause__" => "exception cause",
    "builtins.NotADirectoryError.__context__" => "exception context",
    "builtins.NotADirectoryError.__delattr__" => "Implement delattr(self, name).",
    "builtins.NotADirectoryError.__eq__" => "Return self==value.",
    "builtins.NotADirectoryError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.NotADirectoryError.__ge__" => "Return self>=value.",
    "builtins.NotADirectoryError.__getattribute__" => "Return getattr(self, name).",
    "builtins.NotADirectoryError.__getstate__" => "Helper for pickle.",
    "builtins.NotADirectoryError.__gt__" => "Return self>value.",
    "builtins.NotADirectoryError.__hash__" => "Return hash(self).",
    "builtins.NotADirectoryError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.NotADirectoryError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.NotADirectoryError.__le__" => "Return self<=value.",
    "builtins.NotADirectoryError.__lt__" => "Return self<value.",
    "builtins.NotADirectoryError.__ne__" => "Return self!=value.",
    "builtins.NotADirectoryError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.NotADirectoryError.__reduce_ex__" => "Helper for pickle.",
    "builtins.NotADirectoryError.__repr__" => "Return repr(self).",
    "builtins.NotADirectoryError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.NotADirectoryError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.NotADirectoryError.__str__" => "Return str(self).",
    "builtins.NotADirectoryError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.NotADirectoryError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.NotADirectoryError.errno" => "POSIX exception code",
    "builtins.NotADirectoryError.filename" => "exception filename",
    "builtins.NotADirectoryError.filename2" => "second exception filename",
    "builtins.NotADirectoryError.strerror" => "exception strerror",
    "builtins.NotADirectoryError.winerror" => "Win32 exception code",
    "builtins.NotADirectoryError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.NotImplementedError" => "Method or function hasn't been implemented yet.",
    "builtins.NotImplementedError.__cause__" => "exception cause",
    "builtins.NotImplementedError.__context__" => "exception context",
    "builtins.NotImplementedError.__delattr__" => "Implement delattr(self, name).",
    "builtins.NotImplementedError.__eq__" => "Return self==value.",
    "builtins.NotImplementedError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.NotImplementedError.__ge__" => "Return self>=value.",
    "builtins.NotImplementedError.__getattribute__" => "Return getattr(self, name).",
    "builtins.NotImplementedError.__getstate__" => "Helper for pickle.",
    "builtins.NotImplementedError.__gt__" => "Return self>value.",
    "builtins.NotImplementedError.__hash__" => "Return hash(self).",
    "builtins.NotImplementedError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.NotImplementedError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.NotImplementedError.__le__" => "Return self<=value.",
    "builtins.NotImplementedError.__lt__" => "Return self<value.",
    "builtins.NotImplementedError.__ne__" => "Return self!=value.",
    "builtins.NotImplementedError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.NotImplementedError.__reduce_ex__" => "Helper for pickle.",
    "builtins.NotImplementedError.__repr__" => "Return repr(self).",
    "builtins.NotImplementedError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.NotImplementedError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.NotImplementedError.__str__" => "Return str(self).",
    "builtins.NotImplementedError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.NotImplementedError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.NotImplementedError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.OSError" => "Base class for I/O related errors.",
    "builtins.OSError.__cause__" => "exception cause",
    "builtins.OSError.__context__" => "exception context",
    "builtins.OSError.__delattr__" => "Implement delattr(self, name).",
    "builtins.OSError.__eq__" => "Return self==value.",
    "builtins.OSError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.OSError.__ge__" => "Return self>=value.",
    "builtins.OSError.__getattribute__" => "Return getattr(self, name).",
    "builtins.OSError.__getstate__" => "Helper for pickle.",
    "builtins.OSError.__gt__" => "Return self>value.",
    "builtins.OSError.__hash__" => "Return hash(self).",
    "builtins.OSError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.OSError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.OSError.__le__" => "Return self<=value.",
    "builtins.OSError.__lt__" => "Return self<value.",
    "builtins.OSError.__ne__" => "Return self!=value.",
    "builtins.OSError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.OSError.__reduce_ex__" => "Helper for pickle.",
    "builtins.OSError.__repr__" => "Return repr(self).",
    "builtins.OSError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.OSError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.OSError.__str__" => "Return str(self).",
    "builtins.OSError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.OSError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.OSError.errno" => "POSIX exception code",
    "builtins.OSError.filename" => "exception filename",
    "builtins.OSError.filename2" => "second exception filename",
    "builtins.OSError.strerror" => "exception strerror",
    "builtins.OSError.winerror" => "Win32 exception code",
    "builtins.OSError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.OverflowError" => "Result too large to be represented.",
    "builtins.OverflowError.__cause__" => "exception cause",
    "builtins.OverflowError.__context__" => "exception context",
    "builtins.OverflowError.__delattr__" => "Implement delattr(self, name).",
    "builtins.OverflowError.__eq__" => "Return self==value.",
    "builtins.OverflowError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.OverflowError.__ge__" => "Return self>=value.",
    "builtins.OverflowError.__getattribute__" => "Return getattr(self, name).",
    "builtins.OverflowError.__getstate__" => "Helper for pickle.",
    "builtins.OverflowError.__gt__" => "Return self>value.",
    "builtins.OverflowError.__hash__" => "Return hash(self).",
    "builtins.OverflowError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.OverflowError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.OverflowError.__le__" => "Return self<=value.",
    "builtins.OverflowError.__lt__" => "Return self<value.",
    "builtins.OverflowError.__ne__" => "Return self!=value.",
    "builtins.OverflowError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.OverflowError.__reduce_ex__" => "Helper for pickle.",
    "builtins.OverflowError.__repr__" => "Return repr(self).",
    "builtins.OverflowError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.OverflowError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.OverflowError.__str__" => "Return str(self).",
    "builtins.OverflowError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.OverflowError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.OverflowError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.PendingDeprecationWarning" => "Base class for warnings about features which will be deprecated\nin the future.",
    "builtins.PendingDeprecationWarning.__cause__" => "exception cause",
    "builtins.PendingDeprecationWarning.__context__" => "exception context",
    "builtins.PendingDeprecationWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.PendingDeprecationWarning.__eq__" => "Return self==value.",
    "builtins.PendingDeprecationWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.PendingDeprecationWarning.__ge__" => "Return self>=value.",
    "builtins.PendingDeprecationWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.PendingDeprecationWarning.__getstate__" => "Helper for pickle.",
    "builtins.PendingDeprecationWarning.__gt__" => "Return self>value.",
    "builtins.PendingDeprecationWarning.__hash__" => "Return hash(self).",
    "builtins.PendingDeprecationWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.PendingDeprecationWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.PendingDeprecationWarning.__le__" => "Return self<=value.",
    "builtins.PendingDeprecationWarning.__lt__" => "Return self<value.",
    "builtins.PendingDeprecationWarning.__ne__" => "Return self!=value.",
    "builtins.PendingDeprecationWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.PendingDeprecationWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.PendingDeprecationWarning.__repr__" => "Return repr(self).",
    "builtins.PendingDeprecationWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.PendingDeprecationWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.PendingDeprecationWarning.__str__" => "Return str(self).",
    "builtins.PendingDeprecationWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.PendingDeprecationWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.PendingDeprecationWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.PermissionError" => "Not enough permissions.",
    "builtins.PermissionError.__cause__" => "exception cause",
    "builtins.PermissionError.__context__" => "exception context",
    "builtins.PermissionError.__delattr__" => "Implement delattr(self, name).",
    "builtins.PermissionError.__eq__" => "Return self==value.",
    "builtins.PermissionError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.PermissionError.__ge__" => "Return self>=value.",
    "builtins.PermissionError.__getattribute__" => "Return getattr(self, name).",
    "builtins.PermissionError.__getstate__" => "Helper for pickle.",
    "builtins.PermissionError.__gt__" => "Return self>value.",
    "builtins.PermissionError.__hash__" => "Return hash(self).",
    "builtins.PermissionError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.PermissionError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.PermissionError.__le__" => "Return self<=value.",
    "builtins.PermissionError.__lt__" => "Return self<value.",
    "builtins.PermissionError.__ne__" => "Return self!=value.",
    "builtins.PermissionError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.PermissionError.__reduce_ex__" => "Helper for pickle.",
    "builtins.PermissionError.__repr__" => "Return repr(self).",
    "builtins.PermissionError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.PermissionError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.PermissionError.__str__" => "Return str(self).",
    "builtins.PermissionError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.PermissionError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.PermissionError.errno" => "POSIX exception code",
    "builtins.PermissionError.filename" => "exception filename",
    "builtins.PermissionError.filename2" => "second exception filename",
    "builtins.PermissionError.strerror" => "exception strerror",
    "builtins.PermissionError.winerror" => "Win32 exception code",
    "builtins.PermissionError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ProcessLookupError" => "Process not found.",
    "builtins.ProcessLookupError.__cause__" => "exception cause",
    "builtins.ProcessLookupError.__context__" => "exception context",
    "builtins.ProcessLookupError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ProcessLookupError.__eq__" => "Return self==value.",
    "builtins.ProcessLookupError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ProcessLookupError.__ge__" => "Return self>=value.",
    "builtins.ProcessLookupError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ProcessLookupError.__getstate__" => "Helper for pickle.",
    "builtins.ProcessLookupError.__gt__" => "Return self>value.",
    "builtins.ProcessLookupError.__hash__" => "Return hash(self).",
    "builtins.ProcessLookupError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ProcessLookupError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ProcessLookupError.__le__" => "Return self<=value.",
    "builtins.ProcessLookupError.__lt__" => "Return self<value.",
    "builtins.ProcessLookupError.__ne__" => "Return self!=value.",
    "builtins.ProcessLookupError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ProcessLookupError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ProcessLookupError.__repr__" => "Return repr(self).",
    "builtins.ProcessLookupError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ProcessLookupError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ProcessLookupError.__str__" => "Return str(self).",
    "builtins.ProcessLookupError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ProcessLookupError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ProcessLookupError.errno" => "POSIX exception code",
    "builtins.ProcessLookupError.filename" => "exception filename",
    "builtins.ProcessLookupError.filename2" => "second exception filename",
    "builtins.ProcessLookupError.strerror" => "exception strerror",
    "builtins.ProcessLookupError.winerror" => "Win32 exception code",
    "builtins.ProcessLookupError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.PythonFinalizationError" => "Operation blocked during Python finalization.",
    "builtins.PythonFinalizationError.__cause__" => "exception cause",
    "builtins.PythonFinalizationError.__context__" => "exception context",
    "builtins.PythonFinalizationError.__delattr__" => "Implement delattr(self, name).",
    "builtins.PythonFinalizationError.__eq__" => "Return self==value.",
    "builtins.PythonFinalizationError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.PythonFinalizationError.__ge__" => "Return self>=value.",
    "builtins.PythonFinalizationError.__getattribute__" => "Return getattr(self, name).",
    "builtins.PythonFinalizationError.__getstate__" => "Helper for pickle.",
    "builtins.PythonFinalizationError.__gt__" => "Return self>value.",
    "builtins.PythonFinalizationError.__hash__" => "Return hash(self).",
    "builtins.PythonFinalizationError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.PythonFinalizationError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.PythonFinalizationError.__le__" => "Return self<=value.",
    "builtins.PythonFinalizationError.__lt__" => "Return self<value.",
    "builtins.PythonFinalizationError.__ne__" => "Return self!=value.",
    "builtins.PythonFinalizationError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.PythonFinalizationError.__reduce_ex__" => "Helper for pickle.",
    "builtins.PythonFinalizationError.__repr__" => "Return repr(self).",
    "builtins.PythonFinalizationError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.PythonFinalizationError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.PythonFinalizationError.__str__" => "Return str(self).",
    "builtins.PythonFinalizationError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.PythonFinalizationError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.PythonFinalizationError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.RecursionError" => "Recursion limit exceeded.",
    "builtins.RecursionError.__cause__" => "exception cause",
    "builtins.RecursionError.__context__" => "exception context",
    "builtins.RecursionError.__delattr__" => "Implement delattr(self, name).",
    "builtins.RecursionError.__eq__" => "Return self==value.",
    "builtins.RecursionError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.RecursionError.__ge__" => "Return self>=value.",
    "builtins.RecursionError.__getattribute__" => "Return getattr(self, name).",
    "builtins.RecursionError.__getstate__" => "Helper for pickle.",
    "builtins.RecursionError.__gt__" => "Return self>value.",
    "builtins.RecursionError.__hash__" => "Return hash(self).",
    "builtins.RecursionError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.RecursionError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.RecursionError.__le__" => "Return self<=value.",
    "builtins.RecursionError.__lt__" => "Return self<value.",
    "builtins.RecursionError.__ne__" => "Return self!=value.",
    "builtins.RecursionError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.RecursionError.__reduce_ex__" => "Helper for pickle.",
    "builtins.RecursionError.__repr__" => "Return repr(self).",
    "builtins.RecursionError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.RecursionError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.RecursionError.__str__" => "Return str(self).",
    "builtins.RecursionError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.RecursionError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.RecursionError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ReferenceError" => "Weak ref proxy used after referent went away.",
    "builtins.ReferenceError.__cause__" => "exception cause",
    "builtins.ReferenceError.__context__" => "exception context",
    "builtins.ReferenceError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ReferenceError.__eq__" => "Return self==value.",
    "builtins.ReferenceError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ReferenceError.__ge__" => "Return self>=value.",
    "builtins.ReferenceError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ReferenceError.__getstate__" => "Helper for pickle.",
    "builtins.ReferenceError.__gt__" => "Return self>value.",
    "builtins.ReferenceError.__hash__" => "Return hash(self).",
    "builtins.ReferenceError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ReferenceError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ReferenceError.__le__" => "Return self<=value.",
    "builtins.ReferenceError.__lt__" => "Return self<value.",
    "builtins.ReferenceError.__ne__" => "Return self!=value.",
    "builtins.ReferenceError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ReferenceError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ReferenceError.__repr__" => "Return repr(self).",
    "builtins.ReferenceError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ReferenceError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ReferenceError.__str__" => "Return str(self).",
    "builtins.ReferenceError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ReferenceError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ReferenceError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ResourceWarning" => "Base class for warnings about resource usage.",
    "builtins.ResourceWarning.__cause__" => "exception cause",
    "builtins.ResourceWarning.__context__" => "exception context",
    "builtins.ResourceWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.ResourceWarning.__eq__" => "Return self==value.",
    "builtins.ResourceWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ResourceWarning.__ge__" => "Return self>=value.",
    "builtins.ResourceWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.ResourceWarning.__getstate__" => "Helper for pickle.",
    "builtins.ResourceWarning.__gt__" => "Return self>value.",
    "builtins.ResourceWarning.__hash__" => "Return hash(self).",
    "builtins.ResourceWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ResourceWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ResourceWarning.__le__" => "Return self<=value.",
    "builtins.ResourceWarning.__lt__" => "Return self<value.",
    "builtins.ResourceWarning.__ne__" => "Return self!=value.",
    "builtins.ResourceWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ResourceWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.ResourceWarning.__repr__" => "Return repr(self).",
    "builtins.ResourceWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ResourceWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ResourceWarning.__str__" => "Return str(self).",
    "builtins.ResourceWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ResourceWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ResourceWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.RuntimeError" => "Unspecified run-time error.",
    "builtins.RuntimeError.__cause__" => "exception cause",
    "builtins.RuntimeError.__context__" => "exception context",
    "builtins.RuntimeError.__delattr__" => "Implement delattr(self, name).",
    "builtins.RuntimeError.__eq__" => "Return self==value.",
    "builtins.RuntimeError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.RuntimeError.__ge__" => "Return self>=value.",
    "builtins.RuntimeError.__getattribute__" => "Return getattr(self, name).",
    "builtins.RuntimeError.__getstate__" => "Helper for pickle.",
    "builtins.RuntimeError.__gt__" => "Return self>value.",
    "builtins.RuntimeError.__hash__" => "Return hash(self).",
    "builtins.RuntimeError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.RuntimeError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.RuntimeError.__le__" => "Return self<=value.",
    "builtins.RuntimeError.__lt__" => "Return self<value.",
    "builtins.RuntimeError.__ne__" => "Return self!=value.",
    "builtins.RuntimeError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.RuntimeError.__reduce_ex__" => "Helper for pickle.",
    "builtins.RuntimeError.__repr__" => "Return repr(self).",
    "builtins.RuntimeError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.RuntimeError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.RuntimeError.__str__" => "Return str(self).",
    "builtins.RuntimeError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.RuntimeError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.RuntimeError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.RuntimeWarning" => "Base class for warnings about dubious runtime behavior.",
    "builtins.RuntimeWarning.__cause__" => "exception cause",
    "builtins.RuntimeWarning.__context__" => "exception context",
    "builtins.RuntimeWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.RuntimeWarning.__eq__" => "Return self==value.",
    "builtins.RuntimeWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.RuntimeWarning.__ge__" => "Return self>=value.",
    "builtins.RuntimeWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.RuntimeWarning.__getstate__" => "Helper for pickle.",
    "builtins.RuntimeWarning.__gt__" => "Return self>value.",
    "builtins.RuntimeWarning.__hash__" => "Return hash(self).",
    "builtins.RuntimeWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.RuntimeWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.RuntimeWarning.__le__" => "Return self<=value.",
    "builtins.RuntimeWarning.__lt__" => "Return self<value.",
    "builtins.RuntimeWarning.__ne__" => "Return self!=value.",
    "builtins.RuntimeWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.RuntimeWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.RuntimeWarning.__repr__" => "Return repr(self).",
    "builtins.RuntimeWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.RuntimeWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.RuntimeWarning.__str__" => "Return str(self).",
    "builtins.RuntimeWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.RuntimeWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.RuntimeWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.StopAsyncIteration" => "Signal the end from iterator.__anext__().",
    "builtins.StopAsyncIteration.__cause__" => "exception cause",
    "builtins.StopAsyncIteration.__context__" => "exception context",
    "builtins.StopAsyncIteration.__delattr__" => "Implement delattr(self, name).",
    "builtins.StopAsyncIteration.__eq__" => "Return self==value.",
    "builtins.StopAsyncIteration.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.StopAsyncIteration.__ge__" => "Return self>=value.",
    "builtins.StopAsyncIteration.__getattribute__" => "Return getattr(self, name).",
    "builtins.StopAsyncIteration.__getstate__" => "Helper for pickle.",
    "builtins.StopAsyncIteration.__gt__" => "Return self>value.",
    "builtins.StopAsyncIteration.__hash__" => "Return hash(self).",
    "builtins.StopAsyncIteration.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.StopAsyncIteration.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.StopAsyncIteration.__le__" => "Return self<=value.",
    "builtins.StopAsyncIteration.__lt__" => "Return self<value.",
    "builtins.StopAsyncIteration.__ne__" => "Return self!=value.",
    "builtins.StopAsyncIteration.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.StopAsyncIteration.__reduce_ex__" => "Helper for pickle.",
    "builtins.StopAsyncIteration.__repr__" => "Return repr(self).",
    "builtins.StopAsyncIteration.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.StopAsyncIteration.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.StopAsyncIteration.__str__" => "Return str(self).",
    "builtins.StopAsyncIteration.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.StopAsyncIteration.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.StopAsyncIteration.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.StopIteration" => "Signal the end from iterator.__next__().",
    "builtins.StopIteration.__cause__" => "exception cause",
    "builtins.StopIteration.__context__" => "exception context",
    "builtins.StopIteration.__delattr__" => "Implement delattr(self, name).",
    "builtins.StopIteration.__eq__" => "Return self==value.",
    "builtins.StopIteration.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.StopIteration.__ge__" => "Return self>=value.",
    "builtins.StopIteration.__getattribute__" => "Return getattr(self, name).",
    "builtins.StopIteration.__getstate__" => "Helper for pickle.",
    "builtins.StopIteration.__gt__" => "Return self>value.",
    "builtins.StopIteration.__hash__" => "Return hash(self).",
    "builtins.StopIteration.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.StopIteration.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.StopIteration.__le__" => "Return self<=value.",
    "builtins.StopIteration.__lt__" => "Return self<value.",
    "builtins.StopIteration.__ne__" => "Return self!=value.",
    "builtins.StopIteration.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.StopIteration.__reduce_ex__" => "Helper for pickle.",
    "builtins.StopIteration.__repr__" => "Return repr(self).",
    "builtins.StopIteration.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.StopIteration.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.StopIteration.__str__" => "Return str(self).",
    "builtins.StopIteration.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.StopIteration.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.StopIteration.value" => "generator return value",
    "builtins.StopIteration.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.SyntaxError" => "Invalid syntax.",
    "builtins.SyntaxError.__cause__" => "exception cause",
    "builtins.SyntaxError.__context__" => "exception context",
    "builtins.SyntaxError.__delattr__" => "Implement delattr(self, name).",
    "builtins.SyntaxError.__eq__" => "Return self==value.",
    "builtins.SyntaxError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.SyntaxError.__ge__" => "Return self>=value.",
    "builtins.SyntaxError.__getattribute__" => "Return getattr(self, name).",
    "builtins.SyntaxError.__getstate__" => "Helper for pickle.",
    "builtins.SyntaxError.__gt__" => "Return self>value.",
    "builtins.SyntaxError.__hash__" => "Return hash(self).",
    "builtins.SyntaxError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.SyntaxError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.SyntaxError.__le__" => "Return self<=value.",
    "builtins.SyntaxError.__lt__" => "Return self<value.",
    "builtins.SyntaxError.__ne__" => "Return self!=value.",
    "builtins.SyntaxError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.SyntaxError.__reduce_ex__" => "Helper for pickle.",
    "builtins.SyntaxError.__repr__" => "Return repr(self).",
    "builtins.SyntaxError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.SyntaxError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.SyntaxError.__str__" => "Return str(self).",
    "builtins.SyntaxError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.SyntaxError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.SyntaxError.end_lineno" => "exception end lineno",
    "builtins.SyntaxError.end_offset" => "exception end offset",
    "builtins.SyntaxError.filename" => "exception filename",
    "builtins.SyntaxError.lineno" => "exception lineno",
    "builtins.SyntaxError.msg" => "exception msg",
    "builtins.SyntaxError.offset" => "exception offset",
    "builtins.SyntaxError.print_file_and_line" => "exception print_file_and_line",
    "builtins.SyntaxError.text" => "exception text",
    "builtins.SyntaxError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.SyntaxWarning" => "Base class for warnings about dubious syntax.",
    "builtins.SyntaxWarning.__cause__" => "exception cause",
    "builtins.SyntaxWarning.__context__" => "exception context",
    "builtins.SyntaxWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.SyntaxWarning.__eq__" => "Return self==value.",
    "builtins.SyntaxWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.SyntaxWarning.__ge__" => "Return self>=value.",
    "builtins.SyntaxWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.SyntaxWarning.__getstate__" => "Helper for pickle.",
    "builtins.SyntaxWarning.__gt__" => "Return self>value.",
    "builtins.SyntaxWarning.__hash__" => "Return hash(self).",
    "builtins.SyntaxWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.SyntaxWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.SyntaxWarning.__le__" => "Return self<=value.",
    "builtins.SyntaxWarning.__lt__" => "Return self<value.",
    "builtins.SyntaxWarning.__ne__" => "Return self!=value.",
    "builtins.SyntaxWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.SyntaxWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.SyntaxWarning.__repr__" => "Return repr(self).",
    "builtins.SyntaxWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.SyntaxWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.SyntaxWarning.__str__" => "Return str(self).",
    "builtins.SyntaxWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.SyntaxWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.SyntaxWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.SystemError" => "Internal error in the Python interpreter.\n\nPlease report this to the Python maintainer, along with the traceback,\nthe Python version, and the hardware/OS platform and version.",
    "builtins.SystemError.__cause__" => "exception cause",
    "builtins.SystemError.__context__" => "exception context",
    "builtins.SystemError.__delattr__" => "Implement delattr(self, name).",
    "builtins.SystemError.__eq__" => "Return self==value.",
    "builtins.SystemError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.SystemError.__ge__" => "Return self>=value.",
    "builtins.SystemError.__getattribute__" => "Return getattr(self, name).",
    "builtins.SystemError.__getstate__" => "Helper for pickle.",
    "builtins.SystemError.__gt__" => "Return self>value.",
    "builtins.SystemError.__hash__" => "Return hash(self).",
    "builtins.SystemError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.SystemError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.SystemError.__le__" => "Return self<=value.",
    "builtins.SystemError.__lt__" => "Return self<value.",
    "builtins.SystemError.__ne__" => "Return self!=value.",
    "builtins.SystemError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.SystemError.__reduce_ex__" => "Helper for pickle.",
    "builtins.SystemError.__repr__" => "Return repr(self).",
    "builtins.SystemError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.SystemError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.SystemError.__str__" => "Return str(self).",
    "builtins.SystemError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.SystemError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.SystemError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.SystemExit" => "Request to exit from the interpreter.",
    "builtins.SystemExit.__cause__" => "exception cause",
    "builtins.SystemExit.__context__" => "exception context",
    "builtins.SystemExit.__delattr__" => "Implement delattr(self, name).",
    "builtins.SystemExit.__eq__" => "Return self==value.",
    "builtins.SystemExit.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.SystemExit.__ge__" => "Return self>=value.",
    "builtins.SystemExit.__getattribute__" => "Return getattr(self, name).",
    "builtins.SystemExit.__getstate__" => "Helper for pickle.",
    "builtins.SystemExit.__gt__" => "Return self>value.",
    "builtins.SystemExit.__hash__" => "Return hash(self).",
    "builtins.SystemExit.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.SystemExit.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.SystemExit.__le__" => "Return self<=value.",
    "builtins.SystemExit.__lt__" => "Return self<value.",
    "builtins.SystemExit.__ne__" => "Return self!=value.",
    "builtins.SystemExit.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.SystemExit.__reduce_ex__" => "Helper for pickle.",
    "builtins.SystemExit.__repr__" => "Return repr(self).",
    "builtins.SystemExit.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.SystemExit.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.SystemExit.__str__" => "Return str(self).",
    "builtins.SystemExit.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.SystemExit.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.SystemExit.code" => "exception code",
    "builtins.SystemExit.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.TabError" => "Improper mixture of spaces and tabs.",
    "builtins.TabError.__cause__" => "exception cause",
    "builtins.TabError.__context__" => "exception context",
    "builtins.TabError.__delattr__" => "Implement delattr(self, name).",
    "builtins.TabError.__eq__" => "Return self==value.",
    "builtins.TabError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.TabError.__ge__" => "Return self>=value.",
    "builtins.TabError.__getattribute__" => "Return getattr(self, name).",
    "builtins.TabError.__getstate__" => "Helper for pickle.",
    "builtins.TabError.__gt__" => "Return self>value.",
    "builtins.TabError.__hash__" => "Return hash(self).",
    "builtins.TabError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.TabError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.TabError.__le__" => "Return self<=value.",
    "builtins.TabError.__lt__" => "Return self<value.",
    "builtins.TabError.__ne__" => "Return self!=value.",
    "builtins.TabError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.TabError.__reduce_ex__" => "Helper for pickle.",
    "builtins.TabError.__repr__" => "Return repr(self).",
    "builtins.TabError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.TabError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.TabError.__str__" => "Return str(self).",
    "builtins.TabError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.TabError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.TabError.end_lineno" => "exception end lineno",
    "builtins.TabError.end_offset" => "exception end offset",
    "builtins.TabError.filename" => "exception filename",
    "builtins.TabError.lineno" => "exception lineno",
    "builtins.TabError.msg" => "exception msg",
    "builtins.TabError.offset" => "exception offset",
    "builtins.TabError.print_file_and_line" => "exception print_file_and_line",
    "builtins.TabError.text" => "exception text",
    "builtins.TabError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.TimeoutError" => "Timeout expired.",
    "builtins.TimeoutError.__cause__" => "exception cause",
    "builtins.TimeoutError.__context__" => "exception context",
    "builtins.TimeoutError.__delattr__" => "Implement delattr(self, name).",
    "builtins.TimeoutError.__eq__" => "Return self==value.",
    "builtins.TimeoutError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.TimeoutError.__ge__" => "Return self>=value.",
    "builtins.TimeoutError.__getattribute__" => "Return getattr(self, name).",
    "builtins.TimeoutError.__getstate__" => "Helper for pickle.",
    "builtins.TimeoutError.__gt__" => "Return self>value.",
    "builtins.TimeoutError.__hash__" => "Return hash(self).",
    "builtins.TimeoutError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.TimeoutError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.TimeoutError.__le__" => "Return self<=value.",
    "builtins.TimeoutError.__lt__" => "Return self<value.",
    "builtins.TimeoutError.__ne__" => "Return self!=value.",
    "builtins.TimeoutError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.TimeoutError.__reduce_ex__" => "Helper for pickle.",
    "builtins.TimeoutError.__repr__" => "Return repr(self).",
    "builtins.TimeoutError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.TimeoutError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.TimeoutError.__str__" => "Return str(self).",
    "builtins.TimeoutError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.TimeoutError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.TimeoutError.errno" => "POSIX exception code",
    "builtins.TimeoutError.filename" => "exception filename",
    "builtins.TimeoutError.filename2" => "second exception filename",
    "builtins.TimeoutError.strerror" => "exception strerror",
    "builtins.TimeoutError.winerror" => "Win32 exception code",
    "builtins.TimeoutError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.TypeError" => "Inappropriate argument type.",
    "builtins.TypeError.__cause__" => "exception cause",
    "builtins.TypeError.__context__" => "exception context",
    "builtins.TypeError.__delattr__" => "Implement delattr(self, name).",
    "builtins.TypeError.__eq__" => "Return self==value.",
    "builtins.TypeError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.TypeError.__ge__" => "Return self>=value.",
    "builtins.TypeError.__getattribute__" => "Return getattr(self, name).",
    "builtins.TypeError.__getstate__" => "Helper for pickle.",
    "builtins.TypeError.__gt__" => "Return self>value.",
    "builtins.TypeError.__hash__" => "Return hash(self).",
    "builtins.TypeError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.TypeError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.TypeError.__le__" => "Return self<=value.",
    "builtins.TypeError.__lt__" => "Return self<value.",
    "builtins.TypeError.__ne__" => "Return self!=value.",
    "builtins.TypeError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.TypeError.__reduce_ex__" => "Helper for pickle.",
    "builtins.TypeError.__repr__" => "Return repr(self).",
    "builtins.TypeError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.TypeError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.TypeError.__str__" => "Return str(self).",
    "builtins.TypeError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.TypeError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.TypeError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.UnboundLocalError" => "Local name referenced but not bound to a value.",
    "builtins.UnboundLocalError.__cause__" => "exception cause",
    "builtins.UnboundLocalError.__context__" => "exception context",
    "builtins.UnboundLocalError.__delattr__" => "Implement delattr(self, name).",
    "builtins.UnboundLocalError.__eq__" => "Return self==value.",
    "builtins.UnboundLocalError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.UnboundLocalError.__ge__" => "Return self>=value.",
    "builtins.UnboundLocalError.__getattribute__" => "Return getattr(self, name).",
    "builtins.UnboundLocalError.__getstate__" => "Helper for pickle.",
    "builtins.UnboundLocalError.__gt__" => "Return self>value.",
    "builtins.UnboundLocalError.__hash__" => "Return hash(self).",
    "builtins.UnboundLocalError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.UnboundLocalError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.UnboundLocalError.__le__" => "Return self<=value.",
    "builtins.UnboundLocalError.__lt__" => "Return self<value.",
    "builtins.UnboundLocalError.__ne__" => "Return self!=value.",
    "builtins.UnboundLocalError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.UnboundLocalError.__reduce_ex__" => "Helper for pickle.",
    "builtins.UnboundLocalError.__repr__" => "Return repr(self).",
    "builtins.UnboundLocalError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.UnboundLocalError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.UnboundLocalError.__str__" => "Return str(self).",
    "builtins.UnboundLocalError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.UnboundLocalError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.UnboundLocalError.name" => "name",
    "builtins.UnboundLocalError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.UnicodeDecodeError" => "Unicode decoding error.",
    "builtins.UnicodeDecodeError.__cause__" => "exception cause",
    "builtins.UnicodeDecodeError.__context__" => "exception context",
    "builtins.UnicodeDecodeError.__delattr__" => "Implement delattr(self, name).",
    "builtins.UnicodeDecodeError.__eq__" => "Return self==value.",
    "builtins.UnicodeDecodeError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.UnicodeDecodeError.__ge__" => "Return self>=value.",
    "builtins.UnicodeDecodeError.__getattribute__" => "Return getattr(self, name).",
    "builtins.UnicodeDecodeError.__getstate__" => "Helper for pickle.",
    "builtins.UnicodeDecodeError.__gt__" => "Return self>value.",
    "builtins.UnicodeDecodeError.__hash__" => "Return hash(self).",
    "builtins.UnicodeDecodeError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.UnicodeDecodeError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.UnicodeDecodeError.__le__" => "Return self<=value.",
    "builtins.UnicodeDecodeError.__lt__" => "Return self<value.",
    "builtins.UnicodeDecodeError.__ne__" => "Return self!=value.",
    "builtins.UnicodeDecodeError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.UnicodeDecodeError.__reduce_ex__" => "Helper for pickle.",
    "builtins.UnicodeDecodeError.__repr__" => "Return repr(self).",
    "builtins.UnicodeDecodeError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.UnicodeDecodeError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.UnicodeDecodeError.__str__" => "Return str(self).",
    "builtins.UnicodeDecodeError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.UnicodeDecodeError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.UnicodeDecodeError.encoding" => "exception encoding",
    "builtins.UnicodeDecodeError.end" => "exception end",
    "builtins.UnicodeDecodeError.object" => "exception object",
    "builtins.UnicodeDecodeError.reason" => "exception reason",
    "builtins.UnicodeDecodeError.start" => "exception start",
    "builtins.UnicodeDecodeError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.UnicodeEncodeError" => "Unicode encoding error.",
    "builtins.UnicodeEncodeError.__cause__" => "exception cause",
    "builtins.UnicodeEncodeError.__context__" => "exception context",
    "builtins.UnicodeEncodeError.__delattr__" => "Implement delattr(self, name).",
    "builtins.UnicodeEncodeError.__eq__" => "Return self==value.",
    "builtins.UnicodeEncodeError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.UnicodeEncodeError.__ge__" => "Return self>=value.",
    "builtins.UnicodeEncodeError.__getattribute__" => "Return getattr(self, name).",
    "builtins.UnicodeEncodeError.__getstate__" => "Helper for pickle.",
    "builtins.UnicodeEncodeError.__gt__" => "Return self>value.",
    "builtins.UnicodeEncodeError.__hash__" => "Return hash(self).",
    "builtins.UnicodeEncodeError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.UnicodeEncodeError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.UnicodeEncodeError.__le__" => "Return self<=value.",
    "builtins.UnicodeEncodeError.__lt__" => "Return self<value.",
    "builtins.UnicodeEncodeError.__ne__" => "Return self!=value.",
    "builtins.UnicodeEncodeError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.UnicodeEncodeError.__reduce_ex__" => "Helper for pickle.",
    "builtins.UnicodeEncodeError.__repr__" => "Return repr(self).",
    "builtins.UnicodeEncodeError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.UnicodeEncodeError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.UnicodeEncodeError.__str__" => "Return str(self).",
    "builtins.UnicodeEncodeError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.UnicodeEncodeError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.UnicodeEncodeError.encoding" => "exception encoding",
    "builtins.UnicodeEncodeError.end" => "exception end",
    "builtins.UnicodeEncodeError.object" => "exception object",
    "builtins.UnicodeEncodeError.reason" => "exception reason",
    "builtins.UnicodeEncodeError.start" => "exception start",
    "builtins.UnicodeEncodeError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.UnicodeError" => "Unicode related error.",
    "builtins.UnicodeError.__cause__" => "exception cause",
    "builtins.UnicodeError.__context__" => "exception context",
    "builtins.UnicodeError.__delattr__" => "Implement delattr(self, name).",
    "builtins.UnicodeError.__eq__" => "Return self==value.",
    "builtins.UnicodeError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.UnicodeError.__ge__" => "Return self>=value.",
    "builtins.UnicodeError.__getattribute__" => "Return getattr(self, name).",
    "builtins.UnicodeError.__getstate__" => "Helper for pickle.",
    "builtins.UnicodeError.__gt__" => "Return self>value.",
    "builtins.UnicodeError.__hash__" => "Return hash(self).",
    "builtins.UnicodeError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.UnicodeError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.UnicodeError.__le__" => "Return self<=value.",
    "builtins.UnicodeError.__lt__" => "Return self<value.",
    "builtins.UnicodeError.__ne__" => "Return self!=value.",
    "builtins.UnicodeError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.UnicodeError.__reduce_ex__" => "Helper for pickle.",
    "builtins.UnicodeError.__repr__" => "Return repr(self).",
    "builtins.UnicodeError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.UnicodeError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.UnicodeError.__str__" => "Return str(self).",
    "builtins.UnicodeError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.UnicodeError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.UnicodeError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.UnicodeTranslateError" => "Unicode translation error.",
    "builtins.UnicodeTranslateError.__cause__" => "exception cause",
    "builtins.UnicodeTranslateError.__context__" => "exception context",
    "builtins.UnicodeTranslateError.__delattr__" => "Implement delattr(self, name).",
    "builtins.UnicodeTranslateError.__eq__" => "Return self==value.",
    "builtins.UnicodeTranslateError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.UnicodeTranslateError.__ge__" => "Return self>=value.",
    "builtins.UnicodeTranslateError.__getattribute__" => "Return getattr(self, name).",
    "builtins.UnicodeTranslateError.__getstate__" => "Helper for pickle.",
    "builtins.UnicodeTranslateError.__gt__" => "Return self>value.",
    "builtins.UnicodeTranslateError.__hash__" => "Return hash(self).",
    "builtins.UnicodeTranslateError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.UnicodeTranslateError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.UnicodeTranslateError.__le__" => "Return self<=value.",
    "builtins.UnicodeTranslateError.__lt__" => "Return self<value.",
    "builtins.UnicodeTranslateError.__ne__" => "Return self!=value.",
    "builtins.UnicodeTranslateError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.UnicodeTranslateError.__reduce_ex__" => "Helper for pickle.",
    "builtins.UnicodeTranslateError.__repr__" => "Return repr(self).",
    "builtins.UnicodeTranslateError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.UnicodeTranslateError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.UnicodeTranslateError.__str__" => "Return str(self).",
    "builtins.UnicodeTranslateError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.UnicodeTranslateError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.UnicodeTranslateError.encoding" => "exception encoding",
    "builtins.UnicodeTranslateError.end" => "exception end",
    "builtins.UnicodeTranslateError.object" => "exception object",
    "builtins.UnicodeTranslateError.reason" => "exception reason",
    "builtins.UnicodeTranslateError.start" => "exception start",
    "builtins.UnicodeTranslateError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.UnicodeWarning" => "Base class for warnings about Unicode related problems, mostly\nrelated to conversion problems.",
    "builtins.UnicodeWarning.__cause__" => "exception cause",
    "builtins.UnicodeWarning.__context__" => "exception context",
    "builtins.UnicodeWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.UnicodeWarning.__eq__" => "Return self==value.",
    "builtins.UnicodeWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.UnicodeWarning.__ge__" => "Return self>=value.",
    "builtins.UnicodeWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.UnicodeWarning.__getstate__" => "Helper for pickle.",
    "builtins.UnicodeWarning.__gt__" => "Return self>value.",
    "builtins.UnicodeWarning.__hash__" => "Return hash(self).",
    "builtins.UnicodeWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.UnicodeWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.UnicodeWarning.__le__" => "Return self<=value.",
    "builtins.UnicodeWarning.__lt__" => "Return self<value.",
    "builtins.UnicodeWarning.__ne__" => "Return self!=value.",
    "builtins.UnicodeWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.UnicodeWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.UnicodeWarning.__repr__" => "Return repr(self).",
    "builtins.UnicodeWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.UnicodeWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.UnicodeWarning.__str__" => "Return str(self).",
    "builtins.UnicodeWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.UnicodeWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.UnicodeWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.UserWarning" => "Base class for warnings generated by user code.",
    "builtins.UserWarning.__cause__" => "exception cause",
    "builtins.UserWarning.__context__" => "exception context",
    "builtins.UserWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.UserWarning.__eq__" => "Return self==value.",
    "builtins.UserWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.UserWarning.__ge__" => "Return self>=value.",
    "builtins.UserWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.UserWarning.__getstate__" => "Helper for pickle.",
    "builtins.UserWarning.__gt__" => "Return self>value.",
    "builtins.UserWarning.__hash__" => "Return hash(self).",
    "builtins.UserWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.UserWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.UserWarning.__le__" => "Return self<=value.",
    "builtins.UserWarning.__lt__" => "Return self<value.",
    "builtins.UserWarning.__ne__" => "Return self!=value.",
    "builtins.UserWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.UserWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.UserWarning.__repr__" => "Return repr(self).",
    "builtins.UserWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.UserWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.UserWarning.__str__" => "Return str(self).",
    "builtins.UserWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.UserWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.UserWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ValueError" => "Inappropriate argument value (of correct type).",
    "builtins.ValueError.__cause__" => "exception cause",
    "builtins.ValueError.__context__" => "exception context",
    "builtins.ValueError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ValueError.__eq__" => "Return self==value.",
    "builtins.ValueError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ValueError.__ge__" => "Return self>=value.",
    "builtins.ValueError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ValueError.__getstate__" => "Helper for pickle.",
    "builtins.ValueError.__gt__" => "Return self>value.",
    "builtins.ValueError.__hash__" => "Return hash(self).",
    "builtins.ValueError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ValueError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ValueError.__le__" => "Return self<=value.",
    "builtins.ValueError.__lt__" => "Return self<value.",
    "builtins.ValueError.__ne__" => "Return self!=value.",
    "builtins.ValueError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ValueError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ValueError.__repr__" => "Return repr(self).",
    "builtins.ValueError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ValueError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ValueError.__str__" => "Return str(self).",
    "builtins.ValueError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ValueError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ValueError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.Warning" => "Base class for warning categories.",
    "builtins.Warning.__cause__" => "exception cause",
    "builtins.Warning.__context__" => "exception context",
    "builtins.Warning.__delattr__" => "Implement delattr(self, name).",
    "builtins.Warning.__eq__" => "Return self==value.",
    "builtins.Warning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.Warning.__ge__" => "Return self>=value.",
    "builtins.Warning.__getattribute__" => "Return getattr(self, name).",
    "builtins.Warning.__getstate__" => "Helper for pickle.",
    "builtins.Warning.__gt__" => "Return self>value.",
    "builtins.Warning.__hash__" => "Return hash(self).",
    "builtins.Warning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.Warning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.Warning.__le__" => "Return self<=value.",
    "builtins.Warning.__lt__" => "Return self<value.",
    "builtins.Warning.__ne__" => "Return self!=value.",
    "builtins.Warning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.Warning.__reduce_ex__" => "Helper for pickle.",
    "builtins.Warning.__repr__" => "Return repr(self).",
    "builtins.Warning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.Warning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.Warning.__str__" => "Return str(self).",
    "builtins.Warning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.Warning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.Warning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.WindowsError" => "Base class for I/O related errors.",
    "builtins.WindowsError.__cause__" => "exception cause",
    "builtins.WindowsError.__context__" => "exception context",
    "builtins.WindowsError.__delattr__" => "Implement delattr(self, name).",
    "builtins.WindowsError.__eq__" => "Return self==value.",
    "builtins.WindowsError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.WindowsError.__ge__" => "Return self>=value.",
    "builtins.WindowsError.__getattribute__" => "Return getattr(self, name).",
    "builtins.WindowsError.__getstate__" => "Helper for pickle.",
    "builtins.WindowsError.__gt__" => "Return self>value.",
    "builtins.WindowsError.__hash__" => "Return hash(self).",
    "builtins.WindowsError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.WindowsError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.WindowsError.__le__" => "Return self<=value.",
    "builtins.WindowsError.__lt__" => "Return self<value.",
    "builtins.WindowsError.__ne__" => "Return self!=value.",
    "builtins.WindowsError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.WindowsError.__reduce_ex__" => "Helper for pickle.",
    "builtins.WindowsError.__repr__" => "Return repr(self).",
    "builtins.WindowsError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.WindowsError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.WindowsError.__str__" => "Return str(self).",
    "builtins.WindowsError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.WindowsError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.WindowsError.errno" => "POSIX exception code",
    "builtins.WindowsError.filename" => "exception filename",
    "builtins.WindowsError.filename2" => "second exception filename",
    "builtins.WindowsError.strerror" => "exception strerror",
    "builtins.WindowsError.winerror" => "Win32 exception code",
    "builtins.WindowsError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ZeroDivisionError" => "Second argument to a division or modulo operation was zero.",
    "builtins.ZeroDivisionError.__cause__" => "exception cause",
    "builtins.ZeroDivisionError.__context__" => "exception context",
    "builtins.ZeroDivisionError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ZeroDivisionError.__eq__" => "Return self==value.",
    "builtins.ZeroDivisionError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ZeroDivisionError.__ge__" => "Return self>=value.",
    "builtins.ZeroDivisionError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ZeroDivisionError.__getstate__" => "Helper for pickle.",
    "builtins.ZeroDivisionError.__gt__" => "Return self>value.",
    "builtins.ZeroDivisionError.__hash__" => "Return hash(self).",
    "builtins.ZeroDivisionError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ZeroDivisionError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ZeroDivisionError.__le__" => "Return self<=value.",
    "builtins.ZeroDivisionError.__lt__" => "Return self<value.",
    "builtins.ZeroDivisionError.__ne__" => "Return self!=value.",
    "builtins.ZeroDivisionError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ZeroDivisionError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ZeroDivisionError.__repr__" => "Return repr(self).",
    "builtins.ZeroDivisionError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ZeroDivisionError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ZeroDivisionError.__str__" => "Return str(self).",
    "builtins.ZeroDivisionError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ZeroDivisionError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ZeroDivisionError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins._IncompleteInputError" => "incomplete input.",
    "builtins._IncompleteInputError.__cause__" => "exception cause",
    "builtins._IncompleteInputError.__context__" => "exception context",
    "builtins._IncompleteInputError.__delattr__" => "Implement delattr(self, name).",
    "builtins._IncompleteInputError.__eq__" => "Return self==value.",
    "builtins._IncompleteInputError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins._IncompleteInputError.__ge__" => "Return self>=value.",
    "builtins._IncompleteInputError.__getattribute__" => "Return getattr(self, name).",
    "builtins._IncompleteInputError.__getstate__" => "Helper for pickle.",
    "builtins._IncompleteInputError.__gt__" => "Return self>value.",
    "builtins._IncompleteInputError.__hash__" => "Return hash(self).",
    "builtins._IncompleteInputError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins._IncompleteInputError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins._IncompleteInputError.__le__" => "Return self<=value.",
    "builtins._IncompleteInputError.__lt__" => "Return self<value.",
    "builtins._IncompleteInputError.__ne__" => "Return self!=value.",
    "builtins._IncompleteInputError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins._IncompleteInputError.__reduce_ex__" => "Helper for pickle.",
    "builtins._IncompleteInputError.__repr__" => "Return repr(self).",
    "builtins._IncompleteInputError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins._IncompleteInputError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins._IncompleteInputError.__str__" => "Return str(self).",
    "builtins._IncompleteInputError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins._IncompleteInputError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins._IncompleteInputError.end_lineno" => "exception end lineno",
    "builtins._IncompleteInputError.end_offset" => "exception end offset",
    "builtins._IncompleteInputError.filename" => "exception filename",
    "builtins._IncompleteInputError.lineno" => "exception lineno",
    "builtins._IncompleteInputError.msg" => "exception msg",
    "builtins._IncompleteInputError.offset" => "exception offset",
    "builtins._IncompleteInputError.print_file_and_line" => "exception print_file_and_line",
    "builtins._IncompleteInputError.text" => "exception text",
    "builtins._IncompleteInputError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.__build_class__" => "__build_class__(func, name, /, *bases, [metaclass], **kwds) -> class\n\nInternal helper function used by the class statement.",
    "builtins.__import__" => "Import a module.\n\nBecause this function is meant for use by the Python\ninterpreter and not for general use, it is better to use\nimportlib.import_module() to programmatically import a module.\n\nThe globals argument is only used to determine the context;\nthey are not modified.  The locals argument is unused.  The fromlist\nshould be a list of names to emulate ``from name import ...``, or an\nempty list to emulate ``import name``.\nWhen importing a module from a package, note that __import__('A.B', ...)\nreturns package A when fromlist is empty, but its submodule B when\nfromlist is not empty.  The level argument is used to determine whether to\nperform absolute or relative imports: 0 is absolute, while a positive number\nis the number of parent directories to search relative to the current module.",
    "builtins.abs" => "Return the absolute value of the argument.",
    "builtins.aiter" => "Return an AsyncIterator for an AsyncIterable object.",
    "builtins.all" => "Return True if bool(x) is True for all values x in the iterable.\n\nIf the iterable is empty, return True.",
    "builtins.anext" => "Return the next item from the async iterator.\n\nIf default is given and the async iterator is exhausted,\nit is returned instead of raising StopAsyncIteration.",
    "builtins.any" => "Return True if bool(x) is True for any x in the iterable.\n\nIf the iterable is empty, return False.",
    "builtins.ascii" => "Return an ASCII-only representation of an object.\n\nAs repr(), return a string containing a printable representation of an\nobject, but escape the non-ASCII characters in the string returned by\nrepr() using \\\\x, \\\\u or \\\\U escapes. This generates a string similar\nto that returned by repr() in Python 2.",
    "builtins.bin" => "Return the binary representation of an integer.\n\n>>> bin(2796202)\n'0b1010101010101010101010'",
    "builtins.bool" => "Returns True when the argument is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.",
    "builtins.bool.__abs__" => "abs(self)",
    "builtins.bool.__add__" => "Return self+value.",
    "builtins.bool.__and__" => "Return self&value.",
    "builtins.bool.__bool__" => "True if self else False",
    "builtins.bool.__ceil__" => "Ceiling of an Integral returns itself.",
    "builtins.bool.__delattr__" => "Implement delattr(self, name).",
    "builtins.bool.__divmod__" => "Return divmod(self, value).",
    "builtins.bool.__eq__" => "Return self==value.",
    "builtins.bool.__float__" => "float(self)",
    "builtins.bool.__floor__" => "Flooring an Integral returns itself.",
    "builtins.bool.__floordiv__" => "Return self//value.",
    "builtins.bool.__format__" => "Convert to a string according to format_spec.",
    "builtins.bool.__ge__" => "Return self>=value.",
    "builtins.bool.__getattribute__" => "Return getattr(self, name).",
    "builtins.bool.__getstate__" => "Helper for pickle.",
    "builtins.bool.__gt__" => "Return self>value.",
    "builtins.bool.__hash__" => "Return hash(self).",
    "builtins.bool.__index__" => "Return self converted to an integer, if self is suitable for use as an index into a list.",
    "builtins.bool.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.bool.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.bool.__int__" => "int(self)",
    "builtins.bool.__invert__" => "~self",
    "builtins.bool.__le__" => "Return self<=value.",
    "builtins.bool.__lshift__" => "Return self<<value.",
    "builtins.bool.__lt__" => "Return self<value.",
    "builtins.bool.__mod__" => "Return self%value.",
    "builtins.bool.__mul__" => "Return self*value.",
    "builtins.bool.__ne__" => "Return self!=value.",
    "builtins.bool.__neg__" => "-self",
    "builtins.bool.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.bool.__or__" => "Return self|value.",
    "builtins.bool.__pos__" => "+self",
    "builtins.bool.__pow__" => "Return pow(self, value, mod).",
    "builtins.bool.__radd__" => "Return value+self.",
    "builtins.bool.__rand__" => "Return value&self.",
    "builtins.bool.__rdivmod__" => "Return divmod(value, self).",
    "builtins.bool.__reduce__" => "Helper for pickle.",
    "builtins.bool.__reduce_ex__" => "Helper for pickle.",
    "builtins.bool.__repr__" => "Return repr(self).",
    "builtins.bool.__rfloordiv__" => "Return value//self.",
    "builtins.bool.__rlshift__" => "Return value<<self.",
    "builtins.bool.__rmod__" => "Return value%self.",
    "builtins.bool.__rmul__" => "Return value*self.",
    "builtins.bool.__ror__" => "Return value|self.",
    "builtins.bool.__round__" => "Rounding an Integral returns itself.\n\nRounding with an ndigits argument also returns an integer.",
    "builtins.bool.__rpow__" => "Return pow(value, self, mod).",
    "builtins.bool.__rrshift__" => "Return value>>self.",
    "builtins.bool.__rshift__" => "Return self>>value.",
    "builtins.bool.__rsub__" => "Return value-self.",
    "builtins.bool.__rtruediv__" => "Return value/self.",
    "builtins.bool.__rxor__" => "Return value^self.",
    "builtins.bool.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.bool.__sizeof__" => "Returns size in memory, in bytes.",
    "builtins.bool.__str__" => "Return str(self).",
    "builtins.bool.__sub__" => "Return self-value.",
    "builtins.bool.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.bool.__truediv__" => "Return self/value.",
    "builtins.bool.__trunc__" => "Truncating an Integral returns itself.",
    "builtins.bool.__xor__" => "Return self^value.",
    "builtins.bool.as_integer_ratio" => "Return a pair of integers, whose ratio is equal to the original int.\n\nThe ratio is in lowest terms and has a positive denominator.\n\n>>> (10).as_integer_ratio()\n(10, 1)\n>>> (-10).as_integer_ratio()\n(-10, 1)\n>>> (0).as_integer_ratio()\n(0, 1)",
    "builtins.bool.bit_count" => "Number of ones in the binary representation of the absolute value of self.\n\nAlso known as the population count.\n\n>>> bin(13)\n'0b1101'\n>>> (13).bit_count()\n3",
    "builtins.bool.bit_length" => "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
    "builtins.bool.conjugate" => "Returns self, the complex conjugate of any int.",
    "builtins.bool.denominator" => "the denominator of a rational number in lowest terms",
    "builtins.bool.from_bytes" => "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  sys.byteorder as the byte order value.  Default is to use 'big'.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
    "builtins.bool.imag" => "the imaginary part of a complex number",
    "builtins.bool.is_integer" => "Returns True. Exists for duck type compatibility with float.is_integer.",
    "builtins.bool.numerator" => "the numerator of a rational number in lowest terms",
    "builtins.bool.real" => "the real part of a complex number",
    "builtins.bool.to_bytes" => "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.  Default\n  is length 1.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  sys.byteorder as the byte order value.  Default is to use 'big'.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
    "builtins.breakpoint" => "Call sys.breakpointhook(*args, **kws).  sys.breakpointhook() must accept\nwhatever arguments are passed.\n\nBy default, this drops you into the pdb debugger.",
    "builtins.bytearray" => "bytearray(iterable_of_ints) -> bytearray\nbytearray(string, encoding[, errors]) -> bytearray\nbytearray(bytes_or_buffer) -> mutable copy of bytes_or_buffer\nbytearray(int) -> bytes array of size given by the parameter initialized with null bytes\nbytearray() -> empty bytes array\n\nConstruct a mutable bytearray object from:\n  - an iterable yielding integers in range(256)\n  - a text string encoded using the specified encoding\n  - a bytes or a buffer object\n  - any object implementing the buffer API.\n  - an integer",
    "builtins.bytearray.__add__" => "Return self+value.",
    "builtins.bytearray.__alloc__" => "B.__alloc__() -> int\n\nReturn the number of bytes actually allocated.",
    "builtins.bytearray.__buffer__" => "Return a buffer object that exposes the underlying memory of the object.",
    "builtins.bytearray.__contains__" => "Return bool(key in self).",
    "builtins.bytearray.__delattr__" => "Implement delattr(self, name).",
    "builtins.bytearray.__delitem__" => "Delete self[key].",
    "builtins.bytearray.__eq__" => "Return self==value.",
    "builtins.bytearray.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.bytearray.__ge__" => "Return self>=value.",
    "builtins.bytearray.__getattribute__" => "Return getattr(self, name).",
    "builtins.bytearray.__getitem__" => "Return self[key].",
    "builtins.bytearray.__getstate__" => "Helper for pickle.",
    "builtins.bytearray.__gt__" => "Return self>value.",
    "builtins.bytearray.__iadd__" => "Implement self+=value.",
    "builtins.bytearray.__imul__" => "Implement self*=value.",
    "builtins.bytearray.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.bytearray.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.bytearray.__iter__" => "Implement iter(self).",
    "builtins.bytearray.__le__" => "Return self<=value.",
    "builtins.bytearray.__len__" => "Return len(self).",
    "builtins.bytearray.__lt__" => "Return self<value.",
    "builtins.bytearray.__mod__" => "Return self%value.",
    "builtins.bytearray.__mul__" => "Return self*value.",
    "builtins.bytearray.__ne__" => "Return self!=value.",
    "builtins.bytearray.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.bytearray.__reduce__" => "Return state information for pickling.",
    "builtins.bytearray.__reduce_ex__" => "Return state information for pickling.",
    "builtins.bytearray.__release_buffer__" => "Release the buffer object that exposes the underlying memory of the object.",
    "builtins.bytearray.__repr__" => "Return repr(self).",
    "builtins.bytearray.__rmod__" => "Return value%self.",
    "builtins.bytearray.__rmul__" => "Return value*self.",
    "builtins.bytearray.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.bytearray.__setitem__" => "Set self[key] to value.",
    "builtins.bytearray.__sizeof__" => "Returns the size of the bytearray object in memory, in bytes.",
    "builtins.bytearray.__str__" => "Return str(self).",
    "builtins.bytearray.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.bytearray.append" => "Append a single item to the end of the bytearray.\n\nitem\n  The item to be appended.",
    "builtins.bytearray.capitalize" => "B.capitalize() -> copy of B\n\nReturn a copy of B with only its first character capitalized (ASCII)\nand the rest lower-cased.",
    "builtins.bytearray.center" => "Return a centered string of length width.\n\nPadding is done using the specified fill character.",
    "builtins.bytearray.clear" => "Remove all items from the bytearray.",
    "builtins.bytearray.copy" => "Return a copy of B.",
    "builtins.bytearray.count" => "Return the number of non-overlapping occurrences of subsection 'sub' in bytes B[start:end].\n\nstart\n  Optional start position. Default: start of the bytes.\nend\n  Optional stop position. Default: end of the bytes.",
    "builtins.bytearray.decode" => "Decode the bytearray using the codec registered for encoding.\n\nencoding\n  The encoding with which to decode the bytearray.\nerrors\n  The error handling scheme to use for the handling of decoding errors.\n  The default is 'strict' meaning that decoding errors raise a\n  UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n  as well as any other name registered with codecs.register_error that\n  can handle UnicodeDecodeErrors.",
    "builtins.bytearray.endswith" => "Return True if the bytearray ends with the specified suffix, False otherwise.\n\nsuffix\n  A bytes or a tuple of bytes to try.\nstart\n  Optional start position. Default: start of the bytearray.\nend\n  Optional stop position. Default: end of the bytearray.",
    "builtins.bytearray.expandtabs" => "Return a copy where all tab characters are expanded using spaces.\n\nIf tabsize is not given, a tab size of 8 characters is assumed.",
    "builtins.bytearray.extend" => "Append all the items from the iterator or sequence to the end of the bytearray.\n\niterable_of_ints\n  The iterable of items to append.",
    "builtins.bytearray.find" => "Return the lowest index in B where subsection 'sub' is found, such that 'sub' is contained within B[start:end].\n\n  start\n    Optional start position. Default: start of the bytes.\n  end\n    Optional stop position. Default: end of the bytes.\n\nReturn -1 on failure.",
    "builtins.bytearray.fromhex" => "Create a bytearray object from a string of hexadecimal numbers.\n\nSpaces between two numbers are accepted.\nExample: bytearray.fromhex('B9 01EF') -> bytearray(b'\\\\xb9\\\\x01\\\\xef')",
    "builtins.bytearray.hex" => "Create a string of hexadecimal numbers from a bytearray object.\n\n  sep\n    An optional single character or byte to separate hex bytes.\n  bytes_per_sep\n    How many bytes between separators.  Positive values count from the\n    right, negative values count from the left.\n\nExample:\n>>> value = bytearray([0xb9, 0x01, 0xef])\n>>> value.hex()\n'b901ef'\n>>> value.hex(':')\n'b9:01:ef'\n>>> value.hex(':', 2)\n'b9:01ef'\n>>> value.hex(':', -2)\n'b901:ef'",
    "builtins.bytearray.index" => "Return the lowest index in B where subsection 'sub' is found, such that 'sub' is contained within B[start:end].\n\n  start\n    Optional start position. Default: start of the bytes.\n  end\n    Optional stop position. Default: end of the bytes.\n\nRaise ValueError if the subsection is not found.",
    "builtins.bytearray.insert" => "Insert a single item into the bytearray before the given index.\n\nindex\n  The index where the value is to be inserted.\nitem\n  The item to be inserted.",
    "builtins.bytearray.isalnum" => "B.isalnum() -> bool\n\nReturn True if all characters in B are alphanumeric\nand there is at least one character in B, False otherwise.",
    "builtins.bytearray.isalpha" => "B.isalpha() -> bool\n\nReturn True if all characters in B are alphabetic\nand there is at least one character in B, False otherwise.",
    "builtins.bytearray.isascii" => "B.isascii() -> bool\n\nReturn True if B is empty or all characters in B are ASCII,\nFalse otherwise.",
    "builtins.bytearray.isdigit" => "B.isdigit() -> bool\n\nReturn True if all characters in B are digits\nand there is at least one character in B, False otherwise.",
    "builtins.bytearray.islower" => "B.islower() -> bool\n\nReturn True if all cased characters in B are lowercase and there is\nat least one cased character in B, False otherwise.",
    "builtins.bytearray.isspace" => "B.isspace() -> bool\n\nReturn True if all characters in B are whitespace\nand there is at least one character in B, False otherwise.",
    "builtins.bytearray.istitle" => "B.istitle() -> bool\n\nReturn True if B is a titlecased string and there is at least one\ncharacter in B, i.e. uppercase characters may only follow uncased\ncharacters and lowercase characters only cased ones. Return False\notherwise.",
    "builtins.bytearray.isupper" => "B.isupper() -> bool\n\nReturn True if all cased characters in B are uppercase and there is\nat least one cased character in B, False otherwise.",
    "builtins.bytearray.join" => "Concatenate any number of bytes/bytearray objects.\n\nThe bytearray whose method is called is inserted in between each pair.\n\nThe result is returned as a new bytearray object.",
    "builtins.bytearray.ljust" => "Return a left-justified string of length width.\n\nPadding is done using the specified fill character.",
    "builtins.bytearray.lower" => "B.lower() -> copy of B\n\nReturn a copy of B with all ASCII characters converted to lowercase.",
    "builtins.bytearray.lstrip" => "Strip leading bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading ASCII whitespace.",
    "builtins.bytearray.maketrans" => "Return a translation table usable for the bytes or bytearray translate method.\n\nThe returned table will be one where each byte in frm is mapped to the byte at\nthe same position in to.\n\nThe bytes objects frm and to must be of the same length.",
    "builtins.bytearray.partition" => "Partition the bytearray into three parts using the given separator.\n\nThis will search for the separator sep in the bytearray. If the separator is\nfound, returns a 3-tuple containing the part before the separator, the\nseparator itself, and the part after it as new bytearray objects.\n\nIf the separator is not found, returns a 3-tuple containing the copy of the\noriginal bytearray object and two empty bytearray objects.",
    "builtins.bytearray.pop" => "Remove and return a single item from B.\n\n  index\n    The index from where to remove the item.\n    -1 (the default value) means remove the last item.\n\nIf no index argument is given, will pop the last item.",
    "builtins.bytearray.remove" => "Remove the first occurrence of a value in the bytearray.\n\nvalue\n  The value to remove.",
    "builtins.bytearray.removeprefix" => "Return a bytearray with the given prefix string removed if present.\n\nIf the bytearray starts with the prefix string, return\nbytearray[len(prefix):].  Otherwise, return a copy of the original\nbytearray.",
    "builtins.bytearray.removesuffix" => "Return a bytearray with the given suffix string removed if present.\n\nIf the bytearray ends with the suffix string and that suffix is not\nempty, return bytearray[:-len(suffix)].  Otherwise, return a copy of\nthe original bytearray.",
    "builtins.bytearray.replace" => "Return a copy with all occurrences of substring old replaced by new.\n\n  count\n    Maximum number of occurrences to replace.\n    -1 (the default value) means replace all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplaced.",
    "builtins.bytearray.reverse" => "Reverse the order of the values in B in place.",
    "builtins.bytearray.rfind" => "Return the highest index in B where subsection 'sub' is found, such that 'sub' is contained within B[start:end].\n\n  start\n    Optional start position. Default: start of the bytes.\n  end\n    Optional stop position. Default: end of the bytes.\n\nReturn -1 on failure.",
    "builtins.bytearray.rindex" => "Return the highest index in B where subsection 'sub' is found, such that 'sub' is contained within B[start:end].\n\n  start\n    Optional start position. Default: start of the bytes.\n  end\n    Optional stop position. Default: end of the bytes.\n\nRaise ValueError if the subsection is not found.",
    "builtins.bytearray.rjust" => "Return a right-justified string of length width.\n\nPadding is done using the specified fill character.",
    "builtins.bytearray.rpartition" => "Partition the bytearray into three parts using the given separator.\n\nThis will search for the separator sep in the bytearray, starting at the end.\nIf the separator is found, returns a 3-tuple containing the part before the\nseparator, the separator itself, and the part after it as new bytearray\nobjects.\n\nIf the separator is not found, returns a 3-tuple containing two empty bytearray\nobjects and the copy of the original bytearray object.",
    "builtins.bytearray.rsplit" => "Return a list of the sections in the bytearray, using sep as the delimiter.\n\n  sep\n    The delimiter according which to split the bytearray.\n    None (the default value) means split on ASCII whitespace characters\n    (space, tab, return, newline, formfeed, vertical tab).\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit.\n\nSplitting is done starting at the end of the bytearray and working to the front.",
    "builtins.bytearray.rstrip" => "Strip trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip trailing ASCII whitespace.",
    "builtins.bytearray.split" => "Return a list of the sections in the bytearray, using sep as the delimiter.\n\nsep\n  The delimiter according which to split the bytearray.\n  None (the default value) means split on ASCII whitespace characters\n  (space, tab, return, newline, formfeed, vertical tab).\nmaxsplit\n  Maximum number of splits to do.\n  -1 (the default value) means no limit.",
    "builtins.bytearray.splitlines" => "Return a list of the lines in the bytearray, breaking at line boundaries.\n\nLine breaks are not included in the resulting list unless keepends is given and\ntrue.",
    "builtins.bytearray.startswith" => "Return True if the bytearray starts with the specified prefix, False otherwise.\n\nprefix\n  A bytes or a tuple of bytes to try.\nstart\n  Optional start position. Default: start of the bytearray.\nend\n  Optional stop position. Default: end of the bytearray.",
    "builtins.bytearray.strip" => "Strip leading and trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading and trailing ASCII whitespace.",
    "builtins.bytearray.swapcase" => "B.swapcase() -> copy of B\n\nReturn a copy of B with uppercase ASCII characters converted\nto lowercase ASCII and vice versa.",
    "builtins.bytearray.title" => "B.title() -> copy of B\n\nReturn a titlecased version of B, i.e. ASCII words start with uppercase\ncharacters, all remaining cased characters have lowercase.",
    "builtins.bytearray.translate" => "Return a copy with each character mapped by the given translation table.\n\n  table\n    Translation table, which must be a bytes object of length 256.\n\nAll characters occurring in the optional argument delete are removed.\nThe remaining characters are mapped through the given translation table.",
    "builtins.bytearray.upper" => "B.upper() -> copy of B\n\nReturn a copy of B with all ASCII characters converted to uppercase.",
    "builtins.bytearray.zfill" => "Pad a numeric string with zeros on the left, to fill a field of the given width.\n\nThe original string is never truncated.",
    "builtins.bytearray_iterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.bytearray_iterator.__eq__" => "Return self==value.",
    "builtins.bytearray_iterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.bytearray_iterator.__ge__" => "Return self>=value.",
    "builtins.bytearray_iterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.bytearray_iterator.__getstate__" => "Helper for pickle.",
    "builtins.bytearray_iterator.__gt__" => "Return self>value.",
    "builtins.bytearray_iterator.__hash__" => "Return hash(self).",
    "builtins.bytearray_iterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.bytearray_iterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.bytearray_iterator.__iter__" => "Implement iter(self).",
    "builtins.bytearray_iterator.__le__" => "Return self<=value.",
    "builtins.bytearray_iterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.bytearray_iterator.__lt__" => "Return self<value.",
    "builtins.bytearray_iterator.__ne__" => "Return self!=value.",
    "builtins.bytearray_iterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.bytearray_iterator.__next__" => "Implement next(self).",
    "builtins.bytearray_iterator.__reduce__" => "Return state information for pickling.",
    "builtins.bytearray_iterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.bytearray_iterator.__repr__" => "Return repr(self).",
    "builtins.bytearray_iterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.bytearray_iterator.__setstate__" => "Set state information for unpickling.",
    "builtins.bytearray_iterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.bytearray_iterator.__str__" => "Return str(self).",
    "builtins.bytearray_iterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.bytes" => "bytes(iterable_of_ints) -> bytes\nbytes(string, encoding[, errors]) -> bytes\nbytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer\nbytes(int) -> bytes object of size given by the parameter initialized with null bytes\nbytes() -> empty bytes object\n\nConstruct an immutable array of bytes from:\n  - an iterable yielding integers in range(256)\n  - a text string encoded using the specified encoding\n  - any object implementing the buffer API.\n  - an integer",
    "builtins.bytes.__add__" => "Return self+value.",
    "builtins.bytes.__buffer__" => "Return a buffer object that exposes the underlying memory of the object.",
    "builtins.bytes.__bytes__" => "Convert this value to exact type bytes.",
    "builtins.bytes.__contains__" => "Return bool(key in self).",
    "builtins.bytes.__delattr__" => "Implement delattr(self, name).",
    "builtins.bytes.__eq__" => "Return self==value.",
    "builtins.bytes.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.bytes.__ge__" => "Return self>=value.",
    "builtins.bytes.__getattribute__" => "Return getattr(self, name).",
    "builtins.bytes.__getitem__" => "Return self[key].",
    "builtins.bytes.__getstate__" => "Helper for pickle.",
    "builtins.bytes.__gt__" => "Return self>value.",
    "builtins.bytes.__hash__" => "Return hash(self).",
    "builtins.bytes.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.bytes.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.bytes.__iter__" => "Implement iter(self).",
    "builtins.bytes.__le__" => "Return self<=value.",
    "builtins.bytes.__len__" => "Return len(self).",
    "builtins.bytes.__lt__" => "Return self<value.",
    "builtins.bytes.__mod__" => "Return self%value.",
    "builtins.bytes.__mul__" => "Return self*value.",
    "builtins.bytes.__ne__" => "Return self!=value.",
    "builtins.bytes.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.bytes.__reduce__" => "Helper for pickle.",
    "builtins.bytes.__reduce_ex__" => "Helper for pickle.",
    "builtins.bytes.__repr__" => "Return repr(self).",
    "builtins.bytes.__rmod__" => "Return value%self.",
    "builtins.bytes.__rmul__" => "Return value*self.",
    "builtins.bytes.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.bytes.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.bytes.__str__" => "Return str(self).",
    "builtins.bytes.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.bytes.capitalize" => "B.capitalize() -> copy of B\n\nReturn a copy of B with only its first character capitalized (ASCII)\nand the rest lower-cased.",
    "builtins.bytes.center" => "Return a centered string of length width.\n\nPadding is done using the specified fill character.",
    "builtins.bytes.count" => "Return the number of non-overlapping occurrences of subsection 'sub' in bytes B[start:end].\n\nstart\n  Optional start position. Default: start of the bytes.\nend\n  Optional stop position. Default: end of the bytes.",
    "builtins.bytes.decode" => "Decode the bytes using the codec registered for encoding.\n\nencoding\n  The encoding with which to decode the bytes.\nerrors\n  The error handling scheme to use for the handling of decoding errors.\n  The default is 'strict' meaning that decoding errors raise a\n  UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n  as well as any other name registered with codecs.register_error that\n  can handle UnicodeDecodeErrors.",
    "builtins.bytes.endswith" => "Return True if the bytes ends with the specified suffix, False otherwise.\n\nsuffix\n  A bytes or a tuple of bytes to try.\nstart\n  Optional start position. Default: start of the bytes.\nend\n  Optional stop position. Default: end of the bytes.",
    "builtins.bytes.expandtabs" => "Return a copy where all tab characters are expanded using spaces.\n\nIf tabsize is not given, a tab size of 8 characters is assumed.",
    "builtins.bytes.find" => "Return the lowest index in B where subsection 'sub' is found, such that 'sub' is contained within B[start,end].\n\n  start\n    Optional start position. Default: start of the bytes.\n  end\n    Optional stop position. Default: end of the bytes.\n\nReturn -1 on failure.",
    "builtins.bytes.fromhex" => "Create a bytes object from a string of hexadecimal numbers.\n\nSpaces between two numbers are accepted.\nExample: bytes.fromhex('B9 01EF') -> b'\\\\xb9\\\\x01\\\\xef'.",
    "builtins.bytes.hex" => "Create a string of hexadecimal numbers from a bytes object.\n\n  sep\n    An optional single character or byte to separate hex bytes.\n  bytes_per_sep\n    How many bytes between separators.  Positive values count from the\n    right, negative values count from the left.\n\nExample:\n>>> value = b'\\xb9\\x01\\xef'\n>>> value.hex()\n'b901ef'\n>>> value.hex(':')\n'b9:01:ef'\n>>> value.hex(':', 2)\n'b9:01ef'\n>>> value.hex(':', -2)\n'b901:ef'",
    "builtins.bytes.index" => "Return the lowest index in B where subsection 'sub' is found, such that 'sub' is contained within B[start,end].\n\n  start\n    Optional start position. Default: start of the bytes.\n  end\n    Optional stop position. Default: end of the bytes.\n\nRaise ValueError if the subsection is not found.",
    "builtins.bytes.isalnum" => "B.isalnum() -> bool\n\nReturn True if all characters in B are alphanumeric\nand there is at least one character in B, False otherwise.",
    "builtins.bytes.isalpha" => "B.isalpha() -> bool\n\nReturn True if all characters in B are alphabetic\nand there is at least one character in B, False otherwise.",
    "builtins.bytes.isascii" => "B.isascii() -> bool\n\nReturn True if B is empty or all characters in B are ASCII,\nFalse otherwise.",
    "builtins.bytes.isdigit" => "B.isdigit() -> bool\n\nReturn True if all characters in B are digits\nand there is at least one character in B, False otherwise.",
    "builtins.bytes.islower" => "B.islower() -> bool\n\nReturn True if all cased characters in B are lowercase and there is\nat least one cased character in B, False otherwise.",
    "builtins.bytes.isspace" => "B.isspace() -> bool\n\nReturn True if all characters in B are whitespace\nand there is at least one character in B, False otherwise.",
    "builtins.bytes.istitle" => "B.istitle() -> bool\n\nReturn True if B is a titlecased string and there is at least one\ncharacter in B, i.e. uppercase characters may only follow uncased\ncharacters and lowercase characters only cased ones. Return False\notherwise.",
    "builtins.bytes.isupper" => "B.isupper() -> bool\n\nReturn True if all cased characters in B are uppercase and there is\nat least one cased character in B, False otherwise.",
    "builtins.bytes.join" => "Concatenate any number of bytes objects.\n\nThe bytes whose method is called is inserted in between each pair.\n\nThe result is returned as a new bytes object.\n\nExample: b'.'.join([b'ab', b'pq', b'rs']) -> b'ab.pq.rs'.",
    "builtins.bytes.ljust" => "Return a left-justified string of length width.\n\nPadding is done using the specified fill character.",
    "builtins.bytes.lower" => "B.lower() -> copy of B\n\nReturn a copy of B with all ASCII characters converted to lowercase.",
    "builtins.bytes.lstrip" => "Strip leading bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading  ASCII whitespace.",
    "builtins.bytes.maketrans" => "Return a translation table usable for the bytes or bytearray translate method.\n\nThe returned table will be one where each byte in frm is mapped to the byte at\nthe same position in to.\n\nThe bytes objects frm and to must be of the same length.",
    "builtins.bytes.partition" => "Partition the bytes into three parts using the given separator.\n\nThis will search for the separator sep in the bytes. If the separator is found,\nreturns a 3-tuple containing the part before the separator, the separator\nitself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing the original bytes\nobject and two empty bytes objects.",
    "builtins.bytes.removeprefix" => "Return a bytes object with the given prefix string removed if present.\n\nIf the bytes starts with the prefix string, return bytes[len(prefix):].\nOtherwise, return a copy of the original bytes.",
    "builtins.bytes.removesuffix" => "Return a bytes object with the given suffix string removed if present.\n\nIf the bytes ends with the suffix string and that suffix is not empty,\nreturn bytes[:-len(prefix)].  Otherwise, return a copy of the original\nbytes.",
    "builtins.bytes.replace" => "Return a copy with all occurrences of substring old replaced by new.\n\n  count\n    Maximum number of occurrences to replace.\n    -1 (the default value) means replace all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplaced.",
    "builtins.bytes.rfind" => "Return the highest index in B where subsection 'sub' is found, such that 'sub' is contained within B[start,end].\n\n  start\n    Optional start position. Default: start of the bytes.\n  end\n    Optional stop position. Default: end of the bytes.\n\nReturn -1 on failure.",
    "builtins.bytes.rindex" => "Return the highest index in B where subsection 'sub' is found, such that 'sub' is contained within B[start,end].\n\n  start\n    Optional start position. Default: start of the bytes.\n  end\n    Optional stop position. Default: end of the bytes.\n\nRaise ValueError if the subsection is not found.",
    "builtins.bytes.rjust" => "Return a right-justified string of length width.\n\nPadding is done using the specified fill character.",
    "builtins.bytes.rpartition" => "Partition the bytes into three parts using the given separator.\n\nThis will search for the separator sep in the bytes, starting at the end. If\nthe separator is found, returns a 3-tuple containing the part before the\nseparator, the separator itself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing two empty bytes\nobjects and the original bytes object.",
    "builtins.bytes.rsplit" => "Return a list of the sections in the bytes, using sep as the delimiter.\n\n  sep\n    The delimiter according which to split the bytes.\n    None (the default value) means split on ASCII whitespace characters\n    (space, tab, return, newline, formfeed, vertical tab).\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit.\n\nSplitting is done starting at the end of the bytes and working to the front.",
    "builtins.bytes.rstrip" => "Strip trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip trailing ASCII whitespace.",
    "builtins.bytes.split" => "Return a list of the sections in the bytes, using sep as the delimiter.\n\nsep\n  The delimiter according which to split the bytes.\n  None (the default value) means split on ASCII whitespace characters\n  (space, tab, return, newline, formfeed, vertical tab).\nmaxsplit\n  Maximum number of splits to do.\n  -1 (the default value) means no limit.",
    "builtins.bytes.splitlines" => "Return a list of the lines in the bytes, breaking at line boundaries.\n\nLine breaks are not included in the resulting list unless keepends is given and\ntrue.",
    "builtins.bytes.startswith" => "Return True if the bytes starts with the specified prefix, False otherwise.\n\nprefix\n  A bytes or a tuple of bytes to try.\nstart\n  Optional start position. Default: start of the bytes.\nend\n  Optional stop position. Default: end of the bytes.",
    "builtins.bytes.strip" => "Strip leading and trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading and trailing ASCII whitespace.",
    "builtins.bytes.swapcase" => "B.swapcase() -> copy of B\n\nReturn a copy of B with uppercase ASCII characters converted\nto lowercase ASCII and vice versa.",
    "builtins.bytes.title" => "B.title() -> copy of B\n\nReturn a titlecased version of B, i.e. ASCII words start with uppercase\ncharacters, all remaining cased characters have lowercase.",
    "builtins.bytes.translate" => "Return a copy with each character mapped by the given translation table.\n\n  table\n    Translation table, which must be a bytes object of length 256.\n\nAll characters occurring in the optional argument delete are removed.\nThe remaining characters are mapped through the given translation table.",
    "builtins.bytes.upper" => "B.upper() -> copy of B\n\nReturn a copy of B with all ASCII characters converted to uppercase.",
    "builtins.bytes.zfill" => "Pad a numeric string with zeros on the left, to fill a field of the given width.\n\nThe original string is never truncated.",
    "builtins.bytes_iterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.bytes_iterator.__eq__" => "Return self==value.",
    "builtins.bytes_iterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.bytes_iterator.__ge__" => "Return self>=value.",
    "builtins.bytes_iterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.bytes_iterator.__getstate__" => "Helper for pickle.",
    "builtins.bytes_iterator.__gt__" => "Return self>value.",
    "builtins.bytes_iterator.__hash__" => "Return hash(self).",
    "builtins.bytes_iterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.bytes_iterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.bytes_iterator.__iter__" => "Implement iter(self).",
    "builtins.bytes_iterator.__le__" => "Return self<=value.",
    "builtins.bytes_iterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.bytes_iterator.__lt__" => "Return self<value.",
    "builtins.bytes_iterator.__ne__" => "Return self!=value.",
    "builtins.bytes_iterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.bytes_iterator.__next__" => "Implement next(self).",
    "builtins.bytes_iterator.__reduce__" => "Return state information for pickling.",
    "builtins.bytes_iterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.bytes_iterator.__repr__" => "Return repr(self).",
    "builtins.bytes_iterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.bytes_iterator.__setstate__" => "Set state information for unpickling.",
    "builtins.bytes_iterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.bytes_iterator.__str__" => "Return str(self).",
    "builtins.bytes_iterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.callable" => "Return whether the object is callable (i.e., some kind of function).\n\nNote that classes are callable, as are instances of classes with a\n__call__() method.",
    "builtins.chr" => "Return a Unicode string of one character with ordinal i; 0 <= i <= 0x10ffff.",
    "builtins.classmethod" => "Convert a function to be a class method.\n\nA class method receives the class as implicit first argument,\njust like an instance method receives the instance.\nTo declare a class method, use this idiom:\n\n  class C:\n      @classmethod\n      def f(cls, arg1, arg2, argN):\n          ...\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()).  The instance is ignored except for its class.\nIf a class method is called for a derived class, the derived class\nobject is passed as the implied first argument.\n\nClass methods are different than C++ or Java static methods.\nIf you want those, see the staticmethod builtin.",
    "builtins.classmethod.__delattr__" => "Implement delattr(self, name).",
    "builtins.classmethod.__eq__" => "Return self==value.",
    "builtins.classmethod.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.classmethod.__ge__" => "Return self>=value.",
    "builtins.classmethod.__get__" => "Return an attribute of instance, which is of type owner.",
    "builtins.classmethod.__getattribute__" => "Return getattr(self, name).",
    "builtins.classmethod.__getstate__" => "Helper for pickle.",
    "builtins.classmethod.__gt__" => "Return self>value.",
    "builtins.classmethod.__hash__" => "Return hash(self).",
    "builtins.classmethod.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.classmethod.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.classmethod.__le__" => "Return self<=value.",
    "builtins.classmethod.__lt__" => "Return self<value.",
    "builtins.classmethod.__ne__" => "Return self!=value.",
    "builtins.classmethod.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.classmethod.__reduce__" => "Helper for pickle.",
    "builtins.classmethod.__reduce_ex__" => "Helper for pickle.",
    "builtins.classmethod.__repr__" => "Return repr(self).",
    "builtins.classmethod.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.classmethod.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.classmethod.__str__" => "Return str(self).",
    "builtins.classmethod.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.compile" => "Compile source into a code object that can be executed by exec() or eval().\n\nThe source code may represent a Python module, statement or expression.\nThe filename will be used for run-time error messages.\nThe mode must be 'exec' to compile a module, 'single' to compile a\nsingle (interactive) statement, or 'eval' to compile an expression.\nThe flags argument, if present, controls which future statements influence\nthe compilation of the code.\nThe dont_inherit argument, if true, stops the compilation inheriting\nthe effects of any future statements in effect in the code calling\ncompile; if absent or false these statements do influence the compilation,\nin addition to any features explicitly specified.",
    "builtins.complex" => "Create a complex number from a string or numbers.\n\nIf a string is given, parse it as a complex number.\nIf a single number is given, convert it to a complex number.\nIf the 'real' or 'imag' arguments are given, create a complex number\nwith the specified real and imaginary components.",
    "builtins.complex.__abs__" => "abs(self)",
    "builtins.complex.__add__" => "Return self+value.",
    "builtins.complex.__bool__" => "True if self else False",
    "builtins.complex.__complex__" => "Convert this value to exact type complex.",
    "builtins.complex.__delattr__" => "Implement delattr(self, name).",
    "builtins.complex.__eq__" => "Return self==value.",
    "builtins.complex.__format__" => "Convert to a string according to format_spec.",
    "builtins.complex.__ge__" => "Return self>=value.",
    "builtins.complex.__getattribute__" => "Return getattr(self, name).",
    "builtins.complex.__getstate__" => "Helper for pickle.",
    "builtins.complex.__gt__" => "Return self>value.",
    "builtins.complex.__hash__" => "Return hash(self).",
    "builtins.complex.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.complex.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.complex.__le__" => "Return self<=value.",
    "builtins.complex.__lt__" => "Return self<value.",
    "builtins.complex.__mul__" => "Return self*value.",
    "builtins.complex.__ne__" => "Return self!=value.",
    "builtins.complex.__neg__" => "-self",
    "builtins.complex.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.complex.__pos__" => "+self",
    "builtins.complex.__pow__" => "Return pow(self, value, mod).",
    "builtins.complex.__radd__" => "Return value+self.",
    "builtins.complex.__reduce__" => "Helper for pickle.",
    "builtins.complex.__reduce_ex__" => "Helper for pickle.",
    "builtins.complex.__repr__" => "Return repr(self).",
    "builtins.complex.__rmul__" => "Return value*self.",
    "builtins.complex.__rpow__" => "Return pow(value, self, mod).",
    "builtins.complex.__rsub__" => "Return value-self.",
    "builtins.complex.__rtruediv__" => "Return value/self.",
    "builtins.complex.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.complex.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.complex.__str__" => "Return str(self).",
    "builtins.complex.__sub__" => "Return self-value.",
    "builtins.complex.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.complex.__truediv__" => "Return self/value.",
    "builtins.complex.conjugate" => "Return the complex conjugate of its argument. (3-4j).conjugate() == 3+4j.",
    "builtins.complex.imag" => "the imaginary part of a complex number",
    "builtins.complex.real" => "the real part of a complex number",
    "builtins.delattr" => "Deletes the named attribute from the given object.\n\ndelattr(x, 'y') is equivalent to ``del x.y``",
    "builtins.dict" => "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)",
    "builtins.dict.__class_getitem__" => "See PEP 585",
    "builtins.dict.__contains__" => "True if the dictionary has the specified key, else False.",
    "builtins.dict.__delattr__" => "Implement delattr(self, name).",
    "builtins.dict.__delitem__" => "Delete self[key].",
    "builtins.dict.__eq__" => "Return self==value.",
    "builtins.dict.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.dict.__ge__" => "Return self>=value.",
    "builtins.dict.__getattribute__" => "Return getattr(self, name).",
    "builtins.dict.__getitem__" => "Return self[key].",
    "builtins.dict.__getstate__" => "Helper for pickle.",
    "builtins.dict.__gt__" => "Return self>value.",
    "builtins.dict.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.dict.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.dict.__ior__" => "Return self|=value.",
    "builtins.dict.__iter__" => "Implement iter(self).",
    "builtins.dict.__le__" => "Return self<=value.",
    "builtins.dict.__len__" => "Return len(self).",
    "builtins.dict.__lt__" => "Return self<value.",
    "builtins.dict.__ne__" => "Return self!=value.",
    "builtins.dict.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.dict.__or__" => "Return self|value.",
    "builtins.dict.__reduce__" => "Helper for pickle.",
    "builtins.dict.__reduce_ex__" => "Helper for pickle.",
    "builtins.dict.__repr__" => "Return repr(self).",
    "builtins.dict.__reversed__" => "Return a reverse iterator over the dict keys.",
    "builtins.dict.__ror__" => "Return value|self.",
    "builtins.dict.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.dict.__setitem__" => "Set self[key] to value.",
    "builtins.dict.__sizeof__" => "Return the size of the dict in memory, in bytes.",
    "builtins.dict.__str__" => "Return str(self).",
    "builtins.dict.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.dict.clear" => "Remove all items from the dict.",
    "builtins.dict.copy" => "Return a shallow copy of the dict.",
    "builtins.dict.fromkeys" => "Create a new dictionary with keys from iterable and values set to value.",
    "builtins.dict.get" => "Return the value for key if key is in the dictionary, else default.",
    "builtins.dict.items" => "Return a set-like object providing a view on the dict's items.",
    "builtins.dict.keys" => "Return a set-like object providing a view on the dict's keys.",
    "builtins.dict.pop" => "D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n\nIf the key is not found, return the default if given; otherwise,\nraise a KeyError.",
    "builtins.dict.popitem" => "Remove and return a (key, value) pair as a 2-tuple.\n\nPairs are returned in LIFO (last-in, first-out) order.\nRaises KeyError if the dict is empty.",
    "builtins.dict.setdefault" => "Insert key with a value of default if key is not in the dictionary.\n\nReturn the value for key if key is in the dictionary, else default.",
    "builtins.dict.update" => "D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.\nIf E is present and has a .keys() method, then does:  for k in E.keys(): D[k] = E[k]\nIf E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v\nIn either case, this is followed by: for k in F:  D[k] = F[k]",
    "builtins.dict.values" => "Return an object providing a view on the dict's values.",
    "builtins.dict_itemiterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.dict_itemiterator.__eq__" => "Return self==value.",
    "builtins.dict_itemiterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.dict_itemiterator.__ge__" => "Return self>=value.",
    "builtins.dict_itemiterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.dict_itemiterator.__getstate__" => "Helper for pickle.",
    "builtins.dict_itemiterator.__gt__" => "Return self>value.",
    "builtins.dict_itemiterator.__hash__" => "Return hash(self).",
    "builtins.dict_itemiterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.dict_itemiterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.dict_itemiterator.__iter__" => "Implement iter(self).",
    "builtins.dict_itemiterator.__le__" => "Return self<=value.",
    "builtins.dict_itemiterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.dict_itemiterator.__lt__" => "Return self<value.",
    "builtins.dict_itemiterator.__ne__" => "Return self!=value.",
    "builtins.dict_itemiterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.dict_itemiterator.__next__" => "Implement next(self).",
    "builtins.dict_itemiterator.__reduce__" => "Return state information for pickling.",
    "builtins.dict_itemiterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.dict_itemiterator.__repr__" => "Return repr(self).",
    "builtins.dict_itemiterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.dict_itemiterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.dict_itemiterator.__str__" => "Return str(self).",
    "builtins.dict_itemiterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.dict_items.__and__" => "Return self&value.",
    "builtins.dict_items.__contains__" => "Return bool(key in self).",
    "builtins.dict_items.__delattr__" => "Implement delattr(self, name).",
    "builtins.dict_items.__eq__" => "Return self==value.",
    "builtins.dict_items.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.dict_items.__ge__" => "Return self>=value.",
    "builtins.dict_items.__getattribute__" => "Return getattr(self, name).",
    "builtins.dict_items.__getstate__" => "Helper for pickle.",
    "builtins.dict_items.__gt__" => "Return self>value.",
    "builtins.dict_items.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.dict_items.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.dict_items.__iter__" => "Implement iter(self).",
    "builtins.dict_items.__le__" => "Return self<=value.",
    "builtins.dict_items.__len__" => "Return len(self).",
    "builtins.dict_items.__lt__" => "Return self<value.",
    "builtins.dict_items.__ne__" => "Return self!=value.",
    "builtins.dict_items.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.dict_items.__or__" => "Return self|value.",
    "builtins.dict_items.__rand__" => "Return value&self.",
    "builtins.dict_items.__reduce__" => "Helper for pickle.",
    "builtins.dict_items.__reduce_ex__" => "Helper for pickle.",
    "builtins.dict_items.__repr__" => "Return repr(self).",
    "builtins.dict_items.__reversed__" => "Return a reverse iterator over the dict items.",
    "builtins.dict_items.__ror__" => "Return value|self.",
    "builtins.dict_items.__rsub__" => "Return value-self.",
    "builtins.dict_items.__rxor__" => "Return value^self.",
    "builtins.dict_items.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.dict_items.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.dict_items.__str__" => "Return str(self).",
    "builtins.dict_items.__sub__" => "Return self-value.",
    "builtins.dict_items.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.dict_items.__xor__" => "Return self^value.",
    "builtins.dict_items.isdisjoint" => "Return True if the view and the given iterable have a null intersection.",
    "builtins.dict_items.mapping" => "dictionary that this view refers to",
    "builtins.dict_keyiterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.dict_keyiterator.__eq__" => "Return self==value.",
    "builtins.dict_keyiterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.dict_keyiterator.__ge__" => "Return self>=value.",
    "builtins.dict_keyiterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.dict_keyiterator.__getstate__" => "Helper for pickle.",
    "builtins.dict_keyiterator.__gt__" => "Return self>value.",
    "builtins.dict_keyiterator.__hash__" => "Return hash(self).",
    "builtins.dict_keyiterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.dict_keyiterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.dict_keyiterator.__iter__" => "Implement iter(self).",
    "builtins.dict_keyiterator.__le__" => "Return self<=value.",
    "builtins.dict_keyiterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.dict_keyiterator.__lt__" => "Return self<value.",
    "builtins.dict_keyiterator.__ne__" => "Return self!=value.",
    "builtins.dict_keyiterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.dict_keyiterator.__next__" => "Implement next(self).",
    "builtins.dict_keyiterator.__reduce__" => "Return state information for pickling.",
    "builtins.dict_keyiterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.dict_keyiterator.__repr__" => "Return repr(self).",
    "builtins.dict_keyiterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.dict_keyiterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.dict_keyiterator.__str__" => "Return str(self).",
    "builtins.dict_keyiterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.dict_valueiterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.dict_valueiterator.__eq__" => "Return self==value.",
    "builtins.dict_valueiterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.dict_valueiterator.__ge__" => "Return self>=value.",
    "builtins.dict_valueiterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.dict_valueiterator.__getstate__" => "Helper for pickle.",
    "builtins.dict_valueiterator.__gt__" => "Return self>value.",
    "builtins.dict_valueiterator.__hash__" => "Return hash(self).",
    "builtins.dict_valueiterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.dict_valueiterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.dict_valueiterator.__iter__" => "Implement iter(self).",
    "builtins.dict_valueiterator.__le__" => "Return self<=value.",
    "builtins.dict_valueiterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.dict_valueiterator.__lt__" => "Return self<value.",
    "builtins.dict_valueiterator.__ne__" => "Return self!=value.",
    "builtins.dict_valueiterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.dict_valueiterator.__next__" => "Implement next(self).",
    "builtins.dict_valueiterator.__reduce__" => "Return state information for pickling.",
    "builtins.dict_valueiterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.dict_valueiterator.__repr__" => "Return repr(self).",
    "builtins.dict_valueiterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.dict_valueiterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.dict_valueiterator.__str__" => "Return str(self).",
    "builtins.dict_valueiterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.dict_values.__delattr__" => "Implement delattr(self, name).",
    "builtins.dict_values.__eq__" => "Return self==value.",
    "builtins.dict_values.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.dict_values.__ge__" => "Return self>=value.",
    "builtins.dict_values.__getattribute__" => "Return getattr(self, name).",
    "builtins.dict_values.__getstate__" => "Helper for pickle.",
    "builtins.dict_values.__gt__" => "Return self>value.",
    "builtins.dict_values.__hash__" => "Return hash(self).",
    "builtins.dict_values.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.dict_values.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.dict_values.__iter__" => "Implement iter(self).",
    "builtins.dict_values.__le__" => "Return self<=value.",
    "builtins.dict_values.__len__" => "Return len(self).",
    "builtins.dict_values.__lt__" => "Return self<value.",
    "builtins.dict_values.__ne__" => "Return self!=value.",
    "builtins.dict_values.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.dict_values.__reduce__" => "Helper for pickle.",
    "builtins.dict_values.__reduce_ex__" => "Helper for pickle.",
    "builtins.dict_values.__repr__" => "Return repr(self).",
    "builtins.dict_values.__reversed__" => "Return a reverse iterator over the dict values.",
    "builtins.dict_values.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.dict_values.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.dict_values.__str__" => "Return str(self).",
    "builtins.dict_values.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.dict_values.mapping" => "dictionary that this view refers to",
    "builtins.dir" => "dir([object]) -> list of strings\n\nIf called without an argument, return the names in the current scope.\nElse, return an alphabetized list of names comprising (some of) the attributes\nof the given object, and of attributes reachable from it.\nIf the object supplies a method named __dir__, it will be used; otherwise\nthe default dir() logic is used and returns:\n  for a module object: the module's attributes.\n  for a class object:  its attributes, and recursively the attributes\n    of its bases.\n  for any other object: its attributes, its class's attributes, and\n    recursively the attributes of its class's base classes.",
    "builtins.divmod" => "Return the tuple (x//y, x%y).  Invariant: div*y + mod == x.",
    "builtins.enumerate" => "Return an enumerate object.\n\n  iterable\n    an object supporting iteration\n\nThe enumerate object yields pairs containing a count (from start, which\ndefaults to zero) and a value yielded by the iterable argument.\n\nenumerate is useful for obtaining an indexed list:\n    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...",
    "builtins.enumerate.__class_getitem__" => "See PEP 585",
    "builtins.enumerate.__delattr__" => "Implement delattr(self, name).",
    "builtins.enumerate.__eq__" => "Return self==value.",
    "builtins.enumerate.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.enumerate.__ge__" => "Return self>=value.",
    "builtins.enumerate.__getattribute__" => "Return getattr(self, name).",
    "builtins.enumerate.__getstate__" => "Helper for pickle.",
    "builtins.enumerate.__gt__" => "Return self>value.",
    "builtins.enumerate.__hash__" => "Return hash(self).",
    "builtins.enumerate.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.enumerate.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.enumerate.__iter__" => "Implement iter(self).",
    "builtins.enumerate.__le__" => "Return self<=value.",
    "builtins.enumerate.__lt__" => "Return self<value.",
    "builtins.enumerate.__ne__" => "Return self!=value.",
    "builtins.enumerate.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.enumerate.__next__" => "Implement next(self).",
    "builtins.enumerate.__reduce__" => "Return state information for pickling.",
    "builtins.enumerate.__reduce_ex__" => "Helper for pickle.",
    "builtins.enumerate.__repr__" => "Return repr(self).",
    "builtins.enumerate.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.enumerate.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.enumerate.__str__" => "Return str(self).",
    "builtins.enumerate.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.eval" => "Evaluate the given source in the context of globals and locals.\n\nThe source may be a string representing a Python expression\nor a code object as returned by compile().\nThe globals must be a dictionary and locals can be any mapping,\ndefaulting to the current globals and locals.\nIf only globals is given, locals defaults to it.",
    "builtins.exec" => "Execute the given source in the context of globals and locals.\n\nThe source may be a string representing one or more Python statements\nor a code object as returned by compile().\nThe globals must be a dictionary and locals can be any mapping,\ndefaulting to the current globals and locals.\nIf only globals is given, locals defaults to it.\nThe closure must be a tuple of cellvars, and can only be used\nwhen source is a code object requiring exactly that many cellvars.",
    "builtins.filter" => "Return an iterator yielding those items of iterable for which function(item)\nis true. If function is None, return the items that are true.",
    "builtins.filter.__delattr__" => "Implement delattr(self, name).",
    "builtins.filter.__eq__" => "Return self==value.",
    "builtins.filter.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.filter.__ge__" => "Return self>=value.",
    "builtins.filter.__getattribute__" => "Return getattr(self, name).",
    "builtins.filter.__getstate__" => "Helper for pickle.",
    "builtins.filter.__gt__" => "Return self>value.",
    "builtins.filter.__hash__" => "Return hash(self).",
    "builtins.filter.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.filter.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.filter.__iter__" => "Implement iter(self).",
    "builtins.filter.__le__" => "Return self<=value.",
    "builtins.filter.__lt__" => "Return self<value.",
    "builtins.filter.__ne__" => "Return self!=value.",
    "builtins.filter.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.filter.__next__" => "Implement next(self).",
    "builtins.filter.__reduce__" => "Return state information for pickling.",
    "builtins.filter.__reduce_ex__" => "Helper for pickle.",
    "builtins.filter.__repr__" => "Return repr(self).",
    "builtins.filter.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.filter.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.filter.__str__" => "Return str(self).",
    "builtins.filter.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.float" => "Convert a string or number to a floating-point number, if possible.",
    "builtins.float.__abs__" => "abs(self)",
    "builtins.float.__add__" => "Return self+value.",
    "builtins.float.__bool__" => "True if self else False",
    "builtins.float.__ceil__" => "Return the ceiling as an Integral.",
    "builtins.float.__delattr__" => "Implement delattr(self, name).",
    "builtins.float.__divmod__" => "Return divmod(self, value).",
    "builtins.float.__eq__" => "Return self==value.",
    "builtins.float.__float__" => "float(self)",
    "builtins.float.__floor__" => "Return the floor as an Integral.",
    "builtins.float.__floordiv__" => "Return self//value.",
    "builtins.float.__format__" => "Formats the float according to format_spec.",
    "builtins.float.__ge__" => "Return self>=value.",
    "builtins.float.__getattribute__" => "Return getattr(self, name).",
    "builtins.float.__getformat__" => "You probably don't want to use this function.\n\n  typestr\n    Must be 'double' or 'float'.\n\nIt exists mainly to be used in Python's test suite.\n\nThis function returns whichever of 'unknown', 'IEEE, big-endian' or 'IEEE,\nlittle-endian' best describes the format of floating-point numbers used by the\nC type named by typestr.",
    "builtins.float.__getstate__" => "Helper for pickle.",
    "builtins.float.__gt__" => "Return self>value.",
    "builtins.float.__hash__" => "Return hash(self).",
    "builtins.float.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.float.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.float.__int__" => "int(self)",
    "builtins.float.__le__" => "Return self<=value.",
    "builtins.float.__lt__" => "Return self<value.",
    "builtins.float.__mod__" => "Return self%value.",
    "builtins.float.__mul__" => "Return self*value.",
    "builtins.float.__ne__" => "Return self!=value.",
    "builtins.float.__neg__" => "-self",
    "builtins.float.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.float.__pos__" => "+self",
    "builtins.float.__pow__" => "Return pow(self, value, mod).",
    "builtins.float.__radd__" => "Return value+self.",
    "builtins.float.__rdivmod__" => "Return divmod(value, self).",
    "builtins.float.__reduce__" => "Helper for pickle.",
    "builtins.float.__reduce_ex__" => "Helper for pickle.",
    "builtins.float.__repr__" => "Return repr(self).",
    "builtins.float.__rfloordiv__" => "Return value//self.",
    "builtins.float.__rmod__" => "Return value%self.",
    "builtins.float.__rmul__" => "Return value*self.",
    "builtins.float.__round__" => "Return the Integral closest to x, rounding half toward even.\n\nWhen an argument is passed, work like built-in round(x, ndigits).",
    "builtins.float.__rpow__" => "Return pow(value, self, mod).",
    "builtins.float.__rsub__" => "Return value-self.",
    "builtins.float.__rtruediv__" => "Return value/self.",
    "builtins.float.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.float.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.float.__str__" => "Return str(self).",
    "builtins.float.__sub__" => "Return self-value.",
    "builtins.float.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.float.__truediv__" => "Return self/value.",
    "builtins.float.__trunc__" => "Return the Integral closest to x between 0 and x.",
    "builtins.float.as_integer_ratio" => "Return a pair of integers, whose ratio is exactly equal to the original float.\n\nThe ratio is in lowest terms and has a positive denominator.  Raise\nOverflowError on infinities and a ValueError on NaNs.\n\n>>> (10.0).as_integer_ratio()\n(10, 1)\n>>> (0.0).as_integer_ratio()\n(0, 1)\n>>> (-.25).as_integer_ratio()\n(-1, 4)",
    "builtins.float.conjugate" => "Return self, the complex conjugate of any float.",
    "builtins.float.fromhex" => "Create a floating-point number from a hexadecimal string.\n\n>>> float.fromhex('0x1.ffffp10')\n2047.984375\n>>> float.fromhex('-0x1p-1074')\n-5e-324",
    "builtins.float.hex" => "Return a hexadecimal representation of a floating-point number.\n\n>>> (-0.1).hex()\n'-0x1.999999999999ap-4'\n>>> 3.14159.hex()\n'0x1.921f9f01b866ep+1'",
    "builtins.float.imag" => "the imaginary part of a complex number",
    "builtins.float.is_integer" => "Return True if the float is an integer.",
    "builtins.float.real" => "the real part of a complex number",
    "builtins.format" => "Return type(value).__format__(value, format_spec)\n\nMany built-in types implement format_spec according to the\nFormat Specification Mini-language. See help('FORMATTING').\n\nIf type(value) does not supply a method named __format__\nand format_spec is empty, then str(value) is returned.\nSee also help('SPECIALMETHODS').",
    "builtins.frozenset" => "Build an immutable unordered collection of unique elements.",
    "builtins.frozenset.__and__" => "Return self&value.",
    "builtins.frozenset.__class_getitem__" => "See PEP 585",
    "builtins.frozenset.__contains__" => "x.__contains__(y) <==> y in x.",
    "builtins.frozenset.__delattr__" => "Implement delattr(self, name).",
    "builtins.frozenset.__eq__" => "Return self==value.",
    "builtins.frozenset.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.frozenset.__ge__" => "Return self>=value.",
    "builtins.frozenset.__getattribute__" => "Return getattr(self, name).",
    "builtins.frozenset.__getstate__" => "Helper for pickle.",
    "builtins.frozenset.__gt__" => "Return self>value.",
    "builtins.frozenset.__hash__" => "Return hash(self).",
    "builtins.frozenset.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.frozenset.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.frozenset.__iter__" => "Implement iter(self).",
    "builtins.frozenset.__le__" => "Return self<=value.",
    "builtins.frozenset.__len__" => "Return len(self).",
    "builtins.frozenset.__lt__" => "Return self<value.",
    "builtins.frozenset.__ne__" => "Return self!=value.",
    "builtins.frozenset.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.frozenset.__or__" => "Return self|value.",
    "builtins.frozenset.__rand__" => "Return value&self.",
    "builtins.frozenset.__reduce__" => "Return state information for pickling.",
    "builtins.frozenset.__reduce_ex__" => "Helper for pickle.",
    "builtins.frozenset.__repr__" => "Return repr(self).",
    "builtins.frozenset.__ror__" => "Return value|self.",
    "builtins.frozenset.__rsub__" => "Return value-self.",
    "builtins.frozenset.__rxor__" => "Return value^self.",
    "builtins.frozenset.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.frozenset.__sizeof__" => "S.__sizeof__() -> size of S in memory, in bytes.",
    "builtins.frozenset.__str__" => "Return str(self).",
    "builtins.frozenset.__sub__" => "Return self-value.",
    "builtins.frozenset.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.frozenset.__xor__" => "Return self^value.",
    "builtins.frozenset.copy" => "Return a shallow copy of a set.",
    "builtins.frozenset.difference" => "Return a new set with elements in the set that are not in the others.",
    "builtins.frozenset.intersection" => "Return a new set with elements common to the set and all others.",
    "builtins.frozenset.isdisjoint" => "Return True if two sets have a null intersection.",
    "builtins.frozenset.issubset" => "Report whether another set contains this set.",
    "builtins.frozenset.issuperset" => "Report whether this set contains another set.",
    "builtins.frozenset.symmetric_difference" => "Return a new set with elements in either the set or other but not both.",
    "builtins.frozenset.union" => "Return a new set with elements from the set and all others.",
    "builtins.function" => "Create a function object.\n\ncode\n  a code object\nglobals\n  the globals dictionary\nname\n  a string that overrides the name from the code object\nargdefs\n  a tuple that specifies the default argument values\nclosure\n  a tuple that supplies the bindings for free variables\nkwdefaults\n  a dictionary that specifies the default keyword argument values",
    "builtins.function.__call__" => "Call self as a function.",
    "builtins.function.__delattr__" => "Implement delattr(self, name).",
    "builtins.function.__eq__" => "Return self==value.",
    "builtins.function.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.function.__ge__" => "Return self>=value.",
    "builtins.function.__get__" => "Return an attribute of instance, which is of type owner.",
    "builtins.function.__getattribute__" => "Return getattr(self, name).",
    "builtins.function.__getstate__" => "Helper for pickle.",
    "builtins.function.__gt__" => "Return self>value.",
    "builtins.function.__hash__" => "Return hash(self).",
    "builtins.function.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.function.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.function.__le__" => "Return self<=value.",
    "builtins.function.__lt__" => "Return self<value.",
    "builtins.function.__ne__" => "Return self!=value.",
    "builtins.function.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.function.__reduce__" => "Helper for pickle.",
    "builtins.function.__reduce_ex__" => "Helper for pickle.",
    "builtins.function.__repr__" => "Return repr(self).",
    "builtins.function.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.function.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.function.__str__" => "Return str(self).",
    "builtins.function.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.function.__type_params__" => "Get the declared type parameters for a function.",
    "builtins.getattr" => "getattr(object, name[, default]) -> value\n\nGet a named attribute from an object; getattr(x, 'y') is equivalent to x.y.\nWhen a default argument is given, it is returned when the attribute doesn't\nexist; without it, an exception is raised in that case.",
    "builtins.globals" => "Return the dictionary containing the current scope's global variables.\n\nNOTE: Updates to this dictionary *will* affect name lookups in the current\nglobal scope and vice-versa.",
    "builtins.hasattr" => "Return whether the object has an attribute with the given name.\n\nThis is done by calling getattr(obj, name) and catching AttributeError.",
    "builtins.hash" => "Return the hash value for the given object.\n\nTwo objects that compare equal must also have the same hash value, but the\nreverse is not necessarily true.",
    "builtins.hex" => "Return the hexadecimal representation of an integer.\n\n>>> hex(12648430)\n'0xc0ffee'",
    "builtins.id" => "Return the identity of an object.\n\nThis is guaranteed to be unique among simultaneously existing objects.\n(CPython uses the object's memory address.)",
    "builtins.input" => "Read a string from standard input.  The trailing newline is stripped.\n\nThe prompt string, if given, is printed to standard output without a\ntrailing newline before reading input.\n\nIf the user hits EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return), raise EOFError.\nOn *nix systems, readline is used if available.",
    "builtins.int" => "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating-point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
    "builtins.int.__abs__" => "abs(self)",
    "builtins.int.__add__" => "Return self+value.",
    "builtins.int.__and__" => "Return self&value.",
    "builtins.int.__bool__" => "True if self else False",
    "builtins.int.__ceil__" => "Ceiling of an Integral returns itself.",
    "builtins.int.__delattr__" => "Implement delattr(self, name).",
    "builtins.int.__divmod__" => "Return divmod(self, value).",
    "builtins.int.__eq__" => "Return self==value.",
    "builtins.int.__float__" => "float(self)",
    "builtins.int.__floor__" => "Flooring an Integral returns itself.",
    "builtins.int.__floordiv__" => "Return self//value.",
    "builtins.int.__format__" => "Convert to a string according to format_spec.",
    "builtins.int.__ge__" => "Return self>=value.",
    "builtins.int.__getattribute__" => "Return getattr(self, name).",
    "builtins.int.__getstate__" => "Helper for pickle.",
    "builtins.int.__gt__" => "Return self>value.",
    "builtins.int.__hash__" => "Return hash(self).",
    "builtins.int.__index__" => "Return self converted to an integer, if self is suitable for use as an index into a list.",
    "builtins.int.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.int.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.int.__int__" => "int(self)",
    "builtins.int.__invert__" => "~self",
    "builtins.int.__le__" => "Return self<=value.",
    "builtins.int.__lshift__" => "Return self<<value.",
    "builtins.int.__lt__" => "Return self<value.",
    "builtins.int.__mod__" => "Return self%value.",
    "builtins.int.__mul__" => "Return self*value.",
    "builtins.int.__ne__" => "Return self!=value.",
    "builtins.int.__neg__" => "-self",
    "builtins.int.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.int.__or__" => "Return self|value.",
    "builtins.int.__pos__" => "+self",
    "builtins.int.__pow__" => "Return pow(self, value, mod).",
    "builtins.int.__radd__" => "Return value+self.",
    "builtins.int.__rand__" => "Return value&self.",
    "builtins.int.__rdivmod__" => "Return divmod(value, self).",
    "builtins.int.__reduce__" => "Helper for pickle.",
    "builtins.int.__reduce_ex__" => "Helper for pickle.",
    "builtins.int.__repr__" => "Return repr(self).",
    "builtins.int.__rfloordiv__" => "Return value//self.",
    "builtins.int.__rlshift__" => "Return value<<self.",
    "builtins.int.__rmod__" => "Return value%self.",
    "builtins.int.__rmul__" => "Return value*self.",
    "builtins.int.__ror__" => "Return value|self.",
    "builtins.int.__round__" => "Rounding an Integral returns itself.\n\nRounding with an ndigits argument also returns an integer.",
    "builtins.int.__rpow__" => "Return pow(value, self, mod).",
    "builtins.int.__rrshift__" => "Return value>>self.",
    "builtins.int.__rshift__" => "Return self>>value.",
    "builtins.int.__rsub__" => "Return value-self.",
    "builtins.int.__rtruediv__" => "Return value/self.",
    "builtins.int.__rxor__" => "Return value^self.",
    "builtins.int.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.int.__sizeof__" => "Returns size in memory, in bytes.",
    "builtins.int.__str__" => "Return str(self).",
    "builtins.int.__sub__" => "Return self-value.",
    "builtins.int.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.int.__truediv__" => "Return self/value.",
    "builtins.int.__trunc__" => "Truncating an Integral returns itself.",
    "builtins.int.__xor__" => "Return self^value.",
    "builtins.int.as_integer_ratio" => "Return a pair of integers, whose ratio is equal to the original int.\n\nThe ratio is in lowest terms and has a positive denominator.\n\n>>> (10).as_integer_ratio()\n(10, 1)\n>>> (-10).as_integer_ratio()\n(-10, 1)\n>>> (0).as_integer_ratio()\n(0, 1)",
    "builtins.int.bit_count" => "Number of ones in the binary representation of the absolute value of self.\n\nAlso known as the population count.\n\n>>> bin(13)\n'0b1101'\n>>> (13).bit_count()\n3",
    "builtins.int.bit_length" => "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
    "builtins.int.conjugate" => "Returns self, the complex conjugate of any int.",
    "builtins.int.denominator" => "the denominator of a rational number in lowest terms",
    "builtins.int.from_bytes" => "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  sys.byteorder as the byte order value.  Default is to use 'big'.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
    "builtins.int.imag" => "the imaginary part of a complex number",
    "builtins.int.is_integer" => "Returns True. Exists for duck type compatibility with float.is_integer.",
    "builtins.int.numerator" => "the numerator of a rational number in lowest terms",
    "builtins.int.real" => "the real part of a complex number",
    "builtins.int.to_bytes" => "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.  Default\n  is length 1.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  sys.byteorder as the byte order value.  Default is to use 'big'.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
    "builtins.isinstance" => "Return whether an object is an instance of a class or of a subclass thereof.\n\nA tuple, as in ``isinstance(x, (A, B, ...))``, may be given as the target to\ncheck against. This is equivalent to ``isinstance(x, A) or isinstance(x, B)\nor ...`` etc.",
    "builtins.issubclass" => "Return whether 'cls' is derived from another class or is the same class.\n\nA tuple, as in ``issubclass(x, (A, B, ...))``, may be given as the target to\ncheck against. This is equivalent to ``issubclass(x, A) or issubclass(x, B)\nor ...``.",
    "builtins.iter" => "iter(iterable) -> iterator\niter(callable, sentinel) -> iterator\n\nGet an iterator from an object.  In the first form, the argument must\nsupply its own iterator, or be a sequence.\nIn the second form, the callable is called until it returns the sentinel.",
    "builtins.len" => "Return the number of items in a container.",
    "builtins.list" => "Built-in mutable sequence.\n\nIf no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.",
    "builtins.list.__add__" => "Return self+value.",
    "builtins.list.__class_getitem__" => "See PEP 585",
    "builtins.list.__contains__" => "Return bool(key in self).",
    "builtins.list.__delattr__" => "Implement delattr(self, name).",
    "builtins.list.__delitem__" => "Delete self[key].",
    "builtins.list.__eq__" => "Return self==value.",
    "builtins.list.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.list.__ge__" => "Return self>=value.",
    "builtins.list.__getattribute__" => "Return getattr(self, name).",
    "builtins.list.__getitem__" => "Return self[index].",
    "builtins.list.__getstate__" => "Helper for pickle.",
    "builtins.list.__gt__" => "Return self>value.",
    "builtins.list.__iadd__" => "Implement self+=value.",
    "builtins.list.__imul__" => "Implement self*=value.",
    "builtins.list.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.list.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.list.__iter__" => "Implement iter(self).",
    "builtins.list.__le__" => "Return self<=value.",
    "builtins.list.__len__" => "Return len(self).",
    "builtins.list.__lt__" => "Return self<value.",
    "builtins.list.__mul__" => "Return self*value.",
    "builtins.list.__ne__" => "Return self!=value.",
    "builtins.list.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.list.__reduce__" => "Helper for pickle.",
    "builtins.list.__reduce_ex__" => "Helper for pickle.",
    "builtins.list.__repr__" => "Return repr(self).",
    "builtins.list.__reversed__" => "Return a reverse iterator over the list.",
    "builtins.list.__rmul__" => "Return value*self.",
    "builtins.list.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.list.__setitem__" => "Set self[key] to value.",
    "builtins.list.__sizeof__" => "Return the size of the list in memory, in bytes.",
    "builtins.list.__str__" => "Return str(self).",
    "builtins.list.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.list.append" => "Append object to the end of the list.",
    "builtins.list.clear" => "Remove all items from list.",
    "builtins.list.copy" => "Return a shallow copy of the list.",
    "builtins.list.count" => "Return number of occurrences of value.",
    "builtins.list.extend" => "Extend list by appending elements from the iterable.",
    "builtins.list.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "builtins.list.insert" => "Insert object before index.",
    "builtins.list.pop" => "Remove and return item at index (default last).\n\nRaises IndexError if list is empty or index is out of range.",
    "builtins.list.remove" => "Remove first occurrence of value.\n\nRaises ValueError if the value is not present.",
    "builtins.list.reverse" => "Reverse *IN PLACE*.",
    "builtins.list.sort" => "Sort the list in ascending order and return None.\n\nThe sort is in-place (i.e. the list itself is modified) and stable (i.e. the\norder of two equal elements is maintained).\n\nIf a key function is given, apply it once to each list item and sort them,\nascending or descending, according to their function values.\n\nThe reverse flag can be set to sort in descending order.",
    "builtins.list_iterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.list_iterator.__eq__" => "Return self==value.",
    "builtins.list_iterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.list_iterator.__ge__" => "Return self>=value.",
    "builtins.list_iterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.list_iterator.__getstate__" => "Helper for pickle.",
    "builtins.list_iterator.__gt__" => "Return self>value.",
    "builtins.list_iterator.__hash__" => "Return hash(self).",
    "builtins.list_iterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.list_iterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.list_iterator.__iter__" => "Implement iter(self).",
    "builtins.list_iterator.__le__" => "Return self<=value.",
    "builtins.list_iterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.list_iterator.__lt__" => "Return self<value.",
    "builtins.list_iterator.__ne__" => "Return self!=value.",
    "builtins.list_iterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.list_iterator.__next__" => "Implement next(self).",
    "builtins.list_iterator.__reduce__" => "Return state information for pickling.",
    "builtins.list_iterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.list_iterator.__repr__" => "Return repr(self).",
    "builtins.list_iterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.list_iterator.__setstate__" => "Set state information for unpickling.",
    "builtins.list_iterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.list_iterator.__str__" => "Return str(self).",
    "builtins.list_iterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.locals" => "Return a dictionary containing the current scope's local variables.\n\nNOTE: Whether or not updates to this dictionary will affect name lookups in\nthe local scope and vice-versa is *implementation dependent* and not\ncovered by any backwards compatibility guarantees.",
    "builtins.map" => "Make an iterator that computes the function using arguments from\neach of the iterables.  Stops when the shortest iterable is exhausted.",
    "builtins.map.__delattr__" => "Implement delattr(self, name).",
    "builtins.map.__eq__" => "Return self==value.",
    "builtins.map.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.map.__ge__" => "Return self>=value.",
    "builtins.map.__getattribute__" => "Return getattr(self, name).",
    "builtins.map.__getstate__" => "Helper for pickle.",
    "builtins.map.__gt__" => "Return self>value.",
    "builtins.map.__hash__" => "Return hash(self).",
    "builtins.map.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.map.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.map.__iter__" => "Implement iter(self).",
    "builtins.map.__le__" => "Return self<=value.",
    "builtins.map.__lt__" => "Return self<value.",
    "builtins.map.__ne__" => "Return self!=value.",
    "builtins.map.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.map.__next__" => "Implement next(self).",
    "builtins.map.__reduce__" => "Return state information for pickling.",
    "builtins.map.__reduce_ex__" => "Helper for pickle.",
    "builtins.map.__repr__" => "Return repr(self).",
    "builtins.map.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.map.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.map.__str__" => "Return str(self).",
    "builtins.map.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.max" => "max(iterable, *[, default=obj, key=func]) -> value\nmax(arg1, arg2, *args, *[, key=func]) -> value\n\nWith a single iterable argument, return its biggest item. The\ndefault keyword-only argument specifies an object to return if\nthe provided iterable is empty.\nWith two or more positional arguments, return the largest argument.",
    "builtins.memory_iterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.memory_iterator.__eq__" => "Return self==value.",
    "builtins.memory_iterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.memory_iterator.__ge__" => "Return self>=value.",
    "builtins.memory_iterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.memory_iterator.__getstate__" => "Helper for pickle.",
    "builtins.memory_iterator.__gt__" => "Return self>value.",
    "builtins.memory_iterator.__hash__" => "Return hash(self).",
    "builtins.memory_iterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.memory_iterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.memory_iterator.__iter__" => "Implement iter(self).",
    "builtins.memory_iterator.__le__" => "Return self<=value.",
    "builtins.memory_iterator.__lt__" => "Return self<value.",
    "builtins.memory_iterator.__ne__" => "Return self!=value.",
    "builtins.memory_iterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.memory_iterator.__next__" => "Implement next(self).",
    "builtins.memory_iterator.__reduce__" => "Helper for pickle.",
    "builtins.memory_iterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.memory_iterator.__repr__" => "Return repr(self).",
    "builtins.memory_iterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.memory_iterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.memory_iterator.__str__" => "Return str(self).",
    "builtins.memory_iterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.memoryview" => "Create a new memoryview object which references the given object.",
    "builtins.memoryview.__buffer__" => "Return a buffer object that exposes the underlying memory of the object.",
    "builtins.memoryview.__delattr__" => "Implement delattr(self, name).",
    "builtins.memoryview.__delitem__" => "Delete self[key].",
    "builtins.memoryview.__eq__" => "Return self==value.",
    "builtins.memoryview.__exit__" => "Release the underlying buffer exposed by the memoryview object.",
    "builtins.memoryview.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.memoryview.__ge__" => "Return self>=value.",
    "builtins.memoryview.__getattribute__" => "Return getattr(self, name).",
    "builtins.memoryview.__getitem__" => "Return self[key].",
    "builtins.memoryview.__getstate__" => "Helper for pickle.",
    "builtins.memoryview.__gt__" => "Return self>value.",
    "builtins.memoryview.__hash__" => "Return hash(self).",
    "builtins.memoryview.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.memoryview.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.memoryview.__iter__" => "Implement iter(self).",
    "builtins.memoryview.__le__" => "Return self<=value.",
    "builtins.memoryview.__len__" => "Return len(self).",
    "builtins.memoryview.__lt__" => "Return self<value.",
    "builtins.memoryview.__ne__" => "Return self!=value.",
    "builtins.memoryview.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.memoryview.__reduce__" => "Helper for pickle.",
    "builtins.memoryview.__reduce_ex__" => "Helper for pickle.",
    "builtins.memoryview.__release_buffer__" => "Release the buffer object that exposes the underlying memory of the object.",
    "builtins.memoryview.__repr__" => "Return repr(self).",
    "builtins.memoryview.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.memoryview.__setitem__" => "Set self[key] to value.",
    "builtins.memoryview.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.memoryview.__str__" => "Return str(self).",
    "builtins.memoryview.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.memoryview._from_flags" => "Create a new memoryview object which references the given object.",
    "builtins.memoryview.c_contiguous" => "A bool indicating whether the memory is C contiguous.",
    "builtins.memoryview.cast" => "Cast a memoryview to a new format or shape.",
    "builtins.memoryview.contiguous" => "A bool indicating whether the memory is contiguous.",
    "builtins.memoryview.f_contiguous" => "A bool indicating whether the memory is Fortran contiguous.",
    "builtins.memoryview.format" => "A string containing the format (in struct module style)\nfor each element in the view.",
    "builtins.memoryview.hex" => "Return the data in the buffer as a str of hexadecimal numbers.\n\n  sep\n    An optional single character or byte to separate hex bytes.\n  bytes_per_sep\n    How many bytes between separators.  Positive values count from the\n    right, negative values count from the left.\n\nExample:\n>>> value = memoryview(b'\\xb9\\x01\\xef')\n>>> value.hex()\n'b901ef'\n>>> value.hex(':')\n'b9:01:ef'\n>>> value.hex(':', 2)\n'b9:01ef'\n>>> value.hex(':', -2)\n'b901:ef'",
    "builtins.memoryview.itemsize" => "The size in bytes of each element of the memoryview.",
    "builtins.memoryview.nbytes" => "The amount of space in bytes that the array would use in\na contiguous representation.",
    "builtins.memoryview.ndim" => "An integer indicating how many dimensions of a multi-dimensional\narray the memory represents.",
    "builtins.memoryview.obj" => "The underlying object of the memoryview.",
    "builtins.memoryview.readonly" => "A bool indicating whether the memory is read only.",
    "builtins.memoryview.release" => "Release the underlying buffer exposed by the memoryview object.",
    "builtins.memoryview.shape" => "A tuple of ndim integers giving the shape of the memory\nas an N-dimensional array.",
    "builtins.memoryview.strides" => "A tuple of ndim integers giving the size in bytes to access\neach element for each dimension of the array.",
    "builtins.memoryview.suboffsets" => "A tuple of integers used internally for PIL-style arrays.",
    "builtins.memoryview.tobytes" => "Return the data in the buffer as a byte string.\n\nOrder can be {'C', 'F', 'A'}. When order is 'C' or 'F', the data of the\noriginal array is converted to C or Fortran order. For contiguous views,\n'A' returns an exact copy of the physical memory. In particular, in-memory\nFortran order is preserved. For non-contiguous views, the data is converted\nto C first. order=None is the same as order='C'.",
    "builtins.memoryview.tolist" => "Return the data in the buffer as a list of elements.",
    "builtins.memoryview.toreadonly" => "Return a readonly version of the memoryview.",
    "builtins.min" => "min(iterable, *[, default=obj, key=func]) -> value\nmin(arg1, arg2, *args, *[, key=func]) -> value\n\nWith a single iterable argument, return its smallest item. The\ndefault keyword-only argument specifies an object to return if\nthe provided iterable is empty.\nWith two or more positional arguments, return the smallest argument.",
    "builtins.next" => "next(iterator[, default])\n\nReturn the next item from the iterator. If default is given and the iterator\nis exhausted, it is returned instead of raising StopIteration.",
    "builtins.object" => "The base class of the class hierarchy.\n\nWhen called, it accepts no arguments and returns a new featureless\ninstance that has no instance attributes and cannot be given any.",
    "builtins.object.__delattr__" => "Implement delattr(self, name).",
    "builtins.object.__eq__" => "Return self==value.",
    "builtins.object.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.object.__ge__" => "Return self>=value.",
    "builtins.object.__getattribute__" => "Return getattr(self, name).",
    "builtins.object.__getstate__" => "Helper for pickle.",
    "builtins.object.__gt__" => "Return self>value.",
    "builtins.object.__hash__" => "Return hash(self).",
    "builtins.object.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.object.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.object.__le__" => "Return self<=value.",
    "builtins.object.__lt__" => "Return self<value.",
    "builtins.object.__ne__" => "Return self!=value.",
    "builtins.object.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.object.__reduce__" => "Helper for pickle.",
    "builtins.object.__reduce_ex__" => "Helper for pickle.",
    "builtins.object.__repr__" => "Return repr(self).",
    "builtins.object.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.object.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.object.__str__" => "Return str(self).",
    "builtins.object.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.oct" => "Return the octal representation of an integer.\n\n>>> oct(342391)\n'0o1234567'",
    "builtins.ord" => "Return the ordinal value of a character.\n\nIf the argument is a one-character string, return the Unicode code\npoint of that character.\n\nIf the argument is a bytes or bytearray object of length 1, return its\nsingle byte value.",
    "builtins.pow" => "Equivalent to base**exp with 2 arguments or base**exp % mod with 3 arguments\n\nSome types, such as ints, are able to use a more efficient algorithm when\ninvoked using the three argument form.",
    "builtins.print" => "Prints the values to a stream, or to sys.stdout by default.\n\nsep\n  string inserted between values, default a space.\nend\n  string appended after the last value, default a newline.\nfile\n  a file-like object (stream); defaults to the current sys.stdout.\nflush\n  whether to forcibly flush the stream.",
    "builtins.property" => "Property attribute.\n\n  fget\n    function to be used for getting an attribute value\n  fset\n    function to be used for setting an attribute value\n  fdel\n    function to be used for del'ing an attribute\n  doc\n    docstring\n\nTypical use is to define a managed attribute x:\n\nclass C(object):\n    def getx(self): return self._x\n    def setx(self, value): self._x = value\n    def delx(self): del self._x\n    x = property(getx, setx, delx, \"I'm the 'x' property.\")\n\nDecorators make defining new properties or modifying existing ones easy:\n\nclass C(object):\n    @property\n    def x(self):\n        \"I am the 'x' property.\"\n        return self._x\n    @x.setter\n    def x(self, value):\n        self._x = value\n    @x.deleter\n    def x(self):\n        del self._x",
    "builtins.property.__delattr__" => "Implement delattr(self, name).",
    "builtins.property.__delete__" => "Delete an attribute of instance.",
    "builtins.property.__eq__" => "Return self==value.",
    "builtins.property.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.property.__ge__" => "Return self>=value.",
    "builtins.property.__get__" => "Return an attribute of instance, which is of type owner.",
    "builtins.property.__getattribute__" => "Return getattr(self, name).",
    "builtins.property.__getstate__" => "Helper for pickle.",
    "builtins.property.__gt__" => "Return self>value.",
    "builtins.property.__hash__" => "Return hash(self).",
    "builtins.property.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.property.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.property.__le__" => "Return self<=value.",
    "builtins.property.__lt__" => "Return self<value.",
    "builtins.property.__ne__" => "Return self!=value.",
    "builtins.property.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.property.__reduce__" => "Helper for pickle.",
    "builtins.property.__reduce_ex__" => "Helper for pickle.",
    "builtins.property.__repr__" => "Return repr(self).",
    "builtins.property.__set__" => "Set an attribute of instance to value.",
    "builtins.property.__set_name__" => "Method to set name of a property.",
    "builtins.property.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.property.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.property.__str__" => "Return str(self).",
    "builtins.property.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.property.deleter" => "Descriptor to obtain a copy of the property with a different deleter.",
    "builtins.property.getter" => "Descriptor to obtain a copy of the property with a different getter.",
    "builtins.property.setter" => "Descriptor to obtain a copy of the property with a different setter.",
    "builtins.range" => "range(stop) -> range object\nrange(start, stop[, step]) -> range object\n\nReturn an object that produces a sequence of integers from start (inclusive)\nto stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.\nstart defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.\nThese are exactly the valid indices for a list of 4 elements.\nWhen step is given, it specifies the increment (or decrement).",
    "builtins.range.__bool__" => "True if self else False",
    "builtins.range.__contains__" => "Return bool(key in self).",
    "builtins.range.__delattr__" => "Implement delattr(self, name).",
    "builtins.range.__eq__" => "Return self==value.",
    "builtins.range.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.range.__ge__" => "Return self>=value.",
    "builtins.range.__getattribute__" => "Return getattr(self, name).",
    "builtins.range.__getitem__" => "Return self[key].",
    "builtins.range.__getstate__" => "Helper for pickle.",
    "builtins.range.__gt__" => "Return self>value.",
    "builtins.range.__hash__" => "Return hash(self).",
    "builtins.range.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.range.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.range.__iter__" => "Implement iter(self).",
    "builtins.range.__le__" => "Return self<=value.",
    "builtins.range.__len__" => "Return len(self).",
    "builtins.range.__lt__" => "Return self<value.",
    "builtins.range.__ne__" => "Return self!=value.",
    "builtins.range.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.range.__reduce_ex__" => "Helper for pickle.",
    "builtins.range.__repr__" => "Return repr(self).",
    "builtins.range.__reversed__" => "Return a reverse iterator.",
    "builtins.range.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.range.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.range.__str__" => "Return str(self).",
    "builtins.range.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.range.count" => "rangeobject.count(value) -> integer -- return number of occurrences of value",
    "builtins.range.index" => "rangeobject.index(value) -> integer -- return index of value.\nRaise ValueError if the value is not present.",
    "builtins.range_iterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.range_iterator.__eq__" => "Return self==value.",
    "builtins.range_iterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.range_iterator.__ge__" => "Return self>=value.",
    "builtins.range_iterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.range_iterator.__getstate__" => "Helper for pickle.",
    "builtins.range_iterator.__gt__" => "Return self>value.",
    "builtins.range_iterator.__hash__" => "Return hash(self).",
    "builtins.range_iterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.range_iterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.range_iterator.__iter__" => "Implement iter(self).",
    "builtins.range_iterator.__le__" => "Return self<=value.",
    "builtins.range_iterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.range_iterator.__lt__" => "Return self<value.",
    "builtins.range_iterator.__ne__" => "Return self!=value.",
    "builtins.range_iterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.range_iterator.__next__" => "Implement next(self).",
    "builtins.range_iterator.__reduce__" => "Return state information for pickling.",
    "builtins.range_iterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.range_iterator.__repr__" => "Return repr(self).",
    "builtins.range_iterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.range_iterator.__setstate__" => "Set state information for unpickling.",
    "builtins.range_iterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.range_iterator.__str__" => "Return str(self).",
    "builtins.range_iterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.repr" => "Return the canonical string representation of the object.\n\nFor many object types, including most builtins, eval(repr(obj)) == obj.",
    "builtins.reversed" => "Return a reverse iterator over the values of the given sequence.",
    "builtins.reversed.__delattr__" => "Implement delattr(self, name).",
    "builtins.reversed.__eq__" => "Return self==value.",
    "builtins.reversed.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.reversed.__ge__" => "Return self>=value.",
    "builtins.reversed.__getattribute__" => "Return getattr(self, name).",
    "builtins.reversed.__getstate__" => "Helper for pickle.",
    "builtins.reversed.__gt__" => "Return self>value.",
    "builtins.reversed.__hash__" => "Return hash(self).",
    "builtins.reversed.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.reversed.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.reversed.__iter__" => "Implement iter(self).",
    "builtins.reversed.__le__" => "Return self<=value.",
    "builtins.reversed.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.reversed.__lt__" => "Return self<value.",
    "builtins.reversed.__ne__" => "Return self!=value.",
    "builtins.reversed.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.reversed.__next__" => "Implement next(self).",
    "builtins.reversed.__reduce__" => "Return state information for pickling.",
    "builtins.reversed.__reduce_ex__" => "Helper for pickle.",
    "builtins.reversed.__repr__" => "Return repr(self).",
    "builtins.reversed.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.reversed.__setstate__" => "Set state information for unpickling.",
    "builtins.reversed.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.reversed.__str__" => "Return str(self).",
    "builtins.reversed.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.round" => "Round a number to a given precision in decimal digits.\n\nThe return value is an integer if ndigits is omitted or None.  Otherwise\nthe return value has the same type as the number.  ndigits may be negative.",
    "builtins.set" => "Build an unordered collection of unique elements.",
    "builtins.set.__and__" => "Return self&value.",
    "builtins.set.__class_getitem__" => "See PEP 585",
    "builtins.set.__contains__" => "x.__contains__(y) <==> y in x.",
    "builtins.set.__delattr__" => "Implement delattr(self, name).",
    "builtins.set.__eq__" => "Return self==value.",
    "builtins.set.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.set.__ge__" => "Return self>=value.",
    "builtins.set.__getattribute__" => "Return getattr(self, name).",
    "builtins.set.__getstate__" => "Helper for pickle.",
    "builtins.set.__gt__" => "Return self>value.",
    "builtins.set.__iand__" => "Return self&=value.",
    "builtins.set.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.set.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.set.__ior__" => "Return self|=value.",
    "builtins.set.__isub__" => "Return self-=value.",
    "builtins.set.__iter__" => "Implement iter(self).",
    "builtins.set.__ixor__" => "Return self^=value.",
    "builtins.set.__le__" => "Return self<=value.",
    "builtins.set.__len__" => "Return len(self).",
    "builtins.set.__lt__" => "Return self<value.",
    "builtins.set.__ne__" => "Return self!=value.",
    "builtins.set.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.set.__or__" => "Return self|value.",
    "builtins.set.__rand__" => "Return value&self.",
    "builtins.set.__reduce__" => "Return state information for pickling.",
    "builtins.set.__reduce_ex__" => "Helper for pickle.",
    "builtins.set.__repr__" => "Return repr(self).",
    "builtins.set.__ror__" => "Return value|self.",
    "builtins.set.__rsub__" => "Return value-self.",
    "builtins.set.__rxor__" => "Return value^self.",
    "builtins.set.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.set.__sizeof__" => "S.__sizeof__() -> size of S in memory, in bytes.",
    "builtins.set.__str__" => "Return str(self).",
    "builtins.set.__sub__" => "Return self-value.",
    "builtins.set.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.set.__xor__" => "Return self^value.",
    "builtins.set.add" => "Add an element to a set.\n\nThis has no effect if the element is already present.",
    "builtins.set.clear" => "Remove all elements from this set.",
    "builtins.set.copy" => "Return a shallow copy of a set.",
    "builtins.set.difference" => "Return a new set with elements in the set that are not in the others.",
    "builtins.set.difference_update" => "Update the set, removing elements found in others.",
    "builtins.set.discard" => "Remove an element from a set if it is a member.\n\nUnlike set.remove(), the discard() method does not raise\nan exception when an element is missing from the set.",
    "builtins.set.intersection" => "Return a new set with elements common to the set and all others.",
    "builtins.set.intersection_update" => "Update the set, keeping only elements found in it and all others.",
    "builtins.set.isdisjoint" => "Return True if two sets have a null intersection.",
    "builtins.set.issubset" => "Report whether another set contains this set.",
    "builtins.set.issuperset" => "Report whether this set contains another set.",
    "builtins.set.pop" => "Remove and return an arbitrary set element.\n\nRaises KeyError if the set is empty.",
    "builtins.set.remove" => "Remove an element from a set; it must be a member.\n\nIf the element is not a member, raise a KeyError.",
    "builtins.set.symmetric_difference" => "Return a new set with elements in either the set or other but not both.",
    "builtins.set.symmetric_difference_update" => "Update the set, keeping only elements found in either set, but not in both.",
    "builtins.set.union" => "Return a new set with elements from the set and all others.",
    "builtins.set.update" => "Update the set, adding elements from all others.",
    "builtins.set_iterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.set_iterator.__eq__" => "Return self==value.",
    "builtins.set_iterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.set_iterator.__ge__" => "Return self>=value.",
    "builtins.set_iterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.set_iterator.__getstate__" => "Helper for pickle.",
    "builtins.set_iterator.__gt__" => "Return self>value.",
    "builtins.set_iterator.__hash__" => "Return hash(self).",
    "builtins.set_iterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.set_iterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.set_iterator.__iter__" => "Implement iter(self).",
    "builtins.set_iterator.__le__" => "Return self<=value.",
    "builtins.set_iterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.set_iterator.__lt__" => "Return self<value.",
    "builtins.set_iterator.__ne__" => "Return self!=value.",
    "builtins.set_iterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.set_iterator.__next__" => "Implement next(self).",
    "builtins.set_iterator.__reduce__" => "Return state information for pickling.",
    "builtins.set_iterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.set_iterator.__repr__" => "Return repr(self).",
    "builtins.set_iterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.set_iterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.set_iterator.__str__" => "Return str(self).",
    "builtins.set_iterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.setattr" => "Sets the named attribute on the given object to the specified value.\n\nsetattr(x, 'y', v) is equivalent to ``x.y = v``",
    "builtins.slice" => "slice(stop)\nslice(start, stop[, step])\n\nCreate a slice object.  This is used for extended slicing (e.g. a[0:10:2]).",
    "builtins.slice.__delattr__" => "Implement delattr(self, name).",
    "builtins.slice.__eq__" => "Return self==value.",
    "builtins.slice.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.slice.__ge__" => "Return self>=value.",
    "builtins.slice.__getattribute__" => "Return getattr(self, name).",
    "builtins.slice.__getstate__" => "Helper for pickle.",
    "builtins.slice.__gt__" => "Return self>value.",
    "builtins.slice.__hash__" => "Return hash(self).",
    "builtins.slice.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.slice.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.slice.__le__" => "Return self<=value.",
    "builtins.slice.__lt__" => "Return self<value.",
    "builtins.slice.__ne__" => "Return self!=value.",
    "builtins.slice.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.slice.__reduce__" => "Return state information for pickling.",
    "builtins.slice.__reduce_ex__" => "Helper for pickle.",
    "builtins.slice.__repr__" => "Return repr(self).",
    "builtins.slice.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.slice.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.slice.__str__" => "Return str(self).",
    "builtins.slice.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.slice.indices" => "S.indices(len) -> (start, stop, stride)\n\nAssuming a sequence of length len, calculate the start and stop\nindices, and the stride length of the extended slice described by\nS. Out of bounds indices are clipped in a manner consistent with the\nhandling of normal slices.",
    "builtins.sorted" => "Return a new list containing all items from the iterable in ascending order.\n\nA custom key function can be supplied to customize the sort order, and the\nreverse flag can be set to request the result in descending order.",
    "builtins.staticmethod" => "Convert a function to be a static method.\n\nA static method does not receive an implicit first argument.\nTo declare a static method, use this idiom:\n\n     class C:\n         @staticmethod\n         def f(arg1, arg2, argN):\n             ...\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()). Both the class and the instance are ignored, and\nneither is passed implicitly as the first argument to the method.\n\nStatic methods in Python are similar to those found in Java or C++.\nFor a more advanced concept, see the classmethod builtin.",
    "builtins.staticmethod.__call__" => "Call self as a function.",
    "builtins.staticmethod.__delattr__" => "Implement delattr(self, name).",
    "builtins.staticmethod.__eq__" => "Return self==value.",
    "builtins.staticmethod.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.staticmethod.__ge__" => "Return self>=value.",
    "builtins.staticmethod.__get__" => "Return an attribute of instance, which is of type owner.",
    "builtins.staticmethod.__getattribute__" => "Return getattr(self, name).",
    "builtins.staticmethod.__getstate__" => "Helper for pickle.",
    "builtins.staticmethod.__gt__" => "Return self>value.",
    "builtins.staticmethod.__hash__" => "Return hash(self).",
    "builtins.staticmethod.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.staticmethod.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.staticmethod.__le__" => "Return self<=value.",
    "builtins.staticmethod.__lt__" => "Return self<value.",
    "builtins.staticmethod.__ne__" => "Return self!=value.",
    "builtins.staticmethod.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.staticmethod.__reduce__" => "Helper for pickle.",
    "builtins.staticmethod.__reduce_ex__" => "Helper for pickle.",
    "builtins.staticmethod.__repr__" => "Return repr(self).",
    "builtins.staticmethod.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.staticmethod.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.staticmethod.__str__" => "Return str(self).",
    "builtins.staticmethod.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.str" => "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to 'utf-8'.\nerrors defaults to 'strict'.",
    "builtins.str.__add__" => "Return self+value.",
    "builtins.str.__contains__" => "Return bool(key in self).",
    "builtins.str.__delattr__" => "Implement delattr(self, name).",
    "builtins.str.__eq__" => "Return self==value.",
    "builtins.str.__format__" => "Return a formatted version of the string as described by format_spec.",
    "builtins.str.__ge__" => "Return self>=value.",
    "builtins.str.__getattribute__" => "Return getattr(self, name).",
    "builtins.str.__getitem__" => "Return self[key].",
    "builtins.str.__getstate__" => "Helper for pickle.",
    "builtins.str.__gt__" => "Return self>value.",
    "builtins.str.__hash__" => "Return hash(self).",
    "builtins.str.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.str.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.str.__iter__" => "Implement iter(self).",
    "builtins.str.__le__" => "Return self<=value.",
    "builtins.str.__len__" => "Return len(self).",
    "builtins.str.__lt__" => "Return self<value.",
    "builtins.str.__mod__" => "Return self%value.",
    "builtins.str.__mul__" => "Return self*value.",
    "builtins.str.__ne__" => "Return self!=value.",
    "builtins.str.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.str.__reduce__" => "Helper for pickle.",
    "builtins.str.__reduce_ex__" => "Helper for pickle.",
    "builtins.str.__repr__" => "Return repr(self).",
    "builtins.str.__rmod__" => "Return value%self.",
    "builtins.str.__rmul__" => "Return value*self.",
    "builtins.str.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.str.__sizeof__" => "Return the size of the string in memory, in bytes.",
    "builtins.str.__str__" => "Return str(self).",
    "builtins.str.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.str.capitalize" => "Return a capitalized version of the string.\n\nMore specifically, make the first character have upper case and the rest lower\ncase.",
    "builtins.str.casefold" => "Return a version of the string suitable for caseless comparisons.",
    "builtins.str.center" => "Return a centered string of length width.\n\nPadding is done using the specified fill character (default is a space).",
    "builtins.str.count" => "Return the number of non-overlapping occurrences of substring sub in string S[start:end].\n\nOptional arguments start and end are interpreted as in slice notation.",
    "builtins.str.encode" => "Encode the string using the codec registered for encoding.\n\nencoding\n  The encoding in which to encode the string.\nerrors\n  The error handling scheme to use for encoding errors.\n  The default is 'strict' meaning that encoding errors raise a\n  UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and\n  'xmlcharrefreplace' as well as any other name registered with\n  codecs.register_error that can handle UnicodeEncodeErrors.",
    "builtins.str.endswith" => "Return True if the string ends with the specified suffix, False otherwise.\n\nsuffix\n  A string or a tuple of strings to try.\nstart\n  Optional start position. Default: start of the string.\nend\n  Optional stop position. Default: end of the string.",
    "builtins.str.expandtabs" => "Return a copy where all tab characters are expanded using spaces.\n\nIf tabsize is not given, a tab size of 8 characters is assumed.",
    "builtins.str.find" => "Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end].\n\nOptional arguments start and end are interpreted as in slice notation.\nReturn -1 on failure.",
    "builtins.str.format" => "Return a formatted version of the string, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').",
    "builtins.str.format_map" => "Return a formatted version of the string, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').",
    "builtins.str.index" => "Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end].\n\nOptional arguments start and end are interpreted as in slice notation.\nRaises ValueError when the substring is not found.",
    "builtins.str.isalnum" => "Return True if the string is an alpha-numeric string, False otherwise.\n\nA string is alpha-numeric if all characters in the string are alpha-numeric and\nthere is at least one character in the string.",
    "builtins.str.isalpha" => "Return True if the string is an alphabetic string, False otherwise.\n\nA string is alphabetic if all characters in the string are alphabetic and there\nis at least one character in the string.",
    "builtins.str.isascii" => "Return True if all characters in the string are ASCII, False otherwise.\n\nASCII characters have code points in the range U+0000-U+007F.\nEmpty string is ASCII too.",
    "builtins.str.isdecimal" => "Return True if the string is a decimal string, False otherwise.\n\nA string is a decimal string if all characters in the string are decimal and\nthere is at least one character in the string.",
    "builtins.str.isdigit" => "Return True if the string is a digit string, False otherwise.\n\nA string is a digit string if all characters in the string are digits and there\nis at least one character in the string.",
    "builtins.str.isidentifier" => "Return True if the string is a valid Python identifier, False otherwise.\n\nCall keyword.iskeyword(s) to test whether string s is a reserved identifier,\nsuch as \"def\" or \"class\".",
    "builtins.str.islower" => "Return True if the string is a lowercase string, False otherwise.\n\nA string is lowercase if all cased characters in the string are lowercase and\nthere is at least one cased character in the string.",
    "builtins.str.isnumeric" => "Return True if the string is a numeric string, False otherwise.\n\nA string is numeric if all characters in the string are numeric and there is at\nleast one character in the string.",
    "builtins.str.isprintable" => "Return True if all characters in the string are printable, False otherwise.\n\nA character is printable if repr() may use it in its output.",
    "builtins.str.isspace" => "Return True if the string is a whitespace string, False otherwise.\n\nA string is whitespace if all characters in the string are whitespace and there\nis at least one character in the string.",
    "builtins.str.istitle" => "Return True if the string is a title-cased string, False otherwise.\n\nIn a title-cased string, upper- and title-case characters may only\nfollow uncased characters and lowercase characters only cased ones.",
    "builtins.str.isupper" => "Return True if the string is an uppercase string, False otherwise.\n\nA string is uppercase if all cased characters in the string are uppercase and\nthere is at least one cased character in the string.",
    "builtins.str.join" => "Concatenate any number of strings.\n\nThe string whose method is called is inserted in between each given string.\nThe result is returned as a new string.\n\nExample: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'",
    "builtins.str.ljust" => "Return a left-justified string of length width.\n\nPadding is done using the specified fill character (default is a space).",
    "builtins.str.lower" => "Return a copy of the string converted to lowercase.",
    "builtins.str.lstrip" => "Return a copy of the string with leading whitespace removed.\n\nIf chars is given and not None, remove characters in chars instead.",
    "builtins.str.maketrans" => "Return a translation table usable for str.translate().\n\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.",
    "builtins.str.partition" => "Partition the string into three parts using the given separator.\n\nThis will search for the separator in the string.  If the separator is found,\nreturns a 3-tuple containing the part before the separator, the separator\nitself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing the original string\nand two empty strings.",
    "builtins.str.removeprefix" => "Return a str with the given prefix string removed if present.\n\nIf the string starts with the prefix string, return string[len(prefix):].\nOtherwise, return a copy of the original string.",
    "builtins.str.removesuffix" => "Return a str with the given suffix string removed if present.\n\nIf the string ends with the suffix string and that suffix is not empty,\nreturn string[:-len(suffix)]. Otherwise, return a copy of the original\nstring.",
    "builtins.str.replace" => "Return a copy with all occurrences of substring old replaced by new.\n\n  count\n    Maximum number of occurrences to replace.\n    -1 (the default value) means replace all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplaced.",
    "builtins.str.rfind" => "Return the highest index in S where substring sub is found, such that sub is contained within S[start:end].\n\nOptional arguments start and end are interpreted as in slice notation.\nReturn -1 on failure.",
    "builtins.str.rindex" => "Return the highest index in S where substring sub is found, such that sub is contained within S[start:end].\n\nOptional arguments start and end are interpreted as in slice notation.\nRaises ValueError when the substring is not found.",
    "builtins.str.rjust" => "Return a right-justified string of length width.\n\nPadding is done using the specified fill character (default is a space).",
    "builtins.str.rpartition" => "Partition the string into three parts using the given separator.\n\nThis will search for the separator in the string, starting at the end. If\nthe separator is found, returns a 3-tuple containing the part before the\nseparator, the separator itself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing two empty strings\nand the original string.",
    "builtins.str.rsplit" => "Return a list of the substrings in the string, using sep as the separator string.\n\n  sep\n    The separator used to split the string.\n\n    When set to None (the default value), will split on any whitespace\n    character (including \\n \\r \\t \\f and spaces) and will discard\n    empty strings from the result.\n  maxsplit\n    Maximum number of splits.\n    -1 (the default value) means no limit.\n\nSplitting starts at the end of the string and works to the front.",
    "builtins.str.rstrip" => "Return a copy of the string with trailing whitespace removed.\n\nIf chars is given and not None, remove characters in chars instead.",
    "builtins.str.split" => "Return a list of the substrings in the string, using sep as the separator string.\n\n  sep\n    The separator used to split the string.\n\n    When set to None (the default value), will split on any whitespace\n    character (including \\n \\r \\t \\f and spaces) and will discard\n    empty strings from the result.\n  maxsplit\n    Maximum number of splits.\n    -1 (the default value) means no limit.\n\nSplitting starts at the front of the string and works to the end.\n\nNote, str.split() is mainly useful for data that has been intentionally\ndelimited.  With natural text that includes punctuation, consider using\nthe regular expression module.",
    "builtins.str.splitlines" => "Return a list of the lines in the string, breaking at line boundaries.\n\nLine breaks are not included in the resulting list unless keepends is given and\ntrue.",
    "builtins.str.startswith" => "Return True if the string starts with the specified prefix, False otherwise.\n\nprefix\n  A string or a tuple of strings to try.\nstart\n  Optional start position. Default: start of the string.\nend\n  Optional stop position. Default: end of the string.",
    "builtins.str.strip" => "Return a copy of the string with leading and trailing whitespace removed.\n\nIf chars is given and not None, remove characters in chars instead.",
    "builtins.str.swapcase" => "Convert uppercase characters to lowercase and lowercase characters to uppercase.",
    "builtins.str.title" => "Return a version of the string where each word is titlecased.\n\nMore specifically, words start with uppercased characters and all remaining\ncased characters have lower case.",
    "builtins.str.translate" => "Replace each character in the string using the given translation table.\n\n  table\n    Translation table, which must be a mapping of Unicode ordinals to\n    Unicode ordinals, strings, or None.\n\nThe table must implement lookup/indexing via __getitem__, for instance a\ndictionary or list.  If this operation raises LookupError, the character is\nleft untouched.  Characters mapped to None are deleted.",
    "builtins.str.upper" => "Return a copy of the string converted to uppercase.",
    "builtins.str.zfill" => "Pad a numeric string with zeros on the left, to fill a field of the given width.\n\nThe string is never truncated.",
    "builtins.str_ascii_iterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.str_ascii_iterator.__eq__" => "Return self==value.",
    "builtins.str_ascii_iterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.str_ascii_iterator.__ge__" => "Return self>=value.",
    "builtins.str_ascii_iterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.str_ascii_iterator.__getstate__" => "Helper for pickle.",
    "builtins.str_ascii_iterator.__gt__" => "Return self>value.",
    "builtins.str_ascii_iterator.__hash__" => "Return hash(self).",
    "builtins.str_ascii_iterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.str_ascii_iterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.str_ascii_iterator.__iter__" => "Implement iter(self).",
    "builtins.str_ascii_iterator.__le__" => "Return self<=value.",
    "builtins.str_ascii_iterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.str_ascii_iterator.__lt__" => "Return self<value.",
    "builtins.str_ascii_iterator.__ne__" => "Return self!=value.",
    "builtins.str_ascii_iterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.str_ascii_iterator.__next__" => "Implement next(self).",
    "builtins.str_ascii_iterator.__reduce__" => "Return state information for pickling.",
    "builtins.str_ascii_iterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.str_ascii_iterator.__repr__" => "Return repr(self).",
    "builtins.str_ascii_iterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.str_ascii_iterator.__setstate__" => "Set state information for unpickling.",
    "builtins.str_ascii_iterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.str_ascii_iterator.__str__" => "Return str(self).",
    "builtins.str_ascii_iterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.sum" => "Return the sum of a 'start' value (default: 0) plus an iterable of numbers\n\nWhen the iterable is empty, return the start value.\nThis function is intended specifically for use with numeric values and may\nreject non-numeric types.",
    "builtins.super" => "super() -> same as super(__class__, <first argument>)\nsuper(type) -> unbound super object\nsuper(type, obj) -> bound super object; requires isinstance(obj, type)\nsuper(type, type2) -> bound super object; requires issubclass(type2, type)\nTypical use to call a cooperative superclass method:\nclass C(B):\n    def meth(self, arg):\n        super().meth(arg)\nThis works for class methods too:\nclass C(B):\n    @classmethod\n    def cmeth(cls, arg):\n        super().cmeth(arg)",
    "builtins.super.__delattr__" => "Implement delattr(self, name).",
    "builtins.super.__eq__" => "Return self==value.",
    "builtins.super.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.super.__ge__" => "Return self>=value.",
    "builtins.super.__get__" => "Return an attribute of instance, which is of type owner.",
    "builtins.super.__getattribute__" => "Return getattr(self, name).",
    "builtins.super.__getstate__" => "Helper for pickle.",
    "builtins.super.__gt__" => "Return self>value.",
    "builtins.super.__hash__" => "Return hash(self).",
    "builtins.super.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.super.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.super.__le__" => "Return self<=value.",
    "builtins.super.__lt__" => "Return self<value.",
    "builtins.super.__ne__" => "Return self!=value.",
    "builtins.super.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.super.__reduce__" => "Helper for pickle.",
    "builtins.super.__reduce_ex__" => "Helper for pickle.",
    "builtins.super.__repr__" => "Return repr(self).",
    "builtins.super.__self__" => "the instance invoking super(); may be None",
    "builtins.super.__self_class__" => "the type of the instance invoking super(); may be None",
    "builtins.super.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.super.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.super.__str__" => "Return str(self).",
    "builtins.super.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.super.__thisclass__" => "the class invoking super()",
    "builtins.tuple" => "Built-in immutable sequence.\n\nIf no argument is given, the constructor returns an empty tuple.\nIf iterable is specified the tuple is initialized from iterable's items.\n\nIf the argument is a tuple, the return value is the same object.",
    "builtins.tuple.__add__" => "Return self+value.",
    "builtins.tuple.__class_getitem__" => "See PEP 585",
    "builtins.tuple.__contains__" => "Return bool(key in self).",
    "builtins.tuple.__delattr__" => "Implement delattr(self, name).",
    "builtins.tuple.__eq__" => "Return self==value.",
    "builtins.tuple.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.tuple.__ge__" => "Return self>=value.",
    "builtins.tuple.__getattribute__" => "Return getattr(self, name).",
    "builtins.tuple.__getitem__" => "Return self[key].",
    "builtins.tuple.__getstate__" => "Helper for pickle.",
    "builtins.tuple.__gt__" => "Return self>value.",
    "builtins.tuple.__hash__" => "Return hash(self).",
    "builtins.tuple.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.tuple.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.tuple.__iter__" => "Implement iter(self).",
    "builtins.tuple.__le__" => "Return self<=value.",
    "builtins.tuple.__len__" => "Return len(self).",
    "builtins.tuple.__lt__" => "Return self<value.",
    "builtins.tuple.__mul__" => "Return self*value.",
    "builtins.tuple.__ne__" => "Return self!=value.",
    "builtins.tuple.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.tuple.__reduce__" => "Helper for pickle.",
    "builtins.tuple.__reduce_ex__" => "Helper for pickle.",
    "builtins.tuple.__repr__" => "Return repr(self).",
    "builtins.tuple.__rmul__" => "Return value*self.",
    "builtins.tuple.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.tuple.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.tuple.__str__" => "Return str(self).",
    "builtins.tuple.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.tuple.count" => "Return number of occurrences of value.",
    "builtins.tuple.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "builtins.tuple_iterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.tuple_iterator.__eq__" => "Return self==value.",
    "builtins.tuple_iterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.tuple_iterator.__ge__" => "Return self>=value.",
    "builtins.tuple_iterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.tuple_iterator.__getstate__" => "Helper for pickle.",
    "builtins.tuple_iterator.__gt__" => "Return self>value.",
    "builtins.tuple_iterator.__hash__" => "Return hash(self).",
    "builtins.tuple_iterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.tuple_iterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.tuple_iterator.__iter__" => "Implement iter(self).",
    "builtins.tuple_iterator.__le__" => "Return self<=value.",
    "builtins.tuple_iterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.tuple_iterator.__lt__" => "Return self<value.",
    "builtins.tuple_iterator.__ne__" => "Return self!=value.",
    "builtins.tuple_iterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.tuple_iterator.__next__" => "Implement next(self).",
    "builtins.tuple_iterator.__reduce__" => "Return state information for pickling.",
    "builtins.tuple_iterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.tuple_iterator.__repr__" => "Return repr(self).",
    "builtins.tuple_iterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.tuple_iterator.__setstate__" => "Set state information for unpickling.",
    "builtins.tuple_iterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.tuple_iterator.__str__" => "Return str(self).",
    "builtins.tuple_iterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.type" => "type(object) -> the object's type\ntype(name, bases, dict, **kwds) -> a new type",
    "builtins.type.__base__" => "The base class of the class hierarchy.\n\nWhen called, it accepts no arguments and returns a new featureless\ninstance that has no instance attributes and cannot be given any.",
    "builtins.type.__base__.__delattr__" => "Implement delattr(self, name).",
    "builtins.type.__base__.__eq__" => "Return self==value.",
    "builtins.type.__base__.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.type.__base__.__ge__" => "Return self>=value.",
    "builtins.type.__base__.__getattribute__" => "Return getattr(self, name).",
    "builtins.type.__base__.__getstate__" => "Helper for pickle.",
    "builtins.type.__base__.__gt__" => "Return self>value.",
    "builtins.type.__base__.__hash__" => "Return hash(self).",
    "builtins.type.__base__.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.type.__base__.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.type.__base__.__le__" => "Return self<=value.",
    "builtins.type.__base__.__lt__" => "Return self<value.",
    "builtins.type.__base__.__ne__" => "Return self!=value.",
    "builtins.type.__base__.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.type.__base__.__reduce__" => "Helper for pickle.",
    "builtins.type.__base__.__reduce_ex__" => "Helper for pickle.",
    "builtins.type.__base__.__repr__" => "Return repr(self).",
    "builtins.type.__base__.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.type.__base__.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.type.__base__.__str__" => "Return str(self).",
    "builtins.type.__base__.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.type.__call__" => "Call self as a function.",
    "builtins.type.__delattr__" => "Implement delattr(self, name).",
    "builtins.type.__eq__" => "Return self==value.",
    "builtins.type.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.type.__ge__" => "Return self>=value.",
    "builtins.type.__getattribute__" => "Return getattr(self, name).",
    "builtins.type.__getstate__" => "Helper for pickle.",
    "builtins.type.__gt__" => "Return self>value.",
    "builtins.type.__hash__" => "Return hash(self).",
    "builtins.type.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.type.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.type.__instancecheck__" => "Check if an object is an instance.",
    "builtins.type.__le__" => "Return self<=value.",
    "builtins.type.__lt__" => "Return self<value.",
    "builtins.type.__ne__" => "Return self!=value.",
    "builtins.type.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.type.__or__" => "Return self|value.",
    "builtins.type.__prepare__" => "Create the namespace for the class statement",
    "builtins.type.__reduce__" => "Helper for pickle.",
    "builtins.type.__reduce_ex__" => "Helper for pickle.",
    "builtins.type.__repr__" => "Return repr(self).",
    "builtins.type.__ror__" => "Return value|self.",
    "builtins.type.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.type.__sizeof__" => "Return memory consumption of the type object.",
    "builtins.type.__str__" => "Return str(self).",
    "builtins.type.__subclasscheck__" => "Check if a class is a subclass.",
    "builtins.type.__subclasses__" => "Return a list of immediate subclasses.",
    "builtins.type.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.type.mro" => "Return a type's method resolution order.",
    "builtins.vars" => "vars([object]) -> dictionary\n\nWithout arguments, equivalent to locals().\nWith an argument, equivalent to object.__dict__.",
    "builtins.zip" => "The zip object yields n-length tuples, where n is the number of iterables\npassed as positional arguments to zip().  The i-th element in every tuple\ncomes from the i-th iterable argument to zip().  This continues until the\nshortest argument is exhausted.\n\nIf strict is true and one of the arguments is exhausted before the others,\nraise a ValueError.\n\n   >>> list(zip('abcdefg', range(3), range(4)))\n   [('a', 0, 0), ('b', 1, 1), ('c', 2, 2)]",
    "builtins.zip.__delattr__" => "Implement delattr(self, name).",
    "builtins.zip.__eq__" => "Return self==value.",
    "builtins.zip.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.zip.__ge__" => "Return self>=value.",
    "builtins.zip.__getattribute__" => "Return getattr(self, name).",
    "builtins.zip.__getstate__" => "Helper for pickle.",
    "builtins.zip.__gt__" => "Return self>value.",
    "builtins.zip.__hash__" => "Return hash(self).",
    "builtins.zip.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.zip.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.zip.__iter__" => "Implement iter(self).",
    "builtins.zip.__le__" => "Return self<=value.",
    "builtins.zip.__lt__" => "Return self<value.",
    "builtins.zip.__ne__" => "Return self!=value.",
    "builtins.zip.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.zip.__next__" => "Implement next(self).",
    "builtins.zip.__reduce__" => "Return state information for pickling.",
    "builtins.zip.__reduce_ex__" => "Helper for pickle.",
    "builtins.zip.__repr__" => "Return repr(self).",
    "builtins.zip.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.zip.__setstate__" => "Set state information for unpickling.",
    "builtins.zip.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.zip.__str__" => "Return str(self).",
    "builtins.zip.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "cmath" => "This module provides access to mathematical functions for complex\nnumbers.",
    "cmath.acos" => "Return the arc cosine of z.",
    "cmath.acosh" => "Return the inverse hyperbolic cosine of z.",
    "cmath.asin" => "Return the arc sine of z.",
    "cmath.asinh" => "Return the inverse hyperbolic sine of z.",
    "cmath.atan" => "Return the arc tangent of z.",
    "cmath.atanh" => "Return the inverse hyperbolic tangent of z.",
    "cmath.cos" => "Return the cosine of z.",
    "cmath.cosh" => "Return the hyperbolic cosine of z.",
    "cmath.exp" => "Return the exponential value e**z.",
    "cmath.isclose" => "Determine whether two complex numbers are close in value.\n\n  rel_tol\n    maximum difference for being considered \"close\", relative to the\n    magnitude of the input values\n  abs_tol\n    maximum difference for being considered \"close\", regardless of the\n    magnitude of the input values\n\nReturn True if a is close in value to b, and False otherwise.\n\nFor the values to be considered close, the difference between them must be\nsmaller than at least one of the tolerances.\n\n-inf, inf and NaN behave similarly to the IEEE 754 Standard. That is, NaN is\nnot close to anything, even itself. inf and -inf are only close to themselves.",
    "cmath.isfinite" => "Return True if both the real and imaginary parts of z are finite, else False.",
    "cmath.isinf" => "Checks if the real or imaginary part of z is infinite.",
    "cmath.isnan" => "Checks if the real or imaginary part of z not a number (NaN).",
    "cmath.log" => "log(z[, base]) -> the logarithm of z to the given base.\n\nIf the base is not specified, returns the natural logarithm (base e) of z.",
    "cmath.log10" => "Return the base-10 logarithm of z.",
    "cmath.phase" => "Return argument, also known as the phase angle, of a complex.",
    "cmath.polar" => "Convert a complex from rectangular coordinates to polar coordinates.\n\nr is the distance from 0 and phi the phase angle.",
    "cmath.rect" => "Convert from polar coordinates to rectangular coordinates.",
    "cmath.sin" => "Return the sine of z.",
    "cmath.sinh" => "Return the hyperbolic sine of z.",
    "cmath.sqrt" => "Return the square root of z.",
    "cmath.tan" => "Return the tangent of z.",
    "cmath.tanh" => "Return the hyperbolic tangent of z.",
    "errno" => "This module makes available standard errno system symbols.\n\nThe value of each symbol is the corresponding integer value,\ne.g., on most systems, errno.ENOENT equals the integer 2.\n\nThe dictionary errno.errorcode maps numeric codes to symbol names,\ne.g., errno.errorcode[2] could be the string 'ENOENT'.\n\nSymbols that are not relevant to the underlying system are not defined.\n\nTo map error codes to error messages, use the function os.strerror(),\ne.g. os.strerror(2) could return 'No such file or directory'.",
    "faulthandler" => "faulthandler module.",
    "faulthandler._fatal_error_c_thread" => "Call Py_FatalError() in a new C thread.",
    "faulthandler._raise_exception" => "Call RaiseException(code, flags).",
    "faulthandler._read_null" => "Read from NULL, raise a SIGSEGV or SIGBUS signal depending on the platform.",
    "faulthandler._sigabrt" => "Raise a SIGABRT signal.",
    "faulthandler._sigfpe" => "Raise a SIGFPE signal.",
    "faulthandler._sigsegv" => "Raise a SIGSEGV signal.",
    "faulthandler._stack_overflow" => "Recursive call to raise a stack overflow.",
    "faulthandler.cancel_dump_traceback_later" => "Cancel the previous call to dump_traceback_later().",
    "faulthandler.disable" => "Disable the fault handler.",
    "faulthandler.dump_traceback" => "Dump the traceback of the current thread, or of all threads if all_threads is True, into file.",
    "faulthandler.dump_traceback_later" => "Dump the traceback of all threads in timeout seconds,\nor each timeout seconds if repeat is True. If exit is True, call _exit(1) which is not safe.",
    "faulthandler.enable" => "Enable the fault handler.",
    "faulthandler.is_enabled" => "Check if the handler is enabled.",
    "faulthandler.register" => "Register a handler for the signal 'signum': dump the traceback of the current thread, or of all threads if all_threads is True, into file.",
    "faulthandler.unregister" => "Unregister the handler of the signal 'signum' registered by register().",
    "fcntl" => "This module performs file control and I/O control on file\ndescriptors.  It is an interface to the fcntl() and ioctl() Unix\nroutines.  File descriptors can be obtained with the fileno() method of\na file or socket object.",
    "fcntl.fcntl" => "Perform the operation `cmd` on file descriptor fd.\n\nThe values used for `cmd` are operating system dependent, and are available\nas constants in the fcntl module, using the same names as used in\nthe relevant C header files.  The argument arg is optional, and\ndefaults to 0; it may be an int or a string.  If arg is given as a string,\nthe return value of fcntl is a string of that length, containing the\nresulting value put in the arg buffer by the operating system.  The length\nof the arg string is not allowed to exceed 1024 bytes.  If the arg given\nis an integer or if none is specified, the result value is an integer\ncorresponding to the return value of the fcntl call in the C code.",
    "fcntl.flock" => "Perform the lock operation `operation` on file descriptor `fd`.\n\nSee the Unix manual page for flock(2) for details (On some systems, this\nfunction is emulated using fcntl()).",
    "fcntl.ioctl" => "Perform the operation `request` on file descriptor `fd`.\n\nThe values used for `request` are operating system dependent, and are available\nas constants in the fcntl or termios library modules, using the same names as\nused in the relevant C header files.\n\nThe argument `arg` is optional, and defaults to 0; it may be an int or a\nbuffer containing character data (most likely a string or an array).\n\nIf the argument is a mutable buffer (such as an array) and if the\nmutate_flag argument (which is only allowed in this case) is true then the\nbuffer is (in effect) passed to the operating system and changes made by\nthe OS will be reflected in the contents of the buffer after the call has\nreturned.  The return value is the integer returned by the ioctl system\ncall.\n\nIf the argument is a mutable buffer and the mutable_flag argument is false,\nthe behavior is as if a string had been passed.\n\nIf the argument is an immutable buffer (most likely a string) then a copy\nof the buffer is passed to the operating system and the return value is a\nstring of the same length containing whatever the operating system put in\nthe buffer.  The length of the arg buffer in this case is not allowed to\nexceed 1024 bytes.\n\nIf the arg given is an integer or if none is specified, the result value is\nan integer corresponding to the return value of the ioctl call in the C\ncode.",
    "fcntl.lockf" => "A wrapper around the fcntl() locking calls.\n\n`fd` is the file descriptor of the file to lock or unlock, and operation is one\nof the following values:\n\n    LOCK_UN - unlock\n    LOCK_SH - acquire a shared lock\n    LOCK_EX - acquire an exclusive lock\n\nWhen operation is LOCK_SH or LOCK_EX, it can also be bitwise ORed with\nLOCK_NB to avoid blocking on lock acquisition.  If LOCK_NB is used and the\nlock cannot be acquired, an OSError will be raised and the exception will\nhave an errno attribute set to EACCES or EAGAIN (depending on the operating\nsystem -- for portability, check for either value).\n\n`len` is the number of bytes to lock, with the default meaning to lock to\nEOF.  `start` is the byte offset, relative to `whence`, to that the lock\nstarts.  `whence` is as with fileobj.seek(), specifically:\n\n    0 - relative to the start of the file (SEEK_SET)\n    1 - relative to the current buffer position (SEEK_CUR)\n    2 - relative to the end of the file (SEEK_END)",
    "gc" => "This module provides access to the garbage collector for reference cycles.\n\nenable() -- Enable automatic garbage collection.\ndisable() -- Disable automatic garbage collection.\nisenabled() -- Returns true if automatic collection is enabled.\ncollect() -- Do a full collection right now.\nget_count() -- Return the current collection counts.\nget_stats() -- Return list of dictionaries containing per-generation stats.\nset_debug() -- Set debugging flags.\nget_debug() -- Get debugging flags.\nset_threshold() -- Set the collection thresholds.\nget_threshold() -- Return the current collection thresholds.\nget_objects() -- Return a list of all objects tracked by the collector.\nis_tracked() -- Returns true if a given object is tracked.\nis_finalized() -- Returns true if a given object has been already finalized.\nget_referrers() -- Return the list of objects that refer to an object.\nget_referents() -- Return the list of objects that an object refers to.\nfreeze() -- Freeze all tracked objects and ignore them for future collections.\nunfreeze() -- Unfreeze all objects in the permanent generation.\nget_freeze_count() -- Return the number of objects in the permanent generation.",
    "gc.collect" => "Run the garbage collector.\n\nWith no arguments, run a full collection.  The optional argument\nmay be an integer specifying which generation to collect.  A ValueError\nis raised if the generation number is invalid.\n\nThe number of unreachable objects is returned.",
    "gc.disable" => "Disable automatic garbage collection.",
    "gc.enable" => "Enable automatic garbage collection.",
    "gc.freeze" => "Freeze all current tracked objects and ignore them for future collections.\n\nThis can be used before a POSIX fork() call to make the gc copy-on-write friendly.\nNote: collection before a POSIX fork() call may free pages for future allocation\nwhich can cause copy-on-write.",
    "gc.get_count" => "Return a three-tuple of the current collection counts.",
    "gc.get_debug" => "Get the garbage collection debugging flags.",
    "gc.get_freeze_count" => "Return the number of objects in the permanent generation.",
    "gc.get_objects" => "Return a list of objects tracked by the collector (excluding the list returned).\n\n  generation\n    Generation to extract the objects from.\n\nIf generation is not None, return only the objects tracked by the collector\nthat are in that generation.",
    "gc.get_referents" => "Return the list of objects that are directly referred to by 'objs'.",
    "gc.get_referrers" => "Return the list of objects that directly refer to any of 'objs'.",
    "gc.get_stats" => "Return a list of dictionaries containing per-generation statistics.",
    "gc.get_threshold" => "Return the current collection thresholds.",
    "gc.is_finalized" => "Returns true if the object has been already finalized by the GC.",
    "gc.is_tracked" => "Returns true if the object is tracked by the garbage collector.\n\nSimple atomic objects will return false.",
    "gc.isenabled" => "Returns true if automatic garbage collection is enabled.",
    "gc.set_debug" => "Set the garbage collection debugging flags.\n\n  flags\n    An integer that can have the following bits turned on:\n      DEBUG_STATS - Print statistics during collection.\n      DEBUG_COLLECTABLE - Print collectable objects found.\n      DEBUG_UNCOLLECTABLE - Print unreachable but uncollectable objects\n        found.\n      DEBUG_SAVEALL - Save objects to gc.garbage rather than freeing them.\n      DEBUG_LEAK - Debug leaking programs (everything but STATS).\n\nDebugging information is written to sys.stderr.",
    "gc.set_threshold" => "set_threshold(threshold0, [threshold1, [threshold2]])\nSet the collection thresholds (the collection frequency).\n\nSetting 'threshold0' to zero disables collection.",
    "gc.unfreeze" => "Unfreeze all objects in the permanent generation.\n\nPut all objects in the permanent generation back into oldest generation.",
    "grp" => "Access to the Unix group database.\n\nGroup entries are reported as 4-tuples containing the following fields\nfrom the group database, in order:\n\n  gr_name   - name of the group\n  gr_passwd - group password (encrypted); often empty\n  gr_gid    - numeric ID of the group\n  gr_mem    - list of members\n\nThe gid is an integer, name and password are strings.  (Note that most\nusers are not explicitly listed as members of the groups they are in\naccording to the password database.  Check both databases to get\ncomplete membership information.)",
    "grp.getgrall" => "Return a list of all available group entries, in arbitrary order.\n\nAn entry whose name starts with '+' or '-' represents an instruction\nto use YP/NIS and may not be accessible via getgrnam or getgrgid.",
    "grp.getgrgid" => "Return the group database entry for the given numeric group ID.\n\nIf id is not valid, raise KeyError.",
    "grp.getgrnam" => "Return the group database entry for the given group name.\n\nIf name is not valid, raise KeyError.",
    "grp.struct_group" => "grp.struct_group: Results from getgr*() routines.\n\nThis object may be accessed either as a tuple of\n  (gr_name,gr_passwd,gr_gid,gr_mem)\nor via the object attributes as named in the above tuple.",
    "grp.struct_group.__add__" => "Return self+value.",
    "grp.struct_group.__class_getitem__" => "See PEP 585",
    "grp.struct_group.__contains__" => "Return bool(key in self).",
    "grp.struct_group.__delattr__" => "Implement delattr(self, name).",
    "grp.struct_group.__eq__" => "Return self==value.",
    "grp.struct_group.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "grp.struct_group.__ge__" => "Return self>=value.",
    "grp.struct_group.__getattribute__" => "Return getattr(self, name).",
    "grp.struct_group.__getitem__" => "Return self[key].",
    "grp.struct_group.__getstate__" => "Helper for pickle.",
    "grp.struct_group.__gt__" => "Return self>value.",
    "grp.struct_group.__hash__" => "Return hash(self).",
    "grp.struct_group.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "grp.struct_group.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "grp.struct_group.__iter__" => "Implement iter(self).",
    "grp.struct_group.__le__" => "Return self<=value.",
    "grp.struct_group.__len__" => "Return len(self).",
    "grp.struct_group.__lt__" => "Return self<value.",
    "grp.struct_group.__mul__" => "Return self*value.",
    "grp.struct_group.__ne__" => "Return self!=value.",
    "grp.struct_group.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "grp.struct_group.__reduce_ex__" => "Helper for pickle.",
    "grp.struct_group.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "grp.struct_group.__repr__" => "Return repr(self).",
    "grp.struct_group.__rmul__" => "Return value*self.",
    "grp.struct_group.__setattr__" => "Implement setattr(self, name, value).",
    "grp.struct_group.__sizeof__" => "Size of object in memory, in bytes.",
    "grp.struct_group.__str__" => "Return str(self).",
    "grp.struct_group.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "grp.struct_group.count" => "Return number of occurrences of value.",
    "grp.struct_group.gr_gid" => "group id",
    "grp.struct_group.gr_mem" => "group members",
    "grp.struct_group.gr_name" => "group name",
    "grp.struct_group.gr_passwd" => "password",
    "grp.struct_group.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "itertools" => "Functional tools for creating and using iterators.\n\nInfinite iterators:\ncount(start=0, step=1) --> start, start+step, start+2*step, ...\ncycle(p) --> p0, p1, ... plast, p0, p1, ...\nrepeat(elem [,n]) --> elem, elem, elem, ... endlessly or up to n times\n\nIterators terminating on the shortest input sequence:\naccumulate(p[, func]) --> p0, p0+p1, p0+p1+p2\nbatched(p, n) --> [p0, p1, ..., p_n-1], [p_n, p_n+1, ..., p_2n-1], ...\nchain(p, q, ...) --> p0, p1, ... plast, q0, q1, ...\nchain.from_iterable([p, q, ...]) --> p0, p1, ... plast, q0, q1, ...\ncompress(data, selectors) --> (d[0] if s[0]), (d[1] if s[1]), ...\ndropwhile(predicate, seq) --> seq[n], seq[n+1], starting when predicate fails\ngroupby(iterable[, keyfunc]) --> sub-iterators grouped by value of keyfunc(v)\nfilterfalse(predicate, seq) --> elements of seq where predicate(elem) is False\nislice(seq, [start,] stop [, step]) --> elements from\n       seq[start:stop:step]\npairwise(s) --> (s[0],s[1]), (s[1],s[2]), (s[2], s[3]), ...\nstarmap(fun, seq) --> fun(*seq[0]), fun(*seq[1]), ...\ntee(it, n=2) --> (it1, it2 , ... itn) splits one iterator into n\ntakewhile(predicate, seq) --> seq[0], seq[1], until predicate fails\nzip_longest(p, q, ...) --> (p[0], q[0]), (p[1], q[1]), ...\n\nCombinatoric generators:\nproduct(p, q, ... [repeat=1]) --> cartesian product\npermutations(p[, r])\ncombinations(p, r)\ncombinations_with_replacement(p, r)",
    "itertools._grouper.__delattr__" => "Implement delattr(self, name).",
    "itertools._grouper.__eq__" => "Return self==value.",
    "itertools._grouper.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools._grouper.__ge__" => "Return self>=value.",
    "itertools._grouper.__getattribute__" => "Return getattr(self, name).",
    "itertools._grouper.__getstate__" => "Helper for pickle.",
    "itertools._grouper.__gt__" => "Return self>value.",
    "itertools._grouper.__hash__" => "Return hash(self).",
    "itertools._grouper.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools._grouper.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools._grouper.__iter__" => "Implement iter(self).",
    "itertools._grouper.__le__" => "Return self<=value.",
    "itertools._grouper.__lt__" => "Return self<value.",
    "itertools._grouper.__ne__" => "Return self!=value.",
    "itertools._grouper.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools._grouper.__next__" => "Implement next(self).",
    "itertools._grouper.__reduce__" => "Return state information for pickling.",
    "itertools._grouper.__reduce_ex__" => "Helper for pickle.",
    "itertools._grouper.__repr__" => "Return repr(self).",
    "itertools._grouper.__setattr__" => "Implement setattr(self, name, value).",
    "itertools._grouper.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools._grouper.__str__" => "Return str(self).",
    "itertools._grouper.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools._tee" => "Iterator wrapped to make it copyable.",
    "itertools._tee.__copy__" => "Returns an independent iterator.",
    "itertools._tee.__delattr__" => "Implement delattr(self, name).",
    "itertools._tee.__eq__" => "Return self==value.",
    "itertools._tee.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools._tee.__ge__" => "Return self>=value.",
    "itertools._tee.__getattribute__" => "Return getattr(self, name).",
    "itertools._tee.__getstate__" => "Helper for pickle.",
    "itertools._tee.__gt__" => "Return self>value.",
    "itertools._tee.__hash__" => "Return hash(self).",
    "itertools._tee.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools._tee.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools._tee.__iter__" => "Implement iter(self).",
    "itertools._tee.__le__" => "Return self<=value.",
    "itertools._tee.__lt__" => "Return self<value.",
    "itertools._tee.__ne__" => "Return self!=value.",
    "itertools._tee.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools._tee.__next__" => "Implement next(self).",
    "itertools._tee.__reduce__" => "Return state information for pickling.",
    "itertools._tee.__reduce_ex__" => "Helper for pickle.",
    "itertools._tee.__repr__" => "Return repr(self).",
    "itertools._tee.__setattr__" => "Implement setattr(self, name, value).",
    "itertools._tee.__setstate__" => "Set state information for unpickling.",
    "itertools._tee.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools._tee.__str__" => "Return str(self).",
    "itertools._tee.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools._tee_dataobject" => "teedataobject(iterable, values, next, /)\n--\n\nData container common to multiple tee objects.",
    "itertools._tee_dataobject.__delattr__" => "Implement delattr(self, name).",
    "itertools._tee_dataobject.__eq__" => "Return self==value.",
    "itertools._tee_dataobject.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools._tee_dataobject.__ge__" => "Return self>=value.",
    "itertools._tee_dataobject.__getattribute__" => "Return getattr(self, name).",
    "itertools._tee_dataobject.__getstate__" => "Helper for pickle.",
    "itertools._tee_dataobject.__gt__" => "Return self>value.",
    "itertools._tee_dataobject.__hash__" => "Return hash(self).",
    "itertools._tee_dataobject.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools._tee_dataobject.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools._tee_dataobject.__le__" => "Return self<=value.",
    "itertools._tee_dataobject.__lt__" => "Return self<value.",
    "itertools._tee_dataobject.__ne__" => "Return self!=value.",
    "itertools._tee_dataobject.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools._tee_dataobject.__reduce__" => "Return state information for pickling.",
    "itertools._tee_dataobject.__reduce_ex__" => "Helper for pickle.",
    "itertools._tee_dataobject.__repr__" => "Return repr(self).",
    "itertools._tee_dataobject.__setattr__" => "Implement setattr(self, name, value).",
    "itertools._tee_dataobject.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools._tee_dataobject.__str__" => "Return str(self).",
    "itertools._tee_dataobject.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.accumulate" => "Return series of accumulated sums (or other binary function results).",
    "itertools.accumulate.__delattr__" => "Implement delattr(self, name).",
    "itertools.accumulate.__eq__" => "Return self==value.",
    "itertools.accumulate.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.accumulate.__ge__" => "Return self>=value.",
    "itertools.accumulate.__getattribute__" => "Return getattr(self, name).",
    "itertools.accumulate.__getstate__" => "Helper for pickle.",
    "itertools.accumulate.__gt__" => "Return self>value.",
    "itertools.accumulate.__hash__" => "Return hash(self).",
    "itertools.accumulate.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.accumulate.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.accumulate.__iter__" => "Implement iter(self).",
    "itertools.accumulate.__le__" => "Return self<=value.",
    "itertools.accumulate.__lt__" => "Return self<value.",
    "itertools.accumulate.__ne__" => "Return self!=value.",
    "itertools.accumulate.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.accumulate.__next__" => "Implement next(self).",
    "itertools.accumulate.__reduce__" => "Return state information for pickling.",
    "itertools.accumulate.__reduce_ex__" => "Helper for pickle.",
    "itertools.accumulate.__repr__" => "Return repr(self).",
    "itertools.accumulate.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.accumulate.__setstate__" => "Set state information for unpickling.",
    "itertools.accumulate.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.accumulate.__str__" => "Return str(self).",
    "itertools.accumulate.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.batched" => "Batch data into tuples of length n. The last batch may be shorter than n.\n\nLoops over the input iterable and accumulates data into tuples\nup to size n.  The input is consumed lazily, just enough to\nfill a batch.  The result is yielded as soon as a batch is full\nor when the input iterable is exhausted.\n\n    >>> for batch in batched('ABCDEFG', 3):\n    ...     print(batch)\n    ...\n    ('A', 'B', 'C')\n    ('D', 'E', 'F')\n    ('G',)\n\nIf \"strict\" is True, raises a ValueError if the final batch is shorter\nthan n.",
    "itertools.batched.__delattr__" => "Implement delattr(self, name).",
    "itertools.batched.__eq__" => "Return self==value.",
    "itertools.batched.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.batched.__ge__" => "Return self>=value.",
    "itertools.batched.__getattribute__" => "Return getattr(self, name).",
    "itertools.batched.__getstate__" => "Helper for pickle.",
    "itertools.batched.__gt__" => "Return self>value.",
    "itertools.batched.__hash__" => "Return hash(self).",
    "itertools.batched.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.batched.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.batched.__iter__" => "Implement iter(self).",
    "itertools.batched.__le__" => "Return self<=value.",
    "itertools.batched.__lt__" => "Return self<value.",
    "itertools.batched.__ne__" => "Return self!=value.",
    "itertools.batched.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.batched.__next__" => "Implement next(self).",
    "itertools.batched.__reduce__" => "Helper for pickle.",
    "itertools.batched.__reduce_ex__" => "Helper for pickle.",
    "itertools.batched.__repr__" => "Return repr(self).",
    "itertools.batched.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.batched.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.batched.__str__" => "Return str(self).",
    "itertools.batched.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.chain" => "Return a chain object whose .__next__() method returns elements from the\nfirst iterable until it is exhausted, then elements from the next\niterable, until all of the iterables are exhausted.",
    "itertools.chain.__class_getitem__" => "See PEP 585",
    "itertools.chain.__delattr__" => "Implement delattr(self, name).",
    "itertools.chain.__eq__" => "Return self==value.",
    "itertools.chain.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.chain.__ge__" => "Return self>=value.",
    "itertools.chain.__getattribute__" => "Return getattr(self, name).",
    "itertools.chain.__getstate__" => "Helper for pickle.",
    "itertools.chain.__gt__" => "Return self>value.",
    "itertools.chain.__hash__" => "Return hash(self).",
    "itertools.chain.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.chain.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.chain.__iter__" => "Implement iter(self).",
    "itertools.chain.__le__" => "Return self<=value.",
    "itertools.chain.__lt__" => "Return self<value.",
    "itertools.chain.__ne__" => "Return self!=value.",
    "itertools.chain.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.chain.__next__" => "Implement next(self).",
    "itertools.chain.__reduce__" => "Return state information for pickling.",
    "itertools.chain.__reduce_ex__" => "Helper for pickle.",
    "itertools.chain.__repr__" => "Return repr(self).",
    "itertools.chain.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.chain.__setstate__" => "Set state information for unpickling.",
    "itertools.chain.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.chain.__str__" => "Return str(self).",
    "itertools.chain.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.chain.from_iterable" => "Alternative chain() constructor taking a single iterable argument that evaluates lazily.",
    "itertools.combinations" => "Return successive r-length combinations of elements in the iterable.\n\ncombinations(range(4), 3) --> (0,1,2), (0,1,3), (0,2,3), (1,2,3)",
    "itertools.combinations.__delattr__" => "Implement delattr(self, name).",
    "itertools.combinations.__eq__" => "Return self==value.",
    "itertools.combinations.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.combinations.__ge__" => "Return self>=value.",
    "itertools.combinations.__getattribute__" => "Return getattr(self, name).",
    "itertools.combinations.__getstate__" => "Helper for pickle.",
    "itertools.combinations.__gt__" => "Return self>value.",
    "itertools.combinations.__hash__" => "Return hash(self).",
    "itertools.combinations.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.combinations.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.combinations.__iter__" => "Implement iter(self).",
    "itertools.combinations.__le__" => "Return self<=value.",
    "itertools.combinations.__lt__" => "Return self<value.",
    "itertools.combinations.__ne__" => "Return self!=value.",
    "itertools.combinations.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.combinations.__next__" => "Implement next(self).",
    "itertools.combinations.__reduce__" => "Return state information for pickling.",
    "itertools.combinations.__reduce_ex__" => "Helper for pickle.",
    "itertools.combinations.__repr__" => "Return repr(self).",
    "itertools.combinations.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.combinations.__setstate__" => "Set state information for unpickling.",
    "itertools.combinations.__sizeof__" => "Returns size in memory, in bytes.",
    "itertools.combinations.__str__" => "Return str(self).",
    "itertools.combinations.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.combinations_with_replacement" => "Return successive r-length combinations of elements in the iterable allowing individual elements to have successive repeats.\n\ncombinations_with_replacement('ABC', 2) --> ('A','A'), ('A','B'), ('A','C'), ('B','B'), ('B','C'), ('C','C')",
    "itertools.combinations_with_replacement.__delattr__" => "Implement delattr(self, name).",
    "itertools.combinations_with_replacement.__eq__" => "Return self==value.",
    "itertools.combinations_with_replacement.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.combinations_with_replacement.__ge__" => "Return self>=value.",
    "itertools.combinations_with_replacement.__getattribute__" => "Return getattr(self, name).",
    "itertools.combinations_with_replacement.__getstate__" => "Helper for pickle.",
    "itertools.combinations_with_replacement.__gt__" => "Return self>value.",
    "itertools.combinations_with_replacement.__hash__" => "Return hash(self).",
    "itertools.combinations_with_replacement.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.combinations_with_replacement.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.combinations_with_replacement.__iter__" => "Implement iter(self).",
    "itertools.combinations_with_replacement.__le__" => "Return self<=value.",
    "itertools.combinations_with_replacement.__lt__" => "Return self<value.",
    "itertools.combinations_with_replacement.__ne__" => "Return self!=value.",
    "itertools.combinations_with_replacement.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.combinations_with_replacement.__next__" => "Implement next(self).",
    "itertools.combinations_with_replacement.__reduce__" => "Return state information for pickling.",
    "itertools.combinations_with_replacement.__reduce_ex__" => "Helper for pickle.",
    "itertools.combinations_with_replacement.__repr__" => "Return repr(self).",
    "itertools.combinations_with_replacement.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.combinations_with_replacement.__setstate__" => "Set state information for unpickling.",
    "itertools.combinations_with_replacement.__sizeof__" => "Returns size in memory, in bytes.",
    "itertools.combinations_with_replacement.__str__" => "Return str(self).",
    "itertools.combinations_with_replacement.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.compress" => "Return data elements corresponding to true selector elements.\n\nForms a shorter iterator from selected data elements using the selectors to\nchoose the data elements.",
    "itertools.compress.__delattr__" => "Implement delattr(self, name).",
    "itertools.compress.__eq__" => "Return self==value.",
    "itertools.compress.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.compress.__ge__" => "Return self>=value.",
    "itertools.compress.__getattribute__" => "Return getattr(self, name).",
    "itertools.compress.__getstate__" => "Helper for pickle.",
    "itertools.compress.__gt__" => "Return self>value.",
    "itertools.compress.__hash__" => "Return hash(self).",
    "itertools.compress.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.compress.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.compress.__iter__" => "Implement iter(self).",
    "itertools.compress.__le__" => "Return self<=value.",
    "itertools.compress.__lt__" => "Return self<value.",
    "itertools.compress.__ne__" => "Return self!=value.",
    "itertools.compress.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.compress.__next__" => "Implement next(self).",
    "itertools.compress.__reduce__" => "Return state information for pickling.",
    "itertools.compress.__reduce_ex__" => "Helper for pickle.",
    "itertools.compress.__repr__" => "Return repr(self).",
    "itertools.compress.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.compress.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.compress.__str__" => "Return str(self).",
    "itertools.compress.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.count" => "Return a count object whose .__next__() method returns consecutive values.\n\nEquivalent to:\n    def count(firstval=0, step=1):\n        x = firstval\n        while 1:\n            yield x\n            x += step",
    "itertools.count.__delattr__" => "Implement delattr(self, name).",
    "itertools.count.__eq__" => "Return self==value.",
    "itertools.count.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.count.__ge__" => "Return self>=value.",
    "itertools.count.__getattribute__" => "Return getattr(self, name).",
    "itertools.count.__getstate__" => "Helper for pickle.",
    "itertools.count.__gt__" => "Return self>value.",
    "itertools.count.__hash__" => "Return hash(self).",
    "itertools.count.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.count.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.count.__iter__" => "Implement iter(self).",
    "itertools.count.__le__" => "Return self<=value.",
    "itertools.count.__lt__" => "Return self<value.",
    "itertools.count.__ne__" => "Return self!=value.",
    "itertools.count.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.count.__next__" => "Implement next(self).",
    "itertools.count.__reduce__" => "Return state information for pickling.",
    "itertools.count.__reduce_ex__" => "Helper for pickle.",
    "itertools.count.__repr__" => "Return repr(self).",
    "itertools.count.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.count.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.count.__str__" => "Return str(self).",
    "itertools.count.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.cycle" => "Return elements from the iterable until it is exhausted. Then repeat the sequence indefinitely.",
    "itertools.cycle.__delattr__" => "Implement delattr(self, name).",
    "itertools.cycle.__eq__" => "Return self==value.",
    "itertools.cycle.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.cycle.__ge__" => "Return self>=value.",
    "itertools.cycle.__getattribute__" => "Return getattr(self, name).",
    "itertools.cycle.__getstate__" => "Helper for pickle.",
    "itertools.cycle.__gt__" => "Return self>value.",
    "itertools.cycle.__hash__" => "Return hash(self).",
    "itertools.cycle.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.cycle.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.cycle.__iter__" => "Implement iter(self).",
    "itertools.cycle.__le__" => "Return self<=value.",
    "itertools.cycle.__lt__" => "Return self<value.",
    "itertools.cycle.__ne__" => "Return self!=value.",
    "itertools.cycle.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.cycle.__next__" => "Implement next(self).",
    "itertools.cycle.__reduce__" => "Return state information for pickling.",
    "itertools.cycle.__reduce_ex__" => "Helper for pickle.",
    "itertools.cycle.__repr__" => "Return repr(self).",
    "itertools.cycle.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.cycle.__setstate__" => "Set state information for unpickling.",
    "itertools.cycle.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.cycle.__str__" => "Return str(self).",
    "itertools.cycle.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.dropwhile" => "Drop items from the iterable while predicate(item) is true.\n\nAfterwards, return every element until the iterable is exhausted.",
    "itertools.dropwhile.__delattr__" => "Implement delattr(self, name).",
    "itertools.dropwhile.__eq__" => "Return self==value.",
    "itertools.dropwhile.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.dropwhile.__ge__" => "Return self>=value.",
    "itertools.dropwhile.__getattribute__" => "Return getattr(self, name).",
    "itertools.dropwhile.__getstate__" => "Helper for pickle.",
    "itertools.dropwhile.__gt__" => "Return self>value.",
    "itertools.dropwhile.__hash__" => "Return hash(self).",
    "itertools.dropwhile.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.dropwhile.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.dropwhile.__iter__" => "Implement iter(self).",
    "itertools.dropwhile.__le__" => "Return self<=value.",
    "itertools.dropwhile.__lt__" => "Return self<value.",
    "itertools.dropwhile.__ne__" => "Return self!=value.",
    "itertools.dropwhile.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.dropwhile.__next__" => "Implement next(self).",
    "itertools.dropwhile.__reduce__" => "Return state information for pickling.",
    "itertools.dropwhile.__reduce_ex__" => "Helper for pickle.",
    "itertools.dropwhile.__repr__" => "Return repr(self).",
    "itertools.dropwhile.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.dropwhile.__setstate__" => "Set state information for unpickling.",
    "itertools.dropwhile.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.dropwhile.__str__" => "Return str(self).",
    "itertools.dropwhile.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.filterfalse" => "Return those items of iterable for which function(item) is false.\n\nIf function is None, return the items that are false.",
    "itertools.filterfalse.__delattr__" => "Implement delattr(self, name).",
    "itertools.filterfalse.__eq__" => "Return self==value.",
    "itertools.filterfalse.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.filterfalse.__ge__" => "Return self>=value.",
    "itertools.filterfalse.__getattribute__" => "Return getattr(self, name).",
    "itertools.filterfalse.__getstate__" => "Helper for pickle.",
    "itertools.filterfalse.__gt__" => "Return self>value.",
    "itertools.filterfalse.__hash__" => "Return hash(self).",
    "itertools.filterfalse.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.filterfalse.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.filterfalse.__iter__" => "Implement iter(self).",
    "itertools.filterfalse.__le__" => "Return self<=value.",
    "itertools.filterfalse.__lt__" => "Return self<value.",
    "itertools.filterfalse.__ne__" => "Return self!=value.",
    "itertools.filterfalse.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.filterfalse.__next__" => "Implement next(self).",
    "itertools.filterfalse.__reduce__" => "Return state information for pickling.",
    "itertools.filterfalse.__reduce_ex__" => "Helper for pickle.",
    "itertools.filterfalse.__repr__" => "Return repr(self).",
    "itertools.filterfalse.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.filterfalse.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.filterfalse.__str__" => "Return str(self).",
    "itertools.filterfalse.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.groupby" => "make an iterator that returns consecutive keys and groups from the iterable\n\niterable\n  Elements to divide into groups according to the key function.\nkey\n  A function for computing the group category for each element.\n  If the key function is not specified or is None, the element itself\n  is used for grouping.",
    "itertools.groupby.__delattr__" => "Implement delattr(self, name).",
    "itertools.groupby.__eq__" => "Return self==value.",
    "itertools.groupby.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.groupby.__ge__" => "Return self>=value.",
    "itertools.groupby.__getattribute__" => "Return getattr(self, name).",
    "itertools.groupby.__getstate__" => "Helper for pickle.",
    "itertools.groupby.__gt__" => "Return self>value.",
    "itertools.groupby.__hash__" => "Return hash(self).",
    "itertools.groupby.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.groupby.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.groupby.__iter__" => "Implement iter(self).",
    "itertools.groupby.__le__" => "Return self<=value.",
    "itertools.groupby.__lt__" => "Return self<value.",
    "itertools.groupby.__ne__" => "Return self!=value.",
    "itertools.groupby.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.groupby.__next__" => "Implement next(self).",
    "itertools.groupby.__reduce__" => "Return state information for pickling.",
    "itertools.groupby.__reduce_ex__" => "Helper for pickle.",
    "itertools.groupby.__repr__" => "Return repr(self).",
    "itertools.groupby.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.groupby.__setstate__" => "Set state information for unpickling.",
    "itertools.groupby.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.groupby.__str__" => "Return str(self).",
    "itertools.groupby.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.islice" => "islice(iterable, stop) --> islice object\nislice(iterable, start, stop[, step]) --> islice object\n\nReturn an iterator whose next() method returns selected values from an\niterable.  If start is specified, will skip all preceding elements;\notherwise, start defaults to zero.  Step defaults to one.  If\nspecified as another value, step determines how many values are\nskipped between successive calls.  Works like a slice() on a list\nbut returns an iterator.",
    "itertools.islice.__delattr__" => "Implement delattr(self, name).",
    "itertools.islice.__eq__" => "Return self==value.",
    "itertools.islice.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.islice.__ge__" => "Return self>=value.",
    "itertools.islice.__getattribute__" => "Return getattr(self, name).",
    "itertools.islice.__getstate__" => "Helper for pickle.",
    "itertools.islice.__gt__" => "Return self>value.",
    "itertools.islice.__hash__" => "Return hash(self).",
    "itertools.islice.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.islice.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.islice.__iter__" => "Implement iter(self).",
    "itertools.islice.__le__" => "Return self<=value.",
    "itertools.islice.__lt__" => "Return self<value.",
    "itertools.islice.__ne__" => "Return self!=value.",
    "itertools.islice.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.islice.__next__" => "Implement next(self).",
    "itertools.islice.__reduce__" => "Return state information for pickling.",
    "itertools.islice.__reduce_ex__" => "Helper for pickle.",
    "itertools.islice.__repr__" => "Return repr(self).",
    "itertools.islice.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.islice.__setstate__" => "Set state information for unpickling.",
    "itertools.islice.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.islice.__str__" => "Return str(self).",
    "itertools.islice.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.pairwise" => "Return an iterator of overlapping pairs taken from the input iterator.\n\ns -> (s0,s1), (s1,s2), (s2, s3), ...",
    "itertools.pairwise.__delattr__" => "Implement delattr(self, name).",
    "itertools.pairwise.__eq__" => "Return self==value.",
    "itertools.pairwise.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.pairwise.__ge__" => "Return self>=value.",
    "itertools.pairwise.__getattribute__" => "Return getattr(self, name).",
    "itertools.pairwise.__getstate__" => "Helper for pickle.",
    "itertools.pairwise.__gt__" => "Return self>value.",
    "itertools.pairwise.__hash__" => "Return hash(self).",
    "itertools.pairwise.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.pairwise.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.pairwise.__iter__" => "Implement iter(self).",
    "itertools.pairwise.__le__" => "Return self<=value.",
    "itertools.pairwise.__lt__" => "Return self<value.",
    "itertools.pairwise.__ne__" => "Return self!=value.",
    "itertools.pairwise.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.pairwise.__next__" => "Implement next(self).",
    "itertools.pairwise.__reduce__" => "Helper for pickle.",
    "itertools.pairwise.__reduce_ex__" => "Helper for pickle.",
    "itertools.pairwise.__repr__" => "Return repr(self).",
    "itertools.pairwise.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.pairwise.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.pairwise.__str__" => "Return str(self).",
    "itertools.pairwise.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.permutations" => "Return successive r-length permutations of elements in the iterable.\n\npermutations(range(3), 2) --> (0,1), (0,2), (1,0), (1,2), (2,0), (2,1)",
    "itertools.permutations.__delattr__" => "Implement delattr(self, name).",
    "itertools.permutations.__eq__" => "Return self==value.",
    "itertools.permutations.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.permutations.__ge__" => "Return self>=value.",
    "itertools.permutations.__getattribute__" => "Return getattr(self, name).",
    "itertools.permutations.__getstate__" => "Helper for pickle.",
    "itertools.permutations.__gt__" => "Return self>value.",
    "itertools.permutations.__hash__" => "Return hash(self).",
    "itertools.permutations.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.permutations.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.permutations.__iter__" => "Implement iter(self).",
    "itertools.permutations.__le__" => "Return self<=value.",
    "itertools.permutations.__lt__" => "Return self<value.",
    "itertools.permutations.__ne__" => "Return self!=value.",
    "itertools.permutations.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.permutations.__next__" => "Implement next(self).",
    "itertools.permutations.__reduce__" => "Return state information for pickling.",
    "itertools.permutations.__reduce_ex__" => "Helper for pickle.",
    "itertools.permutations.__repr__" => "Return repr(self).",
    "itertools.permutations.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.permutations.__setstate__" => "Set state information for unpickling.",
    "itertools.permutations.__sizeof__" => "Returns size in memory, in bytes.",
    "itertools.permutations.__str__" => "Return str(self).",
    "itertools.permutations.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.product" => "Cartesian product of input iterables.  Equivalent to nested for-loops.\n\nFor example, product(A, B) returns the same as:  ((x,y) for x in A for y in B).\nThe leftmost iterators are in the outermost for-loop, so the output tuples\ncycle in a manner similar to an odometer (with the rightmost element changing\non every iteration).\n\nTo compute the product of an iterable with itself, specify the number\nof repetitions with the optional repeat keyword argument. For example,\nproduct(A, repeat=4) means the same as product(A, A, A, A).\n\nproduct('ab', range(3)) --> ('a',0) ('a',1) ('a',2) ('b',0) ('b',1) ('b',2)\nproduct((0,1), (0,1), (0,1)) --> (0,0,0) (0,0,1) (0,1,0) (0,1,1) (1,0,0) ...",
    "itertools.product.__delattr__" => "Implement delattr(self, name).",
    "itertools.product.__eq__" => "Return self==value.",
    "itertools.product.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.product.__ge__" => "Return self>=value.",
    "itertools.product.__getattribute__" => "Return getattr(self, name).",
    "itertools.product.__getstate__" => "Helper for pickle.",
    "itertools.product.__gt__" => "Return self>value.",
    "itertools.product.__hash__" => "Return hash(self).",
    "itertools.product.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.product.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.product.__iter__" => "Implement iter(self).",
    "itertools.product.__le__" => "Return self<=value.",
    "itertools.product.__lt__" => "Return self<value.",
    "itertools.product.__ne__" => "Return self!=value.",
    "itertools.product.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.product.__next__" => "Implement next(self).",
    "itertools.product.__reduce__" => "Return state information for pickling.",
    "itertools.product.__reduce_ex__" => "Helper for pickle.",
    "itertools.product.__repr__" => "Return repr(self).",
    "itertools.product.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.product.__setstate__" => "Set state information for unpickling.",
    "itertools.product.__sizeof__" => "Returns size in memory, in bytes.",
    "itertools.product.__str__" => "Return str(self).",
    "itertools.product.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.repeat" => "repeat(object [,times]) -> create an iterator which returns the object\nfor the specified number of times.  If not specified, returns the object\nendlessly.",
    "itertools.repeat.__delattr__" => "Implement delattr(self, name).",
    "itertools.repeat.__eq__" => "Return self==value.",
    "itertools.repeat.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.repeat.__ge__" => "Return self>=value.",
    "itertools.repeat.__getattribute__" => "Return getattr(self, name).",
    "itertools.repeat.__getstate__" => "Helper for pickle.",
    "itertools.repeat.__gt__" => "Return self>value.",
    "itertools.repeat.__hash__" => "Return hash(self).",
    "itertools.repeat.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.repeat.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.repeat.__iter__" => "Implement iter(self).",
    "itertools.repeat.__le__" => "Return self<=value.",
    "itertools.repeat.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "itertools.repeat.__lt__" => "Return self<value.",
    "itertools.repeat.__ne__" => "Return self!=value.",
    "itertools.repeat.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.repeat.__next__" => "Implement next(self).",
    "itertools.repeat.__reduce__" => "Return state information for pickling.",
    "itertools.repeat.__reduce_ex__" => "Helper for pickle.",
    "itertools.repeat.__repr__" => "Return repr(self).",
    "itertools.repeat.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.repeat.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.repeat.__str__" => "Return str(self).",
    "itertools.repeat.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.starmap" => "Return an iterator whose values are returned from the function evaluated with an argument tuple taken from the given sequence.",
    "itertools.starmap.__delattr__" => "Implement delattr(self, name).",
    "itertools.starmap.__eq__" => "Return self==value.",
    "itertools.starmap.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.starmap.__ge__" => "Return self>=value.",
    "itertools.starmap.__getattribute__" => "Return getattr(self, name).",
    "itertools.starmap.__getstate__" => "Helper for pickle.",
    "itertools.starmap.__gt__" => "Return self>value.",
    "itertools.starmap.__hash__" => "Return hash(self).",
    "itertools.starmap.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.starmap.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.starmap.__iter__" => "Implement iter(self).",
    "itertools.starmap.__le__" => "Return self<=value.",
    "itertools.starmap.__lt__" => "Return self<value.",
    "itertools.starmap.__ne__" => "Return self!=value.",
    "itertools.starmap.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.starmap.__next__" => "Implement next(self).",
    "itertools.starmap.__reduce__" => "Return state information for pickling.",
    "itertools.starmap.__reduce_ex__" => "Helper for pickle.",
    "itertools.starmap.__repr__" => "Return repr(self).",
    "itertools.starmap.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.starmap.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.starmap.__str__" => "Return str(self).",
    "itertools.starmap.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.takewhile" => "Return successive entries from an iterable as long as the predicate evaluates to true for each entry.",
    "itertools.takewhile.__delattr__" => "Implement delattr(self, name).",
    "itertools.takewhile.__eq__" => "Return self==value.",
    "itertools.takewhile.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.takewhile.__ge__" => "Return self>=value.",
    "itertools.takewhile.__getattribute__" => "Return getattr(self, name).",
    "itertools.takewhile.__getstate__" => "Helper for pickle.",
    "itertools.takewhile.__gt__" => "Return self>value.",
    "itertools.takewhile.__hash__" => "Return hash(self).",
    "itertools.takewhile.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.takewhile.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.takewhile.__iter__" => "Implement iter(self).",
    "itertools.takewhile.__le__" => "Return self<=value.",
    "itertools.takewhile.__lt__" => "Return self<value.",
    "itertools.takewhile.__ne__" => "Return self!=value.",
    "itertools.takewhile.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.takewhile.__next__" => "Implement next(self).",
    "itertools.takewhile.__reduce__" => "Return state information for pickling.",
    "itertools.takewhile.__reduce_ex__" => "Helper for pickle.",
    "itertools.takewhile.__repr__" => "Return repr(self).",
    "itertools.takewhile.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.takewhile.__setstate__" => "Set state information for unpickling.",
    "itertools.takewhile.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.takewhile.__str__" => "Return str(self).",
    "itertools.takewhile.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.tee" => "Returns a tuple of n independent iterators.",
    "itertools.zip_longest" => "Return a zip_longest object whose .__next__() method returns a tuple where\nthe i-th element comes from the i-th iterable argument.  The .__next__()\nmethod continues until the longest iterable in the argument sequence\nis exhausted and then it raises StopIteration.  When the shorter iterables\nare exhausted, the fillvalue is substituted in their place.  The fillvalue\ndefaults to None or can be specified by a keyword argument.",
    "itertools.zip_longest.__delattr__" => "Implement delattr(self, name).",
    "itertools.zip_longest.__eq__" => "Return self==value.",
    "itertools.zip_longest.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.zip_longest.__ge__" => "Return self>=value.",
    "itertools.zip_longest.__getattribute__" => "Return getattr(self, name).",
    "itertools.zip_longest.__getstate__" => "Helper for pickle.",
    "itertools.zip_longest.__gt__" => "Return self>value.",
    "itertools.zip_longest.__hash__" => "Return hash(self).",
    "itertools.zip_longest.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.zip_longest.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.zip_longest.__iter__" => "Implement iter(self).",
    "itertools.zip_longest.__le__" => "Return self<=value.",
    "itertools.zip_longest.__lt__" => "Return self<value.",
    "itertools.zip_longest.__ne__" => "Return self!=value.",
    "itertools.zip_longest.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.zip_longest.__next__" => "Implement next(self).",
    "itertools.zip_longest.__reduce__" => "Return state information for pickling.",
    "itertools.zip_longest.__reduce_ex__" => "Helper for pickle.",
    "itertools.zip_longest.__repr__" => "Return repr(self).",
    "itertools.zip_longest.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.zip_longest.__setstate__" => "Set state information for unpickling.",
    "itertools.zip_longest.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.zip_longest.__str__" => "Return str(self).",
    "itertools.zip_longest.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "marshal" => "This module contains functions that can read and write Python values in\na binary format. The format is specific to Python, but independent of\nmachine architecture issues.\n\nNot all Python object types are supported; in general, only objects\nwhose value is independent from a particular invocation of Python can be\nwritten and read by this module. The following types are supported:\nNone, integers, floating-point numbers, strings, bytes, bytearrays,\ntuples, lists, sets, dictionaries, and code objects, where it\nshould be understood that tuples, lists and dictionaries are only\nsupported as long as the values contained therein are themselves\nsupported; and recursive lists and dictionaries should not be written\n(they will cause infinite loops).\n\nVariables:\n\nversion -- indicates the format that the module uses. Version 0 is the\n    historical format, version 1 shares interned strings and version 2\n    uses a binary format for floating-point numbers.\n    Version 3 shares common object references (New in version 3.4).\n\nFunctions:\n\ndump() -- write value to a file\nload() -- read value from a file\ndumps() -- marshal value as a bytes object\nloads() -- read value from a bytes-like object",
    "marshal.dump" => "Write the value on the open file.\n\n  value\n    Must be a supported type.\n  file\n    Must be a writeable binary file.\n  version\n    Indicates the data format that dump should use.\n  allow_code\n    Allow to write code objects.\n\nIf the value has (or contains an object that has) an unsupported type, a\nValueError exception is raised - but garbage data will also be written\nto the file. The object will not be properly read back by load().",
    "marshal.dumps" => "Return the bytes object that would be written to a file by dump(value, file).\n\n  value\n    Must be a supported type.\n  version\n    Indicates the data format that dumps should use.\n  allow_code\n    Allow to write code objects.\n\nRaise a ValueError exception if value has (or contains an object that has) an\nunsupported type.",
    "marshal.load" => "Read one value from the open file and return it.\n\n  file\n    Must be readable binary file.\n  allow_code\n    Allow to load code objects.\n\nIf no valid value is read (e.g. because the data has a different Python\nversion's incompatible marshal format), raise EOFError, ValueError or\nTypeError.\n\nNote: If an object containing an unsupported type was marshalled with\ndump(), load() will substitute None for the unmarshallable type.",
    "marshal.loads" => "Convert the bytes-like object to a value.\n\n  allow_code\n    Allow to load code objects.\n\nIf no valid value is found, raise EOFError, ValueError or TypeError.  Extra\nbytes in the input are ignored.",
    "math" => "This module provides access to the mathematical functions\ndefined by the C standard.",
    "math.acos" => "Return the arc cosine (measured in radians) of x.\n\nThe result is between 0 and pi.",
    "math.acosh" => "Return the inverse hyperbolic cosine of x.",
    "math.asin" => "Return the arc sine (measured in radians) of x.\n\nThe result is between -pi/2 and pi/2.",
    "math.asinh" => "Return the inverse hyperbolic sine of x.",
    "math.atan" => "Return the arc tangent (measured in radians) of x.\n\nThe result is between -pi/2 and pi/2.",
    "math.atan2" => "Return the arc tangent (measured in radians) of y/x.\n\nUnlike atan(y/x), the signs of both x and y are considered.",
    "math.atanh" => "Return the inverse hyperbolic tangent of x.",
    "math.cbrt" => "Return the cube root of x.",
    "math.ceil" => "Return the ceiling of x as an Integral.\n\nThis is the smallest integer >= x.",
    "math.comb" => "Number of ways to choose k items from n items without repetition and without order.\n\nEvaluates to n! / (k! * (n - k)!) when k <= n and evaluates\nto zero when k > n.\n\nAlso called the binomial coefficient because it is equivalent\nto the coefficient of k-th term in polynomial expansion of the\nexpression (1 + x)**n.\n\nRaises TypeError if either of the arguments are not integers.\nRaises ValueError if either of the arguments are negative.",
    "math.copysign" => "Return a float with the magnitude (absolute value) of x but the sign of y.\n\nOn platforms that support signed zeros, copysign(1.0, -0.0)\nreturns -1.0.",
    "math.cos" => "Return the cosine of x (measured in radians).",
    "math.cosh" => "Return the hyperbolic cosine of x.",
    "math.degrees" => "Convert angle x from radians to degrees.",
    "math.dist" => "Return the Euclidean distance between two points p and q.\n\nThe points should be specified as sequences (or iterables) of\ncoordinates.  Both inputs must have the same dimension.\n\nRoughly equivalent to:\n    sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q)))",
    "math.erf" => "Error function at x.",
    "math.erfc" => "Complementary error function at x.",
    "math.exp" => "Return e raised to the power of x.",
    "math.exp2" => "Return 2 raised to the power of x.",
    "math.expm1" => "Return exp(x)-1.\n\nThis function avoids the loss of precision involved in the direct evaluation of exp(x)-1 for small x.",
    "math.fabs" => "Return the absolute value of the float x.",
    "math.factorial" => "Find n!.",
    "math.floor" => "Return the floor of x as an Integral.\n\nThis is the largest integer <= x.",
    "math.fma" => "Fused multiply-add operation.\n\nCompute (x * y) + z with a single round.",
    "math.fmod" => "Return fmod(x, y), according to platform C.\n\nx % y may differ.",
    "math.frexp" => "Return the mantissa and exponent of x, as pair (m, e).\n\nm is a float and e is an int, such that x = m * 2.**e.\nIf x is 0, m and e are both 0.  Else 0.5 <= abs(m) < 1.0.",
    "math.fsum" => "Return an accurate floating-point sum of values in the iterable seq.\n\nAssumes IEEE-754 floating-point arithmetic.",
    "math.gamma" => "Gamma function at x.",
    "math.gcd" => "Greatest Common Divisor.",
    "math.hypot" => "hypot(*coordinates) -> value\n\nMultidimensional Euclidean distance from the origin to a point.\n\nRoughly equivalent to:\n    sqrt(sum(x**2 for x in coordinates))\n\nFor a two dimensional point (x, y), gives the hypotenuse\nusing the Pythagorean theorem:  sqrt(x*x + y*y).\n\nFor example, the hypotenuse of a 3/4/5 right triangle is:\n\n    >>> hypot(3.0, 4.0)\n    5.0",
    "math.isclose" => "Determine whether two floating-point numbers are close in value.\n\n  rel_tol\n    maximum difference for being considered \"close\", relative to the\n    magnitude of the input values\n  abs_tol\n    maximum difference for being considered \"close\", regardless of the\n    magnitude of the input values\n\nReturn True if a is close in value to b, and False otherwise.\n\nFor the values to be considered close, the difference between them\nmust be smaller than at least one of the tolerances.\n\n-inf, inf and NaN behave similarly to the IEEE 754 Standard.  That\nis, NaN is not close to anything, even itself.  inf and -inf are\nonly close to themselves.",
    "math.isfinite" => "Return True if x is neither an infinity nor a NaN, and False otherwise.",
    "math.isinf" => "Return True if x is a positive or negative infinity, and False otherwise.",
    "math.isnan" => "Return True if x is a NaN (not a number), and False otherwise.",
    "math.isqrt" => "Return the integer part of the square root of the input.",
    "math.lcm" => "Least Common Multiple.",
    "math.ldexp" => "Return x * (2**i).\n\nThis is essentially the inverse of frexp().",
    "math.lgamma" => "Natural logarithm of absolute value of Gamma function at x.",
    "math.log" => "log(x, [base=math.e])\nReturn the logarithm of x to the given base.\n\nIf the base is not specified, returns the natural logarithm (base e) of x.",
    "math.log10" => "Return the base 10 logarithm of x.",
    "math.log1p" => "Return the natural logarithm of 1+x (base e).\n\nThe result is computed in a way which is accurate for x near zero.",
    "math.log2" => "Return the base 2 logarithm of x.",
    "math.modf" => "Return the fractional and integer parts of x.\n\nBoth results carry the sign of x and are floats.",
    "math.nextafter" => "Return the floating-point value the given number of steps after x towards y.\n\nIf steps is not specified or is None, it defaults to 1.\n\nRaises a TypeError, if x or y is not a double, or if steps is not an integer.\nRaises ValueError if steps is negative.",
    "math.perm" => "Number of ways to choose k items from n items without repetition and with order.\n\nEvaluates to n! / (n - k)! when k <= n and evaluates\nto zero when k > n.\n\nIf k is not specified or is None, then k defaults to n\nand the function returns n!.\n\nRaises TypeError if either of the arguments are not integers.\nRaises ValueError if either of the arguments are negative.",
    "math.pow" => "Return x**y (x to the power of y).",
    "math.prod" => "Calculate the product of all the elements in the input iterable.\n\nThe default start value for the product is 1.\n\nWhen the iterable is empty, return the start value.  This function is\nintended specifically for use with numeric values and may reject\nnon-numeric types.",
    "math.radians" => "Convert angle x from degrees to radians.",
    "math.remainder" => "Difference between x and the closest integer multiple of y.\n\nReturn x - n*y where n*y is the closest integer multiple of y.\nIn the case where x is exactly halfway between two multiples of\ny, the nearest even value of n is used. The result is always exact.",
    "math.sin" => "Return the sine of x (measured in radians).",
    "math.sinh" => "Return the hyperbolic sine of x.",
    "math.sqrt" => "Return the square root of x.",
    "math.sumprod" => "Return the sum of products of values from two iterables p and q.\n\nRoughly equivalent to:\n\n    sum(itertools.starmap(operator.mul, zip(p, q, strict=True)))\n\nFor float and mixed int/float inputs, the intermediate products\nand sums are computed with extended precision.",
    "math.tan" => "Return the tangent of x (measured in radians).",
    "math.tanh" => "Return the hyperbolic tangent of x.",
    "math.trunc" => "Truncates the Real x to the nearest Integral toward 0.\n\nUses the __trunc__ magic method.",
    "math.ulp" => "Return the value of the least significant bit of the float x.",
    "mmap.mmap" => "Windows: mmap(fileno, length[, tagname[, access[, offset]]])\n\nMaps length bytes from the file specified by the file handle fileno,\nand returns a mmap object.  If length is larger than the current size\nof the file, the file is extended to contain length bytes.  If length\nis 0, the maximum length of the map is the current size of the file,\nexcept that if the file is empty Windows raises an exception (you cannot\ncreate an empty mapping on Windows).\n\nUnix: mmap(fileno, length[, flags[, prot[, access[, offset[, trackfd]]]]])\n\nMaps length bytes from the file specified by the file descriptor fileno,\nand returns a mmap object.  If length is 0, the maximum length of the map\nwill be the current size of the file when mmap is called.\nflags specifies the nature of the mapping. MAP_PRIVATE creates a\nprivate copy-on-write mapping, so changes to the contents of the mmap\nobject will be private to this process, and MAP_SHARED creates a mapping\nthat's shared with all other processes mapping the same areas of the file.\nThe default value is MAP_SHARED.\n\nTo map anonymous memory, pass -1 as the fileno (both versions).",
    "mmap.mmap.__buffer__" => "Return a buffer object that exposes the underlying memory of the object.",
    "mmap.mmap.__delattr__" => "Implement delattr(self, name).",
    "mmap.mmap.__delitem__" => "Delete self[key].",
    "mmap.mmap.__eq__" => "Return self==value.",
    "mmap.mmap.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "mmap.mmap.__ge__" => "Return self>=value.",
    "mmap.mmap.__getattribute__" => "Return getattr(self, name).",
    "mmap.mmap.__getitem__" => "Return self[key].",
    "mmap.mmap.__getstate__" => "Helper for pickle.",
    "mmap.mmap.__gt__" => "Return self>value.",
    "mmap.mmap.__hash__" => "Return hash(self).",
    "mmap.mmap.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "mmap.mmap.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "mmap.mmap.__le__" => "Return self<=value.",
    "mmap.mmap.__len__" => "Return len(self).",
    "mmap.mmap.__lt__" => "Return self<value.",
    "mmap.mmap.__ne__" => "Return self!=value.",
    "mmap.mmap.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "mmap.mmap.__reduce__" => "Helper for pickle.",
    "mmap.mmap.__reduce_ex__" => "Helper for pickle.",
    "mmap.mmap.__release_buffer__" => "Release the buffer object that exposes the underlying memory of the object.",
    "mmap.mmap.__repr__" => "Return repr(self).",
    "mmap.mmap.__setattr__" => "Implement setattr(self, name, value).",
    "mmap.mmap.__setitem__" => "Set self[key] to value.",
    "mmap.mmap.__sizeof__" => "Size of object in memory, in bytes.",
    "mmap.mmap.__str__" => "Return str(self).",
    "mmap.mmap.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "msvcrt.GetErrorMode" => "Wrapper around GetErrorMode.",
    "msvcrt.SetErrorMode" => "Wrapper around SetErrorMode.",
    "msvcrt.get_osfhandle" => "Return the file handle for the file descriptor fd.\n\nRaises OSError if fd is not recognized.",
    "msvcrt.getch" => "Read a keypress and return the resulting character as a byte string.\n\nNothing is echoed to the console. This call will block if a keypress is\nnot already available, but will not wait for Enter to be pressed. If the\npressed key was a special function key, this will return '\\000' or\n'\\xe0'; the next call will return the keycode. The Control-C keypress\ncannot be read with this function.",
    "msvcrt.getche" => "Similar to getch(), but the keypress will be echoed if possible.",
    "msvcrt.getwch" => "Wide char variant of getch(), returning a Unicode value.",
    "msvcrt.getwche" => "Wide char variant of getche(), returning a Unicode value.",
    "msvcrt.heapmin" => "Minimize the malloc() heap.\n\nForce the malloc() heap to clean itself up and return unused blocks\nto the operating system. On failure, this raises OSError.",
    "msvcrt.kbhit" => "Returns a nonzero value if a keypress is waiting to be read. Otherwise, return 0.",
    "msvcrt.locking" => "Lock part of a file based on file descriptor fd from the C runtime.\n\nRaises OSError on failure. The locked region of the file extends from\nthe current file position for nbytes bytes, and may continue beyond\nthe end of the file. mode must be one of the LK_* constants listed\nbelow. Multiple regions in a file may be locked at the same time, but\nmay not overlap. Adjacent regions are not merged; they must be unlocked\nindividually.",
    "msvcrt.open_osfhandle" => "Create a C runtime file descriptor from the file handle handle.\n\nThe flags parameter should be a bitwise OR of os.O_APPEND, os.O_RDONLY,\nand os.O_TEXT. The returned file descriptor may be used as a parameter\nto os.fdopen() to create a file object.",
    "msvcrt.putch" => "Print the byte string char to the console without buffering.",
    "msvcrt.putwch" => "Wide char variant of putch(), accepting a Unicode value.",
    "msvcrt.setmode" => "Set the line-end translation mode for the file descriptor fd.\n\nTo set it to text mode, flags should be os.O_TEXT; for binary, it\nshould be os.O_BINARY.\n\nReturn value is the previous mode.",
    "msvcrt.ungetch" => "Opposite of getch.\n\nCause the byte string char to be \"pushed back\" into the\nconsole buffer; it will be the next character read by\ngetch() or getche().",
    "msvcrt.ungetwch" => "Wide char variant of ungetch(), accepting a Unicode value.",
    "nt" => "This module provides access to operating system functionality that is\nstandardized by the C Standard and the POSIX standard (a thinly\ndisguised Unix interface).  Refer to the library manual and\ncorresponding Unix manual entries for more information on calls.",
    "nt.DirEntry.__class_getitem__" => "See PEP 585",
    "nt.DirEntry.__delattr__" => "Implement delattr(self, name).",
    "nt.DirEntry.__eq__" => "Return self==value.",
    "nt.DirEntry.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "nt.DirEntry.__fspath__" => "Returns the path for the entry.",
    "nt.DirEntry.__ge__" => "Return self>=value.",
    "nt.DirEntry.__getattribute__" => "Return getattr(self, name).",
    "nt.DirEntry.__getstate__" => "Helper for pickle.",
    "nt.DirEntry.__gt__" => "Return self>value.",
    "nt.DirEntry.__hash__" => "Return hash(self).",
    "nt.DirEntry.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "nt.DirEntry.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "nt.DirEntry.__le__" => "Return self<=value.",
    "nt.DirEntry.__lt__" => "Return self<value.",
    "nt.DirEntry.__ne__" => "Return self!=value.",
    "nt.DirEntry.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "nt.DirEntry.__reduce__" => "Helper for pickle.",
    "nt.DirEntry.__reduce_ex__" => "Helper for pickle.",
    "nt.DirEntry.__repr__" => "Return repr(self).",
    "nt.DirEntry.__setattr__" => "Implement setattr(self, name, value).",
    "nt.DirEntry.__sizeof__" => "Size of object in memory, in bytes.",
    "nt.DirEntry.__str__" => "Return str(self).",
    "nt.DirEntry.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "nt.DirEntry.inode" => "Return inode of the entry; cached per entry.",
    "nt.DirEntry.is_dir" => "Return True if the entry is a directory; cached per entry.",
    "nt.DirEntry.is_file" => "Return True if the entry is a file; cached per entry.",
    "nt.DirEntry.is_junction" => "Return True if the entry is a junction; cached per entry.",
    "nt.DirEntry.is_symlink" => "Return True if the entry is a symbolic link; cached per entry.",
    "nt.DirEntry.name" => "the entry's base filename, relative to scandir() \"path\" argument",
    "nt.DirEntry.path" => "the entry's full path name; equivalent to os.path.join(scandir_path, entry.name)",
    "nt.DirEntry.stat" => "Return stat_result object for the entry; cached per entry.",
    "nt._add_dll_directory" => "Add a path to the DLL search path.\n\nThis search path is used when resolving dependencies for imported\nextension modules (the module itself is resolved through sys.path),\nand also by ctypes.\n\nReturns an opaque value that may be passed to os.remove_dll_directory\nto remove this directory from the search path.",
    "nt._exit" => "Exit to the system with specified status, without normal exit processing.",
    "nt._findfirstfile" => "A function to get the real file name without accessing the file in Windows.",
    "nt._getdiskusage" => "Return disk usage statistics about the given path as a (total, free) tuple.",
    "nt._getfinalpathname" => "A helper function for samepath on windows.",
    "nt._getvolumepathname" => "A helper function for ismount on Win32.",
    "nt._inputhook" => "Calls PyOS_CallInputHook droppong the GIL first",
    "nt._is_inputhook_installed" => "Checks if PyOS_CallInputHook is set",
    "nt._path_exists" => "Test whether a path exists.  Returns False for broken symbolic links.",
    "nt._path_isdevdrive" => "Determines whether the specified path is on a Windows Dev Drive.",
    "nt._path_isdir" => "Return true if the pathname refers to an existing directory.",
    "nt._path_isfile" => "Test whether a path is a regular file",
    "nt._path_isjunction" => "Test whether a path is a junction",
    "nt._path_islink" => "Test whether a path is a symbolic link",
    "nt._path_lexists" => "Test whether a path exists.  Returns True for broken symbolic links.",
    "nt._path_normpath" => "Normalize path, eliminating double slashes, etc.",
    "nt._path_splitroot" => "Removes everything after the root on Win32.",
    "nt._path_splitroot_ex" => "Split a pathname into drive, root and tail.\n\nThe tail contains anything after the root.",
    "nt._remove_dll_directory" => "Removes a path from the DLL search path.\n\nThe parameter is an opaque value that was returned from\nos.add_dll_directory. You can only remove directories that you added\nyourself.",
    "nt._supports_virtual_terminal" => "Checks if virtual terminal is supported in windows",
    "nt.abort" => "Abort the interpreter immediately.\n\nThis function 'dumps core' or otherwise fails in the hardest way possible\non the hosting operating system.  This function never returns.",
    "nt.access" => "Use the real uid/gid to test for access to a path.\n\n  path\n    Path to be tested; can be string, bytes, or a path-like object.\n  mode\n    Operating-system mode bitfield.  Can be F_OK to test existence,\n    or the inclusive-OR of R_OK, W_OK, and X_OK.\n  dir_fd\n    If not None, it should be a file descriptor open to a directory,\n    and path should be relative; path will then be relative to that\n    directory.\n  effective_ids\n    If True, access will use the effective uid/gid instead of\n    the real uid/gid.\n  follow_symlinks\n    If False, and the last element of the path is a symbolic link,\n    access will examine the symbolic link itself instead of the file\n    the link points to.\n\ndir_fd, effective_ids, and follow_symlinks may not be implemented\n  on your platform.  If they are unavailable, using them will raise a\n  NotImplementedError.\n\nNote that most operations will use the effective uid/gid, therefore this\n  routine can be used in a suid/sgid environment to test if the invoking user\n  has the specified access to the path.",
    "nt.chdir" => "Change the current working directory to the specified path.\n\npath may always be specified as a string.\nOn some platforms, path may also be specified as an open file descriptor.\nIf this functionality is unavailable, using it raises an exception.",
    "nt.chmod" => "Change the access permissions of a file.\n\n  path\n    Path to be modified.  May always be specified as a str, bytes, or a path-like object.\n    On some platforms, path may also be specified as an open file descriptor.\n    If this functionality is unavailable, using it raises an exception.\n  mode\n    Operating-system mode bitfield.\n    Be careful when using number literals for *mode*. The conventional UNIX notation for\n    numeric modes uses an octal base, which needs to be indicated with a ``0o`` prefix in\n    Python.\n  dir_fd\n    If not None, it should be a file descriptor open to a directory,\n    and path should be relative; path will then be relative to that\n    directory.\n  follow_symlinks\n    If False, and the last element of the path is a symbolic link,\n    chmod will modify the symbolic link itself instead of the file\n    the link points to.\n\nIt is an error to use dir_fd or follow_symlinks when specifying path as\n  an open file descriptor.\ndir_fd and follow_symlinks may not be implemented on your platform.\n  If they are unavailable, using them will raise a NotImplementedError.",
    "nt.close" => "Close a file descriptor.",
    "nt.closerange" => "Closes all file descriptors in [fd_low, fd_high), ignoring errors.",
    "nt.cpu_count" => "Return the number of logical CPUs in the system.\n\nReturn None if indeterminable.",
    "nt.device_encoding" => "Return a string describing the encoding of a terminal's file descriptor.\n\nThe file descriptor must be attached to a terminal.\nIf the device is not a terminal, return None.",
    "nt.dup" => "Return a duplicate of a file descriptor.",
    "nt.dup2" => "Duplicate file descriptor.",
    "nt.execv" => "Execute an executable path with arguments, replacing current process.\n\npath\n  Path of executable file.\nargv\n  Tuple or list of strings.",
    "nt.execve" => "Execute an executable path with arguments, replacing current process.\n\npath\n  Path of executable file.\nargv\n  Tuple or list of strings.\nenv\n  Dictionary of strings mapping to strings.",
    "nt.fchmod" => "Change the access permissions of the file given by file descriptor fd.\n\n  fd\n    The file descriptor of the file to be modified.\n  mode\n    Operating-system mode bitfield.\n    Be careful when using number literals for *mode*. The conventional UNIX notation for\n    numeric modes uses an octal base, which needs to be indicated with a ``0o`` prefix in\n    Python.\n\nEquivalent to os.chmod(fd, mode).",
    "nt.fspath" => "Return the file system path representation of the object.\n\nIf the object is str or bytes, then allow it to pass through as-is. If the\nobject defines __fspath__(), then return the result of that method. All other\ntypes raise a TypeError.",
    "nt.fstat" => "Perform a stat system call on the given file descriptor.\n\nLike stat(), but for an open file descriptor.\nEquivalent to os.stat(fd).",
    "nt.fsync" => "Force write of fd to disk.",
    "nt.ftruncate" => "Truncate a file, specified by file descriptor, to a specific length.",
    "nt.get_blocking" => "Get the blocking mode of the file descriptor.\n\nReturn False if the O_NONBLOCK flag is set, True if the flag is cleared.",
    "nt.get_handle_inheritable" => "Get the close-on-exe flag of the specified file descriptor.",
    "nt.get_inheritable" => "Get the close-on-exe flag of the specified file descriptor.",
    "nt.get_terminal_size" => "Return the size of the terminal window as (columns, lines).\n\nThe optional argument fd (default standard output) specifies\nwhich file descriptor should be queried.\n\nIf the file descriptor is not connected to a terminal, an OSError\nis thrown.\n\nThis function will only be defined if an implementation is\navailable for this system.\n\nshutil.get_terminal_size is the high-level function which should\nnormally be used, os.get_terminal_size is the low-level implementation.",
    "nt.getcwd" => "Return a unicode string representing the current working directory.",
    "nt.getcwdb" => "Return a bytes string representing the current working directory.",
    "nt.getlogin" => "Return the actual login name.",
    "nt.getpid" => "Return the current process id.",
    "nt.getppid" => "Return the parent's process id.\n\nIf the parent process has already exited, Windows machines will still\nreturn its id; others systems will return the id of the 'init' process (1).",
    "nt.isatty" => "Return True if the fd is connected to a terminal.\n\nReturn True if the file descriptor is an open file descriptor\nconnected to the slave end of a terminal.",
    "nt.kill" => "Kill a process with a signal.",
    "nt.lchmod" => "Change the access permissions of a file, without following symbolic links.\n\nIf path is a symlink, this affects the link itself rather than the target.\nEquivalent to chmod(path, mode, follow_symlinks=False).\"",
    "nt.link" => "Create a hard link to a file.\n\nIf either src_dir_fd or dst_dir_fd is not None, it should be a file\n  descriptor open to a directory, and the respective path string (src or dst)\n  should be relative; the path will then be relative to that directory.\nIf follow_symlinks is False, and the last element of src is a symbolic\n  link, link will create a link to the symbolic link itself instead of the\n  file the link points to.\nsrc_dir_fd, dst_dir_fd, and follow_symlinks may not be implemented on your\n  platform.  If they are unavailable, using them will raise a\n  NotImplementedError.",
    "nt.listdir" => "Return a list containing the names of the files in the directory.\n\npath can be specified as either str, bytes, or a path-like object.  If path is bytes,\n  the filenames returned will also be bytes; in all other circumstances\n  the filenames returned will be str.\nIf path is None, uses the path='.'.\nOn some platforms, path may also be specified as an open file descriptor;\\\n  the file descriptor must refer to a directory.\n  If this functionality is unavailable, using it raises NotImplementedError.\n\nThe list is in arbitrary order.  It does not include the special\nentries '.' and '..' even if they are present in the directory.",
    "nt.listdrives" => "Return a list containing the names of drives in the system.\n\nA drive name typically looks like 'C:\\\\'.",
    "nt.listmounts" => "Return a list containing mount points for a particular volume.\n\n'volume' should be a GUID path as returned from os.listvolumes.",
    "nt.listvolumes" => "Return a list containing the volumes in the system.\n\nVolumes are typically represented as a GUID path.",
    "nt.lseek" => "Set the position of a file descriptor.  Return the new position.\n\n  fd\n    An open file descriptor, as returned by os.open().\n  position\n    Position, interpreted relative to 'whence'.\n  whence\n    The relative position to seek from. Valid values are:\n    - SEEK_SET: seek from the start of the file.\n    - SEEK_CUR: seek from the current file position.\n    - SEEK_END: seek from the end of the file.\n\nThe return value is the number of bytes relative to the beginning of the file.",
    "nt.lstat" => "Perform a stat system call on the given path, without following symbolic links.\n\nLike stat(), but do not follow symbolic links.\nEquivalent to stat(path, follow_symlinks=False).",
    "nt.mkdir" => "Create a directory.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.\n\nThe mode argument is ignored on Windows. Where it is used, the current umask\nvalue is first masked out.",
    "nt.open" => "Open a file for low level IO.  Returns a file descriptor (integer).\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.",
    "nt.pipe" => "Create a pipe.\n\nReturns a tuple of two file descriptors:\n  (read_fd, write_fd)",
    "nt.putenv" => "Change or add an environment variable.",
    "nt.read" => "Read from a file descriptor.  Returns a bytes object.",
    "nt.readlink" => "Return a string representing the path to which the symbolic link points.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\nand path should be relative; path will then be relative to that directory.\n\ndir_fd may not be implemented on your platform.  If it is unavailable,\nusing it will raise a NotImplementedError.",
    "nt.remove" => "Remove a file (same as unlink()).\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.",
    "nt.rename" => "Rename a file or directory.\n\nIf either src_dir_fd or dst_dir_fd is not None, it should be a file\n  descriptor open to a directory, and the respective path string (src or dst)\n  should be relative; the path will then be relative to that directory.\nsrc_dir_fd and dst_dir_fd, may not be implemented on your platform.\n  If they are unavailable, using them will raise a NotImplementedError.",
    "nt.replace" => "Rename a file or directory, overwriting the destination.\n\nIf either src_dir_fd or dst_dir_fd is not None, it should be a file\n  descriptor open to a directory, and the respective path string (src or dst)\n  should be relative; the path will then be relative to that directory.\nsrc_dir_fd and dst_dir_fd, may not be implemented on your platform.\n  If they are unavailable, using them will raise a NotImplementedError.",
    "nt.rmdir" => "Remove a directory.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.",
    "nt.scandir" => "Return an iterator of DirEntry objects for given path.\n\npath can be specified as either str, bytes, or a path-like object.  If path\nis bytes, the names of yielded DirEntry objects will also be bytes; in\nall other circumstances they will be str.\n\nIf path is None, uses the path='.'.",
    "nt.set_blocking" => "Set the blocking mode of the specified file descriptor.\n\nSet the O_NONBLOCK flag if blocking is False,\nclear the O_NONBLOCK flag otherwise.",
    "nt.set_handle_inheritable" => "Set the inheritable flag of the specified handle.",
    "nt.set_inheritable" => "Set the inheritable flag of the specified file descriptor.",
    "nt.spawnv" => "Execute the program specified by path in a new process.\n\nmode\n  Mode of process creation.\npath\n  Path of executable file.\nargv\n  Tuple or list of strings.",
    "nt.spawnve" => "Execute the program specified by path in a new process.\n\nmode\n  Mode of process creation.\npath\n  Path of executable file.\nargv\n  Tuple or list of strings.\nenv\n  Dictionary of strings mapping to strings.",
    "nt.startfile" => "Start a file with its associated application.\n\nWhen \"operation\" is not specified or \"open\", this acts like\ndouble-clicking the file in Explorer, or giving the file name as an\nargument to the DOS \"start\" command: the file is opened with whatever\napplication (if any) its extension is associated.\nWhen another \"operation\" is given, it specifies what should be done with\nthe file.  A typical operation is \"print\".\n\n\"arguments\" is passed to the application, but should be omitted if the\nfile is a document.\n\n\"cwd\" is the working directory for the operation. If \"filepath\" is\nrelative, it will be resolved against this directory. This argument\nshould usually be an absolute path.\n\n\"show_cmd\" can be used to override the recommended visibility option.\nSee the Windows ShellExecute documentation for values.\n\nstartfile returns as soon as the associated application is launched.\nThere is no option to wait for the application to close, and no way\nto retrieve the application's exit status.\n\nThe filepath is relative to the current directory.  If you want to use\nan absolute path, make sure the first character is not a slash (\"/\");\nthe underlying Win32 ShellExecute function doesn't work if it is.",
    "nt.stat" => "Perform a stat system call on the given path.\n\n  path\n    Path to be examined; can be string, bytes, a path-like object or\n    open-file-descriptor int.\n  dir_fd\n    If not None, it should be a file descriptor open to a directory,\n    and path should be a relative string; path will then be relative to\n    that directory.\n  follow_symlinks\n    If False, and the last element of the path is a symbolic link,\n    stat will examine the symbolic link itself instead of the file\n    the link points to.\n\ndir_fd and follow_symlinks may not be implemented\n  on your platform.  If they are unavailable, using them will raise a\n  NotImplementedError.\n\nIt's an error to use dir_fd or follow_symlinks when specifying path as\n  an open file descriptor.",
    "nt.strerror" => "Translate an error code to a message string.",
    "nt.symlink" => "Create a symbolic link pointing to src named dst.\n\ntarget_is_directory is required on Windows if the target is to be\n  interpreted as a directory.  (On Windows, symlink requires\n  Windows 6.0 or greater, and raises a NotImplementedError otherwise.)\n  target_is_directory is ignored on non-Windows platforms.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.",
    "nt.system" => "Execute the command in a subshell.",
    "nt.times" => "Return a collection containing process timing information.\n\nThe object returned behaves like a named tuple with these fields:\n  (utime, stime, cutime, cstime, elapsed_time)\nAll fields are floating-point numbers.",
    "nt.times_result" => "times_result: Result from os.times().\n\nThis object may be accessed either as a tuple of\n  (user, system, children_user, children_system, elapsed),\nor via the attributes user, system, children_user, children_system,\nand elapsed.\n\nSee os.times for more information.",
    "nt.times_result.__add__" => "Return self+value.",
    "nt.times_result.__class_getitem__" => "See PEP 585",
    "nt.times_result.__contains__" => "Return bool(key in self).",
    "nt.times_result.__delattr__" => "Implement delattr(self, name).",
    "nt.times_result.__eq__" => "Return self==value.",
    "nt.times_result.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "nt.times_result.__ge__" => "Return self>=value.",
    "nt.times_result.__getattribute__" => "Return getattr(self, name).",
    "nt.times_result.__getitem__" => "Return self[key].",
    "nt.times_result.__getstate__" => "Helper for pickle.",
    "nt.times_result.__gt__" => "Return self>value.",
    "nt.times_result.__hash__" => "Return hash(self).",
    "nt.times_result.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "nt.times_result.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "nt.times_result.__iter__" => "Implement iter(self).",
    "nt.times_result.__le__" => "Return self<=value.",
    "nt.times_result.__len__" => "Return len(self).",
    "nt.times_result.__lt__" => "Return self<value.",
    "nt.times_result.__mul__" => "Return self*value.",
    "nt.times_result.__ne__" => "Return self!=value.",
    "nt.times_result.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "nt.times_result.__reduce_ex__" => "Helper for pickle.",
    "nt.times_result.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "nt.times_result.__repr__" => "Return repr(self).",
    "nt.times_result.__rmul__" => "Return value*self.",
    "nt.times_result.__setattr__" => "Implement setattr(self, name, value).",
    "nt.times_result.__sizeof__" => "Size of object in memory, in bytes.",
    "nt.times_result.__str__" => "Return str(self).",
    "nt.times_result.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "nt.times_result.children_system" => "system time of children",
    "nt.times_result.children_user" => "user time of children",
    "nt.times_result.count" => "Return number of occurrences of value.",
    "nt.times_result.elapsed" => "elapsed time since an arbitrary point in the past",
    "nt.times_result.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "nt.times_result.system" => "system time",
    "nt.times_result.user" => "user time",
    "nt.truncate" => "Truncate a file, specified by path, to a specific length.\n\nOn some platforms, path may also be specified as an open file descriptor.\n  If this functionality is unavailable, using it raises an exception.",
    "nt.umask" => "Set the current numeric umask and return the previous umask.",
    "nt.uname_result" => "uname_result: Result from os.uname().\n\nThis object may be accessed either as a tuple of\n  (sysname, nodename, release, version, machine),\nor via the attributes sysname, nodename, release, version, and machine.\n\nSee os.uname for more information.",
    "nt.uname_result.__add__" => "Return self+value.",
    "nt.uname_result.__class_getitem__" => "See PEP 585",
    "nt.uname_result.__contains__" => "Return bool(key in self).",
    "nt.uname_result.__delattr__" => "Implement delattr(self, name).",
    "nt.uname_result.__eq__" => "Return self==value.",
    "nt.uname_result.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "nt.uname_result.__ge__" => "Return self>=value.",
    "nt.uname_result.__getattribute__" => "Return getattr(self, name).",
    "nt.uname_result.__getitem__" => "Return self[key].",
    "nt.uname_result.__getstate__" => "Helper for pickle.",
    "nt.uname_result.__gt__" => "Return self>value.",
    "nt.uname_result.__hash__" => "Return hash(self).",
    "nt.uname_result.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "nt.uname_result.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "nt.uname_result.__iter__" => "Implement iter(self).",
    "nt.uname_result.__le__" => "Return self<=value.",
    "nt.uname_result.__len__" => "Return len(self).",
    "nt.uname_result.__lt__" => "Return self<value.",
    "nt.uname_result.__mul__" => "Return self*value.",
    "nt.uname_result.__ne__" => "Return self!=value.",
    "nt.uname_result.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "nt.uname_result.__reduce_ex__" => "Helper for pickle.",
    "nt.uname_result.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "nt.uname_result.__repr__" => "Return repr(self).",
    "nt.uname_result.__rmul__" => "Return value*self.",
    "nt.uname_result.__setattr__" => "Implement setattr(self, name, value).",
    "nt.uname_result.__sizeof__" => "Size of object in memory, in bytes.",
    "nt.uname_result.__str__" => "Return str(self).",
    "nt.uname_result.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "nt.uname_result.count" => "Return number of occurrences of value.",
    "nt.uname_result.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "nt.uname_result.machine" => "hardware identifier",
    "nt.uname_result.nodename" => "name of machine on network (implementation-defined)",
    "nt.uname_result.release" => "operating system release",
    "nt.uname_result.sysname" => "operating system name",
    "nt.uname_result.version" => "operating system version",
    "nt.unlink" => "Remove a file (same as remove()).\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.",
    "nt.unsetenv" => "Delete an environment variable.",
    "nt.urandom" => "Return a bytes object containing random bytes suitable for cryptographic use.",
    "nt.utime" => "Set the access and modified time of path.\n\npath may always be specified as a string.\nOn some platforms, path may also be specified as an open file descriptor.\n  If this functionality is unavailable, using it raises an exception.\n\nIf times is not None, it must be a tuple (atime, mtime);\n    atime and mtime should be expressed as float seconds since the epoch.\nIf ns is specified, it must be a tuple (atime_ns, mtime_ns);\n    atime_ns and mtime_ns should be expressed as integer nanoseconds\n    since the epoch.\nIf times is None and ns is unspecified, utime uses the current time.\nSpecifying tuples for both times and ns is an error.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\nIf follow_symlinks is False, and the last element of the path is a symbolic\n  link, utime will modify the symbolic link itself instead of the file the\n  link points to.\nIt is an error to use dir_fd or follow_symlinks when specifying path\n  as an open file descriptor.\ndir_fd and follow_symlinks may not be available on your platform.\n  If they are unavailable, using them will raise a NotImplementedError.",
    "nt.waitpid" => "Wait for completion of a given process.\n\nReturns a tuple of information regarding the process:\n    (pid, status << 8)\n\nThe options argument is ignored on Windows.",
    "nt.waitstatus_to_exitcode" => "Convert a wait status to an exit code.\n\nOn Unix:\n\n* If WIFEXITED(status) is true, return WEXITSTATUS(status).\n* If WIFSIGNALED(status) is true, return -WTERMSIG(status).\n* Otherwise, raise a ValueError.\n\nOn Windows, return status shifted right by 8 bits.\n\nOn Unix, if the process is being traced or if waitpid() was called with\nWUNTRACED option, the caller must first check if WIFSTOPPED(status) is true.\nThis function must not be called if WIFSTOPPED(status) is true.",
    "nt.write" => "Write a bytes object to a file descriptor.",
    "posix" => "This module provides access to operating system functionality that is\nstandardized by the C Standard and the POSIX standard (a thinly\ndisguised Unix interface).  Refer to the library manual and\ncorresponding Unix manual entries for more information on calls.",
    "posix.DirEntry.__class_getitem__" => "See PEP 585",
    "posix.DirEntry.__delattr__" => "Implement delattr(self, name).",
    "posix.DirEntry.__eq__" => "Return self==value.",
    "posix.DirEntry.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "posix.DirEntry.__fspath__" => "Returns the path for the entry.",
    "posix.DirEntry.__ge__" => "Return self>=value.",
    "posix.DirEntry.__getattribute__" => "Return getattr(self, name).",
    "posix.DirEntry.__getstate__" => "Helper for pickle.",
    "posix.DirEntry.__gt__" => "Return self>value.",
    "posix.DirEntry.__hash__" => "Return hash(self).",
    "posix.DirEntry.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "posix.DirEntry.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "posix.DirEntry.__le__" => "Return self<=value.",
    "posix.DirEntry.__lt__" => "Return self<value.",
    "posix.DirEntry.__ne__" => "Return self!=value.",
    "posix.DirEntry.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "posix.DirEntry.__reduce__" => "Helper for pickle.",
    "posix.DirEntry.__reduce_ex__" => "Helper for pickle.",
    "posix.DirEntry.__repr__" => "Return repr(self).",
    "posix.DirEntry.__setattr__" => "Implement setattr(self, name, value).",
    "posix.DirEntry.__sizeof__" => "Size of object in memory, in bytes.",
    "posix.DirEntry.__str__" => "Return str(self).",
    "posix.DirEntry.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "posix.DirEntry.inode" => "Return inode of the entry; cached per entry.",
    "posix.DirEntry.is_dir" => "Return True if the entry is a directory; cached per entry.",
    "posix.DirEntry.is_file" => "Return True if the entry is a file; cached per entry.",
    "posix.DirEntry.is_junction" => "Return True if the entry is a junction; cached per entry.",
    "posix.DirEntry.is_symlink" => "Return True if the entry is a symbolic link; cached per entry.",
    "posix.DirEntry.name" => "the entry's base filename, relative to scandir() \"path\" argument",
    "posix.DirEntry.path" => "the entry's full path name; equivalent to os.path.join(scandir_path, entry.name)",
    "posix.DirEntry.stat" => "Return stat_result object for the entry; cached per entry.",
    "posix.WCOREDUMP" => "Return True if the process returning status was dumped to a core file.",
    "posix.WEXITSTATUS" => "Return the process return code from status.",
    "posix.WIFCONTINUED" => "Return True if a particular process was continued from a job control stop.\n\nReturn True if the process returning status was continued from a\njob control stop.",
    "posix.WIFEXITED" => "Return True if the process returning status exited via the exit() system call.",
    "posix.WIFSIGNALED" => "Return True if the process returning status was terminated by a signal.",
    "posix.WIFSTOPPED" => "Return True if the process returning status was stopped.",
    "posix.WSTOPSIG" => "Return the signal that stopped the process that provided the status value.",
    "posix.WTERMSIG" => "Return the signal that terminated the process that provided the status value.",
    "posix._exit" => "Exit to the system with specified status, without normal exit processing.",
    "posix._fcopyfile" => "Efficiently copy content or metadata of 2 regular file descriptors (macOS).",
    "posix._inputhook" => "Calls PyOS_CallInputHook droppong the GIL first",
    "posix._is_inputhook_installed" => "Checks if PyOS_CallInputHook is set",
    "posix._path_normpath" => "Normalize path, eliminating double slashes, etc.",
    "posix._path_splitroot_ex" => "Split a pathname into drive, root and tail.\n\nThe tail contains anything after the root.",
    "posix.abort" => "Abort the interpreter immediately.\n\nThis function 'dumps core' or otherwise fails in the hardest way possible\non the hosting operating system.  This function never returns.",
    "posix.access" => "Use the real uid/gid to test for access to a path.\n\n  path\n    Path to be tested; can be string, bytes, or a path-like object.\n  mode\n    Operating-system mode bitfield.  Can be F_OK to test existence,\n    or the inclusive-OR of R_OK, W_OK, and X_OK.\n  dir_fd\n    If not None, it should be a file descriptor open to a directory,\n    and path should be relative; path will then be relative to that\n    directory.\n  effective_ids\n    If True, access will use the effective uid/gid instead of\n    the real uid/gid.\n  follow_symlinks\n    If False, and the last element of the path is a symbolic link,\n    access will examine the symbolic link itself instead of the file\n    the link points to.\n\ndir_fd, effective_ids, and follow_symlinks may not be implemented\n  on your platform.  If they are unavailable, using them will raise a\n  NotImplementedError.\n\nNote that most operations will use the effective uid/gid, therefore this\n  routine can be used in a suid/sgid environment to test if the invoking user\n  has the specified access to the path.",
    "posix.chdir" => "Change the current working directory to the specified path.\n\npath may always be specified as a string.\nOn some platforms, path may also be specified as an open file descriptor.\nIf this functionality is unavailable, using it raises an exception.",
    "posix.chflags" => "Set file flags.\n\nIf follow_symlinks is False, and the last element of the path is a symbolic\n  link, chflags will change flags on the symbolic link itself instead of the\n  file the link points to.\nfollow_symlinks may not be implemented on your platform.  If it is\nunavailable, using it will raise a NotImplementedError.",
    "posix.chmod" => "Change the access permissions of a file.\n\n  path\n    Path to be modified.  May always be specified as a str, bytes, or a path-like object.\n    On some platforms, path may also be specified as an open file descriptor.\n    If this functionality is unavailable, using it raises an exception.\n  mode\n    Operating-system mode bitfield.\n    Be careful when using number literals for *mode*. The conventional UNIX notation for\n    numeric modes uses an octal base, which needs to be indicated with a ``0o`` prefix in\n    Python.\n  dir_fd\n    If not None, it should be a file descriptor open to a directory,\n    and path should be relative; path will then be relative to that\n    directory.\n  follow_symlinks\n    If False, and the last element of the path is a symbolic link,\n    chmod will modify the symbolic link itself instead of the file\n    the link points to.\n\nIt is an error to use dir_fd or follow_symlinks when specifying path as\n  an open file descriptor.\ndir_fd and follow_symlinks may not be implemented on your platform.\n  If they are unavailable, using them will raise a NotImplementedError.",
    "posix.chown" => "Change the owner and group id of path to the numeric uid and gid.\\\n\n  path\n    Path to be examined; can be string, bytes, a path-like object, or open-file-descriptor int.\n  dir_fd\n    If not None, it should be a file descriptor open to a directory,\n    and path should be relative; path will then be relative to that\n    directory.\n  follow_symlinks\n    If False, and the last element of the path is a symbolic link,\n    stat will examine the symbolic link itself instead of the file\n    the link points to.\n\npath may always be specified as a string.\nOn some platforms, path may also be specified as an open file descriptor.\n  If this functionality is unavailable, using it raises an exception.\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\nIf follow_symlinks is False, and the last element of the path is a symbolic\n  link, chown will modify the symbolic link itself instead of the file the\n  link points to.\nIt is an error to use dir_fd or follow_symlinks when specifying path as\n  an open file descriptor.\ndir_fd and follow_symlinks may not be implemented on your platform.\n  If they are unavailable, using them will raise a NotImplementedError.",
    "posix.chroot" => "Change root directory to path.",
    "posix.close" => "Close a file descriptor.",
    "posix.closerange" => "Closes all file descriptors in [fd_low, fd_high), ignoring errors.",
    "posix.confstr" => "Return a string-valued system configuration variable.",
    "posix.copy_file_range" => "Copy count bytes from one file descriptor to another.\n\n  src\n    Source file descriptor.\n  dst\n    Destination file descriptor.\n  count\n    Number of bytes to copy.\n  offset_src\n    Starting offset in src.\n  offset_dst\n    Starting offset in dst.\n\nIf offset_src is None, then src is read from the current position;\nrespectively for offset_dst.",
    "posix.cpu_count" => "Return the number of logical CPUs in the system.\n\nReturn None if indeterminable.",
    "posix.ctermid" => "Return the name of the controlling terminal for this process.",
    "posix.device_encoding" => "Return a string describing the encoding of a terminal's file descriptor.\n\nThe file descriptor must be attached to a terminal.\nIf the device is not a terminal, return None.",
    "posix.dup" => "Return a duplicate of a file descriptor.",
    "posix.dup2" => "Duplicate file descriptor.",
    "posix.eventfd" => "Creates and returns an event notification file descriptor.",
    "posix.eventfd_read" => "Read eventfd value",
    "posix.eventfd_write" => "Write eventfd value.",
    "posix.execv" => "Execute an executable path with arguments, replacing current process.\n\npath\n  Path of executable file.\nargv\n  Tuple or list of strings.",
    "posix.execve" => "Execute an executable path with arguments, replacing current process.\n\npath\n  Path of executable file.\nargv\n  Tuple or list of strings.\nenv\n  Dictionary of strings mapping to strings.",
    "posix.fchdir" => "Change to the directory of the given file descriptor.\n\nfd must be opened on a directory, not a file.\nEquivalent to os.chdir(fd).",
    "posix.fchmod" => "Change the access permissions of the file given by file descriptor fd.\n\n  fd\n    The file descriptor of the file to be modified.\n  mode\n    Operating-system mode bitfield.\n    Be careful when using number literals for *mode*. The conventional UNIX notation for\n    numeric modes uses an octal base, which needs to be indicated with a ``0o`` prefix in\n    Python.\n\nEquivalent to os.chmod(fd, mode).",
    "posix.fchown" => "Change the owner and group id of the file specified by file descriptor.\n\nEquivalent to os.chown(fd, uid, gid).",
    "posix.fdatasync" => "Force write of fd to disk without forcing update of metadata.",
    "posix.fork" => "Fork a child process.\n\nReturn 0 to child process and PID of child to parent process.",
    "posix.forkpty" => "Fork a new process with a new pseudo-terminal as controlling tty.\n\nReturns a tuple of (pid, master_fd).\nLike fork(), return pid of 0 to the child process,\nand pid of child to the parent process.\nTo both, return fd of newly opened pseudo-terminal.",
    "posix.fpathconf" => "Return the configuration limit name for the file descriptor fd.\n\nIf there is no limit, return -1.",
    "posix.fspath" => "Return the file system path representation of the object.\n\nIf the object is str or bytes, then allow it to pass through as-is. If the\nobject defines __fspath__(), then return the result of that method. All other\ntypes raise a TypeError.",
    "posix.fstat" => "Perform a stat system call on the given file descriptor.\n\nLike stat(), but for an open file descriptor.\nEquivalent to os.stat(fd).",
    "posix.fstatvfs" => "Perform an fstatvfs system call on the given fd.\n\nEquivalent to statvfs(fd).",
    "posix.fsync" => "Force write of fd to disk.",
    "posix.ftruncate" => "Truncate a file, specified by file descriptor, to a specific length.",
    "posix.get_blocking" => "Get the blocking mode of the file descriptor.\n\nReturn False if the O_NONBLOCK flag is set, True if the flag is cleared.",
    "posix.get_inheritable" => "Get the close-on-exe flag of the specified file descriptor.",
    "posix.get_terminal_size" => "Return the size of the terminal window as (columns, lines).\n\nThe optional argument fd (default standard output) specifies\nwhich file descriptor should be queried.\n\nIf the file descriptor is not connected to a terminal, an OSError\nis thrown.\n\nThis function will only be defined if an implementation is\navailable for this system.\n\nshutil.get_terminal_size is the high-level function which should\nnormally be used, os.get_terminal_size is the low-level implementation.",
    "posix.getcwd" => "Return a unicode string representing the current working directory.",
    "posix.getcwdb" => "Return a bytes string representing the current working directory.",
    "posix.getegid" => "Return the current process's effective group id.",
    "posix.geteuid" => "Return the current process's effective user id.",
    "posix.getgid" => "Return the current process's group id.",
    "posix.getgrouplist" => "Returns a list of groups to which a user belongs.\n\nuser\n  username to lookup\ngroup\n  base group id of the user",
    "posix.getgroups" => "Return list of supplemental group IDs for the process.",
    "posix.getloadavg" => "Return average recent system load information.\n\nReturn the number of processes in the system run queue averaged over\nthe last 1, 5, and 15 minutes as a tuple of three floats.\nRaises OSError if the load average was unobtainable.",
    "posix.getlogin" => "Return the actual login name.",
    "posix.getpgid" => "Call the system call getpgid(), and return the result.",
    "posix.getpgrp" => "Return the current process group id.",
    "posix.getpid" => "Return the current process id.",
    "posix.getppid" => "Return the parent's process id.\n\nIf the parent process has already exited, Windows machines will still\nreturn its id; others systems will return the id of the 'init' process (1).",
    "posix.getpriority" => "Return program scheduling priority.",
    "posix.getrandom" => "Obtain a series of random bytes.",
    "posix.getresgid" => "Return a tuple of the current process's real, effective, and saved group ids.",
    "posix.getresuid" => "Return a tuple of the current process's real, effective, and saved user ids.",
    "posix.getsid" => "Call the system call getsid(pid) and return the result.",
    "posix.getuid" => "Return the current process's user id.",
    "posix.getxattr" => "Return the value of extended attribute attribute on path.\n\npath may be either a string, a path-like object, or an open file descriptor.\nIf follow_symlinks is False, and the last element of the path is a symbolic\n  link, getxattr will examine the symbolic link itself instead of the file\n  the link points to.",
    "posix.grantpt" => "Grant access to the slave pseudo-terminal device.\n\n  fd\n    File descriptor of a master pseudo-terminal device.\n\nPerforms a grantpt() C function call.",
    "posix.initgroups" => "Initialize the group access list.\n\nCall the system initgroups() to initialize the group access list with all of\nthe groups of which the specified username is a member, plus the specified\ngroup id.",
    "posix.isatty" => "Return True if the fd is connected to a terminal.\n\nReturn True if the file descriptor is an open file descriptor\nconnected to the slave end of a terminal.",
    "posix.kill" => "Kill a process with a signal.",
    "posix.killpg" => "Kill a process group with a signal.",
    "posix.lchflags" => "Set file flags.\n\nThis function will not follow symbolic links.\nEquivalent to chflags(path, flags, follow_symlinks=False).",
    "posix.lchmod" => "Change the access permissions of a file, without following symbolic links.\n\nIf path is a symlink, this affects the link itself rather than the target.\nEquivalent to chmod(path, mode, follow_symlinks=False).\"",
    "posix.lchown" => "Change the owner and group id of path to the numeric uid and gid.\n\nThis function will not follow symbolic links.\nEquivalent to os.chown(path, uid, gid, follow_symlinks=False).",
    "posix.link" => "Create a hard link to a file.\n\nIf either src_dir_fd or dst_dir_fd is not None, it should be a file\n  descriptor open to a directory, and the respective path string (src or dst)\n  should be relative; the path will then be relative to that directory.\nIf follow_symlinks is False, and the last element of src is a symbolic\n  link, link will create a link to the symbolic link itself instead of the\n  file the link points to.\nsrc_dir_fd, dst_dir_fd, and follow_symlinks may not be implemented on your\n  platform.  If they are unavailable, using them will raise a\n  NotImplementedError.",
    "posix.listdir" => "Return a list containing the names of the files in the directory.\n\npath can be specified as either str, bytes, or a path-like object.  If path is bytes,\n  the filenames returned will also be bytes; in all other circumstances\n  the filenames returned will be str.\nIf path is None, uses the path='.'.\nOn some platforms, path may also be specified as an open file descriptor;\\\n  the file descriptor must refer to a directory.\n  If this functionality is unavailable, using it raises NotImplementedError.\n\nThe list is in arbitrary order.  It does not include the special\nentries '.' and '..' even if they are present in the directory.",
    "posix.listxattr" => "Return a list of extended attributes on path.\n\npath may be either None, a string, a path-like object, or an open file descriptor.\nif path is None, listxattr will examine the current directory.\nIf follow_symlinks is False, and the last element of the path is a symbolic\n  link, listxattr will examine the symbolic link itself instead of the file\n  the link points to.",
    "posix.lockf" => "Apply, test or remove a POSIX lock on an open file descriptor.\n\nfd\n  An open file descriptor.\ncommand\n  One of F_LOCK, F_TLOCK, F_ULOCK or F_TEST.\nlength\n  The number of bytes to lock, starting at the current position.",
    "posix.login_tty" => "Prepare the tty of which fd is a file descriptor for a new login session.\n\nMake the calling process a session leader; make the tty the\ncontrolling tty, the stdin, the stdout, and the stderr of the\ncalling process; close fd.",
    "posix.lseek" => "Set the position of a file descriptor.  Return the new position.\n\n  fd\n    An open file descriptor, as returned by os.open().\n  position\n    Position, interpreted relative to 'whence'.\n  whence\n    The relative position to seek from. Valid values are:\n    - SEEK_SET: seek from the start of the file.\n    - SEEK_CUR: seek from the current file position.\n    - SEEK_END: seek from the end of the file.\n\nThe return value is the number of bytes relative to the beginning of the file.",
    "posix.lstat" => "Perform a stat system call on the given path, without following symbolic links.\n\nLike stat(), but do not follow symbolic links.\nEquivalent to stat(path, follow_symlinks=False).",
    "posix.major" => "Extracts a device major number from a raw device number.",
    "posix.makedev" => "Composes a raw device number from the major and minor device numbers.",
    "posix.minor" => "Extracts a device minor number from a raw device number.",
    "posix.mkdir" => "Create a directory.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.\n\nThe mode argument is ignored on Windows. Where it is used, the current umask\nvalue is first masked out.",
    "posix.mkfifo" => "Create a \"fifo\" (a POSIX named pipe).\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.",
    "posix.mknod" => "Create a node in the file system.\n\nCreate a node in the file system (file, device special file or named pipe)\nat path.  mode specifies both the permissions to use and the\ntype of node to be created, being combined (bitwise OR) with one of\nS_IFREG, S_IFCHR, S_IFBLK, and S_IFIFO.  If S_IFCHR or S_IFBLK is set on mode,\ndevice defines the newly created device special file (probably using\nos.makedev()).  Otherwise device is ignored.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.",
    "posix.nice" => "Add increment to the priority of process and return the new priority.",
    "posix.open" => "Open a file for low level IO.  Returns a file descriptor (integer).\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.",
    "posix.openpty" => "Open a pseudo-terminal.\n\nReturn a tuple of (master_fd, slave_fd) containing open file descriptors\nfor both the master and slave ends.",
    "posix.pathconf" => "Return the configuration limit name for the file or directory path.\n\nIf there is no limit, return -1.\nOn some platforms, path may also be specified as an open file descriptor.\n  If this functionality is unavailable, using it raises an exception.",
    "posix.pidfd_open" => "Return a file descriptor referring to the process *pid*.\n\nThe descriptor can be used to perform process management without races and\nsignals.",
    "posix.pipe" => "Create a pipe.\n\nReturns a tuple of two file descriptors:\n  (read_fd, write_fd)",
    "posix.pipe2" => "Create a pipe with flags set atomically.\n\nReturns a tuple of two file descriptors:\n  (read_fd, write_fd)\n\nflags can be constructed by ORing together one or more of these values:\nO_NONBLOCK, O_CLOEXEC.",
    "posix.posix_fadvise" => "Announce an intention to access data in a specific pattern.\n\nAnnounce an intention to access data in a specific pattern, thus allowing\nthe kernel to make optimizations.\nThe advice applies to the region of the file specified by fd starting at\noffset and continuing for length bytes.\nadvice is one of POSIX_FADV_NORMAL, POSIX_FADV_SEQUENTIAL,\nPOSIX_FADV_RANDOM, POSIX_FADV_NOREUSE, POSIX_FADV_WILLNEED, or\nPOSIX_FADV_DONTNEED.",
    "posix.posix_fallocate" => "Ensure a file has allocated at least a particular number of bytes on disk.\n\nEnsure that the file specified by fd encompasses a range of bytes\nstarting at offset bytes from the beginning and continuing for length bytes.",
    "posix.posix_openpt" => "Open and return a file descriptor for a master pseudo-terminal device.\n\nPerforms a posix_openpt() C function call. The oflag argument is used to\nset file status flags and file access modes as specified in the manual page\nof posix_openpt() of your system.",
    "posix.posix_spawn" => "Execute the program specified by path in a new process.\n\npath\n  Path of executable file.\nargv\n  Tuple or list of strings.\nenv\n  Dictionary of strings mapping to strings.\nfile_actions\n  A sequence of file action tuples.\nsetpgroup\n  The pgroup to use with the POSIX_SPAWN_SETPGROUP flag.\nresetids\n  If the value is `true` the POSIX_SPAWN_RESETIDS will be activated.\nsetsid\n  If the value is `true` the POSIX_SPAWN_SETSID or POSIX_SPAWN_SETSID_NP will be activated.\nsetsigmask\n  The sigmask to use with the POSIX_SPAWN_SETSIGMASK flag.\nsetsigdef\n  The sigmask to use with the POSIX_SPAWN_SETSIGDEF flag.\nscheduler\n  A tuple with the scheduler policy (optional) and parameters.",
    "posix.posix_spawnp" => "Execute the program specified by path in a new process.\n\npath\n  Path of executable file.\nargv\n  Tuple or list of strings.\nenv\n  Dictionary of strings mapping to strings.\nfile_actions\n  A sequence of file action tuples.\nsetpgroup\n  The pgroup to use with the POSIX_SPAWN_SETPGROUP flag.\nresetids\n  If the value is `True` the POSIX_SPAWN_RESETIDS will be activated.\nsetsid\n  If the value is `True` the POSIX_SPAWN_SETSID or POSIX_SPAWN_SETSID_NP will be activated.\nsetsigmask\n  The sigmask to use with the POSIX_SPAWN_SETSIGMASK flag.\nsetsigdef\n  The sigmask to use with the POSIX_SPAWN_SETSIGDEF flag.\nscheduler\n  A tuple with the scheduler policy (optional) and parameters.",
    "posix.pread" => "Read a number of bytes from a file descriptor starting at a particular offset.\n\nRead length bytes from file descriptor fd, starting at offset bytes from\nthe beginning of the file.  The file offset remains unchanged.",
    "posix.preadv" => "Reads from a file descriptor into a number of mutable bytes-like objects.\n\nCombines the functionality of readv() and pread(). As readv(), it will\ntransfer data into each buffer until it is full and then move on to the next\nbuffer in the sequence to hold the rest of the data. Its fourth argument,\nspecifies the file offset at which the input operation is to be performed. It\nwill return the total number of bytes read (which can be less than the total\ncapacity of all the objects).\n\nThe flags argument contains a bitwise OR of zero or more of the following flags:\n\n- RWF_HIPRI\n- RWF_NOWAIT\n\nUsing non-zero flags requires Linux 4.6 or newer.",
    "posix.ptsname" => "Return the name of the slave pseudo-terminal device.\n\n  fd\n    File descriptor of a master pseudo-terminal device.\n\nIf the ptsname_r() C function is available, it is called;\notherwise, performs a ptsname() C function call.",
    "posix.putenv" => "Change or add an environment variable.",
    "posix.pwrite" => "Write bytes to a file descriptor starting at a particular offset.\n\nWrite buffer to fd, starting at offset bytes from the beginning of\nthe file.  Returns the number of bytes written.  Does not change the\ncurrent file offset.",
    "posix.pwritev" => "Writes the contents of bytes-like objects to a file descriptor at a given offset.\n\nCombines the functionality of writev() and pwrite(). All buffers must be a sequence\nof bytes-like objects. Buffers are processed in array order. Entire contents of first\nbuffer is written before proceeding to second, and so on. The operating system may\nset a limit (sysconf() value SC_IOV_MAX) on the number of buffers that can be used.\nThis function writes the contents of each object to the file descriptor and returns\nthe total number of bytes written.\n\nThe flags argument contains a bitwise OR of zero or more of the following flags:\n\n- RWF_DSYNC\n- RWF_SYNC\n- RWF_APPEND\n\nUsing non-zero flags requires Linux 4.7 or newer.",
    "posix.read" => "Read from a file descriptor.  Returns a bytes object.",
    "posix.readlink" => "Return a string representing the path to which the symbolic link points.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\nand path should be relative; path will then be relative to that directory.\n\ndir_fd may not be implemented on your platform.  If it is unavailable,\nusing it will raise a NotImplementedError.",
    "posix.readv" => "Read from a file descriptor fd into an iterable of buffers.\n\nThe buffers should be mutable buffers accepting bytes.\nreadv will transfer data into each buffer until it is full\nand then move on to the next buffer in the sequence to hold\nthe rest of the data.\n\nreadv returns the total number of bytes read,\nwhich may be less than the total capacity of all the buffers.",
    "posix.register_at_fork" => "Register callables to be called when forking a new process.\n\n  before\n    A callable to be called in the parent before the fork() syscall.\n  after_in_child\n    A callable to be called in the child after fork().\n  after_in_parent\n    A callable to be called in the parent after fork().\n\n'before' callbacks are called in reverse order.\n'after_in_child' and 'after_in_parent' callbacks are called in order.",
    "posix.remove" => "Remove a file (same as unlink()).\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.",
    "posix.removexattr" => "Remove extended attribute attribute on path.\n\npath may be either a string, a path-like object, or an open file descriptor.\nIf follow_symlinks is False, and the last element of the path is a symbolic\n  link, removexattr will modify the symbolic link itself instead of the file\n  the link points to.",
    "posix.rename" => "Rename a file or directory.\n\nIf either src_dir_fd or dst_dir_fd is not None, it should be a file\n  descriptor open to a directory, and the respective path string (src or dst)\n  should be relative; the path will then be relative to that directory.\nsrc_dir_fd and dst_dir_fd, may not be implemented on your platform.\n  If they are unavailable, using them will raise a NotImplementedError.",
    "posix.replace" => "Rename a file or directory, overwriting the destination.\n\nIf either src_dir_fd or dst_dir_fd is not None, it should be a file\n  descriptor open to a directory, and the respective path string (src or dst)\n  should be relative; the path will then be relative to that directory.\nsrc_dir_fd and dst_dir_fd, may not be implemented on your platform.\n  If they are unavailable, using them will raise a NotImplementedError.",
    "posix.rmdir" => "Remove a directory.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.",
    "posix.scandir" => "Return an iterator of DirEntry objects for given path.\n\npath can be specified as either str, bytes, or a path-like object.  If path\nis bytes, the names of yielded DirEntry objects will also be bytes; in\nall other circumstances they will be str.\n\nIf path is None, uses the path='.'.",
    "posix.sched_get_priority_max" => "Get the maximum scheduling priority for policy.",
    "posix.sched_get_priority_min" => "Get the minimum scheduling priority for policy.",
    "posix.sched_getaffinity" => "Return the affinity of the process identified by pid (or the current process if zero).\n\nThe affinity is returned as a set of CPU identifiers.",
    "posix.sched_getparam" => "Returns scheduling parameters for the process identified by pid.\n\nIf pid is 0, returns parameters for the calling process.\nReturn value is an instance of sched_param.",
    "posix.sched_getscheduler" => "Get the scheduling policy for the process identified by pid.\n\nPassing 0 for pid returns the scheduling policy for the calling process.",
    "posix.sched_param" => "Currently has only one field: sched_priority\n\nsched_priority\n  A scheduling parameter.",
    "posix.sched_param.__add__" => "Return self+value.",
    "posix.sched_param.__class_getitem__" => "See PEP 585",
    "posix.sched_param.__contains__" => "Return bool(key in self).",
    "posix.sched_param.__delattr__" => "Implement delattr(self, name).",
    "posix.sched_param.__eq__" => "Return self==value.",
    "posix.sched_param.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "posix.sched_param.__ge__" => "Return self>=value.",
    "posix.sched_param.__getattribute__" => "Return getattr(self, name).",
    "posix.sched_param.__getitem__" => "Return self[key].",
    "posix.sched_param.__getstate__" => "Helper for pickle.",
    "posix.sched_param.__gt__" => "Return self>value.",
    "posix.sched_param.__hash__" => "Return hash(self).",
    "posix.sched_param.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "posix.sched_param.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "posix.sched_param.__iter__" => "Implement iter(self).",
    "posix.sched_param.__le__" => "Return self<=value.",
    "posix.sched_param.__len__" => "Return len(self).",
    "posix.sched_param.__lt__" => "Return self<value.",
    "posix.sched_param.__mul__" => "Return self*value.",
    "posix.sched_param.__ne__" => "Return self!=value.",
    "posix.sched_param.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "posix.sched_param.__reduce_ex__" => "Helper for pickle.",
    "posix.sched_param.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "posix.sched_param.__repr__" => "Return repr(self).",
    "posix.sched_param.__rmul__" => "Return value*self.",
    "posix.sched_param.__setattr__" => "Implement setattr(self, name, value).",
    "posix.sched_param.__sizeof__" => "Size of object in memory, in bytes.",
    "posix.sched_param.__str__" => "Return str(self).",
    "posix.sched_param.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "posix.sched_param.count" => "Return number of occurrences of value.",
    "posix.sched_param.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "posix.sched_param.sched_priority" => "the scheduling priority",
    "posix.sched_rr_get_interval" => "Return the round-robin quantum for the process identified by pid, in seconds.\n\nValue returned is a float.",
    "posix.sched_setaffinity" => "Set the CPU affinity of the process identified by pid to mask.\n\nmask should be an iterable of integers identifying CPUs.",
    "posix.sched_setparam" => "Set scheduling parameters for the process identified by pid.\n\nIf pid is 0, sets parameters for the calling process.\nparam should be an instance of sched_param.",
    "posix.sched_setscheduler" => "Set the scheduling policy for the process identified by pid.\n\nIf pid is 0, the calling process is changed.\nparam is an instance of sched_param.",
    "posix.sched_yield" => "Voluntarily relinquish the CPU.",
    "posix.sendfile" => "Copy count bytes from file descriptor in_fd to file descriptor out_fd.",
    "posix.set_blocking" => "Set the blocking mode of the specified file descriptor.\n\nSet the O_NONBLOCK flag if blocking is False,\nclear the O_NONBLOCK flag otherwise.",
    "posix.set_inheritable" => "Set the inheritable flag of the specified file descriptor.",
    "posix.setegid" => "Set the current process's effective group id.",
    "posix.seteuid" => "Set the current process's effective user id.",
    "posix.setgid" => "Set the current process's group id.",
    "posix.setgroups" => "Set the groups of the current process to list.",
    "posix.setns" => "Move the calling thread into different namespaces.\n\nfd\n  A file descriptor to a namespace.\nnstype\n  Type of namespace.",
    "posix.setpgid" => "Call the system call setpgid(pid, pgrp).",
    "posix.setpgrp" => "Make the current process the leader of its process group.",
    "posix.setpriority" => "Set program scheduling priority.",
    "posix.setregid" => "Set the current process's real and effective group ids.",
    "posix.setresgid" => "Set the current process's real, effective, and saved group ids.",
    "posix.setresuid" => "Set the current process's real, effective, and saved user ids.",
    "posix.setreuid" => "Set the current process's real and effective user ids.",
    "posix.setsid" => "Call the system call setsid().",
    "posix.setuid" => "Set the current process's user id.",
    "posix.setxattr" => "Set extended attribute attribute on path to value.\n\npath may be either a string, a path-like object,  or an open file descriptor.\nIf follow_symlinks is False, and the last element of the path is a symbolic\n  link, setxattr will modify the symbolic link itself instead of the file\n  the link points to.",
    "posix.splice" => "Transfer count bytes from one pipe to a descriptor or vice versa.\n\n  src\n    Source file descriptor.\n  dst\n    Destination file descriptor.\n  count\n    Number of bytes to copy.\n  offset_src\n    Starting offset in src.\n  offset_dst\n    Starting offset in dst.\n  flags\n    Flags to modify the semantics of the call.\n\nIf offset_src is None, then src is read from the current position;\nrespectively for offset_dst. The offset associated to the file\ndescriptor that refers to a pipe must be None.",
    "posix.stat" => "Perform a stat system call on the given path.\n\n  path\n    Path to be examined; can be string, bytes, a path-like object or\n    open-file-descriptor int.\n  dir_fd\n    If not None, it should be a file descriptor open to a directory,\n    and path should be a relative string; path will then be relative to\n    that directory.\n  follow_symlinks\n    If False, and the last element of the path is a symbolic link,\n    stat will examine the symbolic link itself instead of the file\n    the link points to.\n\ndir_fd and follow_symlinks may not be implemented\n  on your platform.  If they are unavailable, using them will raise a\n  NotImplementedError.\n\nIt's an error to use dir_fd or follow_symlinks when specifying path as\n  an open file descriptor.",
    "posix.statvfs" => "Perform a statvfs system call on the given path.\n\npath may always be specified as a string.\nOn some platforms, path may also be specified as an open file descriptor.\n  If this functionality is unavailable, using it raises an exception.",
    "posix.strerror" => "Translate an error code to a message string.",
    "posix.symlink" => "Create a symbolic link pointing to src named dst.\n\ntarget_is_directory is required on Windows if the target is to be\n  interpreted as a directory.  (On Windows, symlink requires\n  Windows 6.0 or greater, and raises a NotImplementedError otherwise.)\n  target_is_directory is ignored on non-Windows platforms.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.",
    "posix.sync" => "Force write of everything to disk.",
    "posix.sysconf" => "Return an integer-valued system configuration variable.",
    "posix.system" => "Execute the command in a subshell.",
    "posix.tcgetpgrp" => "Return the process group associated with the terminal specified by fd.",
    "posix.tcsetpgrp" => "Set the process group associated with the terminal specified by fd.",
    "posix.timerfd_create" => "Create and return a timer file descriptor.\n\nclockid\n  A valid clock ID constant as timer file descriptor.\n\n  time.CLOCK_REALTIME\n  time.CLOCK_MONOTONIC\n  time.CLOCK_BOOTTIME\nflags\n  0 or a bit mask of os.TFD_NONBLOCK or os.TFD_CLOEXEC.\n\n  os.TFD_NONBLOCK\n      If *TFD_NONBLOCK* is set as a flag, read doesn't blocks.\n      If *TFD_NONBLOCK* is not set as a flag, read block until the timer fires.\n\n  os.TFD_CLOEXEC\n      If *TFD_CLOEXEC* is set as a flag, enable the close-on-exec flag",
    "posix.timerfd_gettime" => "Return a tuple of a timer file descriptor's (interval, next expiration) in float seconds.\n\nfd\n  A timer file descriptor.",
    "posix.timerfd_gettime_ns" => "Return a tuple of a timer file descriptor's (interval, next expiration) in nanoseconds.\n\nfd\n  A timer file descriptor.",
    "posix.timerfd_settime" => "Alter a timer file descriptor's internal timer in seconds.\n\nfd\n  A timer file descriptor.\nflags\n  0 or a bit mask of TFD_TIMER_ABSTIME or TFD_TIMER_CANCEL_ON_SET.\ninitial\n  The initial expiration time, in seconds.\ninterval\n  The timer's interval, in seconds.",
    "posix.timerfd_settime_ns" => "Alter a timer file descriptor's internal timer in nanoseconds.\n\nfd\n  A timer file descriptor.\nflags\n  0 or a bit mask of TFD_TIMER_ABSTIME or TFD_TIMER_CANCEL_ON_SET.\ninitial\n  initial expiration timing in seconds.\ninterval\n  interval for the timer in seconds.",
    "posix.times" => "Return a collection containing process timing information.\n\nThe object returned behaves like a named tuple with these fields:\n  (utime, stime, cutime, cstime, elapsed_time)\nAll fields are floating-point numbers.",
    "posix.times_result" => "times_result: Result from os.times().\n\nThis object may be accessed either as a tuple of\n  (user, system, children_user, children_system, elapsed),\nor via the attributes user, system, children_user, children_system,\nand elapsed.\n\nSee os.times for more information.",
    "posix.times_result.__add__" => "Return self+value.",
    "posix.times_result.__class_getitem__" => "See PEP 585",
    "posix.times_result.__contains__" => "Return bool(key in self).",
    "posix.times_result.__delattr__" => "Implement delattr(self, name).",
    "posix.times_result.__eq__" => "Return self==value.",
    "posix.times_result.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "posix.times_result.__ge__" => "Return self>=value.",
    "posix.times_result.__getattribute__" => "Return getattr(self, name).",
    "posix.times_result.__getitem__" => "Return self[key].",
    "posix.times_result.__getstate__" => "Helper for pickle.",
    "posix.times_result.__gt__" => "Return self>value.",
    "posix.times_result.__hash__" => "Return hash(self).",
    "posix.times_result.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "posix.times_result.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "posix.times_result.__iter__" => "Implement iter(self).",
    "posix.times_result.__le__" => "Return self<=value.",
    "posix.times_result.__len__" => "Return len(self).",
    "posix.times_result.__lt__" => "Return self<value.",
    "posix.times_result.__mul__" => "Return self*value.",
    "posix.times_result.__ne__" => "Return self!=value.",
    "posix.times_result.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "posix.times_result.__reduce_ex__" => "Helper for pickle.",
    "posix.times_result.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "posix.times_result.__repr__" => "Return repr(self).",
    "posix.times_result.__rmul__" => "Return value*self.",
    "posix.times_result.__setattr__" => "Implement setattr(self, name, value).",
    "posix.times_result.__sizeof__" => "Size of object in memory, in bytes.",
    "posix.times_result.__str__" => "Return str(self).",
    "posix.times_result.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "posix.times_result.children_system" => "system time of children",
    "posix.times_result.children_user" => "user time of children",
    "posix.times_result.count" => "Return number of occurrences of value.",
    "posix.times_result.elapsed" => "elapsed time since an arbitrary point in the past",
    "posix.times_result.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "posix.times_result.system" => "system time",
    "posix.times_result.user" => "user time",
    "posix.truncate" => "Truncate a file, specified by path, to a specific length.\n\nOn some platforms, path may also be specified as an open file descriptor.\n  If this functionality is unavailable, using it raises an exception.",
    "posix.ttyname" => "Return the name of the terminal device connected to 'fd'.\n\nfd\n  Integer file descriptor handle.",
    "posix.umask" => "Set the current numeric umask and return the previous umask.",
    "posix.uname" => "Return an object identifying the current operating system.\n\nThe object behaves like a named tuple with the following fields:\n  (sysname, nodename, release, version, machine)",
    "posix.uname_result" => "uname_result: Result from os.uname().\n\nThis object may be accessed either as a tuple of\n  (sysname, nodename, release, version, machine),\nor via the attributes sysname, nodename, release, version, and machine.\n\nSee os.uname for more information.",
    "posix.uname_result.__add__" => "Return self+value.",
    "posix.uname_result.__class_getitem__" => "See PEP 585",
    "posix.uname_result.__contains__" => "Return bool(key in self).",
    "posix.uname_result.__delattr__" => "Implement delattr(self, name).",
    "posix.uname_result.__eq__" => "Return self==value.",
    "posix.uname_result.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "posix.uname_result.__ge__" => "Return self>=value.",
    "posix.uname_result.__getattribute__" => "Return getattr(self, name).",
    "posix.uname_result.__getitem__" => "Return self[key].",
    "posix.uname_result.__getstate__" => "Helper for pickle.",
    "posix.uname_result.__gt__" => "Return self>value.",
    "posix.uname_result.__hash__" => "Return hash(self).",
    "posix.uname_result.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "posix.uname_result.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "posix.uname_result.__iter__" => "Implement iter(self).",
    "posix.uname_result.__le__" => "Return self<=value.",
    "posix.uname_result.__len__" => "Return len(self).",
    "posix.uname_result.__lt__" => "Return self<value.",
    "posix.uname_result.__mul__" => "Return self*value.",
    "posix.uname_result.__ne__" => "Return self!=value.",
    "posix.uname_result.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "posix.uname_result.__reduce_ex__" => "Helper for pickle.",
    "posix.uname_result.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "posix.uname_result.__repr__" => "Return repr(self).",
    "posix.uname_result.__rmul__" => "Return value*self.",
    "posix.uname_result.__setattr__" => "Implement setattr(self, name, value).",
    "posix.uname_result.__sizeof__" => "Size of object in memory, in bytes.",
    "posix.uname_result.__str__" => "Return str(self).",
    "posix.uname_result.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "posix.uname_result.count" => "Return number of occurrences of value.",
    "posix.uname_result.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "posix.uname_result.machine" => "hardware identifier",
    "posix.uname_result.nodename" => "name of machine on network (implementation-defined)",
    "posix.uname_result.release" => "operating system release",
    "posix.uname_result.sysname" => "operating system name",
    "posix.uname_result.version" => "operating system version",
    "posix.unlink" => "Remove a file (same as remove()).\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.",
    "posix.unlockpt" => "Unlock a pseudo-terminal master/slave pair.\n\n  fd\n    File descriptor of a master pseudo-terminal device.\n\nPerforms an unlockpt() C function call.",
    "posix.unsetenv" => "Delete an environment variable.",
    "posix.unshare" => "Disassociate parts of a process (or thread) execution context.\n\nflags\n  Namespaces to be unshared.",
    "posix.urandom" => "Return a bytes object containing random bytes suitable for cryptographic use.",
    "posix.utime" => "Set the access and modified time of path.\n\npath may always be specified as a string.\nOn some platforms, path may also be specified as an open file descriptor.\n  If this functionality is unavailable, using it raises an exception.\n\nIf times is not None, it must be a tuple (atime, mtime);\n    atime and mtime should be expressed as float seconds since the epoch.\nIf ns is specified, it must be a tuple (atime_ns, mtime_ns);\n    atime_ns and mtime_ns should be expressed as integer nanoseconds\n    since the epoch.\nIf times is None and ns is unspecified, utime uses the current time.\nSpecifying tuples for both times and ns is an error.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\nIf follow_symlinks is False, and the last element of the path is a symbolic\n  link, utime will modify the symbolic link itself instead of the file the\n  link points to.\nIt is an error to use dir_fd or follow_symlinks when specifying path\n  as an open file descriptor.\ndir_fd and follow_symlinks may not be available on your platform.\n  If they are unavailable, using them will raise a NotImplementedError.",
    "posix.wait" => "Wait for completion of a child process.\n\nReturns a tuple of information about the child process:\n    (pid, status)",
    "posix.wait3" => "Wait for completion of a child process.\n\nReturns a tuple of information about the child process:\n  (pid, status, rusage)",
    "posix.wait4" => "Wait for completion of a specific child process.\n\nReturns a tuple of information about the child process:\n  (pid, status, rusage)",
    "posix.waitid" => "Returns the result of waiting for a process or processes.\n\n  idtype\n    Must be one of be P_PID, P_PGID or P_ALL.\n  id\n    The id to wait on.\n  options\n    Constructed from the ORing of one or more of WEXITED, WSTOPPED\n    or WCONTINUED and additionally may be ORed with WNOHANG or WNOWAIT.\n\nReturns either waitid_result or None if WNOHANG is specified and there are\nno children in a waitable state.",
    "posix.waitid_result" => "waitid_result: Result from waitid.\n\nThis object may be accessed either as a tuple of\n  (si_pid, si_uid, si_signo, si_status, si_code),\nor via the attributes si_pid, si_uid, and so on.\n\nSee os.waitid for more information.",
    "posix.waitid_result.__add__" => "Return self+value.",
    "posix.waitid_result.__class_getitem__" => "See PEP 585",
    "posix.waitid_result.__contains__" => "Return bool(key in self).",
    "posix.waitid_result.__delattr__" => "Implement delattr(self, name).",
    "posix.waitid_result.__eq__" => "Return self==value.",
    "posix.waitid_result.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "posix.waitid_result.__ge__" => "Return self>=value.",
    "posix.waitid_result.__getattribute__" => "Return getattr(self, name).",
    "posix.waitid_result.__getitem__" => "Return self[key].",
    "posix.waitid_result.__getstate__" => "Helper for pickle.",
    "posix.waitid_result.__gt__" => "Return self>value.",
    "posix.waitid_result.__hash__" => "Return hash(self).",
    "posix.waitid_result.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "posix.waitid_result.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "posix.waitid_result.__iter__" => "Implement iter(self).",
    "posix.waitid_result.__le__" => "Return self<=value.",
    "posix.waitid_result.__len__" => "Return len(self).",
    "posix.waitid_result.__lt__" => "Return self<value.",
    "posix.waitid_result.__mul__" => "Return self*value.",
    "posix.waitid_result.__ne__" => "Return self!=value.",
    "posix.waitid_result.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "posix.waitid_result.__reduce_ex__" => "Helper for pickle.",
    "posix.waitid_result.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "posix.waitid_result.__repr__" => "Return repr(self).",
    "posix.waitid_result.__rmul__" => "Return value*self.",
    "posix.waitid_result.__setattr__" => "Implement setattr(self, name, value).",
    "posix.waitid_result.__sizeof__" => "Size of object in memory, in bytes.",
    "posix.waitid_result.__str__" => "Return str(self).",
    "posix.waitid_result.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "posix.waitid_result.count" => "Return number of occurrences of value.",
    "posix.waitid_result.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "posix.waitpid" => "Wait for completion of a given child process.\n\nReturns a tuple of information regarding the child process:\n    (pid, status)\n\nThe options argument is ignored on Windows.",
    "posix.waitstatus_to_exitcode" => "Convert a wait status to an exit code.\n\nOn Unix:\n\n* If WIFEXITED(status) is true, return WEXITSTATUS(status).\n* If WIFSIGNALED(status) is true, return -WTERMSIG(status).\n* Otherwise, raise a ValueError.\n\nOn Windows, return status shifted right by 8 bits.\n\nOn Unix, if the process is being traced or if waitpid() was called with\nWUNTRACED option, the caller must first check if WIFSTOPPED(status) is true.\nThis function must not be called if WIFSTOPPED(status) is true.",
    "posix.write" => "Write a bytes object to a file descriptor.",
    "posix.writev" => "Iterate over buffers, and write the contents of each to a file descriptor.\n\nReturns the total number of bytes written.\nbuffers must be a sequence of bytes-like objects.",
    "pwd" => "This module provides access to the Unix password database.\nIt is available on all Unix versions.\n\nPassword database entries are reported as 7-tuples containing the following\nitems from the password database (see `<pwd.h>'), in order:\npw_name, pw_passwd, pw_uid, pw_gid, pw_gecos, pw_dir, pw_shell.\nThe uid and gid items are integers, all others are strings. An\nexception is raised if the entry asked for cannot be found.",
    "pwd.getpwall" => "Return a list of all available password database entries, in arbitrary order.\n\nSee help(pwd) for more on password database entries.",
    "pwd.getpwnam" => "Return the password database entry for the given user name.\n\nSee `help(pwd)` for more on password database entries.",
    "pwd.getpwuid" => "Return the password database entry for the given numeric user ID.\n\nSee `help(pwd)` for more on password database entries.",
    "pwd.struct_passwd" => "pwd.struct_passwd: Results from getpw*() routines.\n\nThis object may be accessed either as a tuple of\n  (pw_name,pw_passwd,pw_uid,pw_gid,pw_gecos,pw_dir,pw_shell)\nor via the object attributes as named in the above tuple.",
    "pwd.struct_passwd.__add__" => "Return self+value.",
    "pwd.struct_passwd.__class_getitem__" => "See PEP 585",
    "pwd.struct_passwd.__contains__" => "Return bool(key in self).",
    "pwd.struct_passwd.__delattr__" => "Implement delattr(self, name).",
    "pwd.struct_passwd.__eq__" => "Return self==value.",
    "pwd.struct_passwd.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "pwd.struct_passwd.__ge__" => "Return self>=value.",
    "pwd.struct_passwd.__getattribute__" => "Return getattr(self, name).",
    "pwd.struct_passwd.__getitem__" => "Return self[key].",
    "pwd.struct_passwd.__getstate__" => "Helper for pickle.",
    "pwd.struct_passwd.__gt__" => "Return self>value.",
    "pwd.struct_passwd.__hash__" => "Return hash(self).",
    "pwd.struct_passwd.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "pwd.struct_passwd.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "pwd.struct_passwd.__iter__" => "Implement iter(self).",
    "pwd.struct_passwd.__le__" => "Return self<=value.",
    "pwd.struct_passwd.__len__" => "Return len(self).",
    "pwd.struct_passwd.__lt__" => "Return self<value.",
    "pwd.struct_passwd.__mul__" => "Return self*value.",
    "pwd.struct_passwd.__ne__" => "Return self!=value.",
    "pwd.struct_passwd.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "pwd.struct_passwd.__reduce_ex__" => "Helper for pickle.",
    "pwd.struct_passwd.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "pwd.struct_passwd.__repr__" => "Return repr(self).",
    "pwd.struct_passwd.__rmul__" => "Return value*self.",
    "pwd.struct_passwd.__setattr__" => "Implement setattr(self, name, value).",
    "pwd.struct_passwd.__sizeof__" => "Size of object in memory, in bytes.",
    "pwd.struct_passwd.__str__" => "Return str(self).",
    "pwd.struct_passwd.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "pwd.struct_passwd.count" => "Return number of occurrences of value.",
    "pwd.struct_passwd.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "pwd.struct_passwd.pw_dir" => "home directory",
    "pwd.struct_passwd.pw_gecos" => "real name",
    "pwd.struct_passwd.pw_gid" => "group id",
    "pwd.struct_passwd.pw_name" => "user name",
    "pwd.struct_passwd.pw_passwd" => "password",
    "pwd.struct_passwd.pw_shell" => "shell program",
    "pwd.struct_passwd.pw_uid" => "user id",
    "pyexpat" => "Python wrapper for Expat parser.",
    "pyexpat.ErrorString" => "Returns string error for given number.",
    "pyexpat.ParserCreate" => "Return a new XML parser object.",
    "pyexpat.XMLParserType" => "XML parser",
    "pyexpat.XMLParserType.ExternalEntityParserCreate" => "Create a parser for parsing an external entity based on the information passed to the ExternalEntityRefHandler.",
    "pyexpat.XMLParserType.GetBase" => "Return base URL string for the parser.",
    "pyexpat.XMLParserType.GetInputContext" => "Return the untranslated text of the input that caused the current event.\n\nIf the event was generated by a large amount of text (such as a start tag\nfor an element with many attributes), not all of the text may be available.",
    "pyexpat.XMLParserType.GetReparseDeferralEnabled" => "Retrieve reparse deferral enabled status; always returns false with Expat <2.6.0.",
    "pyexpat.XMLParserType.Parse" => "Parse XML data.\n\n`isfinal' should be true at end of input.",
    "pyexpat.XMLParserType.ParseFile" => "Parse XML data from file-like object.",
    "pyexpat.XMLParserType.SetBase" => "Set the base URL for the parser.",
    "pyexpat.XMLParserType.SetParamEntityParsing" => "Controls parsing of parameter entities (including the external DTD subset).\n\nPossible flag values are XML_PARAM_ENTITY_PARSING_NEVER,\nXML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE and\nXML_PARAM_ENTITY_PARSING_ALWAYS. Returns true if setting the flag\nwas successful.",
    "pyexpat.XMLParserType.SetReparseDeferralEnabled" => "Enable/Disable reparse deferral; enabled by default with Expat >=2.6.0.",
    "pyexpat.XMLParserType.UseForeignDTD" => "Allows the application to provide an artificial external subset if one is not specified as part of the document instance.\n\nThis readily allows the use of a 'default' document type controlled by the\napplication, while still getting the advantage of providing document type\ninformation to the parser. 'flag' defaults to True if not provided.",
    "pyexpat.XMLParserType.__delattr__" => "Implement delattr(self, name).",
    "pyexpat.XMLParserType.__eq__" => "Return self==value.",
    "pyexpat.XMLParserType.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "pyexpat.XMLParserType.__ge__" => "Return self>=value.",
    "pyexpat.XMLParserType.__getattribute__" => "Return getattr(self, name).",
    "pyexpat.XMLParserType.__getstate__" => "Helper for pickle.",
    "pyexpat.XMLParserType.__gt__" => "Return self>value.",
    "pyexpat.XMLParserType.__hash__" => "Return hash(self).",
    "pyexpat.XMLParserType.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "pyexpat.XMLParserType.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "pyexpat.XMLParserType.__le__" => "Return self<=value.",
    "pyexpat.XMLParserType.__lt__" => "Return self<value.",
    "pyexpat.XMLParserType.__ne__" => "Return self!=value.",
    "pyexpat.XMLParserType.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "pyexpat.XMLParserType.__reduce__" => "Helper for pickle.",
    "pyexpat.XMLParserType.__reduce_ex__" => "Helper for pickle.",
    "pyexpat.XMLParserType.__repr__" => "Return repr(self).",
    "pyexpat.XMLParserType.__setattr__" => "Implement setattr(self, name, value).",
    "pyexpat.XMLParserType.__sizeof__" => "Size of object in memory, in bytes.",
    "pyexpat.XMLParserType.__str__" => "Return str(self).",
    "pyexpat.XMLParserType.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "readline" => "Importing this module enables command line editing using GNU readline.",
    "readline.add_history" => "Add an item to the history buffer.",
    "readline.append_history_file" => "Append the last nelements items of the history list to file.\n\nThe default filename is ~/.history.",
    "readline.clear_history" => "Clear the current readline history.",
    "readline.get_begidx" => "Get the beginning index of the completion scope.",
    "readline.get_completer" => "Get the current completer function.",
    "readline.get_completer_delims" => "Get the word delimiters for completion.",
    "readline.get_completion_type" => "Get the type of completion being attempted.",
    "readline.get_current_history_length" => "Return the current (not the maximum) length of history.",
    "readline.get_endidx" => "Get the ending index of the completion scope.",
    "readline.get_history_item" => "Return the current contents of history item at one-based index.",
    "readline.get_history_length" => "Return the maximum number of lines that will be written to the history file.",
    "readline.get_line_buffer" => "Return the current contents of the line buffer.",
    "readline.insert_text" => "Insert text into the line buffer at the cursor position.",
    "readline.parse_and_bind" => "Execute the init line provided in the string argument.",
    "readline.read_history_file" => "Load a readline history file.\n\nThe default filename is ~/.history.",
    "readline.read_init_file" => "Execute a readline initialization file.\n\nThe default filename is the last filename used.",
    "readline.redisplay" => "Change what's displayed on the screen to reflect contents of the line buffer.",
    "readline.remove_history_item" => "Remove history item given by its zero-based position.",
    "readline.replace_history_item" => "Replaces history item given by its position with contents of line.\n\npos is zero-based.",
    "readline.set_auto_history" => "Enables or disables automatic history.",
    "readline.set_completer" => "Set or remove the completer function.\n\nThe function is called as function(text, state),\nfor state in 0, 1, 2, ..., until it returns a non-string.\nIt should return the next possible completion starting with 'text'.",
    "readline.set_completer_delims" => "Set the word delimiters for completion.",
    "readline.set_completion_display_matches_hook" => "Set or remove the completion display function.\n\nThe function is called as\n  function(substitution, [matches], longest_match_length)\nonce each time matches need to be displayed.",
    "readline.set_history_length" => "Set the maximal number of lines which will be written to the history file.\n\nA negative length is used to inhibit history truncation.",
    "readline.set_pre_input_hook" => "Set or remove the function invoked by the rl_pre_input_hook callback.\n\nThe function is called with no arguments after the first prompt\nhas been printed and just before readline starts reading input\ncharacters.",
    "readline.set_startup_hook" => "Set or remove the function invoked by the rl_startup_hook callback.\n\nThe function is called with no arguments just\nbefore readline prints the first prompt.",
    "readline.write_history_file" => "Save a readline history file.\n\nThe default filename is ~/.history.",
    "resource.struct_rusage" => "struct_rusage: Result from getrusage.\n\nThis object may be accessed either as a tuple of\n    (utime,stime,maxrss,ixrss,idrss,isrss,minflt,majflt,\n    nswap,inblock,oublock,msgsnd,msgrcv,nsignals,nvcsw,nivcsw)\nor via the attributes ru_utime, ru_stime, ru_maxrss, and so on.",
    "resource.struct_rusage.__add__" => "Return self+value.",
    "resource.struct_rusage.__class_getitem__" => "See PEP 585",
    "resource.struct_rusage.__contains__" => "Return bool(key in self).",
    "resource.struct_rusage.__delattr__" => "Implement delattr(self, name).",
    "resource.struct_rusage.__eq__" => "Return self==value.",
    "resource.struct_rusage.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "resource.struct_rusage.__ge__" => "Return self>=value.",
    "resource.struct_rusage.__getattribute__" => "Return getattr(self, name).",
    "resource.struct_rusage.__getitem__" => "Return self[key].",
    "resource.struct_rusage.__getstate__" => "Helper for pickle.",
    "resource.struct_rusage.__gt__" => "Return self>value.",
    "resource.struct_rusage.__hash__" => "Return hash(self).",
    "resource.struct_rusage.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "resource.struct_rusage.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "resource.struct_rusage.__iter__" => "Implement iter(self).",
    "resource.struct_rusage.__le__" => "Return self<=value.",
    "resource.struct_rusage.__len__" => "Return len(self).",
    "resource.struct_rusage.__lt__" => "Return self<value.",
    "resource.struct_rusage.__mul__" => "Return self*value.",
    "resource.struct_rusage.__ne__" => "Return self!=value.",
    "resource.struct_rusage.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "resource.struct_rusage.__reduce_ex__" => "Helper for pickle.",
    "resource.struct_rusage.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "resource.struct_rusage.__repr__" => "Return repr(self).",
    "resource.struct_rusage.__rmul__" => "Return value*self.",
    "resource.struct_rusage.__setattr__" => "Implement setattr(self, name, value).",
    "resource.struct_rusage.__sizeof__" => "Size of object in memory, in bytes.",
    "resource.struct_rusage.__str__" => "Return str(self).",
    "resource.struct_rusage.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "resource.struct_rusage.count" => "Return number of occurrences of value.",
    "resource.struct_rusage.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "resource.struct_rusage.ru_idrss" => "unshared data size",
    "resource.struct_rusage.ru_inblock" => "block input operations",
    "resource.struct_rusage.ru_isrss" => "unshared stack size",
    "resource.struct_rusage.ru_ixrss" => "shared memory size",
    "resource.struct_rusage.ru_majflt" => "page faults requiring I/O",
    "resource.struct_rusage.ru_maxrss" => "max. resident set size",
    "resource.struct_rusage.ru_minflt" => "page faults not requiring I/O",
    "resource.struct_rusage.ru_msgrcv" => "IPC messages received",
    "resource.struct_rusage.ru_msgsnd" => "IPC messages sent",
    "resource.struct_rusage.ru_nivcsw" => "involuntary context switches",
    "resource.struct_rusage.ru_nsignals" => "signals received",
    "resource.struct_rusage.ru_nswap" => "number of swap outs",
    "resource.struct_rusage.ru_nvcsw" => "voluntary context switches",
    "resource.struct_rusage.ru_oublock" => "block output operations",
    "resource.struct_rusage.ru_stime" => "system time used",
    "resource.struct_rusage.ru_utime" => "user time used",
    "select" => "This module supports asynchronous I/O on multiple file descriptors.\n\n*** IMPORTANT NOTICE ***\nOn Windows, only sockets are supported; on Unix, all file descriptors.",
    "select.epoll" => "select.epoll(sizehint=-1, flags=0)\n\nReturns an epolling object\n\nsizehint must be a positive integer or -1 for the default size. The\nsizehint is used to optimize internal data structures. It doesn't limit\nthe maximum number of monitored events.",
    "select.epoll.__delattr__" => "Implement delattr(self, name).",
    "select.epoll.__eq__" => "Return self==value.",
    "select.epoll.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "select.epoll.__ge__" => "Return self>=value.",
    "select.epoll.__getattribute__" => "Return getattr(self, name).",
    "select.epoll.__getstate__" => "Helper for pickle.",
    "select.epoll.__gt__" => "Return self>value.",
    "select.epoll.__hash__" => "Return hash(self).",
    "select.epoll.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "select.epoll.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "select.epoll.__le__" => "Return self<=value.",
    "select.epoll.__lt__" => "Return self<value.",
    "select.epoll.__ne__" => "Return self!=value.",
    "select.epoll.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "select.epoll.__reduce__" => "Helper for pickle.",
    "select.epoll.__reduce_ex__" => "Helper for pickle.",
    "select.epoll.__repr__" => "Return repr(self).",
    "select.epoll.__setattr__" => "Implement setattr(self, name, value).",
    "select.epoll.__sizeof__" => "Size of object in memory, in bytes.",
    "select.epoll.__str__" => "Return str(self).",
    "select.epoll.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "select.epoll.close" => "Close the epoll control file descriptor.\n\nFurther operations on the epoll object will raise an exception.",
    "select.epoll.closed" => "True if the epoll handler is closed",
    "select.epoll.fileno" => "Return the epoll control file descriptor.",
    "select.epoll.fromfd" => "Create an epoll object from a given control fd.",
    "select.epoll.modify" => "Modify event mask for a registered file descriptor.\n\nfd\n  the target file descriptor of the operation\neventmask\n  a bit set composed of the various EPOLL constants",
    "select.epoll.poll" => "Wait for events on the epoll file descriptor.\n\n  timeout\n    the maximum time to wait in seconds (as float);\n    a timeout of None or -1 makes poll wait indefinitely\n  maxevents\n    the maximum number of events returned; -1 means no limit\n\nReturns a list containing any descriptors that have events to report,\nas a list of (fd, events) 2-tuples.",
    "select.epoll.register" => "Registers a new fd or raises an OSError if the fd is already registered.\n\n  fd\n    the target file descriptor of the operation\n  eventmask\n    a bit set composed of the various EPOLL constants\n\nThe epoll interface supports all file descriptors that support poll.",
    "select.epoll.unregister" => "Remove a registered file descriptor from the epoll object.\n\nfd\n  the target file descriptor of the operation",
    "select.kevent" => "kevent(ident, filter=KQ_FILTER_READ, flags=KQ_EV_ADD, fflags=0, data=0, udata=0)\n\nThis object is the equivalent of the struct kevent for the C API.\n\nSee the kqueue manpage for more detailed information about the meaning\nof the arguments.\n\nOne minor note: while you might hope that udata could store a\nreference to a python object, it cannot, because it is impossible to\nkeep a proper reference count of the object once it's passed into the\nkernel. Therefore, I have restricted it to only storing an integer.  I\nrecommend ignoring it and simply using the 'ident' field to key off\nof. You could also set up a dictionary on the python side to store a\nudata->object mapping.",
    "select.kevent.__delattr__" => "Implement delattr(self, name).",
    "select.kevent.__eq__" => "Return self==value.",
    "select.kevent.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "select.kevent.__ge__" => "Return self>=value.",
    "select.kevent.__getattribute__" => "Return getattr(self, name).",
    "select.kevent.__getstate__" => "Helper for pickle.",
    "select.kevent.__gt__" => "Return self>value.",
    "select.kevent.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "select.kevent.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "select.kevent.__le__" => "Return self<=value.",
    "select.kevent.__lt__" => "Return self<value.",
    "select.kevent.__ne__" => "Return self!=value.",
    "select.kevent.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "select.kevent.__reduce__" => "Helper for pickle.",
    "select.kevent.__reduce_ex__" => "Helper for pickle.",
    "select.kevent.__repr__" => "Return repr(self).",
    "select.kevent.__setattr__" => "Implement setattr(self, name, value).",
    "select.kevent.__sizeof__" => "Size of object in memory, in bytes.",
    "select.kevent.__str__" => "Return str(self).",
    "select.kevent.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "select.kqueue" => "Kqueue syscall wrapper.\n\nFor example, to start watching a socket for input:\n>>> kq = kqueue()\n>>> sock = socket()\n>>> sock.connect((host, port))\n>>> kq.control([kevent(sock, KQ_FILTER_WRITE, KQ_EV_ADD)], 0)\n\nTo wait one second for it to become writeable:\n>>> kq.control(None, 1, 1000)\n\nTo stop listening:\n>>> kq.control([kevent(sock, KQ_FILTER_WRITE, KQ_EV_DELETE)], 0)",
    "select.kqueue.__del__" => "Called when the instance is about to be destroyed.",
    "select.kqueue.__delattr__" => "Implement delattr(self, name).",
    "select.kqueue.__eq__" => "Return self==value.",
    "select.kqueue.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "select.kqueue.__ge__" => "Return self>=value.",
    "select.kqueue.__getattribute__" => "Return getattr(self, name).",
    "select.kqueue.__getstate__" => "Helper for pickle.",
    "select.kqueue.__gt__" => "Return self>value.",
    "select.kqueue.__hash__" => "Return hash(self).",
    "select.kqueue.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "select.kqueue.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "select.kqueue.__le__" => "Return self<=value.",
    "select.kqueue.__lt__" => "Return self<value.",
    "select.kqueue.__ne__" => "Return self!=value.",
    "select.kqueue.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "select.kqueue.__reduce__" => "Helper for pickle.",
    "select.kqueue.__reduce_ex__" => "Helper for pickle.",
    "select.kqueue.__repr__" => "Return repr(self).",
    "select.kqueue.__setattr__" => "Implement setattr(self, name, value).",
    "select.kqueue.__sizeof__" => "Size of object in memory, in bytes.",
    "select.kqueue.__str__" => "Return str(self).",
    "select.kqueue.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "select.kqueue.close" => "Close the kqueue control file descriptor.\n\nFurther operations on the kqueue object will raise an exception.",
    "select.kqueue.closed" => "True if the kqueue handler is closed",
    "select.kqueue.control" => "Calls the kernel kevent function.\n\nchangelist\n  Must be an iterable of kevent objects describing the changes to be made\n  to the kernel's watch list or None.\nmaxevents\n  The maximum number of events that the kernel will return.\ntimeout\n  The maximum time to wait in seconds, or else None to wait forever.\n  This accepts floats for smaller timeouts, too.",
    "select.kqueue.fileno" => "Return the kqueue control file descriptor.",
    "select.kqueue.fromfd" => "Create a kqueue object from a given control fd.",
    "select.poll" => "Returns a polling object.\n\nThis object supports registering and unregistering file descriptors, and then\npolling them for I/O events.",
    "select.select" => "Wait until one or more file descriptors are ready for some kind of I/O.\n\nThe first three arguments are iterables of file descriptors to be waited for:\nrlist -- wait until ready for reading\nwlist -- wait until ready for writing\nxlist -- wait for an \"exceptional condition\"\nIf only one kind of condition is required, pass [] for the other lists.\n\nA file descriptor is either a socket or file object, or a small integer\ngotten from a fileno() method call on one of those.\n\nThe optional 4th argument specifies a timeout in seconds; it may be\na floating-point number to specify fractions of seconds.  If it is absent\nor None, the call will never time out.\n\nThe return value is a tuple of three lists corresponding to the first three\narguments; each contains the subset of the corresponding file descriptors\nthat are ready.\n\n*** IMPORTANT NOTICE ***\nOn Windows, only sockets are supported; on Unix, all file\ndescriptors can be used.",
    "sys" => "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_exc - the last uncaught exception\n  Only available in an interactive session after a\n  traceback has been printed.\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are the (deprecated) legacy representation of last_exc.\n\nStatic objects:\n\nbuiltin_module_names -- tuple of module names built into this interpreter\ncopyright -- copyright notice pertaining to this interpreter\nexec_prefix -- prefix used to find the machine-specific Python library\nexecutable -- absolute path of the executable binary of the Python interpreter\nfloat_info -- a named tuple with information about the float implementation.\nfloat_repr_style -- string indicating the style of repr() output for floats\nhash_info -- a named tuple with information about the hash algorithm.\nhexversion -- version information encoded as a single integer\nimplementation -- Python implementation information.\nint_info -- a named tuple with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the value of the largest Unicode code point\nplatform -- platform identifier\nprefix -- prefix used to find the Python library\nthread_info -- a named tuple with information about the thread implementation.\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\ndllhandle -- [Windows only] integer handle of the Python DLL\nwinver -- [Windows only] version number of the Python DLL\n_enablelegacywindowsfsencoding -- [Windows only]\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexception() -- return the current thread's active exception\nexc_info() -- return information about the current thread's active exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function",
    "sys.__breakpointhook__" => "This hook function is called by built-in breakpoint().",
    "sys.__displayhook__" => "Print an object to sys.stdout and also save it in builtins._",
    "sys.__excepthook__" => "Handle an exception by displaying it with a traceback on sys.stderr.",
    "sys.__unraisablehook__" => "Handle an unraisable exception.\n\nThe unraisable argument has the following attributes:\n\n* exc_type: Exception type.\n* exc_value: Exception value, can be None.\n* exc_traceback: Exception traceback, can be None.\n* err_msg: Error message, can be None.\n* object: Object causing the exception, can be None.",
    "sys._baserepl" => "Private function for getting the base REPL",
    "sys._clear_internal_caches" => "Clear all internal performance-related caches.",
    "sys._clear_type_cache" => "Clear the internal type lookup cache.",
    "sys._current_exceptions" => "Return a dict mapping each thread's identifier to its current raised exception.\n\nThis function should be used for specialized purposes only.",
    "sys._current_frames" => "Return a dict mapping each thread's thread id to its current stack frame.\n\nThis function should be used for specialized purposes only.",
    "sys._debugmallocstats" => "Print summary info to stderr about the state of pymalloc's structures.\n\nIn Py_DEBUG mode, also perform some expensive internal consistency\nchecks.",
    "sys._enablelegacywindowsfsencoding" => "Changes the default filesystem encoding to mbcs:replace.\n\nThis is done for consistency with earlier versions of Python. See PEP\n529 for more information.\n\nThis is equivalent to defining the PYTHONLEGACYWINDOWSFSENCODING\nenvironment variable before launching Python.",
    "sys._get_cpu_count_config" => "Private function for getting PyConfig.cpu_count",
    "sys._getframe" => "Return a frame object from the call stack.\n\nIf optional integer depth is given, return the frame object that many\ncalls below the top of the stack.  If that is deeper than the call\nstack, ValueError is raised.  The default for depth is zero, returning\nthe frame at the top of the call stack.\n\nThis function should be used for internal and specialized purposes\nonly.",
    "sys._getframemodulename" => "Return the name of the module for a calling frame.\n\nThe default depth returns the module containing the call to this API.\nA more typical use in a library will pass a depth of 1 to get the user's\nmodule rather than the library module.\n\nIf no frame, module, or name can be found, returns None.",
    "sys._is_gil_enabled" => "Return True if the GIL is currently enabled and False otherwise.",
    "sys._is_interned" => "Return True if the given string is \"interned\".",
    "sys._setprofileallthreads" => "Set the profiling function in all running threads belonging to the current interpreter.\n\nIt will be called on each function call and return.  See the profiler\nchapter in the library manual.",
    "sys._settraceallthreads" => "Set the global debug tracing function in all running threads belonging to the current interpreter.\n\nIt will be called on each function call. See the debugger chapter\nin the library manual.",
    "sys.activate_stack_trampoline" => "Activate stack profiler trampoline *backend*.",
    "sys.addaudithook" => "Adds a new audit hook callback.",
    "sys.audit" => "Passes the event to any audit hooks that are attached.",
    "sys.breakpointhook" => "This hook function is called by built-in breakpoint().",
    "sys.call_tracing" => "Call func(*args), while tracing is enabled.\n\nThe tracing state is saved, and restored afterwards.  This is intended\nto be called from a debugger from a checkpoint, to recursively debug\nsome other code.",
    "sys.deactivate_stack_trampoline" => "Deactivate the current stack profiler trampoline backend.\n\nIf no stack profiler is activated, this function has no effect.",
    "sys.displayhook" => "Print an object to sys.stdout and also save it in builtins._",
    "sys.exc_info" => "Return current exception information: (type, value, traceback).\n\nReturn information about the most recent exception caught by an except\nclause in the current stack frame or in an older stack frame.",
    "sys.excepthook" => "Handle an exception by displaying it with a traceback on sys.stderr.",
    "sys.exception" => "Return the current exception.\n\nReturn the most recent exception caught by an except clause\nin the current stack frame or in an older stack frame, or None\nif no such exception exists.",
    "sys.exit" => "Exit the interpreter by raising SystemExit(status).\n\nIf the status is omitted or None, it defaults to zero (i.e., success).\nIf the status is an integer, it will be used as the system exit status.\nIf it is another kind of object, it will be printed and the system\nexit status will be one (i.e., failure).",
    "sys.get_asyncgen_hooks" => "Return the installed asynchronous generators hooks.\n\nThis returns a namedtuple of the form (firstiter, finalizer).",
    "sys.get_coroutine_origin_tracking_depth" => "Check status of origin tracking for coroutine objects in this thread.",
    "sys.get_int_max_str_digits" => "Return the maximum string digits limit for non-binary int<->str conversions.",
    "sys.getallocatedblocks" => "Return the number of memory blocks currently allocated.",
    "sys.getdefaultencoding" => "Return the current default encoding used by the Unicode implementation.",
    "sys.getdlopenflags" => "Return the current value of the flags that are used for dlopen calls.\n\nThe flag constants are defined in the os module.",
    "sys.getfilesystemencodeerrors" => "Return the error mode used Unicode to OS filename conversion.",
    "sys.getfilesystemencoding" => "Return the encoding used to convert Unicode filenames to OS filenames.",
    "sys.getprofile" => "Return the profiling function set with sys.setprofile.\n\nSee the profiler chapter in the library manual.",
    "sys.getrecursionlimit" => "Return the current value of the recursion limit.\n\nThe recursion limit is the maximum depth of the Python interpreter\nstack.  This limit prevents infinite recursion from causing an overflow\nof the C stack and crashing Python.",
    "sys.getrefcount" => "Return the reference count of object.\n\nThe count returned is generally one higher than you might expect,\nbecause it includes the (temporary) reference as an argument to\ngetrefcount().",
    "sys.getsizeof" => "getsizeof(object [, default]) -> int\n\nReturn the size of object in bytes.",
    "sys.getswitchinterval" => "Return the current thread switch interval; see sys.setswitchinterval().",
    "sys.gettrace" => "Return the global debug tracing function set with sys.settrace.\n\nSee the debugger chapter in the library manual.",
    "sys.getunicodeinternedsize" => "Return the number of elements of the unicode interned dictionary",
    "sys.getwindowsversion" => "Return info about the running version of Windows as a named tuple.\n\nThe members are named: major, minor, build, platform, service_pack,\nservice_pack_major, service_pack_minor, suite_mask, product_type and\nplatform_version. For backward compatibility, only the first 5 items\nare available by indexing. All elements are numbers, except\nservice_pack and platform_type which are strings, and platform_version\nwhich is a 3-tuple. Platform is always 2. Product_type may be 1 for a\nworkstation, 2 for a domain controller, 3 for a server.\nPlatform_version is a 3-tuple containing a version number that is\nintended for identifying the OS rather than feature detection.",
    "sys.intern" => "``Intern'' the given string.\n\nThis enters the string in the (global) table of interned strings whose\npurpose is to speed up dictionary lookups. Return the string itself or\nthe previously interned string object with the same value.",
    "sys.is_finalizing" => "Return True if Python is exiting.",
    "sys.is_stack_trampoline_active" => "Return *True* if a stack profiler trampoline is active.",
    "sys.set_asyncgen_hooks" => "set_asyncgen_hooks([firstiter] [, finalizer])\n\nSet a finalizer for async generators objects.",
    "sys.set_coroutine_origin_tracking_depth" => "Enable or disable origin tracking for coroutine objects in this thread.\n\nCoroutine objects will track 'depth' frames of traceback information\nabout where they came from, available in their cr_origin attribute.\n\nSet a depth of 0 to disable.",
    "sys.set_int_max_str_digits" => "Set the maximum string digits limit for non-binary int<->str conversions.",
    "sys.setdlopenflags" => "Set the flags used by the interpreter for dlopen calls.\n\nThis is used, for example, when the interpreter loads extension\nmodules. Among other things, this will enable a lazy resolving of\nsymbols when importing a module, if called as sys.setdlopenflags(0).\nTo share symbols across extension modules, call as\nsys.setdlopenflags(os.RTLD_GLOBAL).  Symbolic names for the flag\nmodules can be found in the os module (RTLD_xxx constants, e.g.\nos.RTLD_LAZY).",
    "sys.setprofile" => "Set the profiling function.\n\nIt will be called on each function call and return.  See the profiler\nchapter in the library manual.",
    "sys.setrecursionlimit" => "Set the maximum depth of the Python interpreter stack to n.\n\nThis limit prevents infinite recursion from causing an overflow of the C\nstack and crashing Python.  The highest possible limit is platform-\ndependent.",
    "sys.setswitchinterval" => "Set the ideal thread switching delay inside the Python interpreter.\n\nThe actual frequency of switching threads can be lower if the\ninterpreter executes long sequences of uninterruptible code\n(this is implementation-specific and workload-dependent).\n\nThe parameter must represent the desired switching delay in seconds\nA typical value is 0.005 (5 milliseconds).",
    "sys.settrace" => "Set the global debug tracing function.\n\nIt will be called on each function call.  See the debugger chapter\nin the library manual.",
    "sys.unraisablehook" => "Handle an unraisable exception.\n\nThe unraisable argument has the following attributes:\n\n* exc_type: Exception type.\n* exc_value: Exception value, can be None.\n* exc_traceback: Exception traceback, can be None.\n* err_msg: Error message, can be None.\n* object: Object causing the exception, can be None.",
    "syslog.LOG_MASK" => "Calculates the mask for the individual priority pri.",
    "syslog.LOG_UPTO" => "Calculates the mask for all priorities up to and including pri.",
    "syslog.closelog" => "Reset the syslog module values and call the system library closelog().",
    "syslog.openlog" => "Set logging options of subsequent syslog() calls.",
    "syslog.setlogmask" => "Set the priority mask to maskpri and return the previous mask value.",
    "syslog.syslog" => "syslog([priority=LOG_INFO,] message)\nSend the string message to the system logger.",
    "termios" => "This module provides an interface to the Posix calls for tty I/O control.\nFor a complete description of these calls, see the Posix or Unix manual\npages. It is only available for those Unix versions that support Posix\ntermios style tty I/O control.\n\nAll functions in this module take a file descriptor fd as their first\nargument. This can be an integer file descriptor, such as returned by\nsys.stdin.fileno(), or a file object, such as sys.stdin itself.",
    "termios.error.__cause__" => "exception cause",
    "termios.error.__context__" => "exception context",
    "termios.error.__delattr__" => "Implement delattr(self, name).",
    "termios.error.__eq__" => "Return self==value.",
    "termios.error.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "termios.error.__ge__" => "Return self>=value.",
    "termios.error.__getattribute__" => "Return getattr(self, name).",
    "termios.error.__getstate__" => "Helper for pickle.",
    "termios.error.__gt__" => "Return self>value.",
    "termios.error.__hash__" => "Return hash(self).",
    "termios.error.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "termios.error.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "termios.error.__le__" => "Return self<=value.",
    "termios.error.__lt__" => "Return self<value.",
    "termios.error.__ne__" => "Return self!=value.",
    "termios.error.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "termios.error.__reduce_ex__" => "Helper for pickle.",
    "termios.error.__repr__" => "Return repr(self).",
    "termios.error.__setattr__" => "Implement setattr(self, name, value).",
    "termios.error.__sizeof__" => "Size of object in memory, in bytes.",
    "termios.error.__str__" => "Return str(self).",
    "termios.error.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "termios.error.__weakref__" => "list of weak references to the object",
    "termios.error.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "termios.error.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "termios.tcdrain" => "Wait until all output written to file descriptor fd has been transmitted.",
    "termios.tcflow" => "Suspend or resume input or output on file descriptor fd.\n\nThe action argument can be termios.TCOOFF to suspend output,\ntermios.TCOON to restart output, termios.TCIOFF to suspend input,\nor termios.TCION to restart input.",
    "termios.tcflush" => "Discard queued data on file descriptor fd.\n\nThe queue selector specifies which queue: termios.TCIFLUSH for the input\nqueue, termios.TCOFLUSH for the output queue, or termios.TCIOFLUSH for\nboth queues.",
    "termios.tcgetattr" => "Get the tty attributes for file descriptor fd.\n\nReturns a list [iflag, oflag, cflag, lflag, ispeed, ospeed, cc]\nwhere cc is a list of the tty special characters (each a string of\nlength 1, except the items with indices VMIN and VTIME, which are\nintegers when these fields are defined).  The interpretation of the\nflags and the speeds as well as the indexing in the cc array must be\ndone using the symbolic constants defined in this module.",
    "termios.tcgetwinsize" => "Get the tty winsize for file descriptor fd.\n\nReturns a tuple (ws_row, ws_col).",
    "termios.tcsendbreak" => "Send a break on file descriptor fd.\n\nA zero duration sends a break for 0.25-0.5 seconds; a nonzero duration\nhas a system dependent meaning.",
    "termios.tcsetattr" => "Set the tty attributes for file descriptor fd.\n\nThe attributes to be set are taken from the attributes argument, which\nis a list like the one returned by tcgetattr(). The when argument\ndetermines when the attributes are changed: termios.TCSANOW to\nchange immediately, termios.TCSADRAIN to change after transmitting all\nqueued output, or termios.TCSAFLUSH to change after transmitting all\nqueued output and discarding all queued input.",
    "termios.tcsetwinsize" => "Set the tty winsize for file descriptor fd.\n\nThe winsize to be set is taken from the winsize argument, which\nis a two-item tuple (ws_row, ws_col) like the one returned by tcgetwinsize().",
    "time" => "This module provides various functions to manipulate time values.\n\nThere are two standard representations of time.  One is the number\nof seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\nor a floating-point number (to represent fractions of seconds).\nThe epoch is the point where the time starts, the return value of time.gmtime(0).\nIt is January 1, 1970, 00:00:00 (UTC) on all platforms.\n\nThe other representation is a tuple of 9 integers giving local time.\nThe tuple items are:\n  year (including century, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\nIf the DST flag is 0, the time is given in the regular time zone;\nif it is 1, the time is given in the DST time zone;\nif it is -1, mktime() should guess based on the date and time.",
    "time.asctime" => "asctime([tuple]) -> string\n\nConvert a time tuple to a string, e.g. 'Sat Jun 06 16:26:11 1998'.\nWhen the time tuple is not present, current time as returned by localtime()\nis used.",
    "time.clock_getres" => "clock_getres(clk_id) -> floating-point number\n\nReturn the resolution (precision) of the specified clock clk_id.",
    "time.clock_gettime" => "Return the time of the specified clock clk_id as a float.",
    "time.clock_gettime_ns" => "Return the time of the specified clock clk_id as nanoseconds (int).",
    "time.clock_settime" => "clock_settime(clk_id, time)\n\nSet the time of the specified clock clk_id.",
    "time.clock_settime_ns" => "clock_settime_ns(clk_id, time)\n\nSet the time of the specified clock clk_id with nanoseconds.",
    "time.ctime" => "ctime(seconds) -> string\n\nConvert a time in seconds since the Epoch to a string in local time.\nThis is equivalent to asctime(localtime(seconds)). When the time tuple is\nnot present, current time as returned by localtime() is used.",
    "time.get_clock_info" => "get_clock_info(name: str) -> dict\n\nGet information of the specified clock.",
    "time.gmtime" => "gmtime([seconds]) -> (tm_year, tm_mon, tm_mday, tm_hour, tm_min,\n                       tm_sec, tm_wday, tm_yday, tm_isdst)\n\nConvert seconds since the Epoch to a time tuple expressing UTC (a.k.a.\nGMT).  When 'seconds' is not passed in, convert the current time instead.\n\nIf the platform supports the tm_gmtoff and tm_zone, they are available as\nattributes only.",
    "time.localtime" => "localtime([seconds]) -> (tm_year,tm_mon,tm_mday,tm_hour,tm_min,\n                          tm_sec,tm_wday,tm_yday,tm_isdst)\n\nConvert seconds since the Epoch to a time tuple expressing local time.\nWhen 'seconds' is not passed in, convert the current time instead.",
    "time.mktime" => "mktime(tuple) -> floating-point number\n\nConvert a time tuple in local time to seconds since the Epoch.\nNote that mktime(gmtime(0)) will not generally return zero for most\ntime zones; instead the returned value will either be equal to that\nof the timezone or altzone attributes on the time module.",
    "time.monotonic" => "monotonic() -> float\n\nMonotonic clock, cannot go backward.",
    "time.monotonic_ns" => "monotonic_ns() -> int\n\nMonotonic clock, cannot go backward, as nanoseconds.",
    "time.perf_counter" => "perf_counter() -> float\n\nPerformance counter for benchmarking.",
    "time.perf_counter_ns" => "perf_counter_ns() -> int\n\nPerformance counter for benchmarking as nanoseconds.",
    "time.process_time" => "process_time() -> float\n\nProcess time for profiling: sum of the kernel and user-space CPU time.",
    "time.process_time_ns" => "process_time() -> int\n\nProcess time for profiling as nanoseconds:\nsum of the kernel and user-space CPU time.",
    "time.pthread_getcpuclockid" => "pthread_getcpuclockid(thread_id) -> int\n\nReturn the clk_id of a thread's CPU time clock.",
    "time.sleep" => "sleep(seconds)\n\nDelay execution for a given number of seconds.  The argument may be\na floating-point number for subsecond precision.",
    "time.strftime" => "strftime(format[, tuple]) -> string\n\nConvert a time tuple to a string according to a format specification.\nSee the library reference manual for formatting codes. When the time tuple\nis not present, current time as returned by localtime() is used.\n\nCommonly used format codes:\n\n%Y  Year with century as a decimal number.\n%m  Month as a decimal number [01,12].\n%d  Day of the month as a decimal number [01,31].\n%H  Hour (24-hour clock) as a decimal number [00,23].\n%M  Minute as a decimal number [00,59].\n%S  Second as a decimal number [00,61].\n%z  Time zone offset from UTC.\n%a  Locale's abbreviated weekday name.\n%A  Locale's full weekday name.\n%b  Locale's abbreviated month name.\n%B  Locale's full month name.\n%c  Locale's appropriate date and time representation.\n%I  Hour (12-hour clock) as a decimal number [01,12].\n%p  Locale's equivalent of either AM or PM.\n\nOther codes may be available on your platform.  See documentation for\nthe C library strftime function.",
    "time.strptime" => "strptime(string, format) -> struct_time\n\nParse a string to a time tuple according to a format specification.\nSee the library reference manual for formatting codes (same as\nstrftime()).\n\nCommonly used format codes:\n\n%Y  Year with century as a decimal number.\n%m  Month as a decimal number [01,12].\n%d  Day of the month as a decimal number [01,31].\n%H  Hour (24-hour clock) as a decimal number [00,23].\n%M  Minute as a decimal number [00,59].\n%S  Second as a decimal number [00,61].\n%z  Time zone offset from UTC.\n%a  Locale's abbreviated weekday name.\n%A  Locale's full weekday name.\n%b  Locale's abbreviated month name.\n%B  Locale's full month name.\n%c  Locale's appropriate date and time representation.\n%I  Hour (12-hour clock) as a decimal number [01,12].\n%p  Locale's equivalent of either AM or PM.\n\nOther codes may be available on your platform.  See documentation for\nthe C library strftime function.",
    "time.struct_time" => "The time value as returned by gmtime(), localtime(), and strptime(), and\naccepted by asctime(), mktime() and strftime().  May be considered as a\nsequence of 9 integers.\n\nNote that several fields' values are not the same as those defined by\nthe C language standard for struct tm.  For example, the value of the\nfield tm_year is the actual year, not year - 1900.  See individual\nfields' descriptions for details.",
    "time.struct_time.__add__" => "Return self+value.",
    "time.struct_time.__class_getitem__" => "See PEP 585",
    "time.struct_time.__contains__" => "Return bool(key in self).",
    "time.struct_time.__delattr__" => "Implement delattr(self, name).",
    "time.struct_time.__eq__" => "Return self==value.",
    "time.struct_time.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "time.struct_time.__ge__" => "Return self>=value.",
    "time.struct_time.__getattribute__" => "Return getattr(self, name).",
    "time.struct_time.__getitem__" => "Return self[key].",
    "time.struct_time.__getstate__" => "Helper for pickle.",
    "time.struct_time.__gt__" => "Return self>value.",
    "time.struct_time.__hash__" => "Return hash(self).",
    "time.struct_time.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "time.struct_time.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "time.struct_time.__iter__" => "Implement iter(self).",
    "time.struct_time.__le__" => "Return self<=value.",
    "time.struct_time.__len__" => "Return len(self).",
    "time.struct_time.__lt__" => "Return self<value.",
    "time.struct_time.__mul__" => "Return self*value.",
    "time.struct_time.__ne__" => "Return self!=value.",
    "time.struct_time.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "time.struct_time.__reduce_ex__" => "Helper for pickle.",
    "time.struct_time.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "time.struct_time.__repr__" => "Return repr(self).",
    "time.struct_time.__rmul__" => "Return value*self.",
    "time.struct_time.__setattr__" => "Implement setattr(self, name, value).",
    "time.struct_time.__sizeof__" => "Size of object in memory, in bytes.",
    "time.struct_time.__str__" => "Return str(self).",
    "time.struct_time.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "time.struct_time.count" => "Return number of occurrences of value.",
    "time.struct_time.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "time.struct_time.tm_gmtoff" => "offset from UTC in seconds",
    "time.struct_time.tm_hour" => "hours, range [0, 23]",
    "time.struct_time.tm_isdst" => "1 if summer time is in effect, 0 if not, and -1 if unknown",
    "time.struct_time.tm_mday" => "day of month, range [1, 31]",
    "time.struct_time.tm_min" => "minutes, range [0, 59]",
    "time.struct_time.tm_mon" => "month of year, range [1, 12]",
    "time.struct_time.tm_sec" => "seconds, range [0, 61])",
    "time.struct_time.tm_wday" => "day of week, range [0, 6], Monday is 0",
    "time.struct_time.tm_yday" => "day of year, range [1, 366]",
    "time.struct_time.tm_year" => "year, for example, 1993",
    "time.struct_time.tm_zone" => "abbreviation of timezone name",
    "time.thread_time" => "thread_time() -> float\n\nThread time for profiling: sum of the kernel and user-space CPU time.",
    "time.thread_time_ns" => "thread_time() -> int\n\nThread time for profiling as nanoseconds:\nsum of the kernel and user-space CPU time.",
    "time.time" => "time() -> floating-point number\n\nReturn the current time in seconds since the Epoch.\nFractions of a second may be present if the system clock provides them.",
    "time.time_ns" => "time_ns() -> int\n\nReturn the current time in nanoseconds since the Epoch.",
    "time.tzset" => "tzset()\n\nInitialize, or reinitialize, the local timezone to the value stored in\nos.environ['TZ']. The TZ environment variable should be specified in\nstandard Unix timezone format as documented in the tzset man page\n(eg. 'US/Eastern', 'Europe/Amsterdam'). Unknown timezones will silently\nfall back to UTC. If the TZ environment variable is not set, the local\ntimezone is set to the systems best guess of wallclock time.\nChanging the TZ environment variable without calling tzset *may* change\nthe local timezone used by methods such as localtime, but this behaviour\nshould not be relied on.",
    "unicodedata" => "This module provides access to the Unicode Character Database which\ndefines character properties for all Unicode characters. The data in\nthis database is based on the UnicodeData.txt file version\n15.1.0 which is publicly available from ftp://ftp.unicode.org/.\n\nThe module uses the same names and symbols as defined by the\nUnicodeData File Format 15.1.0.",
    "unicodedata.UCD.__delattr__" => "Implement delattr(self, name).",
    "unicodedata.UCD.__eq__" => "Return self==value.",
    "unicodedata.UCD.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "unicodedata.UCD.__ge__" => "Return self>=value.",
    "unicodedata.UCD.__getattribute__" => "Return getattr(self, name).",
    "unicodedata.UCD.__getstate__" => "Helper for pickle.",
    "unicodedata.UCD.__gt__" => "Return self>value.",
    "unicodedata.UCD.__hash__" => "Return hash(self).",
    "unicodedata.UCD.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "unicodedata.UCD.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "unicodedata.UCD.__le__" => "Return self<=value.",
    "unicodedata.UCD.__lt__" => "Return self<value.",
    "unicodedata.UCD.__ne__" => "Return self!=value.",
    "unicodedata.UCD.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "unicodedata.UCD.__reduce__" => "Helper for pickle.",
    "unicodedata.UCD.__reduce_ex__" => "Helper for pickle.",
    "unicodedata.UCD.__repr__" => "Return repr(self).",
    "unicodedata.UCD.__setattr__" => "Implement setattr(self, name, value).",
    "unicodedata.UCD.__sizeof__" => "Size of object in memory, in bytes.",
    "unicodedata.UCD.__str__" => "Return str(self).",
    "unicodedata.UCD.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "unicodedata.UCD.bidirectional" => "Returns the bidirectional class assigned to the character chr as string.\n\nIf no such value is defined, an empty string is returned.",
    "unicodedata.UCD.category" => "Returns the general category assigned to the character chr as string.",
    "unicodedata.UCD.combining" => "Returns the canonical combining class assigned to the character chr as integer.\n\nReturns 0 if no combining class is defined.",
    "unicodedata.UCD.decimal" => "Converts a Unicode character into its equivalent decimal value.\n\nReturns the decimal value assigned to the character chr as integer.\nIf no such value is defined, default is returned, or, if not given,\nValueError is raised.",
    "unicodedata.UCD.decomposition" => "Returns the character decomposition mapping assigned to the character chr as string.\n\nAn empty string is returned in case no such mapping is defined.",
    "unicodedata.UCD.digit" => "Converts a Unicode character into its equivalent digit value.\n\nReturns the digit value assigned to the character chr as integer.\nIf no such value is defined, default is returned, or, if not given,\nValueError is raised.",
    "unicodedata.UCD.east_asian_width" => "Returns the east asian width assigned to the character chr as string.",
    "unicodedata.UCD.is_normalized" => "Return whether the Unicode string unistr is in the normal form 'form'.\n\nValid values for form are 'NFC', 'NFKC', 'NFD', and 'NFKD'.",
    "unicodedata.UCD.lookup" => "Look up character by name.\n\nIf a character with the given name is found, return the\ncorresponding character.  If not found, KeyError is raised.",
    "unicodedata.UCD.mirrored" => "Returns the mirrored property assigned to the character chr as integer.\n\nReturns 1 if the character has been identified as a \"mirrored\"\ncharacter in bidirectional text, 0 otherwise.",
    "unicodedata.UCD.name" => "Returns the name assigned to the character chr as a string.\n\nIf no name is defined, default is returned, or, if not given,\nValueError is raised.",
    "unicodedata.UCD.normalize" => "Return the normal form 'form' for the Unicode string unistr.\n\nValid values for form are 'NFC', 'NFKC', 'NFD', and 'NFKD'.",
    "unicodedata.UCD.numeric" => "Converts a Unicode character into its equivalent numeric value.\n\nReturns the numeric value assigned to the character chr as float.\nIf no such value is defined, default is returned, or, if not given,\nValueError is raised.",
    "unicodedata.bidirectional" => "Returns the bidirectional class assigned to the character chr as string.\n\nIf no such value is defined, an empty string is returned.",
    "unicodedata.category" => "Returns the general category assigned to the character chr as string.",
    "unicodedata.combining" => "Returns the canonical combining class assigned to the character chr as integer.\n\nReturns 0 if no combining class is defined.",
    "unicodedata.decimal" => "Converts a Unicode character into its equivalent decimal value.\n\nReturns the decimal value assigned to the character chr as integer.\nIf no such value is defined, default is returned, or, if not given,\nValueError is raised.",
    "unicodedata.decomposition" => "Returns the character decomposition mapping assigned to the character chr as string.\n\nAn empty string is returned in case no such mapping is defined.",
    "unicodedata.digit" => "Converts a Unicode character into its equivalent digit value.\n\nReturns the digit value assigned to the character chr as integer.\nIf no such value is defined, default is returned, or, if not given,\nValueError is raised.",
    "unicodedata.east_asian_width" => "Returns the east asian width assigned to the character chr as string.",
    "unicodedata.is_normalized" => "Return whether the Unicode string unistr is in the normal form 'form'.\n\nValid values for form are 'NFC', 'NFKC', 'NFD', and 'NFKD'.",
    "unicodedata.lookup" => "Look up character by name.\n\nIf a character with the given name is found, return the\ncorresponding character.  If not found, KeyError is raised.",
    "unicodedata.mirrored" => "Returns the mirrored property assigned to the character chr as integer.\n\nReturns 1 if the character has been identified as a \"mirrored\"\ncharacter in bidirectional text, 0 otherwise.",
    "unicodedata.name" => "Returns the name assigned to the character chr as a string.\n\nIf no name is defined, default is returned, or, if not given,\nValueError is raised.",
    "unicodedata.normalize" => "Return the normal form 'form' for the Unicode string unistr.\n\nValid values for form are 'NFC', 'NFKC', 'NFD', and 'NFKD'.",
    "unicodedata.numeric" => "Converts a Unicode character into its equivalent numeric value.\n\nReturns the numeric value assigned to the character chr as float.\nIf no such value is defined, default is returned, or, if not given,\nValueError is raised.",
    "winreg" => "This module provides access to the Windows registry API.\n\nFunctions:\n\nCloseKey() - Closes a registry key.\nConnectRegistry() - Establishes a connection to a predefined registry handle\n                    on another computer.\nCreateKey() - Creates the specified key, or opens it if it already exists.\nDeleteKey() - Deletes the specified key.\nDeleteValue() - Removes a named value from the specified registry key.\nEnumKey() - Enumerates subkeys of the specified open registry key.\nEnumValue() - Enumerates values of the specified open registry key.\nExpandEnvironmentStrings() - Expand the env strings in a REG_EXPAND_SZ\n                             string.\nFlushKey() - Writes all the attributes of the specified key to the registry.\nLoadKey() - Creates a subkey under HKEY_USER or HKEY_LOCAL_MACHINE and\n            stores registration information from a specified file into that\n            subkey.\nOpenKey() - Opens the specified key.\nOpenKeyEx() - Alias of OpenKey().\nQueryValue() - Retrieves the value associated with the unnamed value for a\n               specified key in the registry.\nQueryValueEx() - Retrieves the type and data for a specified value name\n                 associated with an open registry key.\nQueryInfoKey() - Returns information about the specified key.\nSaveKey() - Saves the specified key, and all its subkeys a file.\nSetValue() - Associates a value with a specified key.\nSetValueEx() - Stores data in the value field of an open registry key.\n\nSpecial objects:\n\nHKEYType -- type object for HKEY objects\nerror -- exception raised for Win32 errors\n\nInteger constants:\nMany constants are defined - see the documentation for each function\nto see what constants are used, and where.",
    "winreg.CloseKey" => "Closes a previously opened registry key.\n\n  hkey\n    A previously opened key.\n\nNote that if the key is not closed using this method, it will be\nclosed when the hkey object is destroyed by Python.",
    "winreg.ConnectRegistry" => "Establishes a connection to the registry on another computer.\n\n  computer_name\n    The name of the remote computer, of the form r\"\\\\computername\".  If\n    None, the local computer is used.\n  key\n    The predefined key to connect to.\n\nThe return value is the handle of the opened key.\nIf the function fails, an OSError exception is raised.",
    "winreg.CreateKey" => "Creates or opens the specified key.\n\n  key\n    An already open key, or one of the predefined HKEY_* constants.\n  sub_key\n    The name of the key this method opens or creates.\n\nIf key is one of the predefined keys, sub_key may be None. In that case,\nthe handle returned is the same key handle passed in to the function.\n\nIf the key already exists, this function opens the existing key.\n\nThe return value is the handle of the opened key.\nIf the function fails, an OSError exception is raised.",
    "winreg.CreateKeyEx" => "Creates or opens the specified key.\n\n  key\n    An already open key, or one of the predefined HKEY_* constants.\n  sub_key\n    The name of the key this method opens or creates.\n  reserved\n    A reserved integer, and must be zero.  Default is zero.\n  access\n    An integer that specifies an access mask that describes the\n    desired security access for the key. Default is KEY_WRITE.\n\nIf key is one of the predefined keys, sub_key may be None. In that case,\nthe handle returned is the same key handle passed in to the function.\n\nIf the key already exists, this function opens the existing key\n\nThe return value is the handle of the opened key.\nIf the function fails, an OSError exception is raised.",
    "winreg.DeleteKey" => "Deletes the specified key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  sub_key\n    A string that must be the name of a subkey of the key identified by\n    the key parameter. This value must not be None, and the key may not\n    have subkeys.\n\nThis method can not delete keys with subkeys.\n\nIf the function succeeds, the entire key, including all of its values,\nis removed.  If the function fails, an OSError exception is raised.",
    "winreg.DeleteKeyEx" => "Deletes the specified key (intended for 64-bit OS).\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  sub_key\n    A string that must be the name of a subkey of the key identified by\n    the key parameter. This value must not be None, and the key may not\n    have subkeys.\n  access\n    An integer that specifies an access mask that describes the\n    desired security access for the key. Default is KEY_WOW64_64KEY.\n  reserved\n    A reserved integer, and must be zero.  Default is zero.\n\nWhile this function is intended to be used for 64-bit OS, it is also\n available on 32-bit systems.\n\nThis method can not delete keys with subkeys.\n\nIf the function succeeds, the entire key, including all of its values,\nis removed.  If the function fails, an OSError exception is raised.\nOn unsupported Windows versions, NotImplementedError is raised.",
    "winreg.DeleteValue" => "Removes a named value from a registry key.\n\nkey\n  An already open key, or any one of the predefined HKEY_* constants.\nvalue\n  A string that identifies the value to remove.",
    "winreg.DisableReflectionKey" => "Disables registry reflection for 32bit processes running on a 64bit OS.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n\nWill generally raise NotImplementedError if executed on a 32bit OS.\n\nIf the key is not on the reflection list, the function succeeds but has\nno effect.  Disabling reflection for a key does not affect reflection\nof any subkeys.",
    "winreg.EnableReflectionKey" => "Restores registry reflection for the specified disabled key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n\nWill generally raise NotImplementedError if executed on a 32bit OS.\nRestoring reflection for a key does not affect reflection of any\nsubkeys.",
    "winreg.EnumKey" => "Enumerates subkeys of an open registry key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  index\n    An integer that identifies the index of the key to retrieve.\n\nThe function retrieves the name of one subkey each time it is called.\nIt is typically called repeatedly until an OSError exception is\nraised, indicating no more values are available.",
    "winreg.EnumValue" => "Enumerates values of an open registry key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  index\n    An integer that identifies the index of the value to retrieve.\n\nThe function retrieves the name of one subkey each time it is called.\nIt is typically called repeatedly, until an OSError exception\nis raised, indicating no more values.\n\nThe result is a tuple of 3 items:\n  value_name\n    A string that identifies the value.\n  value_data\n    An object that holds the value data, and whose type depends\n    on the underlying registry type.\n  data_type\n    An integer that identifies the type of the value data.",
    "winreg.ExpandEnvironmentStrings" => "Expand environment vars.",
    "winreg.FlushKey" => "Writes all the attributes of a key to the registry.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n\nIt is not necessary to call FlushKey to change a key.  Registry changes\nare flushed to disk by the registry using its lazy flusher.  Registry\nchanges are also flushed to disk at system shutdown.  Unlike\nCloseKey(), the FlushKey() method returns only when all the data has\nbeen written to the registry.\n\nAn application should only call FlushKey() if it requires absolute\ncertainty that registry changes are on disk.  If you don't know whether\na FlushKey() call is required, it probably isn't.",
    "winreg.HKEYType" => "PyHKEY Object - A Python object, representing a win32 registry key.\n\nThis object wraps a Windows HKEY object, automatically closing it when\nthe object is destroyed.  To guarantee cleanup, you can call either\nthe Close() method on the PyHKEY, or the CloseKey() method.\n\nAll functions which accept a handle object also accept an integer --\nhowever, use of the handle object is encouraged.\n\nFunctions:\nClose() - Closes the underlying handle.\nDetach() - Returns the integer Win32 handle, detaching it from the object\n\nProperties:\nhandle - The integer Win32 handle.\n\nOperations:\n__bool__ - Handles with an open object return true, otherwise false.\n__int__ - Converting a handle to an integer returns the Win32 handle.\nrich comparison - Handle objects are compared using the handle value.",
    "winreg.HKEYType.Close" => "Closes the underlying Windows handle.\n\nIf the handle is already closed, no error is raised.",
    "winreg.HKEYType.Detach" => "Detaches the Windows handle from the handle object.\n\nThe result is the value of the handle before it is detached.  If the\nhandle is already detached, this will return zero.\n\nAfter calling this function, the handle is effectively invalidated,\nbut the handle is not closed.  You would call this function when you\nneed the underlying win32 handle to exist beyond the lifetime of the\nhandle object.",
    "winreg.HKEYType.__abs__" => "abs(self)",
    "winreg.HKEYType.__add__" => "Return self+value.",
    "winreg.HKEYType.__and__" => "Return self&value.",
    "winreg.HKEYType.__bool__" => "True if self else False",
    "winreg.HKEYType.__delattr__" => "Implement delattr(self, name).",
    "winreg.HKEYType.__divmod__" => "Return divmod(self, value).",
    "winreg.HKEYType.__eq__" => "Return self==value.",
    "winreg.HKEYType.__float__" => "float(self)",
    "winreg.HKEYType.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "winreg.HKEYType.__ge__" => "Return self>=value.",
    "winreg.HKEYType.__getattribute__" => "Return getattr(self, name).",
    "winreg.HKEYType.__getstate__" => "Helper for pickle.",
    "winreg.HKEYType.__gt__" => "Return self>value.",
    "winreg.HKEYType.__hash__" => "Return hash(self).",
    "winreg.HKEYType.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "winreg.HKEYType.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "winreg.HKEYType.__int__" => "int(self)",
    "winreg.HKEYType.__invert__" => "~self",
    "winreg.HKEYType.__le__" => "Return self<=value.",
    "winreg.HKEYType.__lshift__" => "Return self<<value.",
    "winreg.HKEYType.__lt__" => "Return self<value.",
    "winreg.HKEYType.__mod__" => "Return self%value.",
    "winreg.HKEYType.__mul__" => "Return self*value.",
    "winreg.HKEYType.__ne__" => "Return self!=value.",
    "winreg.HKEYType.__neg__" => "-self",
    "winreg.HKEYType.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "winreg.HKEYType.__or__" => "Return self|value.",
    "winreg.HKEYType.__pos__" => "+self",
    "winreg.HKEYType.__pow__" => "Return pow(self, value, mod).",
    "winreg.HKEYType.__radd__" => "Return value+self.",
    "winreg.HKEYType.__rand__" => "Return value&self.",
    "winreg.HKEYType.__rdivmod__" => "Return divmod(value, self).",
    "winreg.HKEYType.__reduce__" => "Helper for pickle.",
    "winreg.HKEYType.__reduce_ex__" => "Helper for pickle.",
    "winreg.HKEYType.__repr__" => "Return repr(self).",
    "winreg.HKEYType.__rlshift__" => "Return value<<self.",
    "winreg.HKEYType.__rmod__" => "Return value%self.",
    "winreg.HKEYType.__rmul__" => "Return value*self.",
    "winreg.HKEYType.__ror__" => "Return value|self.",
    "winreg.HKEYType.__rpow__" => "Return pow(value, self, mod).",
    "winreg.HKEYType.__rrshift__" => "Return value>>self.",
    "winreg.HKEYType.__rshift__" => "Return self>>value.",
    "winreg.HKEYType.__rsub__" => "Return value-self.",
    "winreg.HKEYType.__rxor__" => "Return value^self.",
    "winreg.HKEYType.__setattr__" => "Implement setattr(self, name, value).",
    "winreg.HKEYType.__sizeof__" => "Size of object in memory, in bytes.",
    "winreg.HKEYType.__str__" => "Return str(self).",
    "winreg.HKEYType.__sub__" => "Return self-value.",
    "winreg.HKEYType.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "winreg.HKEYType.__xor__" => "Return self^value.",
    "winreg.LoadKey" => "Insert data into the registry from a file.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  sub_key\n    A string that identifies the sub-key to load.\n  file_name\n    The name of the file to load registry data from.  This file must\n    have been created with the SaveKey() function.  Under the file\n    allocation table (FAT) file system, the filename may not have an\n    extension.\n\nCreates a subkey under the specified key and stores registration\ninformation from a specified file into that subkey.\n\nA call to LoadKey() fails if the calling process does not have the\nSE_RESTORE_PRIVILEGE privilege.\n\nIf key is a handle returned by ConnectRegistry(), then the path\nspecified in fileName is relative to the remote computer.\n\nThe MSDN docs imply key must be in the HKEY_USER or HKEY_LOCAL_MACHINE\ntree.",
    "winreg.OpenKey" => "Opens the specified key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  sub_key\n    A string that identifies the sub_key to open.\n  reserved\n    A reserved integer that must be zero.  Default is zero.\n  access\n    An integer that specifies an access mask that describes the desired\n    security access for the key.  Default is KEY_READ.\n\nThe result is a new handle to the specified key.\nIf the function fails, an OSError exception is raised.",
    "winreg.OpenKeyEx" => "Opens the specified key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  sub_key\n    A string that identifies the sub_key to open.\n  reserved\n    A reserved integer that must be zero.  Default is zero.\n  access\n    An integer that specifies an access mask that describes the desired\n    security access for the key.  Default is KEY_READ.\n\nThe result is a new handle to the specified key.\nIf the function fails, an OSError exception is raised.",
    "winreg.QueryInfoKey" => "Returns information about a key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n\nThe result is a tuple of 3 items:\nAn integer that identifies the number of sub keys this key has.\nAn integer that identifies the number of values this key has.\nAn integer that identifies when the key was last modified (if available)\nas 100's of nanoseconds since Jan 1, 1600.",
    "winreg.QueryReflectionKey" => "Returns the reflection state for the specified key as a bool.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n\nWill generally raise NotImplementedError if executed on a 32bit OS.",
    "winreg.QueryValue" => "Retrieves the unnamed value for a key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  sub_key\n    A string that holds the name of the subkey with which the value\n    is associated.  If this parameter is None or empty, the function\n    retrieves the value set by the SetValue() method for the key\n    identified by key.\n\nValues in the registry have name, type, and data components. This method\nretrieves the data for a key's first value that has a NULL name.\nBut since the underlying API call doesn't return the type, you'll\nprobably be happier using QueryValueEx; this function is just here for\ncompleteness.",
    "winreg.QueryValueEx" => "Retrieves the type and value of a specified sub-key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  name\n    A string indicating the value to query.\n\nBehaves mostly like QueryValue(), but also returns the type of the\nspecified value name associated with the given open registry key.\n\nThe return value is a tuple of the value and the type_id.",
    "winreg.SaveKey" => "Saves the specified key, and all its subkeys to the specified file.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  file_name\n    The name of the file to save registry data to.  This file cannot\n    already exist. If this filename includes an extension, it cannot be\n    used on file allocation table (FAT) file systems by the LoadKey(),\n    ReplaceKey() or RestoreKey() methods.\n\nIf key represents a key on a remote computer, the path described by\nfile_name is relative to the remote computer.\n\nThe caller of this method must possess the SeBackupPrivilege\nsecurity privilege.  This function passes NULL for security_attributes\nto the API.",
    "winreg.SetValue" => "Associates a value with a specified key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  sub_key\n    A string that names the subkey with which the value is associated.\n  type\n    An integer that specifies the type of the data.  Currently this must\n    be REG_SZ, meaning only strings are supported.\n  value\n    A string that specifies the new value.\n\nIf the key specified by the sub_key parameter does not exist, the\nSetValue function creates it.\n\nValue lengths are limited by available memory. Long values (more than\n2048 bytes) should be stored as files with the filenames stored in\nthe configuration registry to help the registry perform efficiently.\n\nThe key identified by the key parameter must have been opened with\nKEY_SET_VALUE access.",
    "winreg.SetValueEx" => "Stores data in the value field of an open registry key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  value_name\n    A string containing the name of the value to set, or None.\n  reserved\n    Can be anything - zero is always passed to the API.\n  type\n    An integer that specifies the type of the data, one of:\n    REG_BINARY -- Binary data in any form.\n    REG_DWORD -- A 32-bit number.\n    REG_DWORD_LITTLE_ENDIAN -- A 32-bit number in little-endian format. Equivalent to REG_DWORD\n    REG_DWORD_BIG_ENDIAN -- A 32-bit number in big-endian format.\n    REG_EXPAND_SZ -- A null-terminated string that contains unexpanded\n                     references to environment variables (for example,\n                     %PATH%).\n    REG_LINK -- A Unicode symbolic link.\n    REG_MULTI_SZ -- A sequence of null-terminated strings, terminated\n                    by two null characters.  Note that Python handles\n                    this termination automatically.\n    REG_NONE -- No defined value type.\n    REG_QWORD -- A 64-bit number.\n    REG_QWORD_LITTLE_ENDIAN -- A 64-bit number in little-endian format. Equivalent to REG_QWORD.\n    REG_RESOURCE_LIST -- A device-driver resource list.\n    REG_SZ -- A null-terminated string.\n  value\n    A string that specifies the new value.\n\nThis method can also set additional value and type information for the\nspecified key.  The key identified by the key parameter must have been\nopened with KEY_SET_VALUE access.\n\nTo open the key, use the CreateKeyEx() or OpenKeyEx() methods.\n\nValue lengths are limited by available memory. Long values (more than\n2048 bytes) should be stored as files with the filenames stored in\nthe configuration registry to help the registry perform efficiently.",
    "winsound" => "PlaySound(sound, flags) - play a sound\nSND_FILENAME - sound is a wav file name\nSND_ALIAS - sound is a registry sound association name\nSND_LOOP - Play the sound repeatedly; must also specify SND_ASYNC\nSND_MEMORY - sound is a memory image of a wav file\nSND_PURGE - stop all instances of the specified sound\nSND_ASYNC - PlaySound returns immediately\nSND_NODEFAULT - Do not play a default beep if the sound can not be found\nSND_NOSTOP - Do not interrupt any sounds currently playing\nSND_NOWAIT - Return immediately if the sound driver is busy\nSND_APPLICATION - sound is an application-specific alias in the registry.\nBeep(frequency, duration) - Make a beep through the PC speaker.\nMessageBeep(type) - Call Windows MessageBeep.",
    "winsound.Beep" => "A wrapper around the Windows Beep API.\n\nfrequency\n  Frequency of the sound in hertz.\n  Must be in the range 37 through 32,767.\nduration\n  How long the sound should play, in milliseconds.",
    "winsound.MessageBeep" => "Call Windows MessageBeep(x).\n\nx defaults to MB_OK.",
    "winsound.PlaySound" => "A wrapper around the Windows PlaySound API.\n\nsound\n  The sound to play; a filename, data, or None.\nflags\n  Flag values, ored together.  See module documentation.",
    "zlib" => "The functions in this module allow compression and decompression using the\nzlib library, which is based on GNU zip.\n\nadler32(string[, start]) -- Compute an Adler-32 checksum.\ncompress(data[, level]) -- Compress data, with compression level 0-9 or -1.\ncompressobj([level[, ...]]) -- Return a compressor object.\ncrc32(string[, start]) -- Compute a CRC-32 checksum.\ndecompress(string,[wbits],[bufsize]) -- Decompresses a compressed string.\ndecompressobj([wbits[, zdict]]) -- Return a decompressor object.\n\n'wbits' is window buffer size and container format.\nCompressor objects support compress() and flush() methods; decompressor\nobjects support decompress() and flush().",
    "zlib._ZlibDecompressor" => "Create a decompressor object for decompressing data incrementally.\n\nwbits = 15\nzdict\n   The predefined compression dictionary. This is a sequence of bytes\n   (such as a bytes object) containing subsequences that are expected\n   to occur frequently in the data that is to be compressed. Those\n   subsequences that are expected to be most common should come at the\n   end of the dictionary. This must be the same dictionary as used by the\n   compressor that produced the input data.",
    "zlib._ZlibDecompressor.__delattr__" => "Implement delattr(self, name).",
    "zlib._ZlibDecompressor.__eq__" => "Return self==value.",
    "zlib._ZlibDecompressor.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "zlib._ZlibDecompressor.__ge__" => "Return self>=value.",
    "zlib._ZlibDecompressor.__getattribute__" => "Return getattr(self, name).",
    "zlib._ZlibDecompressor.__getstate__" => "Helper for pickle.",
    "zlib._ZlibDecompressor.__gt__" => "Return self>value.",
    "zlib._ZlibDecompressor.__hash__" => "Return hash(self).",
    "zlib._ZlibDecompressor.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "zlib._ZlibDecompressor.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "zlib._ZlibDecompressor.__le__" => "Return self<=value.",
    "zlib._ZlibDecompressor.__lt__" => "Return self<value.",
    "zlib._ZlibDecompressor.__ne__" => "Return self!=value.",
    "zlib._ZlibDecompressor.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "zlib._ZlibDecompressor.__reduce__" => "Helper for pickle.",
    "zlib._ZlibDecompressor.__reduce_ex__" => "Helper for pickle.",
    "zlib._ZlibDecompressor.__repr__" => "Return repr(self).",
    "zlib._ZlibDecompressor.__setattr__" => "Implement setattr(self, name, value).",
    "zlib._ZlibDecompressor.__sizeof__" => "Size of object in memory, in bytes.",
    "zlib._ZlibDecompressor.__str__" => "Return str(self).",
    "zlib._ZlibDecompressor.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "zlib._ZlibDecompressor.decompress" => "Decompress *data*, returning uncompressed data as bytes.\n\nIf *max_length* is nonnegative, returns at most *max_length* bytes of\ndecompressed data. If this limit is reached and further output can be\nproduced, *self.needs_input* will be set to ``False``. In this case, the next\ncall to *decompress()* may provide *data* as b'' to obtain more of the output.\n\nIf all of the input data was decompressed and returned (either because this\nwas less than *max_length* bytes, or because *max_length* was negative),\n*self.needs_input* will be set to True.\n\nAttempting to decompress data after the end of stream is reached raises an\nEOFError.  Any data found after the end of the stream is ignored and saved in\nthe unused_data attribute.",
    "zlib._ZlibDecompressor.eof" => "True if the end-of-stream marker has been reached.",
    "zlib._ZlibDecompressor.needs_input" => "True if more input is needed before more decompressed data can be produced.",
    "zlib._ZlibDecompressor.unused_data" => "Data found after the end of the compressed stream.",
    "zlib.adler32" => "Compute an Adler-32 checksum of data.\n\n  value\n    Starting value of the checksum.\n\nThe returned checksum is an integer.",
    "zlib.compress" => "Returns a bytes object containing compressed data.\n\ndata\n  Binary data to be compressed.\nlevel\n  Compression level, in 0-9 or -1.\nwbits\n  The window buffer size and container format.",
    "zlib.compressobj" => "Return a compressor object.\n\nlevel\n  The compression level (an integer in the range 0-9 or -1; default is\n  currently equivalent to 6).  Higher compression levels are slower,\n  but produce smaller results.\nmethod\n  The compression algorithm.  If given, this must be DEFLATED.\nwbits\n  +9 to +15: The base-two logarithm of the window size.  Include a zlib\n      container.\n  -9 to -15: Generate a raw stream.\n  +25 to +31: Include a gzip container.\nmemLevel\n  Controls the amount of memory used for internal compression state.\n  Valid values range from 1 to 9.  Higher values result in higher memory\n  usage, faster compression, and smaller output.\nstrategy\n  Used to tune the compression algorithm.  Possible values are\n  Z_DEFAULT_STRATEGY, Z_FILTERED, and Z_HUFFMAN_ONLY.\nzdict\n  The predefined compression dictionary - a sequence of bytes\n  containing subsequences that are likely to occur in the input data.",
    "zlib.crc32" => "Compute a CRC-32 checksum of data.\n\n  value\n    Starting value of the checksum.\n\nThe returned checksum is an integer.",
    "zlib.decompress" => "Returns a bytes object containing the uncompressed data.\n\ndata\n  Compressed data.\nwbits\n  The window buffer size and container format.\nbufsize\n  The initial output buffer size.",
    "zlib.decompressobj" => "Return a decompressor object.\n\nwbits\n  The window buffer size and container format.\nzdict\n  The predefined compression dictionary.  This must be the same\n  dictionary as used by the compressor that produced the input data.",
    "zlib.error.__cause__" => "exception cause",
    "zlib.error.__context__" => "exception context",
    "zlib.error.__delattr__" => "Implement delattr(self, name).",
    "zlib.error.__eq__" => "Return self==value.",
    "zlib.error.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "zlib.error.__ge__" => "Return self>=value.",
    "zlib.error.__getattribute__" => "Return getattr(self, name).",
    "zlib.error.__getstate__" => "Helper for pickle.",
    "zlib.error.__gt__" => "Return self>value.",
    "zlib.error.__hash__" => "Return hash(self).",
    "zlib.error.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "zlib.error.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "zlib.error.__le__" => "Return self<=value.",
    "zlib.error.__lt__" => "Return self<value.",
    "zlib.error.__ne__" => "Return self!=value.",
    "zlib.error.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "zlib.error.__reduce_ex__" => "Helper for pickle.",
    "zlib.error.__repr__" => "Return repr(self).",
    "zlib.error.__setattr__" => "Implement setattr(self, name, value).",
    "zlib.error.__sizeof__" => "Size of object in memory, in bytes.",
    "zlib.error.__str__" => "Return str(self).",
    "zlib.error.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "zlib.error.__weakref__" => "list of weak references to the object",
    "zlib.error.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "zlib.error.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
};
