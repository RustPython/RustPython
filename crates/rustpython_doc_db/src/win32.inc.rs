// This file was auto generated by: generate.py
// CPython version: 3.13.9
// spell-checker: disable

use phf::{Map, phf_map};

pub static DB: Map<&'static str, &'static str> = phf_map! {
    "_abc" => "Module contains faster C implementation of abc.ABCMeta",
    "_abc._abc_init" => "Internal ABC helper for class set-up. Should be never used outside abc module.",
    "_abc._abc_instancecheck" => "Internal ABC helper for instance checks. Should be never used outside abc module.",
    "_abc._abc_register" => "Internal ABC helper for subclasss registration. Should be never used outside abc module.",
    "_abc._abc_subclasscheck" => "Internal ABC helper for subclasss checks. Should be never used outside abc module.",
    "_abc._get_dump" => "Internal ABC helper for cache and registry debugging.\n\nReturn shallow copies of registry, of both caches, and\nnegative cache version. Don't call this function directly,\ninstead use ABC._dump_registry() for a nice repr.",
    "_abc._reset_caches" => "Internal ABC helper to reset both caches of a given class.\n\nShould be only used by refleak.py",
    "_abc._reset_registry" => "Internal ABC helper to reset registry of a given class.\n\nShould be only used by refleak.py",
    "_abc.get_cache_token" => "Returns the current ABC cache token.\n\nThe token is an opaque object (supporting equality testing) identifying the\ncurrent version of the ABC cache for virtual subclasses. The token changes\nwith every call to register() on any ABC.",
    "_asyncio" => "Accelerator module for asyncio",
    "_asyncio.Future" => "This class is *almost* compatible with concurrent.futures.Future.\n\nDifferences:\n\n- result() and exception() do not take a timeout argument and\n  raise an exception when the future isn't done yet.\n\n- Callbacks registered with add_done_callback() are always called\n  via the event loop's call_soon_threadsafe().\n\n- This class is not compatible with the wait() and as_completed()\n  methods in the concurrent.futures package.",
    "_asyncio.Future.__await__" => "Return an iterator to be used in await expression.",
    "_asyncio.Future.__class_getitem__" => "See PEP 585",
    "_asyncio.Future.__del__" => "Called when the instance is about to be destroyed.",
    "_asyncio.Future.__delattr__" => "Implement delattr(self, name).",
    "_asyncio.Future.__eq__" => "Return self==value.",
    "_asyncio.Future.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_asyncio.Future.__ge__" => "Return self>=value.",
    "_asyncio.Future.__getattribute__" => "Return getattr(self, name).",
    "_asyncio.Future.__getstate__" => "Helper for pickle.",
    "_asyncio.Future.__gt__" => "Return self>value.",
    "_asyncio.Future.__hash__" => "Return hash(self).",
    "_asyncio.Future.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_asyncio.Future.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_asyncio.Future.__iter__" => "Implement iter(self).",
    "_asyncio.Future.__le__" => "Return self<=value.",
    "_asyncio.Future.__lt__" => "Return self<value.",
    "_asyncio.Future.__ne__" => "Return self!=value.",
    "_asyncio.Future.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_asyncio.Future.__reduce__" => "Helper for pickle.",
    "_asyncio.Future.__reduce_ex__" => "Helper for pickle.",
    "_asyncio.Future.__repr__" => "Return repr(self).",
    "_asyncio.Future.__setattr__" => "Implement setattr(self, name, value).",
    "_asyncio.Future.__sizeof__" => "Size of object in memory, in bytes.",
    "_asyncio.Future.__str__" => "Return str(self).",
    "_asyncio.Future.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_asyncio.Future._make_cancelled_error" => "Create the CancelledError to raise if the Future is cancelled.\n\nThis should only be called once when handling a cancellation since\nit erases the context exception value.",
    "_asyncio.Future.add_done_callback" => "Add a callback to be run when the future becomes done.\n\nThe callback is called with a single argument - the future object. If\nthe future is already done when this is called, the callback is\nscheduled with call_soon.",
    "_asyncio.Future.cancel" => "Cancel the future and schedule callbacks.\n\nIf the future is already done or cancelled, return False.  Otherwise,\nchange the future's state to cancelled, schedule the callbacks and\nreturn True.",
    "_asyncio.Future.cancelled" => "Return True if the future was cancelled.",
    "_asyncio.Future.done" => "Return True if the future is done.\n\nDone means either that a result / exception are available, or that the\nfuture was cancelled.",
    "_asyncio.Future.exception" => "Return the exception that was set on this future.\n\nThe exception (or None if no exception was set) is returned only if\nthe future is done.  If the future has been cancelled, raises\nCancelledError.  If the future isn't done yet, raises\nInvalidStateError.",
    "_asyncio.Future.get_loop" => "Return the event loop the Future is bound to.",
    "_asyncio.Future.remove_done_callback" => "Remove all instances of a callback from the \"call when done\" list.\n\nReturns the number of callbacks removed.",
    "_asyncio.Future.result" => "Return the result this future represents.\n\nIf the future has been cancelled, raises CancelledError.  If the\nfuture's result isn't yet available, raises InvalidStateError.  If\nthe future is done and has an exception set, this exception is raised.",
    "_asyncio.Future.set_exception" => "Mark the future done and set an exception.\n\nIf the future is already done when this method is called, raises\nInvalidStateError.",
    "_asyncio.Future.set_result" => "Mark the future done and set its result.\n\nIf the future is already done when this method is called, raises\nInvalidStateError.",
    "_asyncio.Task" => "A coroutine wrapped in a Future.",
    "_asyncio.Task.__await__" => "Return an iterator to be used in await expression.",
    "_asyncio.Task.__class_getitem__" => "See PEP 585",
    "_asyncio.Task.__del__" => "Called when the instance is about to be destroyed.",
    "_asyncio.Task.__delattr__" => "Implement delattr(self, name).",
    "_asyncio.Task.__eq__" => "Return self==value.",
    "_asyncio.Task.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_asyncio.Task.__ge__" => "Return self>=value.",
    "_asyncio.Task.__getattribute__" => "Return getattr(self, name).",
    "_asyncio.Task.__getstate__" => "Helper for pickle.",
    "_asyncio.Task.__gt__" => "Return self>value.",
    "_asyncio.Task.__hash__" => "Return hash(self).",
    "_asyncio.Task.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_asyncio.Task.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_asyncio.Task.__iter__" => "Implement iter(self).",
    "_asyncio.Task.__le__" => "Return self<=value.",
    "_asyncio.Task.__lt__" => "Return self<value.",
    "_asyncio.Task.__ne__" => "Return self!=value.",
    "_asyncio.Task.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_asyncio.Task.__reduce__" => "Helper for pickle.",
    "_asyncio.Task.__reduce_ex__" => "Helper for pickle.",
    "_asyncio.Task.__repr__" => "Return repr(self).",
    "_asyncio.Task.__setattr__" => "Implement setattr(self, name, value).",
    "_asyncio.Task.__sizeof__" => "Size of object in memory, in bytes.",
    "_asyncio.Task.__str__" => "Return str(self).",
    "_asyncio.Task.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_asyncio.Task._make_cancelled_error" => "Create the CancelledError to raise if the Task is cancelled.\n\nThis should only be called once when handling a cancellation since\nit erases the context exception value.",
    "_asyncio.Task.add_done_callback" => "Add a callback to be run when the future becomes done.\n\nThe callback is called with a single argument - the future object. If\nthe future is already done when this is called, the callback is\nscheduled with call_soon.",
    "_asyncio.Task.cancel" => "Request that this task cancel itself.\n\nThis arranges for a CancelledError to be thrown into the\nwrapped coroutine on the next cycle through the event loop.\nThe coroutine then has a chance to clean up or even deny\nthe request using try/except/finally.\n\nUnlike Future.cancel, this does not guarantee that the\ntask will be cancelled: the exception might be caught and\nacted upon, delaying cancellation of the task or preventing\ncancellation completely.  The task may also return a value or\nraise a different exception.\n\nImmediately after this method is called, Task.cancelled() will\nnot return True (unless the task was already cancelled).  A\ntask will be marked as cancelled when the wrapped coroutine\nterminates with a CancelledError exception (even if cancel()\nwas not called).\n\nThis also increases the task's count of cancellation requests.",
    "_asyncio.Task.cancelled" => "Return True if the future was cancelled.",
    "_asyncio.Task.cancelling" => "Return the count of the task's cancellation requests.\n\nThis count is incremented when .cancel() is called\nand may be decremented using .uncancel().",
    "_asyncio.Task.done" => "Return True if the future is done.\n\nDone means either that a result / exception are available, or that the\nfuture was cancelled.",
    "_asyncio.Task.exception" => "Return the exception that was set on this future.\n\nThe exception (or None if no exception was set) is returned only if\nthe future is done.  If the future has been cancelled, raises\nCancelledError.  If the future isn't done yet, raises\nInvalidStateError.",
    "_asyncio.Task.get_loop" => "Return the event loop the Future is bound to.",
    "_asyncio.Task.get_stack" => "Return the list of stack frames for this task's coroutine.\n\nIf the coroutine is not done, this returns the stack where it is\nsuspended.  If the coroutine has completed successfully or was\ncancelled, this returns an empty list.  If the coroutine was\nterminated by an exception, this returns the list of traceback\nframes.\n\nThe frames are always ordered from oldest to newest.\n\nThe optional limit gives the maximum number of frames to\nreturn; by default all available frames are returned.  Its\nmeaning differs depending on whether a stack or a traceback is\nreturned: the newest frames of a stack are returned, but the\noldest frames of a traceback are returned.  (This matches the\nbehavior of the traceback module.)\n\nFor reasons beyond our control, only one stack frame is\nreturned for a suspended coroutine.",
    "_asyncio.Task.print_stack" => "Print the stack or traceback for this task's coroutine.\n\nThis produces output similar to that of the traceback module,\nfor the frames retrieved by get_stack().  The limit argument\nis passed to get_stack().  The file argument is an I/O stream\nto which the output is written; by default output is written\nto sys.stderr.",
    "_asyncio.Task.remove_done_callback" => "Remove all instances of a callback from the \"call when done\" list.\n\nReturns the number of callbacks removed.",
    "_asyncio.Task.result" => "Return the result this future represents.\n\nIf the future has been cancelled, raises CancelledError.  If the\nfuture's result isn't yet available, raises InvalidStateError.  If\nthe future is done and has an exception set, this exception is raised.",
    "_asyncio.Task.uncancel" => "Decrement the task's count of cancellation requests.\n\nThis should be used by tasks that catch CancelledError\nand wish to continue indefinitely until they are cancelled again.\n\nReturns the remaining number of cancellation requests.",
    "_asyncio._enter_task" => "Enter into task execution or resume suspended task.\n\nTask belongs to loop.\n\nReturns None.",
    "_asyncio._get_running_loop" => "Return the running event loop or None.\n\nThis is a low-level function intended to be used by event loops.\nThis function is thread-specific.",
    "_asyncio._leave_task" => "Leave task execution or suspend a task.\n\nTask belongs to loop.\n\nReturns None.",
    "_asyncio._register_eager_task" => "Register a new task in asyncio as executed by loop.\n\nReturns None.",
    "_asyncio._register_task" => "Register a new task in asyncio as executed by loop.\n\nReturns None.",
    "_asyncio._set_running_loop" => "Set the running event loop.\n\nThis is a low-level function intended to be used by event loops.\nThis function is thread-specific.",
    "_asyncio._swap_current_task" => "Temporarily swap in the supplied task and return the original one (or None).\n\nThis is intended for use during eager coroutine execution.",
    "_asyncio._unregister_eager_task" => "Unregister a task.\n\nReturns None.",
    "_asyncio._unregister_task" => "Unregister a task.\n\nReturns None.",
    "_asyncio.current_task" => "Return a currently executed task.",
    "_asyncio.get_event_loop" => "Return an asyncio event loop.\n\nWhen called from a coroutine or a callback (e.g. scheduled with\ncall_soon or similar API), this function will always return the\nrunning event loop.\n\nIf there is no running event loop set, the function will return\nthe result of `get_event_loop_policy().get_event_loop()` call.",
    "_asyncio.get_running_loop" => "Return the running event loop.  Raise a RuntimeError if there is none.\n\nThis function is thread-specific.",
    "_bisect" => "Bisection algorithms.\n\nThis module provides support for maintaining a list in sorted order without\nhaving to sort the list after each insertion. For long lists of items with\nexpensive comparison operations, this can be an improvement over the more\ncommon approach.",
    "_bisect.bisect_left" => "Return the index where to insert item x in list a, assuming a is sorted.\n\nThe return value i is such that all e in a[:i] have e < x, and all e in\na[i:] have e >= x.  So if x already appears in the list, a.insert(i, x) will\ninsert just before the leftmost x already there.\n\nOptional args lo (default 0) and hi (default len(a)) bound the\nslice of a to be searched.\n\nA custom key function can be supplied to customize the sort order.",
    "_bisect.bisect_right" => "Return the index where to insert item x in list a, assuming a is sorted.\n\nThe return value i is such that all e in a[:i] have e <= x, and all e in\na[i:] have e > x.  So if x already appears in the list, a.insert(i, x) will\ninsert just after the rightmost x already there.\n\nOptional args lo (default 0) and hi (default len(a)) bound the\nslice of a to be searched.\n\nA custom key function can be supplied to customize the sort order.",
    "_bisect.insort_left" => "Insert item x in list a, and keep it sorted assuming a is sorted.\n\nIf x is already in a, insert it to the left of the leftmost x.\n\nOptional args lo (default 0) and hi (default len(a)) bound the\nslice of a to be searched.\n\nA custom key function can be supplied to customize the sort order.",
    "_bisect.insort_right" => "Insert item x in list a, and keep it sorted assuming a is sorted.\n\nIf x is already in a, insert it to the right of the rightmost x.\n\nOptional args lo (default 0) and hi (default len(a)) bound the\nslice of a to be searched.\n\nA custom key function can be supplied to customize the sort order.",
    "_blake2" => "_blake2b provides BLAKE2b for hashlib",
    "_blake2.blake2b" => "Return a new BLAKE2b hash object.",
    "_blake2.blake2b.__delattr__" => "Implement delattr(self, name).",
    "_blake2.blake2b.__eq__" => "Return self==value.",
    "_blake2.blake2b.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_blake2.blake2b.__ge__" => "Return self>=value.",
    "_blake2.blake2b.__getattribute__" => "Return getattr(self, name).",
    "_blake2.blake2b.__getstate__" => "Helper for pickle.",
    "_blake2.blake2b.__gt__" => "Return self>value.",
    "_blake2.blake2b.__hash__" => "Return hash(self).",
    "_blake2.blake2b.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_blake2.blake2b.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_blake2.blake2b.__le__" => "Return self<=value.",
    "_blake2.blake2b.__lt__" => "Return self<value.",
    "_blake2.blake2b.__ne__" => "Return self!=value.",
    "_blake2.blake2b.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_blake2.blake2b.__reduce__" => "Helper for pickle.",
    "_blake2.blake2b.__reduce_ex__" => "Helper for pickle.",
    "_blake2.blake2b.__repr__" => "Return repr(self).",
    "_blake2.blake2b.__setattr__" => "Implement setattr(self, name, value).",
    "_blake2.blake2b.__sizeof__" => "Size of object in memory, in bytes.",
    "_blake2.blake2b.__str__" => "Return str(self).",
    "_blake2.blake2b.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_blake2.blake2b.copy" => "Return a copy of the hash object.",
    "_blake2.blake2b.digest" => "Return the digest value as a bytes object.",
    "_blake2.blake2b.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_blake2.blake2b.update" => "Update this hash object's state with the provided bytes-like object.",
    "_blake2.blake2s" => "Return a new BLAKE2s hash object.",
    "_blake2.blake2s.__delattr__" => "Implement delattr(self, name).",
    "_blake2.blake2s.__eq__" => "Return self==value.",
    "_blake2.blake2s.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_blake2.blake2s.__ge__" => "Return self>=value.",
    "_blake2.blake2s.__getattribute__" => "Return getattr(self, name).",
    "_blake2.blake2s.__getstate__" => "Helper for pickle.",
    "_blake2.blake2s.__gt__" => "Return self>value.",
    "_blake2.blake2s.__hash__" => "Return hash(self).",
    "_blake2.blake2s.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_blake2.blake2s.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_blake2.blake2s.__le__" => "Return self<=value.",
    "_blake2.blake2s.__lt__" => "Return self<value.",
    "_blake2.blake2s.__ne__" => "Return self!=value.",
    "_blake2.blake2s.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_blake2.blake2s.__reduce__" => "Helper for pickle.",
    "_blake2.blake2s.__reduce_ex__" => "Helper for pickle.",
    "_blake2.blake2s.__repr__" => "Return repr(self).",
    "_blake2.blake2s.__setattr__" => "Implement setattr(self, name, value).",
    "_blake2.blake2s.__sizeof__" => "Size of object in memory, in bytes.",
    "_blake2.blake2s.__str__" => "Return str(self).",
    "_blake2.blake2s.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_blake2.blake2s.copy" => "Return a copy of the hash object.",
    "_blake2.blake2s.digest" => "Return the digest value as a bytes object.",
    "_blake2.blake2s.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_blake2.blake2s.update" => "Update this hash object's state with the provided bytes-like object.",
    "_bz2.BZ2Compressor" => "Create a compressor object for compressing data incrementally.\n\n  compresslevel\n    Compression level, as a number between 1 and 9.\n\nFor one-shot compression, use the compress() function instead.",
    "_bz2.BZ2Compressor.__delattr__" => "Implement delattr(self, name).",
    "_bz2.BZ2Compressor.__eq__" => "Return self==value.",
    "_bz2.BZ2Compressor.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_bz2.BZ2Compressor.__ge__" => "Return self>=value.",
    "_bz2.BZ2Compressor.__getattribute__" => "Return getattr(self, name).",
    "_bz2.BZ2Compressor.__getstate__" => "Helper for pickle.",
    "_bz2.BZ2Compressor.__gt__" => "Return self>value.",
    "_bz2.BZ2Compressor.__hash__" => "Return hash(self).",
    "_bz2.BZ2Compressor.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_bz2.BZ2Compressor.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_bz2.BZ2Compressor.__le__" => "Return self<=value.",
    "_bz2.BZ2Compressor.__lt__" => "Return self<value.",
    "_bz2.BZ2Compressor.__ne__" => "Return self!=value.",
    "_bz2.BZ2Compressor.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_bz2.BZ2Compressor.__reduce__" => "Helper for pickle.",
    "_bz2.BZ2Compressor.__reduce_ex__" => "Helper for pickle.",
    "_bz2.BZ2Compressor.__repr__" => "Return repr(self).",
    "_bz2.BZ2Compressor.__setattr__" => "Implement setattr(self, name, value).",
    "_bz2.BZ2Compressor.__sizeof__" => "Size of object in memory, in bytes.",
    "_bz2.BZ2Compressor.__str__" => "Return str(self).",
    "_bz2.BZ2Compressor.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_bz2.BZ2Compressor.compress" => "Provide data to the compressor object.\n\nReturns a chunk of compressed data if possible, or b'' otherwise.\n\nWhen you have finished providing data to the compressor, call the\nflush() method to finish the compression process.",
    "_bz2.BZ2Compressor.flush" => "Finish the compression process.\n\nReturns the compressed data left in internal buffers.\n\nThe compressor object may not be used after this method is called.",
    "_bz2.BZ2Decompressor" => "Create a decompressor object for decompressing data incrementally.\n\nFor one-shot decompression, use the decompress() function instead.",
    "_bz2.BZ2Decompressor.__delattr__" => "Implement delattr(self, name).",
    "_bz2.BZ2Decompressor.__eq__" => "Return self==value.",
    "_bz2.BZ2Decompressor.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_bz2.BZ2Decompressor.__ge__" => "Return self>=value.",
    "_bz2.BZ2Decompressor.__getattribute__" => "Return getattr(self, name).",
    "_bz2.BZ2Decompressor.__getstate__" => "Helper for pickle.",
    "_bz2.BZ2Decompressor.__gt__" => "Return self>value.",
    "_bz2.BZ2Decompressor.__hash__" => "Return hash(self).",
    "_bz2.BZ2Decompressor.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_bz2.BZ2Decompressor.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_bz2.BZ2Decompressor.__le__" => "Return self<=value.",
    "_bz2.BZ2Decompressor.__lt__" => "Return self<value.",
    "_bz2.BZ2Decompressor.__ne__" => "Return self!=value.",
    "_bz2.BZ2Decompressor.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_bz2.BZ2Decompressor.__reduce__" => "Helper for pickle.",
    "_bz2.BZ2Decompressor.__reduce_ex__" => "Helper for pickle.",
    "_bz2.BZ2Decompressor.__repr__" => "Return repr(self).",
    "_bz2.BZ2Decompressor.__setattr__" => "Implement setattr(self, name, value).",
    "_bz2.BZ2Decompressor.__sizeof__" => "Size of object in memory, in bytes.",
    "_bz2.BZ2Decompressor.__str__" => "Return str(self).",
    "_bz2.BZ2Decompressor.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_bz2.BZ2Decompressor.decompress" => "Decompress *data*, returning uncompressed data as bytes.\n\nIf *max_length* is nonnegative, returns at most *max_length* bytes of\ndecompressed data. If this limit is reached and further output can be\nproduced, *self.needs_input* will be set to ``False``. In this case, the next\ncall to *decompress()* may provide *data* as b'' to obtain more of the output.\n\nIf all of the input data was decompressed and returned (either because this\nwas less than *max_length* bytes, or because *max_length* was negative),\n*self.needs_input* will be set to True.\n\nAttempting to decompress data after the end of stream is reached raises an\nEOFError.  Any data found after the end of the stream is ignored and saved in\nthe unused_data attribute.",
    "_bz2.BZ2Decompressor.eof" => "True if the end-of-stream marker has been reached.",
    "_bz2.BZ2Decompressor.needs_input" => "True if more input is needed before more decompressed data can be produced.",
    "_bz2.BZ2Decompressor.unused_data" => "Data found after the end of the compressed stream.",
    "_codecs.decode" => "Decodes obj using the codec registered for encoding.\n\nDefault encoding is 'utf-8'.  errors may be given to set a\ndifferent error handling scheme.  Default is 'strict' meaning that encoding\nerrors raise a ValueError.  Other possible values are 'ignore', 'replace'\nand 'backslashreplace' as well as any other name registered with\ncodecs.register_error that can handle ValueErrors.",
    "_codecs.encode" => "Encodes obj using the codec registered for encoding.\n\nThe default encoding is 'utf-8'.  errors may be given to set a\ndifferent error handling scheme.  Default is 'strict' meaning that encoding\nerrors raise a ValueError.  Other possible values are 'ignore', 'replace'\nand 'backslashreplace' as well as any other name registered with\ncodecs.register_error that can handle ValueErrors.",
    "_codecs.lookup" => "Looks up a codec tuple in the Python codec registry and returns a CodecInfo object.",
    "_codecs.lookup_error" => "lookup_error(errors) -> handler\n\nReturn the error handler for the specified error handling name or raise a\nLookupError, if no handler exists under this name.",
    "_codecs.register" => "Register a codec search function.\n\nSearch functions are expected to take one argument, the encoding name in\nall lower case letters, and either return None, or a tuple of functions\n(encoder, decoder, stream_reader, stream_writer) (or a CodecInfo object).",
    "_codecs.register_error" => "Register the specified error handler under the name errors.\n\nhandler must be a callable object, that will be called with an exception\ninstance containing information about the location of the encoding/decoding\nerror and must return a (replacement, new position) tuple.",
    "_codecs.unregister" => "Unregister a codec search function and clear the registry's cache.\n\nIf the search function is not registered, do nothing.",
    "_collections" => "High performance data structures.\n- deque:        ordered collection accessible from endpoints only\n- defaultdict:  dict subclass with a default value factory",
    "_collections._count_elements" => "Count elements in the iterable, updating the mapping",
    "_contextvars" => "Context Variables",
    "_contextvars.Context.__contains__" => "Return bool(key in self).",
    "_contextvars.Context.__delattr__" => "Implement delattr(self, name).",
    "_contextvars.Context.__eq__" => "Return self==value.",
    "_contextvars.Context.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_contextvars.Context.__ge__" => "Return self>=value.",
    "_contextvars.Context.__getattribute__" => "Return getattr(self, name).",
    "_contextvars.Context.__getitem__" => "Return self[key].",
    "_contextvars.Context.__getstate__" => "Helper for pickle.",
    "_contextvars.Context.__gt__" => "Return self>value.",
    "_contextvars.Context.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_contextvars.Context.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_contextvars.Context.__iter__" => "Implement iter(self).",
    "_contextvars.Context.__le__" => "Return self<=value.",
    "_contextvars.Context.__len__" => "Return len(self).",
    "_contextvars.Context.__lt__" => "Return self<value.",
    "_contextvars.Context.__ne__" => "Return self!=value.",
    "_contextvars.Context.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_contextvars.Context.__reduce__" => "Helper for pickle.",
    "_contextvars.Context.__reduce_ex__" => "Helper for pickle.",
    "_contextvars.Context.__repr__" => "Return repr(self).",
    "_contextvars.Context.__setattr__" => "Implement setattr(self, name, value).",
    "_contextvars.Context.__sizeof__" => "Size of object in memory, in bytes.",
    "_contextvars.Context.__str__" => "Return str(self).",
    "_contextvars.Context.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_contextvars.Context.copy" => "Return a shallow copy of the context object.",
    "_contextvars.Context.get" => "Return the value for `key` if `key` has the value in the context object.\n\nIf `key` does not exist, return `default`. If `default` is not given,\nreturn None.",
    "_contextvars.Context.items" => "Return all variables and their values in the context object.\n\nThe result is returned as a list of 2-tuples (variable, value).",
    "_contextvars.Context.keys" => "Return a list of all variables in the context object.",
    "_contextvars.Context.values" => "Return a list of all variables' values in the context object.",
    "_contextvars.ContextVar.__class_getitem__" => "See PEP 585",
    "_contextvars.ContextVar.__delattr__" => "Implement delattr(self, name).",
    "_contextvars.ContextVar.__eq__" => "Return self==value.",
    "_contextvars.ContextVar.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_contextvars.ContextVar.__ge__" => "Return self>=value.",
    "_contextvars.ContextVar.__getattribute__" => "Return getattr(self, name).",
    "_contextvars.ContextVar.__getstate__" => "Helper for pickle.",
    "_contextvars.ContextVar.__gt__" => "Return self>value.",
    "_contextvars.ContextVar.__hash__" => "Return hash(self).",
    "_contextvars.ContextVar.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_contextvars.ContextVar.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_contextvars.ContextVar.__le__" => "Return self<=value.",
    "_contextvars.ContextVar.__lt__" => "Return self<value.",
    "_contextvars.ContextVar.__ne__" => "Return self!=value.",
    "_contextvars.ContextVar.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_contextvars.ContextVar.__reduce__" => "Helper for pickle.",
    "_contextvars.ContextVar.__reduce_ex__" => "Helper for pickle.",
    "_contextvars.ContextVar.__repr__" => "Return repr(self).",
    "_contextvars.ContextVar.__setattr__" => "Implement setattr(self, name, value).",
    "_contextvars.ContextVar.__sizeof__" => "Size of object in memory, in bytes.",
    "_contextvars.ContextVar.__str__" => "Return str(self).",
    "_contextvars.ContextVar.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_contextvars.ContextVar.get" => "Return a value for the context variable for the current context.\n\nIf there is no value for the variable in the current context, the method will:\n * return the value of the default argument of the method, if provided; or\n * return the default value for the context variable, if it was created\n   with one; or\n * raise a LookupError.",
    "_contextvars.ContextVar.reset" => "Reset the context variable.\n\nThe variable is reset to the value it had before the `ContextVar.set()` that\ncreated the token was used.",
    "_contextvars.ContextVar.set" => "Call to set a new value for the context variable in the current context.\n\nThe required value argument is the new value for the context variable.\n\nReturns a Token object that can be used to restore the variable to its previous\nvalue via the `ContextVar.reset()` method.",
    "_contextvars.Token.__class_getitem__" => "See PEP 585",
    "_contextvars.Token.__delattr__" => "Implement delattr(self, name).",
    "_contextvars.Token.__eq__" => "Return self==value.",
    "_contextvars.Token.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_contextvars.Token.__ge__" => "Return self>=value.",
    "_contextvars.Token.__getattribute__" => "Return getattr(self, name).",
    "_contextvars.Token.__getstate__" => "Helper for pickle.",
    "_contextvars.Token.__gt__" => "Return self>value.",
    "_contextvars.Token.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_contextvars.Token.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_contextvars.Token.__le__" => "Return self<=value.",
    "_contextvars.Token.__lt__" => "Return self<value.",
    "_contextvars.Token.__ne__" => "Return self!=value.",
    "_contextvars.Token.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_contextvars.Token.__reduce__" => "Helper for pickle.",
    "_contextvars.Token.__reduce_ex__" => "Helper for pickle.",
    "_contextvars.Token.__repr__" => "Return repr(self).",
    "_contextvars.Token.__setattr__" => "Implement setattr(self, name, value).",
    "_contextvars.Token.__sizeof__" => "Size of object in memory, in bytes.",
    "_contextvars.Token.__str__" => "Return str(self).",
    "_contextvars.Token.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_csv" => "CSV parsing and writing.",
    "_csv.Dialect" => "CSV dialect\n\nThe Dialect type records CSV parsing and generation options.",
    "_csv.Dialect.__delattr__" => "Implement delattr(self, name).",
    "_csv.Dialect.__eq__" => "Return self==value.",
    "_csv.Dialect.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_csv.Dialect.__ge__" => "Return self>=value.",
    "_csv.Dialect.__getattribute__" => "Return getattr(self, name).",
    "_csv.Dialect.__getstate__" => "Helper for pickle.",
    "_csv.Dialect.__gt__" => "Return self>value.",
    "_csv.Dialect.__hash__" => "Return hash(self).",
    "_csv.Dialect.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_csv.Dialect.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_csv.Dialect.__le__" => "Return self<=value.",
    "_csv.Dialect.__lt__" => "Return self<value.",
    "_csv.Dialect.__ne__" => "Return self!=value.",
    "_csv.Dialect.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_csv.Dialect.__reduce__" => "raises an exception to avoid pickling",
    "_csv.Dialect.__reduce_ex__" => "raises an exception to avoid pickling",
    "_csv.Dialect.__repr__" => "Return repr(self).",
    "_csv.Dialect.__setattr__" => "Implement setattr(self, name, value).",
    "_csv.Dialect.__sizeof__" => "Size of object in memory, in bytes.",
    "_csv.Dialect.__str__" => "Return str(self).",
    "_csv.Dialect.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_csv.Error.__cause__" => "exception cause",
    "_csv.Error.__context__" => "exception context",
    "_csv.Error.__delattr__" => "Implement delattr(self, name).",
    "_csv.Error.__eq__" => "Return self==value.",
    "_csv.Error.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_csv.Error.__ge__" => "Return self>=value.",
    "_csv.Error.__getattribute__" => "Return getattr(self, name).",
    "_csv.Error.__getstate__" => "Helper for pickle.",
    "_csv.Error.__gt__" => "Return self>value.",
    "_csv.Error.__hash__" => "Return hash(self).",
    "_csv.Error.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_csv.Error.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_csv.Error.__le__" => "Return self<=value.",
    "_csv.Error.__lt__" => "Return self<value.",
    "_csv.Error.__ne__" => "Return self!=value.",
    "_csv.Error.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_csv.Error.__reduce_ex__" => "Helper for pickle.",
    "_csv.Error.__repr__" => "Return repr(self).",
    "_csv.Error.__setattr__" => "Implement setattr(self, name, value).",
    "_csv.Error.__sizeof__" => "Size of object in memory, in bytes.",
    "_csv.Error.__str__" => "Return str(self).",
    "_csv.Error.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_csv.Error.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_csv.Error.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_csv.Reader" => "CSV reader\n\nReader objects are responsible for reading and parsing tabular data\nin CSV format.",
    "_csv.Reader.__delattr__" => "Implement delattr(self, name).",
    "_csv.Reader.__eq__" => "Return self==value.",
    "_csv.Reader.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_csv.Reader.__ge__" => "Return self>=value.",
    "_csv.Reader.__getattribute__" => "Return getattr(self, name).",
    "_csv.Reader.__getstate__" => "Helper for pickle.",
    "_csv.Reader.__gt__" => "Return self>value.",
    "_csv.Reader.__hash__" => "Return hash(self).",
    "_csv.Reader.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_csv.Reader.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_csv.Reader.__iter__" => "Implement iter(self).",
    "_csv.Reader.__le__" => "Return self<=value.",
    "_csv.Reader.__lt__" => "Return self<value.",
    "_csv.Reader.__ne__" => "Return self!=value.",
    "_csv.Reader.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_csv.Reader.__next__" => "Implement next(self).",
    "_csv.Reader.__reduce__" => "Helper for pickle.",
    "_csv.Reader.__reduce_ex__" => "Helper for pickle.",
    "_csv.Reader.__repr__" => "Return repr(self).",
    "_csv.Reader.__setattr__" => "Implement setattr(self, name, value).",
    "_csv.Reader.__sizeof__" => "Size of object in memory, in bytes.",
    "_csv.Reader.__str__" => "Return str(self).",
    "_csv.Reader.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_csv.Writer" => "CSV writer\n\nWriter objects are responsible for generating tabular data\nin CSV format from sequence input.",
    "_csv.Writer.__delattr__" => "Implement delattr(self, name).",
    "_csv.Writer.__eq__" => "Return self==value.",
    "_csv.Writer.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_csv.Writer.__ge__" => "Return self>=value.",
    "_csv.Writer.__getattribute__" => "Return getattr(self, name).",
    "_csv.Writer.__getstate__" => "Helper for pickle.",
    "_csv.Writer.__gt__" => "Return self>value.",
    "_csv.Writer.__hash__" => "Return hash(self).",
    "_csv.Writer.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_csv.Writer.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_csv.Writer.__le__" => "Return self<=value.",
    "_csv.Writer.__lt__" => "Return self<value.",
    "_csv.Writer.__ne__" => "Return self!=value.",
    "_csv.Writer.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_csv.Writer.__reduce__" => "Helper for pickle.",
    "_csv.Writer.__reduce_ex__" => "Helper for pickle.",
    "_csv.Writer.__repr__" => "Return repr(self).",
    "_csv.Writer.__setattr__" => "Implement setattr(self, name, value).",
    "_csv.Writer.__sizeof__" => "Size of object in memory, in bytes.",
    "_csv.Writer.__str__" => "Return str(self).",
    "_csv.Writer.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_csv.Writer.writerow" => "Construct and write a CSV record from an iterable of fields.\n\nNon-string elements will be converted to string.",
    "_csv.Writer.writerows" => "Construct and write a series of iterables to a csv file.\n\nNon-string elements will be converted to string.",
    "_csv.field_size_limit" => "Sets an upper limit on parsed fields.\n\nReturns old limit. If limit is not given, no new limit is set and\nthe old limit is returned",
    "_csv.get_dialect" => "Return the dialect instance associated with name.",
    "_csv.list_dialects" => "Return a list of all known dialect names.",
    "_csv.reader" => "Return a reader object that will process lines from the given iterable.\n\nThe \"iterable\" argument can be any object that returns a line\nof input for each iteration, such as a file object or a list.  The\noptional \"dialect\" argument defines a CSV dialect.  The function\nalso accepts optional keyword arguments which override settings\nprovided by the dialect.\n\nThe returned object is an iterator.  Each iteration returns a row\nof the CSV file (which can span multiple input lines).",
    "_csv.register_dialect" => "Create a mapping from a string name to a CVS dialect.\n\nThe optional \"dialect\" argument specifies the base dialect instance\nor the name of the registered dialect.  The function also accepts\noptional keyword arguments which override settings provided by the\ndialect.",
    "_csv.unregister_dialect" => "Delete the name/dialect mapping associated with a string name.",
    "_csv.writer" => "Return a writer object that will write user data on the given file object.\n\nThe \"fileobj\" argument can be any object that supports the file API.\nThe optional \"dialect\" argument defines a CSV dialect.  The function\nalso accepts optional keyword arguments which override settings\nprovided by the dialect.",
    "_ctypes" => "Create and manipulate C compatible data types in Python.",
    "_ctypes.Array" => "Abstract base class for arrays.\n\nThe recommended way to create concrete array types is by multiplying any\nctypes data type with a non-negative integer. Alternatively, you can subclass\nthis type and define _length_ and _type_ class variables. Array elements can\nbe read and written using standard subscript and slice accesses for slice\nreads, the resulting object is not itself an Array.",
    "_ctypes.CFuncPtr" => "Function Pointer",
    "_ctypes.COMError" => "Raised when a COM method call failed.",
    "_ctypes.COMError.__cause__" => "exception cause",
    "_ctypes.COMError.__context__" => "exception context",
    "_ctypes.COMError.__delattr__" => "Implement delattr(self, name).",
    "_ctypes.COMError.__eq__" => "Return self==value.",
    "_ctypes.COMError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_ctypes.COMError.__ge__" => "Return self>=value.",
    "_ctypes.COMError.__getattribute__" => "Return getattr(self, name).",
    "_ctypes.COMError.__getstate__" => "Helper for pickle.",
    "_ctypes.COMError.__gt__" => "Return self>value.",
    "_ctypes.COMError.__hash__" => "Return hash(self).",
    "_ctypes.COMError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_ctypes.COMError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_ctypes.COMError.__le__" => "Return self<=value.",
    "_ctypes.COMError.__lt__" => "Return self<value.",
    "_ctypes.COMError.__ne__" => "Return self!=value.",
    "_ctypes.COMError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_ctypes.COMError.__reduce_ex__" => "Helper for pickle.",
    "_ctypes.COMError.__repr__" => "Return repr(self).",
    "_ctypes.COMError.__setattr__" => "Implement setattr(self, name, value).",
    "_ctypes.COMError.__sizeof__" => "Size of object in memory, in bytes.",
    "_ctypes.COMError.__str__" => "Return str(self).",
    "_ctypes.COMError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_ctypes.COMError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_ctypes.COMError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_ctypes.CopyComPointer" => "CopyComPointer(src, dst) -> HRESULT value",
    "_ctypes.FormatError" => "FormatError([integer]) -> string\n\nConvert a win32 error code into a string. If the error code is not\ngiven, the return value of a call to GetLastError() is used.",
    "_ctypes.FreeLibrary" => "FreeLibrary(handle) -> void\n\nFree the handle of an executable previously loaded by LoadLibrary.",
    "_ctypes.LoadLibrary" => "LoadLibrary(name, load_flags) -> handle\n\nLoad an executable (usually a DLL), and return a handle to it.\nThe handle may be used to locate exported functions in this\nmodule. load_flags are as defined for LoadLibraryEx in the\nWindows API.",
    "_ctypes.POINTER" => "Create and return a new ctypes pointer type.\n\n  type\n    A ctypes type.\n\nPointer types are cached and reused internally,\nso calling this function repeatedly is cheap.",
    "_ctypes.Structure" => "Structure base class",
    "_ctypes.Union" => "Union base class",
    "_ctypes._Pointer" => "XXX to be provided",
    "_ctypes._SimpleCData" => "XXX to be provided",
    "_ctypes.addressof" => "addressof(C instance) -> integer\nReturn the address of the C instance internal buffer",
    "_ctypes.alignment" => "alignment(C type) -> integer\nalignment(C instance) -> integer\nReturn the alignment requirements of a C instance",
    "_ctypes.buffer_info" => "Return buffer interface information",
    "_ctypes.byref" => "byref(C instance[, offset=0]) -> byref-object\nReturn a pointer lookalike to a C instance, only usable\nas function argument",
    "_ctypes.pointer" => "Create a new pointer instance, pointing to 'obj'.\n\nThe returned object is of the type POINTER(type(obj)). Note that if you\njust want to pass a pointer to an object to a foreign function call, you\nshould use byref(obj) which is much faster.",
    "_ctypes.resize" => "Resize the memory buffer of a ctypes instance",
    "_ctypes.sizeof" => "sizeof(C type) -> integer\nsizeof(C instance) -> integer\nReturn the size in bytes of a C instance",
    "_datetime" => "Fast implementation of the datetime type.",
    "_decimal" => "C decimal arithmetic module",
    "_decimal.getcontext" => "Get the current default context.",
    "_decimal.localcontext" => "Return a context manager that will set the default context to a copy of ctx\non entry to the with-statement and restore the previous default context when\nexiting the with-statement. If no context is specified, a copy of the current\ndefault context is used.",
    "_decimal.setcontext" => "Set a new default context.",
    "_elementtree._set_factories" => "Change the factories used to create comments and processing instructions.\n\nFor internal use only.",
    "_functools" => "Tools that operate on functions.",
    "_functools.cmp_to_key" => "Convert a cmp= function into a key= function.\n\nmycmp\n  Function that compares two objects.",
    "_functools.reduce" => "reduce(function, iterable[, initial], /) -> value\n\nApply a function of two arguments cumulatively to the items of an iterable, from left to right.\n\nThis effectively reduces the iterable to a single value.  If initial is present,\nit is placed before the items of the iterable in the calculation, and serves as\na default when the iterable is empty.\n\nFor example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])\ncalculates ((((1 + 2) + 3) + 4) + 5).",
    "_hashlib" => "OpenSSL interface for hashlib module",
    "_hashlib.HASH" => "A hash is an object used to calculate a checksum of a string of information.\n\nMethods:\n\nupdate() -- updates the current digest with an additional string\ndigest() -- return the current digest value\nhexdigest() -- return the current digest as a string of hexadecimal digits\ncopy() -- return a copy of the current hash object\n\nAttributes:\n\nname -- the hash algorithm being used by this object\ndigest_size -- number of bytes in this hashes output",
    "_hashlib.HASH.__delattr__" => "Implement delattr(self, name).",
    "_hashlib.HASH.__eq__" => "Return self==value.",
    "_hashlib.HASH.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_hashlib.HASH.__ge__" => "Return self>=value.",
    "_hashlib.HASH.__getattribute__" => "Return getattr(self, name).",
    "_hashlib.HASH.__getstate__" => "Helper for pickle.",
    "_hashlib.HASH.__gt__" => "Return self>value.",
    "_hashlib.HASH.__hash__" => "Return hash(self).",
    "_hashlib.HASH.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_hashlib.HASH.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_hashlib.HASH.__le__" => "Return self<=value.",
    "_hashlib.HASH.__lt__" => "Return self<value.",
    "_hashlib.HASH.__ne__" => "Return self!=value.",
    "_hashlib.HASH.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_hashlib.HASH.__reduce__" => "Helper for pickle.",
    "_hashlib.HASH.__reduce_ex__" => "Helper for pickle.",
    "_hashlib.HASH.__repr__" => "Return repr(self).",
    "_hashlib.HASH.__setattr__" => "Implement setattr(self, name, value).",
    "_hashlib.HASH.__sizeof__" => "Size of object in memory, in bytes.",
    "_hashlib.HASH.__str__" => "Return str(self).",
    "_hashlib.HASH.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_hashlib.HASH.copy" => "Return a copy of the hash object.",
    "_hashlib.HASH.digest" => "Return the digest value as a bytes object.",
    "_hashlib.HASH.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_hashlib.HASH.update" => "Update this hash object's state with the provided string.",
    "_hashlib.HASHXOF" => "A hash is an object used to calculate a checksum of a string of information.\n\nMethods:\n\nupdate() -- updates the current digest with an additional string\ndigest(length) -- return the current digest value\nhexdigest(length) -- return the current digest as a string of hexadecimal digits\ncopy() -- return a copy of the current hash object\n\nAttributes:\n\nname -- the hash algorithm being used by this object\ndigest_size -- number of bytes in this hashes output",
    "_hashlib.HASHXOF.__delattr__" => "Implement delattr(self, name).",
    "_hashlib.HASHXOF.__eq__" => "Return self==value.",
    "_hashlib.HASHXOF.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_hashlib.HASHXOF.__ge__" => "Return self>=value.",
    "_hashlib.HASHXOF.__getattribute__" => "Return getattr(self, name).",
    "_hashlib.HASHXOF.__getstate__" => "Helper for pickle.",
    "_hashlib.HASHXOF.__gt__" => "Return self>value.",
    "_hashlib.HASHXOF.__hash__" => "Return hash(self).",
    "_hashlib.HASHXOF.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_hashlib.HASHXOF.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_hashlib.HASHXOF.__le__" => "Return self<=value.",
    "_hashlib.HASHXOF.__lt__" => "Return self<value.",
    "_hashlib.HASHXOF.__ne__" => "Return self!=value.",
    "_hashlib.HASHXOF.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_hashlib.HASHXOF.__reduce__" => "Helper for pickle.",
    "_hashlib.HASHXOF.__reduce_ex__" => "Helper for pickle.",
    "_hashlib.HASHXOF.__repr__" => "Return repr(self).",
    "_hashlib.HASHXOF.__setattr__" => "Implement setattr(self, name, value).",
    "_hashlib.HASHXOF.__sizeof__" => "Size of object in memory, in bytes.",
    "_hashlib.HASHXOF.__str__" => "Return str(self).",
    "_hashlib.HASHXOF.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_hashlib.HASHXOF.copy" => "Return a copy of the hash object.",
    "_hashlib.HASHXOF.digest" => "Return the digest value as a bytes object.",
    "_hashlib.HASHXOF.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_hashlib.HASHXOF.update" => "Update this hash object's state with the provided string.",
    "_hashlib.HMAC" => "The object used to calculate HMAC of a message.\n\nMethods:\n\nupdate() -- updates the current digest with an additional string\ndigest() -- return the current digest value\nhexdigest() -- return the current digest as a string of hexadecimal digits\ncopy() -- return a copy of the current hash object\n\nAttributes:\n\nname -- the name, including the hash algorithm used by this object\ndigest_size -- number of bytes in digest() output",
    "_hashlib.HMAC.__delattr__" => "Implement delattr(self, name).",
    "_hashlib.HMAC.__eq__" => "Return self==value.",
    "_hashlib.HMAC.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_hashlib.HMAC.__ge__" => "Return self>=value.",
    "_hashlib.HMAC.__getattribute__" => "Return getattr(self, name).",
    "_hashlib.HMAC.__getstate__" => "Helper for pickle.",
    "_hashlib.HMAC.__gt__" => "Return self>value.",
    "_hashlib.HMAC.__hash__" => "Return hash(self).",
    "_hashlib.HMAC.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_hashlib.HMAC.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_hashlib.HMAC.__le__" => "Return self<=value.",
    "_hashlib.HMAC.__lt__" => "Return self<value.",
    "_hashlib.HMAC.__ne__" => "Return self!=value.",
    "_hashlib.HMAC.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_hashlib.HMAC.__reduce__" => "Helper for pickle.",
    "_hashlib.HMAC.__reduce_ex__" => "Helper for pickle.",
    "_hashlib.HMAC.__repr__" => "Return repr(self).",
    "_hashlib.HMAC.__setattr__" => "Implement setattr(self, name, value).",
    "_hashlib.HMAC.__sizeof__" => "Size of object in memory, in bytes.",
    "_hashlib.HMAC.__str__" => "Return str(self).",
    "_hashlib.HMAC.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_hashlib.HMAC.copy" => "Return a copy (\"clone\") of the HMAC object.",
    "_hashlib.HMAC.digest" => "Return the digest of the bytes passed to the update() method so far.",
    "_hashlib.HMAC.hexdigest" => "Return hexadecimal digest of the bytes passed to the update() method so far.\n\nThis may be used to exchange the value safely in email or other non-binary\nenvironments.",
    "_hashlib.HMAC.update" => "Update the HMAC object with msg.",
    "_hashlib.UnsupportedDigestmodError.__cause__" => "exception cause",
    "_hashlib.UnsupportedDigestmodError.__context__" => "exception context",
    "_hashlib.UnsupportedDigestmodError.__delattr__" => "Implement delattr(self, name).",
    "_hashlib.UnsupportedDigestmodError.__eq__" => "Return self==value.",
    "_hashlib.UnsupportedDigestmodError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_hashlib.UnsupportedDigestmodError.__ge__" => "Return self>=value.",
    "_hashlib.UnsupportedDigestmodError.__getattribute__" => "Return getattr(self, name).",
    "_hashlib.UnsupportedDigestmodError.__getstate__" => "Helper for pickle.",
    "_hashlib.UnsupportedDigestmodError.__gt__" => "Return self>value.",
    "_hashlib.UnsupportedDigestmodError.__hash__" => "Return hash(self).",
    "_hashlib.UnsupportedDigestmodError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_hashlib.UnsupportedDigestmodError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_hashlib.UnsupportedDigestmodError.__le__" => "Return self<=value.",
    "_hashlib.UnsupportedDigestmodError.__lt__" => "Return self<value.",
    "_hashlib.UnsupportedDigestmodError.__ne__" => "Return self!=value.",
    "_hashlib.UnsupportedDigestmodError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_hashlib.UnsupportedDigestmodError.__reduce_ex__" => "Helper for pickle.",
    "_hashlib.UnsupportedDigestmodError.__repr__" => "Return repr(self).",
    "_hashlib.UnsupportedDigestmodError.__setattr__" => "Implement setattr(self, name, value).",
    "_hashlib.UnsupportedDigestmodError.__sizeof__" => "Size of object in memory, in bytes.",
    "_hashlib.UnsupportedDigestmodError.__str__" => "Return str(self).",
    "_hashlib.UnsupportedDigestmodError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_hashlib.UnsupportedDigestmodError.__weakref__" => "list of weak references to the object",
    "_hashlib.UnsupportedDigestmodError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_hashlib.UnsupportedDigestmodError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_hashlib.compare_digest" => "Return 'a == b'.\n\nThis function uses an approach designed to prevent\ntiming analysis, making it appropriate for cryptography.\n\na and b must both be of the same type: either str (ASCII only),\nor any bytes-like object.\n\nNote: If a and b are of different lengths, or if an error occurs,\na timing attack could theoretically reveal information about the\ntypes and lengths of a and b--but not their values.",
    "_hashlib.get_fips_mode" => "Determine the OpenSSL FIPS mode of operation.\n\nFor OpenSSL 3.0.0 and newer it returns the state of the default provider\nin the default OSSL context. It's not quite the same as FIPS_mode() but good\nenough for unittests.\n\nEffectively any non-zero return value indicates FIPS mode;\nvalues other than 1 may have additional significance.",
    "_hashlib.hmac_digest" => "Single-shot HMAC.",
    "_hashlib.hmac_new" => "Return a new hmac object.",
    "_hashlib.new" => "Return a new hash object using the named algorithm.\n\nAn optional string argument may be provided and will be\nautomatically hashed.\n\nThe MD5 and SHA1 algorithms are always supported.",
    "_hashlib.openssl_md5" => "Returns a md5 hash object; optionally initialized with a string",
    "_hashlib.openssl_sha1" => "Returns a sha1 hash object; optionally initialized with a string",
    "_hashlib.openssl_sha224" => "Returns a sha224 hash object; optionally initialized with a string",
    "_hashlib.openssl_sha256" => "Returns a sha256 hash object; optionally initialized with a string",
    "_hashlib.openssl_sha384" => "Returns a sha384 hash object; optionally initialized with a string",
    "_hashlib.openssl_sha3_224" => "Returns a sha3-224 hash object; optionally initialized with a string",
    "_hashlib.openssl_sha3_256" => "Returns a sha3-256 hash object; optionally initialized with a string",
    "_hashlib.openssl_sha3_384" => "Returns a sha3-384 hash object; optionally initialized with a string",
    "_hashlib.openssl_sha3_512" => "Returns a sha3-512 hash object; optionally initialized with a string",
    "_hashlib.openssl_sha512" => "Returns a sha512 hash object; optionally initialized with a string",
    "_hashlib.openssl_shake_128" => "Returns a shake-128 variable hash object; optionally initialized with a string",
    "_hashlib.openssl_shake_256" => "Returns a shake-256 variable hash object; optionally initialized with a string",
    "_hashlib.pbkdf2_hmac" => "Password based key derivation function 2 (PKCS #5 v2.0) with HMAC as pseudorandom function.",
    "_hashlib.scrypt" => "scrypt password-based key derivation function.",
    "_heapq" => "Heap queue algorithm (a.k.a. priority queue).\n\nHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\nall k, counting elements from 0.  For the sake of comparison,\nnon-existing elements are considered to be infinite.  The interesting\nproperty of a heap is that a[0] is always its smallest element.\n\nUsage:\n\nheap = []            # creates an empty heap\nheappush(heap, item) # pushes a new item on the heap\nitem = heappop(heap) # pops the smallest item from the heap\nitem = heap[0]       # smallest item on the heap without popping it\nheapify(x)           # transforms list into a heap, in-place, in linear time\nitem = heapreplace(heap, item) # pops and returns smallest item, and adds\n                               # new item; the heap size is unchanged\n\nOur API differs from textbook heap algorithms as follows:\n\n- We use 0-based indexing.  This makes the relationship between the\n  index for a node and the indexes for its children slightly less\n  obvious, but is more suitable since Python uses 0-based indexing.\n\n- Our heappop() method returns the smallest item, not the largest.\n\nThese two make it possible to view the heap as a regular Python list\nwithout surprises: heap[0] is the smallest item, and heap.sort()\nmaintains the heap invariant!",
    "_heapq._heapify_max" => "Maxheap variant of heapify.",
    "_heapq._heappop_max" => "Maxheap variant of heappop.",
    "_heapq._heapreplace_max" => "Maxheap variant of heapreplace.",
    "_heapq.heapify" => "Transform list into a heap, in-place, in O(len(heap)) time.",
    "_heapq.heappop" => "Pop the smallest item off the heap, maintaining the heap invariant.",
    "_heapq.heappush" => "Push item onto heap, maintaining the heap invariant.",
    "_heapq.heappushpop" => "Push item on the heap, then pop and return the smallest item from the heap.\n\nThe combined action runs more efficiently than heappush() followed by\na separate call to heappop().",
    "_heapq.heapreplace" => "Pop and return the current smallest value, and add the new item.\n\nThis is more efficient than heappop() followed by heappush(), and can be\nmore appropriate when using a fixed-size heap.  Note that the value\nreturned may be larger than item!  That constrains reasonable uses of\nthis routine unless written as part of a conditional replacement:\n\n    if item > heap[0]:\n        item = heapreplace(heap, item)",
    "_imp" => "(Extremely) low-level import machinery bits as used by importlib.",
    "_imp._fix_co_filename" => "Changes code.co_filename to specify the passed-in file path.\n\ncode\n  Code object to change.\npath\n  File path to use.",
    "_imp._frozen_module_names" => "Returns the list of available frozen modules.",
    "_imp._override_frozen_modules_for_tests" => "(internal-only) Override PyConfig.use_frozen_modules.\n\n(-1: \"off\", 1: \"on\", 0: no override)\nSee frozen_modules() in Lib/test/support/import_helper.py.",
    "_imp._override_multi_interp_extensions_check" => "(internal-only) Override PyInterpreterConfig.check_multi_interp_extensions.\n\n(-1: \"never\", 1: \"always\", 0: no override)",
    "_imp.acquire_lock" => "Acquires the interpreter's import lock for the current thread.\n\nThis lock should be used by import hooks to ensure thread-safety when importing\nmodules. On platforms without threads, this function does nothing.",
    "_imp.create_builtin" => "Create an extension module.",
    "_imp.create_dynamic" => "Create an extension module.",
    "_imp.exec_builtin" => "Initialize a built-in module.",
    "_imp.exec_dynamic" => "Initialize an extension module.",
    "_imp.extension_suffixes" => "Returns the list of file suffixes used to identify extension modules.",
    "_imp.find_frozen" => "Return info about the corresponding frozen module (if there is one) or None.\n\nThe returned info (a 2-tuple):\n\n * data         the raw marshalled bytes\n * is_package   whether or not it is a package\n * origname     the originally frozen module's name, or None if not\n                a stdlib module (this will usually be the same as\n                the module's current name)",
    "_imp.get_frozen_object" => "Create a code object for a frozen module.",
    "_imp.init_frozen" => "Initializes a frozen module.",
    "_imp.is_builtin" => "Returns True if the module name corresponds to a built-in module.",
    "_imp.is_frozen" => "Returns True if the module name corresponds to a frozen module.",
    "_imp.is_frozen_package" => "Returns True if the module name is of a frozen package.",
    "_imp.lock_held" => "Return True if the import lock is currently held, else False.\n\nOn platforms without threads, return False.",
    "_imp.release_lock" => "Release the interpreter's import lock.\n\nOn platforms without threads, this function does nothing.",
    "_interpchannels" => "This module provides primitive operations to manage Python interpreters.\nThe 'interpreters' module provides a more convenient interface.",
    "_interpchannels.ChannelClosedError.__cause__" => "exception cause",
    "_interpchannels.ChannelClosedError.__context__" => "exception context",
    "_interpchannels.ChannelClosedError.__delattr__" => "Implement delattr(self, name).",
    "_interpchannels.ChannelClosedError.__eq__" => "Return self==value.",
    "_interpchannels.ChannelClosedError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_interpchannels.ChannelClosedError.__ge__" => "Return self>=value.",
    "_interpchannels.ChannelClosedError.__getattribute__" => "Return getattr(self, name).",
    "_interpchannels.ChannelClosedError.__getstate__" => "Helper for pickle.",
    "_interpchannels.ChannelClosedError.__gt__" => "Return self>value.",
    "_interpchannels.ChannelClosedError.__hash__" => "Return hash(self).",
    "_interpchannels.ChannelClosedError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_interpchannels.ChannelClosedError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_interpchannels.ChannelClosedError.__le__" => "Return self<=value.",
    "_interpchannels.ChannelClosedError.__lt__" => "Return self<value.",
    "_interpchannels.ChannelClosedError.__ne__" => "Return self!=value.",
    "_interpchannels.ChannelClosedError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_interpchannels.ChannelClosedError.__reduce_ex__" => "Helper for pickle.",
    "_interpchannels.ChannelClosedError.__repr__" => "Return repr(self).",
    "_interpchannels.ChannelClosedError.__setattr__" => "Implement setattr(self, name, value).",
    "_interpchannels.ChannelClosedError.__sizeof__" => "Size of object in memory, in bytes.",
    "_interpchannels.ChannelClosedError.__str__" => "Return str(self).",
    "_interpchannels.ChannelClosedError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_interpchannels.ChannelClosedError.__weakref__" => "list of weak references to the object",
    "_interpchannels.ChannelClosedError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_interpchannels.ChannelClosedError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_interpchannels.ChannelEmptyError.__cause__" => "exception cause",
    "_interpchannels.ChannelEmptyError.__context__" => "exception context",
    "_interpchannels.ChannelEmptyError.__delattr__" => "Implement delattr(self, name).",
    "_interpchannels.ChannelEmptyError.__eq__" => "Return self==value.",
    "_interpchannels.ChannelEmptyError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_interpchannels.ChannelEmptyError.__ge__" => "Return self>=value.",
    "_interpchannels.ChannelEmptyError.__getattribute__" => "Return getattr(self, name).",
    "_interpchannels.ChannelEmptyError.__getstate__" => "Helper for pickle.",
    "_interpchannels.ChannelEmptyError.__gt__" => "Return self>value.",
    "_interpchannels.ChannelEmptyError.__hash__" => "Return hash(self).",
    "_interpchannels.ChannelEmptyError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_interpchannels.ChannelEmptyError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_interpchannels.ChannelEmptyError.__le__" => "Return self<=value.",
    "_interpchannels.ChannelEmptyError.__lt__" => "Return self<value.",
    "_interpchannels.ChannelEmptyError.__ne__" => "Return self!=value.",
    "_interpchannels.ChannelEmptyError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_interpchannels.ChannelEmptyError.__reduce_ex__" => "Helper for pickle.",
    "_interpchannels.ChannelEmptyError.__repr__" => "Return repr(self).",
    "_interpchannels.ChannelEmptyError.__setattr__" => "Implement setattr(self, name, value).",
    "_interpchannels.ChannelEmptyError.__sizeof__" => "Size of object in memory, in bytes.",
    "_interpchannels.ChannelEmptyError.__str__" => "Return str(self).",
    "_interpchannels.ChannelEmptyError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_interpchannels.ChannelEmptyError.__weakref__" => "list of weak references to the object",
    "_interpchannels.ChannelEmptyError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_interpchannels.ChannelEmptyError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_interpchannels.ChannelError.__cause__" => "exception cause",
    "_interpchannels.ChannelError.__context__" => "exception context",
    "_interpchannels.ChannelError.__delattr__" => "Implement delattr(self, name).",
    "_interpchannels.ChannelError.__eq__" => "Return self==value.",
    "_interpchannels.ChannelError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_interpchannels.ChannelError.__ge__" => "Return self>=value.",
    "_interpchannels.ChannelError.__getattribute__" => "Return getattr(self, name).",
    "_interpchannels.ChannelError.__getstate__" => "Helper for pickle.",
    "_interpchannels.ChannelError.__gt__" => "Return self>value.",
    "_interpchannels.ChannelError.__hash__" => "Return hash(self).",
    "_interpchannels.ChannelError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_interpchannels.ChannelError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_interpchannels.ChannelError.__le__" => "Return self<=value.",
    "_interpchannels.ChannelError.__lt__" => "Return self<value.",
    "_interpchannels.ChannelError.__ne__" => "Return self!=value.",
    "_interpchannels.ChannelError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_interpchannels.ChannelError.__reduce_ex__" => "Helper for pickle.",
    "_interpchannels.ChannelError.__repr__" => "Return repr(self).",
    "_interpchannels.ChannelError.__setattr__" => "Implement setattr(self, name, value).",
    "_interpchannels.ChannelError.__sizeof__" => "Size of object in memory, in bytes.",
    "_interpchannels.ChannelError.__str__" => "Return str(self).",
    "_interpchannels.ChannelError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_interpchannels.ChannelError.__weakref__" => "list of weak references to the object",
    "_interpchannels.ChannelError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_interpchannels.ChannelError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_interpchannels.ChannelID" => "A channel ID identifies a channel and may be used as an int.",
    "_interpchannels.ChannelID.__delattr__" => "Implement delattr(self, name).",
    "_interpchannels.ChannelID.__eq__" => "Return self==value.",
    "_interpchannels.ChannelID.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_interpchannels.ChannelID.__ge__" => "Return self>=value.",
    "_interpchannels.ChannelID.__getattribute__" => "Return getattr(self, name).",
    "_interpchannels.ChannelID.__getstate__" => "Helper for pickle.",
    "_interpchannels.ChannelID.__gt__" => "Return self>value.",
    "_interpchannels.ChannelID.__hash__" => "Return hash(self).",
    "_interpchannels.ChannelID.__index__" => "Return self converted to an integer, if self is suitable for use as an index into a list.",
    "_interpchannels.ChannelID.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_interpchannels.ChannelID.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_interpchannels.ChannelID.__int__" => "int(self)",
    "_interpchannels.ChannelID.__le__" => "Return self<=value.",
    "_interpchannels.ChannelID.__lt__" => "Return self<value.",
    "_interpchannels.ChannelID.__ne__" => "Return self!=value.",
    "_interpchannels.ChannelID.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_interpchannels.ChannelID.__reduce__" => "Helper for pickle.",
    "_interpchannels.ChannelID.__reduce_ex__" => "Helper for pickle.",
    "_interpchannels.ChannelID.__repr__" => "Return repr(self).",
    "_interpchannels.ChannelID.__setattr__" => "Implement setattr(self, name, value).",
    "_interpchannels.ChannelID.__sizeof__" => "Size of object in memory, in bytes.",
    "_interpchannels.ChannelID.__str__" => "Return str(self).",
    "_interpchannels.ChannelID.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_interpchannels.ChannelID.end" => "'send', 'recv', or 'both'",
    "_interpchannels.ChannelID.recv" => "the 'recv' end of the channel",
    "_interpchannels.ChannelID.send" => "the 'send' end of the channel",
    "_interpchannels.ChannelInfo" => "ChannelInfo\n\nA named tuple of a channel's state.",
    "_interpchannels.ChannelInfo.__add__" => "Return self+value.",
    "_interpchannels.ChannelInfo.__class_getitem__" => "See PEP 585",
    "_interpchannels.ChannelInfo.__contains__" => "Return bool(key in self).",
    "_interpchannels.ChannelInfo.__delattr__" => "Implement delattr(self, name).",
    "_interpchannels.ChannelInfo.__eq__" => "Return self==value.",
    "_interpchannels.ChannelInfo.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_interpchannels.ChannelInfo.__ge__" => "Return self>=value.",
    "_interpchannels.ChannelInfo.__getattribute__" => "Return getattr(self, name).",
    "_interpchannels.ChannelInfo.__getitem__" => "Return self[key].",
    "_interpchannels.ChannelInfo.__getstate__" => "Helper for pickle.",
    "_interpchannels.ChannelInfo.__gt__" => "Return self>value.",
    "_interpchannels.ChannelInfo.__hash__" => "Return hash(self).",
    "_interpchannels.ChannelInfo.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_interpchannels.ChannelInfo.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_interpchannels.ChannelInfo.__iter__" => "Implement iter(self).",
    "_interpchannels.ChannelInfo.__le__" => "Return self<=value.",
    "_interpchannels.ChannelInfo.__len__" => "Return len(self).",
    "_interpchannels.ChannelInfo.__lt__" => "Return self<value.",
    "_interpchannels.ChannelInfo.__mul__" => "Return self*value.",
    "_interpchannels.ChannelInfo.__ne__" => "Return self!=value.",
    "_interpchannels.ChannelInfo.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_interpchannels.ChannelInfo.__reduce_ex__" => "Helper for pickle.",
    "_interpchannels.ChannelInfo.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "_interpchannels.ChannelInfo.__repr__" => "Return repr(self).",
    "_interpchannels.ChannelInfo.__rmul__" => "Return value*self.",
    "_interpchannels.ChannelInfo.__setattr__" => "Implement setattr(self, name, value).",
    "_interpchannels.ChannelInfo.__sizeof__" => "Size of object in memory, in bytes.",
    "_interpchannels.ChannelInfo.__str__" => "Return str(self).",
    "_interpchannels.ChannelInfo.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_interpchannels.ChannelInfo.closed" => "both ends are closed",
    "_interpchannels.ChannelInfo.closing" => "send is closed, recv is non-empty",
    "_interpchannels.ChannelInfo.count" => "queued objects",
    "_interpchannels.ChannelInfo.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "_interpchannels.ChannelInfo.num_interp_both" => "interpreters bound to both ends",
    "_interpchannels.ChannelInfo.num_interp_both_recv_released" => "interpreters bound to both ends and released_from_the recv end",
    "_interpchannels.ChannelInfo.num_interp_both_released" => "interpreters bound to both ends and released_from_both",
    "_interpchannels.ChannelInfo.num_interp_both_send_released" => "interpreters bound to both ends and released_from_the send end",
    "_interpchannels.ChannelInfo.num_interp_recv" => "interpreters bound to the send end",
    "_interpchannels.ChannelInfo.num_interp_recv_released" => "interpreters bound to the send end and released",
    "_interpchannels.ChannelInfo.num_interp_send" => "interpreters bound to the send end",
    "_interpchannels.ChannelInfo.num_interp_send_released" => "interpreters bound to the send end and released",
    "_interpchannels.ChannelInfo.open" => "both ends are open",
    "_interpchannels.ChannelInfo.recv_associated" => "current interpreter is bound to the recv end",
    "_interpchannels.ChannelInfo.recv_released" => "current interpreter *was* bound to the recv end",
    "_interpchannels.ChannelInfo.send_associated" => "current interpreter is bound to the send end",
    "_interpchannels.ChannelInfo.send_released" => "current interpreter *was* bound to the send end",
    "_interpchannels.ChannelNotEmptyError.__cause__" => "exception cause",
    "_interpchannels.ChannelNotEmptyError.__context__" => "exception context",
    "_interpchannels.ChannelNotEmptyError.__delattr__" => "Implement delattr(self, name).",
    "_interpchannels.ChannelNotEmptyError.__eq__" => "Return self==value.",
    "_interpchannels.ChannelNotEmptyError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_interpchannels.ChannelNotEmptyError.__ge__" => "Return self>=value.",
    "_interpchannels.ChannelNotEmptyError.__getattribute__" => "Return getattr(self, name).",
    "_interpchannels.ChannelNotEmptyError.__getstate__" => "Helper for pickle.",
    "_interpchannels.ChannelNotEmptyError.__gt__" => "Return self>value.",
    "_interpchannels.ChannelNotEmptyError.__hash__" => "Return hash(self).",
    "_interpchannels.ChannelNotEmptyError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_interpchannels.ChannelNotEmptyError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_interpchannels.ChannelNotEmptyError.__le__" => "Return self<=value.",
    "_interpchannels.ChannelNotEmptyError.__lt__" => "Return self<value.",
    "_interpchannels.ChannelNotEmptyError.__ne__" => "Return self!=value.",
    "_interpchannels.ChannelNotEmptyError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_interpchannels.ChannelNotEmptyError.__reduce_ex__" => "Helper for pickle.",
    "_interpchannels.ChannelNotEmptyError.__repr__" => "Return repr(self).",
    "_interpchannels.ChannelNotEmptyError.__setattr__" => "Implement setattr(self, name, value).",
    "_interpchannels.ChannelNotEmptyError.__sizeof__" => "Size of object in memory, in bytes.",
    "_interpchannels.ChannelNotEmptyError.__str__" => "Return str(self).",
    "_interpchannels.ChannelNotEmptyError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_interpchannels.ChannelNotEmptyError.__weakref__" => "list of weak references to the object",
    "_interpchannels.ChannelNotEmptyError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_interpchannels.ChannelNotEmptyError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_interpchannels.ChannelNotFoundError.__cause__" => "exception cause",
    "_interpchannels.ChannelNotFoundError.__context__" => "exception context",
    "_interpchannels.ChannelNotFoundError.__delattr__" => "Implement delattr(self, name).",
    "_interpchannels.ChannelNotFoundError.__eq__" => "Return self==value.",
    "_interpchannels.ChannelNotFoundError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_interpchannels.ChannelNotFoundError.__ge__" => "Return self>=value.",
    "_interpchannels.ChannelNotFoundError.__getattribute__" => "Return getattr(self, name).",
    "_interpchannels.ChannelNotFoundError.__getstate__" => "Helper for pickle.",
    "_interpchannels.ChannelNotFoundError.__gt__" => "Return self>value.",
    "_interpchannels.ChannelNotFoundError.__hash__" => "Return hash(self).",
    "_interpchannels.ChannelNotFoundError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_interpchannels.ChannelNotFoundError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_interpchannels.ChannelNotFoundError.__le__" => "Return self<=value.",
    "_interpchannels.ChannelNotFoundError.__lt__" => "Return self<value.",
    "_interpchannels.ChannelNotFoundError.__ne__" => "Return self!=value.",
    "_interpchannels.ChannelNotFoundError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_interpchannels.ChannelNotFoundError.__reduce_ex__" => "Helper for pickle.",
    "_interpchannels.ChannelNotFoundError.__repr__" => "Return repr(self).",
    "_interpchannels.ChannelNotFoundError.__setattr__" => "Implement setattr(self, name, value).",
    "_interpchannels.ChannelNotFoundError.__sizeof__" => "Size of object in memory, in bytes.",
    "_interpchannels.ChannelNotFoundError.__str__" => "Return str(self).",
    "_interpchannels.ChannelNotFoundError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_interpchannels.ChannelNotFoundError.__weakref__" => "list of weak references to the object",
    "_interpchannels.ChannelNotFoundError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_interpchannels.ChannelNotFoundError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_interpchannels.close" => "channel_close(cid, *, send=None, recv=None, force=False)\n\nClose the channel for all interpreters.\n\nIf the channel is empty then the keyword args are ignored and both\nends are immediately closed.  Otherwise, if 'force' is True then\nall queued items are released and both ends are immediately\nclosed.\n\nIf the channel is not empty *and* 'force' is False then following\nhappens:\n\n * recv is True (regardless of send):\n   - raise ChannelNotEmptyError\n * recv is None and send is None:\n   - raise ChannelNotEmptyError\n * send is True and recv is not True:\n   - fully close the 'send' end\n   - close the 'recv' end to interpreters not already receiving\n   - fully close it once empty\n\nClosing an already closed channel results in a ChannelClosedError.\n\nOnce the channel's ID has no more ref counts in any interpreter\nthe channel will be destroyed.",
    "_interpchannels.create" => "channel_create(unboundop) -> cid\n\nCreate a new cross-interpreter channel and return a unique generated ID.",
    "_interpchannels.destroy" => "channel_destroy(cid)\n\nClose and finalize the channel.  Afterward attempts to use the channel\nwill behave as though it never existed.",
    "_interpchannels.get_channel_defaults" => "get_channel_defaults(cid)\n\nReturn the channel's default values, set when it was created.",
    "_interpchannels.get_count" => "get_count(cid)\n\nReturn the number of items in the channel.",
    "_interpchannels.get_info" => "get_info(cid)\n\nReturn details about the channel.",
    "_interpchannels.list_all" => "channel_list_all() -> [cid]\n\nReturn the list of all IDs for active channels.",
    "_interpchannels.list_interpreters" => "channel_list_interpreters(cid, *, send) -> [id]\n\nReturn the list of all interpreter IDs associated with an end of the channel.\n\nThe 'send' argument should be a boolean indicating whether to use the send or\nreceive end.",
    "_interpchannels.recv" => "channel_recv(cid, [default]) -> (obj, unboundop)\n\nReturn a new object from the data at the front of the channel's queue.\n\nIf there is nothing to receive then raise ChannelEmptyError, unless\na default value is provided.  In that case return it.",
    "_interpchannels.release" => "channel_release(cid, *, send=None, recv=None, force=True)\n\nClose the channel for the current interpreter.  'send' and 'recv'\n(bool) may be used to indicate the ends to close.  By default both\nends are closed.  Closing an already closed end is a noop.",
    "_interpchannels.send" => "channel_send(cid, obj, *, blocking=True, timeout=None)\n\nAdd the object's data to the channel's queue.\nBy default this waits for the object to be received.",
    "_interpchannels.send_buffer" => "channel_send_buffer(cid, obj, *, blocking=True, timeout=None)\n\nAdd the object's buffer to the channel's queue.\nBy default this waits for the object to be received.",
    "_interpqueues" => "This module provides primitive operations to manage Python interpreters.\nThe 'interpreters' module provides a more convenient interface.",
    "_interpqueues.bind" => "bind(qid)\n\nTake a reference to the identified queue.\nThe queue is not destroyed until there are no references left.",
    "_interpqueues.create" => "create(maxsize, fmt, unboundop) -> qid\n\nCreate a new cross-interpreter queue and return its unique generated ID.\nIt is a new reference as though bind() had been called on the queue.\n\nThe caller is responsible for calling destroy() for the new queue\nbefore the runtime is finalized.",
    "_interpqueues.destroy" => "destroy(qid)\n\nClear and destroy the queue.  Afterward attempts to use the queue\nwill behave as though it never existed.",
    "_interpqueues.get" => "get(qid) -> (obj, fmt)\n\nReturn a new object from the data at the front of the queue.\nThe object's format is also returned.\n\nIf there is nothing to receive then raise QueueEmpty.",
    "_interpqueues.get_count" => "get_count(qid)\n\nReturn the number of items in the queue.",
    "_interpqueues.get_maxsize" => "get_maxsize(qid)\n\nReturn the maximum number of items in the queue.",
    "_interpqueues.get_queue_defaults" => "get_queue_defaults(qid)\n\nReturn the queue's default values, set when it was created.",
    "_interpqueues.is_full" => "is_full(qid)\n\nReturn true if the queue has a maxsize and has reached it.",
    "_interpqueues.list_all" => "list_all() -> [(qid, fmt)]\n\nReturn the list of IDs for all queues.\nEach corresponding default format is also included.",
    "_interpqueues.put" => "put(qid, obj, fmt)\n\nAdd the object's data to the queue.",
    "_interpqueues.release" => "release(qid)\n\nRelease a reference to the queue.\nThe queue is destroyed once there are no references left.",
    "_interpreters" => "This module provides primitive operations to manage Python interpreters.\nThe 'interpreters' module provides a more convenient interface.",
    "_interpreters.CrossInterpreterBufferView.__buffer__" => "Return a buffer object that exposes the underlying memory of the object.",
    "_interpreters.CrossInterpreterBufferView.__delattr__" => "Implement delattr(self, name).",
    "_interpreters.CrossInterpreterBufferView.__eq__" => "Return self==value.",
    "_interpreters.CrossInterpreterBufferView.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_interpreters.CrossInterpreterBufferView.__ge__" => "Return self>=value.",
    "_interpreters.CrossInterpreterBufferView.__getattribute__" => "Return getattr(self, name).",
    "_interpreters.CrossInterpreterBufferView.__getstate__" => "Helper for pickle.",
    "_interpreters.CrossInterpreterBufferView.__gt__" => "Return self>value.",
    "_interpreters.CrossInterpreterBufferView.__hash__" => "Return hash(self).",
    "_interpreters.CrossInterpreterBufferView.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_interpreters.CrossInterpreterBufferView.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_interpreters.CrossInterpreterBufferView.__le__" => "Return self<=value.",
    "_interpreters.CrossInterpreterBufferView.__lt__" => "Return self<value.",
    "_interpreters.CrossInterpreterBufferView.__ne__" => "Return self!=value.",
    "_interpreters.CrossInterpreterBufferView.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_interpreters.CrossInterpreterBufferView.__reduce__" => "Helper for pickle.",
    "_interpreters.CrossInterpreterBufferView.__reduce_ex__" => "Helper for pickle.",
    "_interpreters.CrossInterpreterBufferView.__repr__" => "Return repr(self).",
    "_interpreters.CrossInterpreterBufferView.__setattr__" => "Implement setattr(self, name, value).",
    "_interpreters.CrossInterpreterBufferView.__sizeof__" => "Size of object in memory, in bytes.",
    "_interpreters.CrossInterpreterBufferView.__str__" => "Return str(self).",
    "_interpreters.CrossInterpreterBufferView.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_interpreters.call" => "call(id, callable, args=None, kwargs=None, *, restrict=False)\n\nCall the provided object in the identified interpreter.\nPass the given args and kwargs, if possible.\n\n\"callable\" may be a plain function with no free vars that takes\nno arguments.\n\nThe function's code object is used and all its state\nis ignored, including its __globals__ dict.",
    "_interpreters.capture_exception" => "capture_exception(exc=None) -> types.SimpleNamespace\n\nReturn a snapshot of an exception.  If \"exc\" is None\nthen the current exception, if any, is used (but not cleared).\n\nThe returned snapshot is the same as what _interpreters.exec() returns.",
    "_interpreters.create" => "create([config], *, reqrefs=False) -> ID\n\nCreate a new interpreter and return a unique generated ID.\n\nThe caller is responsible for destroying the interpreter before exiting,\ntypically by using _interpreters.destroy().  This can be managed \nautomatically by passing \"reqrefs=True\" and then using _incref() and\n_decref()` appropriately.\n\n\"config\" must be a valid interpreter config or the name of a\npredefined config (\"isolated\" or \"legacy\").  The default\nis \"isolated\".",
    "_interpreters.destroy" => "destroy(id, *, restrict=False)\n\nDestroy the identified interpreter.\n\nAttempting to destroy the current interpreter raises InterpreterError.\nSo does an unrecognized ID.",
    "_interpreters.exec" => "exec(id, code, shared=None, *, restrict=False)\n\nExecute the provided code in the identified interpreter.\nThis is equivalent to running the builtin exec() under the target\ninterpreter, using the __dict__ of its __main__ module as both\nglobals and locals.\n\n\"code\" may be a string containing the text of a Python script.\n\nFunctions (and code objects) are also supported, with some restrictions.\nThe code/function must not take any arguments or be a closure\n(i.e. have cell vars).  Methods and other callables are not supported.\n\nIf a function is provided, its code object is used and all its state\nis ignored, including its __globals__ dict.",
    "_interpreters.get_config" => "get_config(id, *, restrict=False) -> types.SimpleNamespace\n\nReturn a representation of the config used to initialize the interpreter.",
    "_interpreters.get_current" => "get_current() -> (ID, whence)\n\nReturn the ID of current interpreter.",
    "_interpreters.get_main" => "get_main() -> (ID, whence)\n\nReturn the ID of main interpreter.",
    "_interpreters.is_running" => "is_running(id, *, restrict=False) -> bool\n\nReturn whether or not the identified interpreter is running.",
    "_interpreters.is_shareable" => "is_shareable(obj) -> bool\n\nReturn True if the object's data may be shared between interpreters and\nFalse otherwise.",
    "_interpreters.list_all" => "list_all() -> [(ID, whence)]\n\nReturn a list containing the ID of every existing interpreter.",
    "_interpreters.new_config" => "new_config(name='isolated', /, **overrides) -> type.SimpleNamespace\n\nReturn a representation of a new PyInterpreterConfig.\n\nThe name determines the initial values of the config.  Supported named\nconfigs are: default, isolated, legacy, and empty.\n\nAny keyword arguments are set on the corresponding config fields,\noverriding the initial values.",
    "_interpreters.run_func" => "run_func(id, func, shared=None, *, restrict=False)\n\nExecute the body of the provided function in the identified interpreter.\nCode objects are also supported.  In both cases, closures and args\nare not supported.  Methods and other callables are not supported either.\n\n(See _interpreters.exec().",
    "_interpreters.run_string" => "run_string(id, script, shared=None, *, restrict=False)\n\nExecute the provided string in the identified interpreter.\n\n(See _interpreters.exec().",
    "_interpreters.set___main___attrs" => "set___main___attrs(id, ns, *, restrict=False)\n\nBind the given attributes in the interpreter's __main__ module.",
    "_interpreters.whence" => "whence(id) -> int\n\nReturn an identifier for where the interpreter was created.",
    "_io" => "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to raise an OSError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis an in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.",
    "_io.BufferedRWPair" => "A buffered reader and writer object together.\n\nA buffered reader object and buffered writer object put together to\nform a sequential IO object that can read and write. This is typically\nused with a socket or two-way pipe.\n\nreader and writer are RawIOBase objects that are readable and\nwriteable respectively. If the buffer_size is omitted it defaults to\nDEFAULT_BUFFER_SIZE.",
    "_io.BufferedRWPair.__del__" => "Called when the instance is about to be destroyed.",
    "_io.BufferedRWPair.__delattr__" => "Implement delattr(self, name).",
    "_io.BufferedRWPair.__eq__" => "Return self==value.",
    "_io.BufferedRWPair.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io.BufferedRWPair.__ge__" => "Return self>=value.",
    "_io.BufferedRWPair.__getattribute__" => "Return getattr(self, name).",
    "_io.BufferedRWPair.__getstate__" => "Helper for pickle.",
    "_io.BufferedRWPair.__gt__" => "Return self>value.",
    "_io.BufferedRWPair.__hash__" => "Return hash(self).",
    "_io.BufferedRWPair.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io.BufferedRWPair.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io.BufferedRWPair.__iter__" => "Implement iter(self).",
    "_io.BufferedRWPair.__le__" => "Return self<=value.",
    "_io.BufferedRWPair.__lt__" => "Return self<value.",
    "_io.BufferedRWPair.__ne__" => "Return self!=value.",
    "_io.BufferedRWPair.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io.BufferedRWPair.__next__" => "Implement next(self).",
    "_io.BufferedRWPair.__reduce__" => "Helper for pickle.",
    "_io.BufferedRWPair.__reduce_ex__" => "Helper for pickle.",
    "_io.BufferedRWPair.__repr__" => "Return repr(self).",
    "_io.BufferedRWPair.__setattr__" => "Implement setattr(self, name, value).",
    "_io.BufferedRWPair.__sizeof__" => "Size of object in memory, in bytes.",
    "_io.BufferedRWPair.__str__" => "Return str(self).",
    "_io.BufferedRWPair.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io.BufferedRWPair.detach" => "Disconnect this buffer from its underlying raw stream and return it.\n\nAfter the raw stream has been detached, the buffer is in an unusable\nstate.",
    "_io.BufferedRWPair.fileno" => "Return underlying file descriptor if one exists.\n\nRaise OSError if the IO object does not use a file descriptor.",
    "_io.BufferedRWPair.readline" => "Read and return a line from the stream.\n\nIf size is specified, at most size bytes will be read.\n\nThe line terminator is always b'\\n' for binary files; for text\nfiles, the newlines argument to open can be used to select the line\nterminator(s) recognized.",
    "_io.BufferedRWPair.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io.BufferedRWPair.seek" => "Change the stream position to the given byte offset.\n\n  offset\n    The stream position, relative to 'whence'.\n  whence\n    The relative position to seek from.\n\nThe offset is interpreted relative to the position indicated by whence.\nValues for whence are:\n\n* os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n* os.SEEK_CUR or 1 -- current stream position; offset may be negative\n* os.SEEK_END or 2 -- end of stream; offset is usually negative\n\nReturn the new absolute position.",
    "_io.BufferedRWPair.seekable" => "Return whether object supports random access.\n\nIf False, seek(), tell() and truncate() will raise OSError.\nThis method may need to do a test seek().",
    "_io.BufferedRWPair.tell" => "Return current stream position.",
    "_io.BufferedRWPair.truncate" => "Truncate file to size bytes.\n\nFile pointer is left unchanged. Size defaults to the current IO position\nas reported by tell(). Return the new size.",
    "_io.BufferedRWPair.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io.BufferedRandom" => "A buffered interface to random access streams.\n\nThe constructor creates a reader and writer for a seekable stream,\nraw, given in the first argument. If the buffer_size is omitted it\ndefaults to DEFAULT_BUFFER_SIZE.",
    "_io.BufferedRandom.__del__" => "Called when the instance is about to be destroyed.",
    "_io.BufferedRandom.__delattr__" => "Implement delattr(self, name).",
    "_io.BufferedRandom.__eq__" => "Return self==value.",
    "_io.BufferedRandom.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io.BufferedRandom.__ge__" => "Return self>=value.",
    "_io.BufferedRandom.__getattribute__" => "Return getattr(self, name).",
    "_io.BufferedRandom.__gt__" => "Return self>value.",
    "_io.BufferedRandom.__hash__" => "Return hash(self).",
    "_io.BufferedRandom.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io.BufferedRandom.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io.BufferedRandom.__iter__" => "Implement iter(self).",
    "_io.BufferedRandom.__le__" => "Return self<=value.",
    "_io.BufferedRandom.__lt__" => "Return self<value.",
    "_io.BufferedRandom.__ne__" => "Return self!=value.",
    "_io.BufferedRandom.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io.BufferedRandom.__next__" => "Implement next(self).",
    "_io.BufferedRandom.__reduce__" => "Helper for pickle.",
    "_io.BufferedRandom.__reduce_ex__" => "Helper for pickle.",
    "_io.BufferedRandom.__repr__" => "Return repr(self).",
    "_io.BufferedRandom.__setattr__" => "Implement setattr(self, name, value).",
    "_io.BufferedRandom.__str__" => "Return str(self).",
    "_io.BufferedRandom.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io.BufferedRandom.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io.BufferedRandom.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io.BufferedReader" => "Create a new buffered reader using the given readable raw IO object.",
    "_io.BufferedReader.__del__" => "Called when the instance is about to be destroyed.",
    "_io.BufferedReader.__delattr__" => "Implement delattr(self, name).",
    "_io.BufferedReader.__eq__" => "Return self==value.",
    "_io.BufferedReader.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io.BufferedReader.__ge__" => "Return self>=value.",
    "_io.BufferedReader.__getattribute__" => "Return getattr(self, name).",
    "_io.BufferedReader.__gt__" => "Return self>value.",
    "_io.BufferedReader.__hash__" => "Return hash(self).",
    "_io.BufferedReader.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io.BufferedReader.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io.BufferedReader.__iter__" => "Implement iter(self).",
    "_io.BufferedReader.__le__" => "Return self<=value.",
    "_io.BufferedReader.__lt__" => "Return self<value.",
    "_io.BufferedReader.__ne__" => "Return self!=value.",
    "_io.BufferedReader.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io.BufferedReader.__next__" => "Implement next(self).",
    "_io.BufferedReader.__reduce__" => "Helper for pickle.",
    "_io.BufferedReader.__reduce_ex__" => "Helper for pickle.",
    "_io.BufferedReader.__repr__" => "Return repr(self).",
    "_io.BufferedReader.__setattr__" => "Implement setattr(self, name, value).",
    "_io.BufferedReader.__str__" => "Return str(self).",
    "_io.BufferedReader.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io.BufferedReader.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io.BufferedReader.writable" => "Return whether object was opened for writing.\n\nIf False, write() will raise OSError.",
    "_io.BufferedReader.write" => "Write buffer b to the IO stream.\n\nReturn the number of bytes written, which is always\nthe length of b in bytes.\n\nRaise BlockingIOError if the buffer is full and the\nunderlying raw stream cannot accept more data at the moment.",
    "_io.BufferedReader.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io.BufferedWriter" => "A buffer for a writeable sequential RawIO object.\n\nThe constructor creates a BufferedWriter for the given writeable raw\nstream. If the buffer_size is not given, it defaults to\nDEFAULT_BUFFER_SIZE.",
    "_io.BufferedWriter.__del__" => "Called when the instance is about to be destroyed.",
    "_io.BufferedWriter.__delattr__" => "Implement delattr(self, name).",
    "_io.BufferedWriter.__eq__" => "Return self==value.",
    "_io.BufferedWriter.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io.BufferedWriter.__ge__" => "Return self>=value.",
    "_io.BufferedWriter.__getattribute__" => "Return getattr(self, name).",
    "_io.BufferedWriter.__gt__" => "Return self>value.",
    "_io.BufferedWriter.__hash__" => "Return hash(self).",
    "_io.BufferedWriter.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io.BufferedWriter.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io.BufferedWriter.__iter__" => "Implement iter(self).",
    "_io.BufferedWriter.__le__" => "Return self<=value.",
    "_io.BufferedWriter.__lt__" => "Return self<value.",
    "_io.BufferedWriter.__ne__" => "Return self!=value.",
    "_io.BufferedWriter.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io.BufferedWriter.__next__" => "Implement next(self).",
    "_io.BufferedWriter.__reduce__" => "Helper for pickle.",
    "_io.BufferedWriter.__reduce_ex__" => "Helper for pickle.",
    "_io.BufferedWriter.__repr__" => "Return repr(self).",
    "_io.BufferedWriter.__setattr__" => "Implement setattr(self, name, value).",
    "_io.BufferedWriter.__str__" => "Return str(self).",
    "_io.BufferedWriter.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io.BufferedWriter.read" => "Read and return up to n bytes.\n\nIf the size argument is omitted, None, or negative, read and\nreturn all data until EOF.\n\nIf the size argument is positive, and the underlying raw stream is\nnot 'interactive', multiple raw reads may be issued to satisfy\nthe byte count (unless EOF is reached first).\nHowever, for interactive raw streams (as well as sockets and pipes),\nat most one raw read will be issued, and a short result does not\nimply that EOF is imminent.\n\nReturn an empty bytes object on EOF.\n\nReturn None if the underlying raw stream was open in non-blocking\nmode and no data is available at the moment.",
    "_io.BufferedWriter.read1" => "Read and return up to size bytes, with at most one read() call to the underlying raw stream.\n\nReturn an empty bytes object on EOF.\nA short result does not imply that EOF is imminent.",
    "_io.BufferedWriter.readable" => "Return whether object was opened for reading.\n\nIf False, read() will raise OSError.",
    "_io.BufferedWriter.readline" => "Read and return a line from the stream.\n\nIf size is specified, at most size bytes will be read.\n\nThe line terminator is always b'\\n' for binary files; for text\nfiles, the newlines argument to open can be used to select the line\nterminator(s) recognized.",
    "_io.BufferedWriter.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io.BufferedWriter.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io.BytesIO" => "Buffered I/O implementation using an in-memory bytes buffer.",
    "_io.BytesIO.__del__" => "Called when the instance is about to be destroyed.",
    "_io.BytesIO.__delattr__" => "Implement delattr(self, name).",
    "_io.BytesIO.__eq__" => "Return self==value.",
    "_io.BytesIO.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io.BytesIO.__ge__" => "Return self>=value.",
    "_io.BytesIO.__getattribute__" => "Return getattr(self, name).",
    "_io.BytesIO.__gt__" => "Return self>value.",
    "_io.BytesIO.__hash__" => "Return hash(self).",
    "_io.BytesIO.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io.BytesIO.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io.BytesIO.__iter__" => "Implement iter(self).",
    "_io.BytesIO.__le__" => "Return self<=value.",
    "_io.BytesIO.__lt__" => "Return self<value.",
    "_io.BytesIO.__ne__" => "Return self!=value.",
    "_io.BytesIO.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io.BytesIO.__next__" => "Implement next(self).",
    "_io.BytesIO.__reduce__" => "Helper for pickle.",
    "_io.BytesIO.__reduce_ex__" => "Helper for pickle.",
    "_io.BytesIO.__repr__" => "Return repr(self).",
    "_io.BytesIO.__setattr__" => "Implement setattr(self, name, value).",
    "_io.BytesIO.__str__" => "Return str(self).",
    "_io.BytesIO.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io.BytesIO.close" => "Disable all I/O operations.",
    "_io.BytesIO.closed" => "True if the file is closed.",
    "_io.BytesIO.detach" => "Disconnect this buffer from its underlying raw stream and return it.\n\nAfter the raw stream has been detached, the buffer is in an unusable\nstate.",
    "_io.BytesIO.fileno" => "Return underlying file descriptor if one exists.\n\nRaise OSError if the IO object does not use a file descriptor.",
    "_io.BytesIO.flush" => "Does nothing.",
    "_io.BytesIO.getbuffer" => "Get a read-write view over the contents of the BytesIO object.",
    "_io.BytesIO.getvalue" => "Retrieve the entire contents of the BytesIO object.",
    "_io.BytesIO.isatty" => "Always returns False.\n\nBytesIO objects are not connected to a TTY-like device.",
    "_io.BytesIO.read" => "Read at most size bytes, returned as a bytes object.\n\nIf the size argument is negative, read until EOF is reached.\nReturn an empty bytes object at EOF.",
    "_io.BytesIO.read1" => "Read at most size bytes, returned as a bytes object.\n\nIf the size argument is negative or omitted, read until EOF is reached.\nReturn an empty bytes object at EOF.",
    "_io.BytesIO.readable" => "Returns True if the IO object can be read.",
    "_io.BytesIO.readinto" => "Read bytes into buffer.\n\nReturns number of bytes read (0 for EOF), or None if the object\nis set not to block and has no data to read.",
    "_io.BytesIO.readline" => "Next line from the file, as a bytes object.\n\nRetain newline.  A non-negative size argument limits the maximum\nnumber of bytes to return (an incomplete line may be returned then).\nReturn an empty bytes object at EOF.",
    "_io.BytesIO.readlines" => "List of bytes objects, each a line from the file.\n\nCall readline() repeatedly and return a list of the lines so read.\nThe optional size argument, if given, is an approximate bound on the\ntotal number of bytes in the lines returned.",
    "_io.BytesIO.seek" => "Change stream position.\n\nSeek to byte offset pos relative to position indicated by whence:\n     0  Start of stream (the default).  pos should be >= 0;\n     1  Current position - pos may be negative;\n     2  End of stream - pos usually negative.\nReturns the new absolute position.",
    "_io.BytesIO.seekable" => "Returns True if the IO object can be seeked.",
    "_io.BytesIO.tell" => "Current file position, an integer.",
    "_io.BytesIO.truncate" => "Truncate the file to at most size bytes.\n\nSize defaults to the current file position, as returned by tell().\nThe current file position is unchanged.  Returns the new size.",
    "_io.BytesIO.writable" => "Returns True if the IO object can be written.",
    "_io.BytesIO.write" => "Write bytes to file.\n\nReturn the number of bytes written.",
    "_io.BytesIO.writelines" => "Write lines to the file.\n\nNote that newlines are not added.  lines can be any iterable object\nproducing bytes-like objects. This is equivalent to calling write() for\neach element.",
    "_io.FileIO" => "Open a file.\n\nThe mode can be 'r' (default), 'w', 'x' or 'a' for reading,\nwriting, exclusive creation or appending.  The file will be created if it\ndoesn't exist when opened for writing or appending; it will be truncated\nwhen opened for writing.  A FileExistsError will be raised if it already\nexists when opened for creating. Opening a file for creating implies\nwriting so this mode behaves in a similar way to 'w'.Add a '+' to the mode\nto allow simultaneous reading and writing. A custom opener can be used by\npassing a callable as *opener*. The underlying file descriptor for the file\nobject is then obtained by calling opener with (*name*, *flags*).\n*opener* must return an open file descriptor (passing os.open as *opener*\nresults in functionality similar to passing None).",
    "_io.FileIO.__del__" => "Called when the instance is about to be destroyed.",
    "_io.FileIO.__delattr__" => "Implement delattr(self, name).",
    "_io.FileIO.__eq__" => "Return self==value.",
    "_io.FileIO.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io.FileIO.__ge__" => "Return self>=value.",
    "_io.FileIO.__getattribute__" => "Return getattr(self, name).",
    "_io.FileIO.__gt__" => "Return self>value.",
    "_io.FileIO.__hash__" => "Return hash(self).",
    "_io.FileIO.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io.FileIO.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io.FileIO.__iter__" => "Implement iter(self).",
    "_io.FileIO.__le__" => "Return self<=value.",
    "_io.FileIO.__lt__" => "Return self<value.",
    "_io.FileIO.__ne__" => "Return self!=value.",
    "_io.FileIO.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io.FileIO.__next__" => "Implement next(self).",
    "_io.FileIO.__reduce__" => "Helper for pickle.",
    "_io.FileIO.__reduce_ex__" => "Helper for pickle.",
    "_io.FileIO.__repr__" => "Return repr(self).",
    "_io.FileIO.__setattr__" => "Implement setattr(self, name, value).",
    "_io.FileIO.__sizeof__" => "Size of object in memory, in bytes.",
    "_io.FileIO.__str__" => "Return str(self).",
    "_io.FileIO.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io.FileIO.close" => "Close the file.\n\nA closed file cannot be used for further I/O operations.  close() may be\ncalled more than once without error.",
    "_io.FileIO.closed" => "True if the file is closed",
    "_io.FileIO.closefd" => "True if the file descriptor will be closed by close().",
    "_io.FileIO.fileno" => "Return the underlying file descriptor (an integer).",
    "_io.FileIO.flush" => "Flush write buffers, if applicable.\n\nThis is not implemented for read-only and non-blocking streams.",
    "_io.FileIO.isatty" => "True if the file is connected to a TTY device.",
    "_io.FileIO.mode" => "String giving the file mode",
    "_io.FileIO.read" => "Read at most size bytes, returned as bytes.\n\nOnly makes one system call, so less data may be returned than requested.\nIn non-blocking mode, returns None if no data is available.\nReturn an empty bytes object at EOF.",
    "_io.FileIO.readable" => "True if file was opened in a read mode.",
    "_io.FileIO.readall" => "Read all data from the file, returned as bytes.\n\nIn non-blocking mode, returns as much as is immediately available,\nor None if no data is available.  Return an empty bytes object at EOF.",
    "_io.FileIO.readinto" => "Same as RawIOBase.readinto().",
    "_io.FileIO.readline" => "Read and return a line from the stream.\n\nIf size is specified, at most size bytes will be read.\n\nThe line terminator is always b'\\n' for binary files; for text\nfiles, the newlines argument to open can be used to select the line\nterminator(s) recognized.",
    "_io.FileIO.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io.FileIO.seek" => "Move to new file position and return the file position.\n\nArgument offset is a byte count.  Optional argument whence defaults to\nSEEK_SET or 0 (offset from start of file, offset should be >= 0); other values\nare SEEK_CUR or 1 (move relative to current position, positive or negative),\nand SEEK_END or 2 (move relative to end of file, usually negative, although\nmany platforms allow seeking beyond the end of a file).\n\nNote that not all file objects are seekable.",
    "_io.FileIO.seekable" => "True if file supports random-access.",
    "_io.FileIO.tell" => "Current file position.\n\nCan raise OSError for non seekable files.",
    "_io.FileIO.truncate" => "Truncate the file to at most size bytes and return the truncated size.\n\nSize defaults to the current file position, as returned by tell().\nThe current file position is changed to the value of size.",
    "_io.FileIO.writable" => "True if file was opened in a write mode.",
    "_io.FileIO.write" => "Write buffer b to file, return number of bytes written.\n\nOnly makes one system call, so not all of the data may be written.\nThe number of bytes actually written is returned.  In non-blocking mode,\nreturns None if the write would block.",
    "_io.FileIO.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io.IncrementalNewlineDecoder" => "Codec used when reading a file in universal newlines mode.\n\nIt wraps another incremental decoder, translating \\r\\n and \\r into \\n.\nIt also records the types of newlines encountered.  When used with\ntranslate=False, it ensures that the newline sequence is returned in\none piece. When used with decoder=None, it expects unicode strings as\ndecode input and translates newlines without first invoking an external\ndecoder.",
    "_io.IncrementalNewlineDecoder.__delattr__" => "Implement delattr(self, name).",
    "_io.IncrementalNewlineDecoder.__eq__" => "Return self==value.",
    "_io.IncrementalNewlineDecoder.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io.IncrementalNewlineDecoder.__ge__" => "Return self>=value.",
    "_io.IncrementalNewlineDecoder.__getattribute__" => "Return getattr(self, name).",
    "_io.IncrementalNewlineDecoder.__getstate__" => "Helper for pickle.",
    "_io.IncrementalNewlineDecoder.__gt__" => "Return self>value.",
    "_io.IncrementalNewlineDecoder.__hash__" => "Return hash(self).",
    "_io.IncrementalNewlineDecoder.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io.IncrementalNewlineDecoder.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io.IncrementalNewlineDecoder.__le__" => "Return self<=value.",
    "_io.IncrementalNewlineDecoder.__lt__" => "Return self<value.",
    "_io.IncrementalNewlineDecoder.__ne__" => "Return self!=value.",
    "_io.IncrementalNewlineDecoder.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io.IncrementalNewlineDecoder.__reduce__" => "Helper for pickle.",
    "_io.IncrementalNewlineDecoder.__reduce_ex__" => "Helper for pickle.",
    "_io.IncrementalNewlineDecoder.__repr__" => "Return repr(self).",
    "_io.IncrementalNewlineDecoder.__setattr__" => "Implement setattr(self, name, value).",
    "_io.IncrementalNewlineDecoder.__sizeof__" => "Size of object in memory, in bytes.",
    "_io.IncrementalNewlineDecoder.__str__" => "Return str(self).",
    "_io.IncrementalNewlineDecoder.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io.StringIO" => "Text I/O implementation using an in-memory buffer.\n\nThe initial_value argument sets the value of object.  The newline\nargument is like the one of TextIOWrapper's constructor.",
    "_io.StringIO.__del__" => "Called when the instance is about to be destroyed.",
    "_io.StringIO.__delattr__" => "Implement delattr(self, name).",
    "_io.StringIO.__eq__" => "Return self==value.",
    "_io.StringIO.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io.StringIO.__ge__" => "Return self>=value.",
    "_io.StringIO.__getattribute__" => "Return getattr(self, name).",
    "_io.StringIO.__gt__" => "Return self>value.",
    "_io.StringIO.__hash__" => "Return hash(self).",
    "_io.StringIO.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io.StringIO.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io.StringIO.__iter__" => "Implement iter(self).",
    "_io.StringIO.__le__" => "Return self<=value.",
    "_io.StringIO.__lt__" => "Return self<value.",
    "_io.StringIO.__ne__" => "Return self!=value.",
    "_io.StringIO.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io.StringIO.__next__" => "Implement next(self).",
    "_io.StringIO.__reduce__" => "Helper for pickle.",
    "_io.StringIO.__reduce_ex__" => "Helper for pickle.",
    "_io.StringIO.__repr__" => "Return repr(self).",
    "_io.StringIO.__setattr__" => "Implement setattr(self, name, value).",
    "_io.StringIO.__sizeof__" => "Size of object in memory, in bytes.",
    "_io.StringIO.__str__" => "Return str(self).",
    "_io.StringIO.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io.StringIO.close" => "Close the IO object.\n\nAttempting any further operation after the object is closed\nwill raise a ValueError.\n\nThis method has no effect if the file is already closed.",
    "_io.StringIO.detach" => "Separate the underlying buffer from the TextIOBase and return it.\n\nAfter the underlying buffer has been detached, the TextIO is in an unusable state.",
    "_io.StringIO.encoding" => "Encoding of the text stream.\n\nSubclasses should override.",
    "_io.StringIO.errors" => "The error setting of the decoder or encoder.\n\nSubclasses should override.",
    "_io.StringIO.fileno" => "Return underlying file descriptor if one exists.\n\nRaise OSError if the IO object does not use a file descriptor.",
    "_io.StringIO.flush" => "Flush write buffers, if applicable.\n\nThis is not implemented for read-only and non-blocking streams.",
    "_io.StringIO.getvalue" => "Retrieve the entire contents of the object.",
    "_io.StringIO.isatty" => "Return whether this is an 'interactive' stream.\n\nReturn False if it can't be determined.",
    "_io.StringIO.read" => "Read at most size characters, returned as a string.\n\nIf the argument is negative or omitted, read until EOF\nis reached. Return an empty string at EOF.",
    "_io.StringIO.readable" => "Returns True if the IO object can be read.",
    "_io.StringIO.readline" => "Read until newline or EOF.\n\nReturns an empty string if EOF is hit immediately.",
    "_io.StringIO.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io.StringIO.seek" => "Change stream position.\n\nSeek to character offset pos relative to position indicated by whence:\n    0  Start of stream (the default).  pos should be >= 0;\n    1  Current position - pos must be 0;\n    2  End of stream - pos must be 0.\nReturns the new absolute position.",
    "_io.StringIO.seekable" => "Returns True if the IO object can be seeked.",
    "_io.StringIO.tell" => "Tell the current file position.",
    "_io.StringIO.truncate" => "Truncate size to pos.\n\nThe pos argument defaults to the current file position, as\nreturned by tell().  The current file position is unchanged.\nReturns the new absolute position.",
    "_io.StringIO.writable" => "Returns True if the IO object can be written.",
    "_io.StringIO.write" => "Write string to file.\n\nReturns the number of characters written, which is always equal to\nthe length of the string.",
    "_io.StringIO.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io.TextIOWrapper" => "Character and line based layer over a BufferedIOBase object, buffer.\n\nencoding gives the name of the encoding that the stream will be\ndecoded or encoded with. It defaults to locale.getencoding().\n\nerrors determines the strictness of encoding and decoding (see\nhelp(codecs.Codec) or the documentation for codecs.register) and\ndefaults to \"strict\".\n\nnewline controls how line endings are handled. It can be None, '',\n'\\n', '\\r', and '\\r\\n'.  It works as follows:\n\n* On input, if newline is None, universal newlines mode is\n  enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n  these are translated into '\\n' before being returned to the\n  caller. If it is '', universal newline mode is enabled, but line\n  endings are returned to the caller untranslated. If it has any of\n  the other legal values, input lines are only terminated by the given\n  string, and the line ending is returned to the caller untranslated.\n\n* On output, if newline is None, any '\\n' characters written are\n  translated to the system default line separator, os.linesep. If\n  newline is '' or '\\n', no translation takes place. If newline is any\n  of the other legal values, any '\\n' characters written are translated\n  to the given string.\n\nIf line_buffering is True, a call to flush is implied when a call to\nwrite contains a newline character.",
    "_io.TextIOWrapper.__del__" => "Called when the instance is about to be destroyed.",
    "_io.TextIOWrapper.__delattr__" => "Implement delattr(self, name).",
    "_io.TextIOWrapper.__eq__" => "Return self==value.",
    "_io.TextIOWrapper.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io.TextIOWrapper.__ge__" => "Return self>=value.",
    "_io.TextIOWrapper.__getattribute__" => "Return getattr(self, name).",
    "_io.TextIOWrapper.__gt__" => "Return self>value.",
    "_io.TextIOWrapper.__hash__" => "Return hash(self).",
    "_io.TextIOWrapper.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io.TextIOWrapper.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io.TextIOWrapper.__iter__" => "Implement iter(self).",
    "_io.TextIOWrapper.__le__" => "Return self<=value.",
    "_io.TextIOWrapper.__lt__" => "Return self<value.",
    "_io.TextIOWrapper.__ne__" => "Return self!=value.",
    "_io.TextIOWrapper.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io.TextIOWrapper.__next__" => "Implement next(self).",
    "_io.TextIOWrapper.__reduce__" => "Helper for pickle.",
    "_io.TextIOWrapper.__reduce_ex__" => "Helper for pickle.",
    "_io.TextIOWrapper.__repr__" => "Return repr(self).",
    "_io.TextIOWrapper.__setattr__" => "Implement setattr(self, name, value).",
    "_io.TextIOWrapper.__sizeof__" => "Size of object in memory, in bytes.",
    "_io.TextIOWrapper.__str__" => "Return str(self).",
    "_io.TextIOWrapper.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io.TextIOWrapper.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io.TextIOWrapper.reconfigure" => "Reconfigure the text stream with new parameters.\n\nThis also does an implicit stream flush.",
    "_io.TextIOWrapper.seek" => "Set the stream position, and return the new stream position.\n\n  cookie\n    Zero or an opaque number returned by tell().\n  whence\n    The relative position to seek from.\n\nFour operations are supported, given by the following argument\ncombinations:\n\n- seek(0, SEEK_SET): Rewind to the start of the stream.\n- seek(cookie, SEEK_SET): Restore a previous position;\n  'cookie' must be a number returned by tell().\n- seek(0, SEEK_END): Fast-forward to the end of the stream.\n- seek(0, SEEK_CUR): Leave the current stream position unchanged.\n\nAny other argument combinations are invalid,\nand may raise exceptions.",
    "_io.TextIOWrapper.tell" => "Return the stream position as an opaque number.\n\nThe return value of tell() can be given as input to seek(), to restore a\nprevious stream position.",
    "_io.TextIOWrapper.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io._BufferedIOBase" => "Base class for buffered IO objects.\n\nThe main difference with RawIOBase is that the read() method\nsupports omitting the size argument, and does not have a default\nimplementation that defers to readinto().\n\nIn addition, read(), readinto() and write() may raise\nBlockingIOError if the underlying raw stream is in non-blocking\nmode and not ready; unlike their raw counterparts, they will never\nreturn None.\n\nA typical implementation should not inherit from a RawIOBase\nimplementation, but wrap one.",
    "_io._BufferedIOBase.__del__" => "Called when the instance is about to be destroyed.",
    "_io._BufferedIOBase.__delattr__" => "Implement delattr(self, name).",
    "_io._BufferedIOBase.__eq__" => "Return self==value.",
    "_io._BufferedIOBase.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io._BufferedIOBase.__ge__" => "Return self>=value.",
    "_io._BufferedIOBase.__getattribute__" => "Return getattr(self, name).",
    "_io._BufferedIOBase.__getstate__" => "Helper for pickle.",
    "_io._BufferedIOBase.__gt__" => "Return self>value.",
    "_io._BufferedIOBase.__hash__" => "Return hash(self).",
    "_io._BufferedIOBase.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io._BufferedIOBase.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io._BufferedIOBase.__iter__" => "Implement iter(self).",
    "_io._BufferedIOBase.__le__" => "Return self<=value.",
    "_io._BufferedIOBase.__lt__" => "Return self<value.",
    "_io._BufferedIOBase.__ne__" => "Return self!=value.",
    "_io._BufferedIOBase.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io._BufferedIOBase.__next__" => "Implement next(self).",
    "_io._BufferedIOBase.__reduce__" => "Helper for pickle.",
    "_io._BufferedIOBase.__reduce_ex__" => "Helper for pickle.",
    "_io._BufferedIOBase.__repr__" => "Return repr(self).",
    "_io._BufferedIOBase.__setattr__" => "Implement setattr(self, name, value).",
    "_io._BufferedIOBase.__sizeof__" => "Size of object in memory, in bytes.",
    "_io._BufferedIOBase.__str__" => "Return str(self).",
    "_io._BufferedIOBase.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io._BufferedIOBase.close" => "Flush and close the IO object.\n\nThis method has no effect if the file is already closed.",
    "_io._BufferedIOBase.detach" => "Disconnect this buffer from its underlying raw stream and return it.\n\nAfter the raw stream has been detached, the buffer is in an unusable\nstate.",
    "_io._BufferedIOBase.fileno" => "Return underlying file descriptor if one exists.\n\nRaise OSError if the IO object does not use a file descriptor.",
    "_io._BufferedIOBase.flush" => "Flush write buffers, if applicable.\n\nThis is not implemented for read-only and non-blocking streams.",
    "_io._BufferedIOBase.isatty" => "Return whether this is an 'interactive' stream.\n\nReturn False if it can't be determined.",
    "_io._BufferedIOBase.read" => "Read and return up to n bytes.\n\nIf the size argument is omitted, None, or negative, read and\nreturn all data until EOF.\n\nIf the size argument is positive, and the underlying raw stream is\nnot 'interactive', multiple raw reads may be issued to satisfy\nthe byte count (unless EOF is reached first).\nHowever, for interactive raw streams (as well as sockets and pipes),\nat most one raw read will be issued, and a short result does not\nimply that EOF is imminent.\n\nReturn an empty bytes object on EOF.\n\nReturn None if the underlying raw stream was open in non-blocking\nmode and no data is available at the moment.",
    "_io._BufferedIOBase.read1" => "Read and return up to size bytes, with at most one read() call to the underlying raw stream.\n\nReturn an empty bytes object on EOF.\nA short result does not imply that EOF is imminent.",
    "_io._BufferedIOBase.readable" => "Return whether object was opened for reading.\n\nIf False, read() will raise OSError.",
    "_io._BufferedIOBase.readline" => "Read and return a line from the stream.\n\nIf size is specified, at most size bytes will be read.\n\nThe line terminator is always b'\\n' for binary files; for text\nfiles, the newlines argument to open can be used to select the line\nterminator(s) recognized.",
    "_io._BufferedIOBase.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io._BufferedIOBase.seek" => "Change the stream position to the given byte offset.\n\n  offset\n    The stream position, relative to 'whence'.\n  whence\n    The relative position to seek from.\n\nThe offset is interpreted relative to the position indicated by whence.\nValues for whence are:\n\n* os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n* os.SEEK_CUR or 1 -- current stream position; offset may be negative\n* os.SEEK_END or 2 -- end of stream; offset is usually negative\n\nReturn the new absolute position.",
    "_io._BufferedIOBase.seekable" => "Return whether object supports random access.\n\nIf False, seek(), tell() and truncate() will raise OSError.\nThis method may need to do a test seek().",
    "_io._BufferedIOBase.tell" => "Return current stream position.",
    "_io._BufferedIOBase.truncate" => "Truncate file to size bytes.\n\nFile pointer is left unchanged. Size defaults to the current IO position\nas reported by tell(). Return the new size.",
    "_io._BufferedIOBase.writable" => "Return whether object was opened for writing.\n\nIf False, write() will raise OSError.",
    "_io._BufferedIOBase.write" => "Write buffer b to the IO stream.\n\nReturn the number of bytes written, which is always\nthe length of b in bytes.\n\nRaise BlockingIOError if the buffer is full and the\nunderlying raw stream cannot accept more data at the moment.",
    "_io._BufferedIOBase.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io._BytesIOBuffer.__buffer__" => "Return a buffer object that exposes the underlying memory of the object.",
    "_io._BytesIOBuffer.__delattr__" => "Implement delattr(self, name).",
    "_io._BytesIOBuffer.__eq__" => "Return self==value.",
    "_io._BytesIOBuffer.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io._BytesIOBuffer.__ge__" => "Return self>=value.",
    "_io._BytesIOBuffer.__getattribute__" => "Return getattr(self, name).",
    "_io._BytesIOBuffer.__getstate__" => "Helper for pickle.",
    "_io._BytesIOBuffer.__gt__" => "Return self>value.",
    "_io._BytesIOBuffer.__hash__" => "Return hash(self).",
    "_io._BytesIOBuffer.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io._BytesIOBuffer.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io._BytesIOBuffer.__le__" => "Return self<=value.",
    "_io._BytesIOBuffer.__lt__" => "Return self<value.",
    "_io._BytesIOBuffer.__ne__" => "Return self!=value.",
    "_io._BytesIOBuffer.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io._BytesIOBuffer.__reduce__" => "Helper for pickle.",
    "_io._BytesIOBuffer.__reduce_ex__" => "Helper for pickle.",
    "_io._BytesIOBuffer.__release_buffer__" => "Release the buffer object that exposes the underlying memory of the object.",
    "_io._BytesIOBuffer.__repr__" => "Return repr(self).",
    "_io._BytesIOBuffer.__setattr__" => "Implement setattr(self, name, value).",
    "_io._BytesIOBuffer.__sizeof__" => "Size of object in memory, in bytes.",
    "_io._BytesIOBuffer.__str__" => "Return str(self).",
    "_io._BytesIOBuffer.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io._IOBase" => "The abstract base class for all I/O classes.\n\nThis class provides dummy implementations for many methods that\nderived classes can override selectively; the default implementations\nrepresent a file that cannot be read, written or seeked.\n\nEven though IOBase does not declare read, readinto, or write because\ntheir signatures will vary, implementations and clients should\nconsider those methods part of the interface. Also, implementations\nmay raise UnsupportedOperation when operations they do not support are\ncalled.\n\nThe basic type used for binary data read from or written to a file is\nbytes. Other bytes-like objects are accepted as method arguments too.\nIn some cases (such as readinto), a writable object is required. Text\nI/O classes work with str data.\n\nNote that calling any method (except additional calls to close(),\nwhich are ignored) on a closed stream should raise a ValueError.\n\nIOBase (and its subclasses) support the iterator protocol, meaning\nthat an IOBase object can be iterated over yielding the lines in a\nstream.\n\nIOBase also supports the :keyword:`with` statement. In this example,\nfp is closed after the suite of the with statement is complete:\n\nwith open('spam.txt', 'r') as fp:\n    fp.write('Spam and eggs!')",
    "_io._IOBase.__del__" => "Called when the instance is about to be destroyed.",
    "_io._IOBase.__delattr__" => "Implement delattr(self, name).",
    "_io._IOBase.__eq__" => "Return self==value.",
    "_io._IOBase.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io._IOBase.__ge__" => "Return self>=value.",
    "_io._IOBase.__getattribute__" => "Return getattr(self, name).",
    "_io._IOBase.__getstate__" => "Helper for pickle.",
    "_io._IOBase.__gt__" => "Return self>value.",
    "_io._IOBase.__hash__" => "Return hash(self).",
    "_io._IOBase.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io._IOBase.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io._IOBase.__iter__" => "Implement iter(self).",
    "_io._IOBase.__le__" => "Return self<=value.",
    "_io._IOBase.__lt__" => "Return self<value.",
    "_io._IOBase.__ne__" => "Return self!=value.",
    "_io._IOBase.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io._IOBase.__next__" => "Implement next(self).",
    "_io._IOBase.__reduce__" => "Helper for pickle.",
    "_io._IOBase.__reduce_ex__" => "Helper for pickle.",
    "_io._IOBase.__repr__" => "Return repr(self).",
    "_io._IOBase.__setattr__" => "Implement setattr(self, name, value).",
    "_io._IOBase.__sizeof__" => "Size of object in memory, in bytes.",
    "_io._IOBase.__str__" => "Return str(self).",
    "_io._IOBase.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io._IOBase.close" => "Flush and close the IO object.\n\nThis method has no effect if the file is already closed.",
    "_io._IOBase.fileno" => "Return underlying file descriptor if one exists.\n\nRaise OSError if the IO object does not use a file descriptor.",
    "_io._IOBase.flush" => "Flush write buffers, if applicable.\n\nThis is not implemented for read-only and non-blocking streams.",
    "_io._IOBase.isatty" => "Return whether this is an 'interactive' stream.\n\nReturn False if it can't be determined.",
    "_io._IOBase.readable" => "Return whether object was opened for reading.\n\nIf False, read() will raise OSError.",
    "_io._IOBase.readline" => "Read and return a line from the stream.\n\nIf size is specified, at most size bytes will be read.\n\nThe line terminator is always b'\\n' for binary files; for text\nfiles, the newlines argument to open can be used to select the line\nterminator(s) recognized.",
    "_io._IOBase.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io._IOBase.seek" => "Change the stream position to the given byte offset.\n\n  offset\n    The stream position, relative to 'whence'.\n  whence\n    The relative position to seek from.\n\nThe offset is interpreted relative to the position indicated by whence.\nValues for whence are:\n\n* os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n* os.SEEK_CUR or 1 -- current stream position; offset may be negative\n* os.SEEK_END or 2 -- end of stream; offset is usually negative\n\nReturn the new absolute position.",
    "_io._IOBase.seekable" => "Return whether object supports random access.\n\nIf False, seek(), tell() and truncate() will raise OSError.\nThis method may need to do a test seek().",
    "_io._IOBase.tell" => "Return current stream position.",
    "_io._IOBase.truncate" => "Truncate file to size bytes.\n\nFile pointer is left unchanged. Size defaults to the current IO position\nas reported by tell(). Return the new size.",
    "_io._IOBase.writable" => "Return whether object was opened for writing.\n\nIf False, write() will raise OSError.",
    "_io._IOBase.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io._RawIOBase" => "Base class for raw binary I/O.",
    "_io._RawIOBase.__del__" => "Called when the instance is about to be destroyed.",
    "_io._RawIOBase.__delattr__" => "Implement delattr(self, name).",
    "_io._RawIOBase.__eq__" => "Return self==value.",
    "_io._RawIOBase.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io._RawIOBase.__ge__" => "Return self>=value.",
    "_io._RawIOBase.__getattribute__" => "Return getattr(self, name).",
    "_io._RawIOBase.__getstate__" => "Helper for pickle.",
    "_io._RawIOBase.__gt__" => "Return self>value.",
    "_io._RawIOBase.__hash__" => "Return hash(self).",
    "_io._RawIOBase.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io._RawIOBase.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io._RawIOBase.__iter__" => "Implement iter(self).",
    "_io._RawIOBase.__le__" => "Return self<=value.",
    "_io._RawIOBase.__lt__" => "Return self<value.",
    "_io._RawIOBase.__ne__" => "Return self!=value.",
    "_io._RawIOBase.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io._RawIOBase.__next__" => "Implement next(self).",
    "_io._RawIOBase.__reduce__" => "Helper for pickle.",
    "_io._RawIOBase.__reduce_ex__" => "Helper for pickle.",
    "_io._RawIOBase.__repr__" => "Return repr(self).",
    "_io._RawIOBase.__setattr__" => "Implement setattr(self, name, value).",
    "_io._RawIOBase.__sizeof__" => "Size of object in memory, in bytes.",
    "_io._RawIOBase.__str__" => "Return str(self).",
    "_io._RawIOBase.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io._RawIOBase.close" => "Flush and close the IO object.\n\nThis method has no effect if the file is already closed.",
    "_io._RawIOBase.fileno" => "Return underlying file descriptor if one exists.\n\nRaise OSError if the IO object does not use a file descriptor.",
    "_io._RawIOBase.flush" => "Flush write buffers, if applicable.\n\nThis is not implemented for read-only and non-blocking streams.",
    "_io._RawIOBase.isatty" => "Return whether this is an 'interactive' stream.\n\nReturn False if it can't be determined.",
    "_io._RawIOBase.readable" => "Return whether object was opened for reading.\n\nIf False, read() will raise OSError.",
    "_io._RawIOBase.readall" => "Read until EOF, using multiple read() call.",
    "_io._RawIOBase.readline" => "Read and return a line from the stream.\n\nIf size is specified, at most size bytes will be read.\n\nThe line terminator is always b'\\n' for binary files; for text\nfiles, the newlines argument to open can be used to select the line\nterminator(s) recognized.",
    "_io._RawIOBase.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io._RawIOBase.seek" => "Change the stream position to the given byte offset.\n\n  offset\n    The stream position, relative to 'whence'.\n  whence\n    The relative position to seek from.\n\nThe offset is interpreted relative to the position indicated by whence.\nValues for whence are:\n\n* os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n* os.SEEK_CUR or 1 -- current stream position; offset may be negative\n* os.SEEK_END or 2 -- end of stream; offset is usually negative\n\nReturn the new absolute position.",
    "_io._RawIOBase.seekable" => "Return whether object supports random access.\n\nIf False, seek(), tell() and truncate() will raise OSError.\nThis method may need to do a test seek().",
    "_io._RawIOBase.tell" => "Return current stream position.",
    "_io._RawIOBase.truncate" => "Truncate file to size bytes.\n\nFile pointer is left unchanged. Size defaults to the current IO position\nas reported by tell(). Return the new size.",
    "_io._RawIOBase.writable" => "Return whether object was opened for writing.\n\nIf False, write() will raise OSError.",
    "_io._RawIOBase.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io._TextIOBase" => "Base class for text I/O.\n\nThis class provides a character and line based interface to stream\nI/O. There is no readinto method because Python's character strings\nare immutable.",
    "_io._TextIOBase.__del__" => "Called when the instance is about to be destroyed.",
    "_io._TextIOBase.__delattr__" => "Implement delattr(self, name).",
    "_io._TextIOBase.__eq__" => "Return self==value.",
    "_io._TextIOBase.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io._TextIOBase.__ge__" => "Return self>=value.",
    "_io._TextIOBase.__getattribute__" => "Return getattr(self, name).",
    "_io._TextIOBase.__getstate__" => "Helper for pickle.",
    "_io._TextIOBase.__gt__" => "Return self>value.",
    "_io._TextIOBase.__hash__" => "Return hash(self).",
    "_io._TextIOBase.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io._TextIOBase.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io._TextIOBase.__iter__" => "Implement iter(self).",
    "_io._TextIOBase.__le__" => "Return self<=value.",
    "_io._TextIOBase.__lt__" => "Return self<value.",
    "_io._TextIOBase.__ne__" => "Return self!=value.",
    "_io._TextIOBase.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io._TextIOBase.__next__" => "Implement next(self).",
    "_io._TextIOBase.__reduce__" => "Helper for pickle.",
    "_io._TextIOBase.__reduce_ex__" => "Helper for pickle.",
    "_io._TextIOBase.__repr__" => "Return repr(self).",
    "_io._TextIOBase.__setattr__" => "Implement setattr(self, name, value).",
    "_io._TextIOBase.__sizeof__" => "Size of object in memory, in bytes.",
    "_io._TextIOBase.__str__" => "Return str(self).",
    "_io._TextIOBase.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io._TextIOBase.close" => "Flush and close the IO object.\n\nThis method has no effect if the file is already closed.",
    "_io._TextIOBase.detach" => "Separate the underlying buffer from the TextIOBase and return it.\n\nAfter the underlying buffer has been detached, the TextIO is in an unusable state.",
    "_io._TextIOBase.encoding" => "Encoding of the text stream.\n\nSubclasses should override.",
    "_io._TextIOBase.errors" => "The error setting of the decoder or encoder.\n\nSubclasses should override.",
    "_io._TextIOBase.fileno" => "Return underlying file descriptor if one exists.\n\nRaise OSError if the IO object does not use a file descriptor.",
    "_io._TextIOBase.flush" => "Flush write buffers, if applicable.\n\nThis is not implemented for read-only and non-blocking streams.",
    "_io._TextIOBase.isatty" => "Return whether this is an 'interactive' stream.\n\nReturn False if it can't be determined.",
    "_io._TextIOBase.newlines" => "Line endings translated so far.\n\nOnly line endings translated during reading are considered.\n\nSubclasses should override.",
    "_io._TextIOBase.read" => "Read at most size characters from stream.\n\nRead from underlying buffer until we have size characters or we hit EOF.\nIf size is negative or omitted, read until EOF.",
    "_io._TextIOBase.readable" => "Return whether object was opened for reading.\n\nIf False, read() will raise OSError.",
    "_io._TextIOBase.readline" => "Read until newline or EOF.\n\nReturn an empty string if EOF is hit immediately.\nIf size is specified, at most size characters will be read.",
    "_io._TextIOBase.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io._TextIOBase.seek" => "Change the stream position to the given byte offset.\n\n  offset\n    The stream position, relative to 'whence'.\n  whence\n    The relative position to seek from.\n\nThe offset is interpreted relative to the position indicated by whence.\nValues for whence are:\n\n* os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n* os.SEEK_CUR or 1 -- current stream position; offset may be negative\n* os.SEEK_END or 2 -- end of stream; offset is usually negative\n\nReturn the new absolute position.",
    "_io._TextIOBase.seekable" => "Return whether object supports random access.\n\nIf False, seek(), tell() and truncate() will raise OSError.\nThis method may need to do a test seek().",
    "_io._TextIOBase.tell" => "Return current stream position.",
    "_io._TextIOBase.truncate" => "Truncate file to size bytes.\n\nFile pointer is left unchanged. Size defaults to the current IO position\nas reported by tell(). Return the new size.",
    "_io._TextIOBase.writable" => "Return whether object was opened for writing.\n\nIf False, write() will raise OSError.",
    "_io._TextIOBase.write" => "Write string s to stream.\n\nReturn the number of characters written\n(which is always equal to the length of the string).",
    "_io._TextIOBase.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io._WindowsConsoleIO" => "Open a console buffer by file descriptor.\n\nThe mode can be 'rb' (default), or 'wb' for reading or writing bytes. All\nother mode characters will be ignored. Mode 'b' will be assumed if it is\nomitted. The *opener* parameter is always ignored.",
    "_io._WindowsConsoleIO.__del__" => "Called when the instance is about to be destroyed.",
    "_io._WindowsConsoleIO.__delattr__" => "Implement delattr(self, name).",
    "_io._WindowsConsoleIO.__eq__" => "Return self==value.",
    "_io._WindowsConsoleIO.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_io._WindowsConsoleIO.__ge__" => "Return self>=value.",
    "_io._WindowsConsoleIO.__getattribute__" => "Return getattr(self, name).",
    "_io._WindowsConsoleIO.__getstate__" => "Helper for pickle.",
    "_io._WindowsConsoleIO.__gt__" => "Return self>value.",
    "_io._WindowsConsoleIO.__hash__" => "Return hash(self).",
    "_io._WindowsConsoleIO.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_io._WindowsConsoleIO.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_io._WindowsConsoleIO.__iter__" => "Implement iter(self).",
    "_io._WindowsConsoleIO.__le__" => "Return self<=value.",
    "_io._WindowsConsoleIO.__lt__" => "Return self<value.",
    "_io._WindowsConsoleIO.__ne__" => "Return self!=value.",
    "_io._WindowsConsoleIO.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_io._WindowsConsoleIO.__next__" => "Implement next(self).",
    "_io._WindowsConsoleIO.__reduce__" => "Helper for pickle.",
    "_io._WindowsConsoleIO.__reduce_ex__" => "Helper for pickle.",
    "_io._WindowsConsoleIO.__repr__" => "Return repr(self).",
    "_io._WindowsConsoleIO.__setattr__" => "Implement setattr(self, name, value).",
    "_io._WindowsConsoleIO.__sizeof__" => "Size of object in memory, in bytes.",
    "_io._WindowsConsoleIO.__str__" => "Return str(self).",
    "_io._WindowsConsoleIO.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_io._WindowsConsoleIO.close" => "Close the console object.\n\nA closed console object cannot be used for further I/O operations.\nclose() may be called more than once without error.",
    "_io._WindowsConsoleIO.closed" => "True if the file is closed",
    "_io._WindowsConsoleIO.closefd" => "True if the file descriptor will be closed by close().",
    "_io._WindowsConsoleIO.fileno" => "Return the underlying file descriptor (an integer).",
    "_io._WindowsConsoleIO.flush" => "Flush write buffers, if applicable.\n\nThis is not implemented for read-only and non-blocking streams.",
    "_io._WindowsConsoleIO.isatty" => "Always True.",
    "_io._WindowsConsoleIO.mode" => "String giving the file mode",
    "_io._WindowsConsoleIO.read" => "Read at most size bytes, returned as bytes.\n\nOnly makes one system call when size is a positive integer,\nso less data may be returned than requested.\nReturn an empty bytes object at EOF.",
    "_io._WindowsConsoleIO.readable" => "True if console is an input buffer.",
    "_io._WindowsConsoleIO.readall" => "Read all data from the console, returned as bytes.\n\nReturn an empty bytes object at EOF.",
    "_io._WindowsConsoleIO.readinto" => "Same as RawIOBase.readinto().",
    "_io._WindowsConsoleIO.readline" => "Read and return a line from the stream.\n\nIf size is specified, at most size bytes will be read.\n\nThe line terminator is always b'\\n' for binary files; for text\nfiles, the newlines argument to open can be used to select the line\nterminator(s) recognized.",
    "_io._WindowsConsoleIO.readlines" => "Return a list of lines from the stream.\n\nhint can be specified to control the number of lines read: no more\nlines will be read if the total size (in bytes/characters) of all\nlines so far exceeds hint.",
    "_io._WindowsConsoleIO.seek" => "Change the stream position to the given byte offset.\n\n  offset\n    The stream position, relative to 'whence'.\n  whence\n    The relative position to seek from.\n\nThe offset is interpreted relative to the position indicated by whence.\nValues for whence are:\n\n* os.SEEK_SET or 0 -- start of stream (the default); offset should be zero or positive\n* os.SEEK_CUR or 1 -- current stream position; offset may be negative\n* os.SEEK_END or 2 -- end of stream; offset is usually negative\n\nReturn the new absolute position.",
    "_io._WindowsConsoleIO.seekable" => "Return whether object supports random access.\n\nIf False, seek(), tell() and truncate() will raise OSError.\nThis method may need to do a test seek().",
    "_io._WindowsConsoleIO.tell" => "Return current stream position.",
    "_io._WindowsConsoleIO.truncate" => "Truncate file to size bytes.\n\nFile pointer is left unchanged. Size defaults to the current IO position\nas reported by tell(). Return the new size.",
    "_io._WindowsConsoleIO.writable" => "True if console is an output buffer.",
    "_io._WindowsConsoleIO.write" => "Write buffer b to file, return number of bytes written.\n\nOnly makes one system call, so not all of the data may be written.\nThe number of bytes actually written is returned.",
    "_io._WindowsConsoleIO.writelines" => "Write a list of lines to stream.\n\nLine separators are not added, so it is usual for each of the\nlines provided to have a line separator at the end.",
    "_io.open" => "Open file and return a stream.  Raise OSError upon failure.\n\nfile is either a text or byte string giving the name (and the path\nif the file isn't in the current working directory) of the file to\nbe opened or an integer file descriptor of the file to be\nwrapped. (If a file descriptor is given, it is closed when the\nreturned I/O object is closed, unless closefd is set to False.)\n\nmode is an optional string that specifies the mode in which the file\nis opened. It defaults to 'r' which means open for reading in text\nmode.  Other common values are 'w' for writing (truncating the file if\nit already exists), 'x' for creating and writing to a new file, and\n'a' for appending (which on some Unix systems, means that all writes\nappend to the end of the file regardless of the current seek position).\nIn text mode, if encoding is not specified the encoding used is platform\ndependent: locale.getencoding() is called to get the current locale encoding.\n(For reading and writing raw bytes use binary mode and leave encoding\nunspecified.) The available modes are:\n\n========= ===============================================================\nCharacter Meaning\n--------- ---------------------------------------------------------------\n'r'       open for reading (default)\n'w'       open for writing, truncating the file first\n'x'       create a new file and open it for writing\n'a'       open for writing, appending to the end of the file if it exists\n'b'       binary mode\n't'       text mode (default)\n'+'       open a disk file for updating (reading and writing)\n========= ===============================================================\n\nThe default mode is 'rt' (open for reading text). For binary random\naccess, the mode 'w+b' opens and truncates the file to 0 bytes, while\n'r+b' opens the file without truncation. The 'x' mode implies 'w' and\nraises an `FileExistsError` if the file already exists.\n\nPython distinguishes between files opened in binary and text modes,\neven when the underlying operating system doesn't. Files opened in\nbinary mode (appending 'b' to the mode argument) return contents as\nbytes objects without any decoding. In text mode (the default, or when\n't' is appended to the mode argument), the contents of the file are\nreturned as strings, the bytes having been first decoded using a\nplatform-dependent encoding or using the specified encoding if given.\n\nbuffering is an optional integer used to set the buffering policy.\nPass 0 to switch buffering off (only allowed in binary mode), 1 to select\nline buffering (only usable in text mode), and an integer > 1 to indicate\nthe size of a fixed-size chunk buffer.  When no buffering argument is\ngiven, the default buffering policy works as follows:\n\n* Binary files are buffered in fixed-size chunks; the size of the buffer\n  is chosen using a heuristic trying to determine the underlying device's\n  \"block size\" and falling back on `io.DEFAULT_BUFFER_SIZE`.\n  On many systems, the buffer will typically be 4096 or 8192 bytes long.\n\n* \"Interactive\" text files (files for which isatty() returns True)\n  use line buffering.  Other text files use the policy described above\n  for binary files.\n\nencoding is the name of the encoding used to decode or encode the\nfile. This should only be used in text mode. The default encoding is\nplatform dependent, but any encoding supported by Python can be\npassed.  See the codecs module for the list of supported encodings.\n\nerrors is an optional string that specifies how encoding errors are to\nbe handled---this argument should not be used in binary mode. Pass\n'strict' to raise a ValueError exception if there is an encoding error\n(the default of None has the same effect), or pass 'ignore' to ignore\nerrors. (Note that ignoring encoding errors can lead to data loss.)\nSee the documentation for codecs.register or run 'help(codecs.Codec)'\nfor a list of the permitted encoding error strings.\n\nnewline controls how universal newlines works (it only applies to text\nmode). It can be None, '', '\\n', '\\r', and '\\r\\n'.  It works as\nfollows:\n\n* On input, if newline is None, universal newlines mode is\n  enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n  these are translated into '\\n' before being returned to the\n  caller. If it is '', universal newline mode is enabled, but line\n  endings are returned to the caller untranslated. If it has any of\n  the other legal values, input lines are only terminated by the given\n  string, and the line ending is returned to the caller untranslated.\n\n* On output, if newline is None, any '\\n' characters written are\n  translated to the system default line separator, os.linesep. If\n  newline is '' or '\\n', no translation takes place. If newline is any\n  of the other legal values, any '\\n' characters written are translated\n  to the given string.\n\nIf closefd is False, the underlying file descriptor will be kept open\nwhen the file is closed. This does not work when a file name is given\nand must be True in that case.\n\nA custom opener can be used by passing a callable as *opener*. The\nunderlying file descriptor for the file object is then obtained by\ncalling *opener* with (*file*, *flags*). *opener* must return an open\nfile descriptor (passing os.open as *opener* results in functionality\nsimilar to passing None).\n\nopen() returns a file object whose type depends on the mode, and\nthrough which the standard file operations such as reading and writing\nare performed. When open() is used to open a file in a text mode ('w',\n'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open\na file in a binary mode, the returned class varies: in read binary\nmode, it returns a BufferedReader; in write binary and append binary\nmodes, it returns a BufferedWriter, and in read/write mode, it returns\na BufferedRandom.\n\nIt is also possible to use a string or bytearray as a file for both\nreading and writing. For strings StringIO can be used like a file\nopened in a text mode, and for bytes a BytesIO can be used like a file\nopened in a binary mode.",
    "_io.open_code" => "Opens the provided file with the intent to import the contents.\n\nThis may perform extra validation beyond open(), but is otherwise interchangeable\nwith calling open(path, 'rb').",
    "_io.text_encoding" => "A helper function to choose the text encoding.\n\nWhen encoding is not None, this function returns it.\nOtherwise, this function returns the default text encoding\n(i.e. \"locale\" or \"utf-8\" depends on UTF-8 mode).\n\nThis function emits an EncodingWarning if encoding is None and\nsys.flags.warn_default_encoding is true.\n\nThis can be used in APIs with an encoding=None parameter.\nHowever, please consider using encoding=\"utf-8\" for new APIs.",
    "_json" => "json speedups",
    "_json.encode_basestring" => "encode_basestring(string) -> string\n\nReturn a JSON representation of a Python string",
    "_json.encode_basestring_ascii" => "encode_basestring_ascii(string) -> string\n\nReturn an ASCII-only JSON representation of a Python string",
    "_json.make_encoder" => "Encoder(markers, default, encoder, indent, key_separator, item_separator, sort_keys, skipkeys, allow_nan)",
    "_json.make_encoder.__call__" => "Call self as a function.",
    "_json.make_encoder.__delattr__" => "Implement delattr(self, name).",
    "_json.make_encoder.__eq__" => "Return self==value.",
    "_json.make_encoder.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_json.make_encoder.__ge__" => "Return self>=value.",
    "_json.make_encoder.__getattribute__" => "Return getattr(self, name).",
    "_json.make_encoder.__getstate__" => "Helper for pickle.",
    "_json.make_encoder.__gt__" => "Return self>value.",
    "_json.make_encoder.__hash__" => "Return hash(self).",
    "_json.make_encoder.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_json.make_encoder.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_json.make_encoder.__le__" => "Return self<=value.",
    "_json.make_encoder.__lt__" => "Return self<value.",
    "_json.make_encoder.__ne__" => "Return self!=value.",
    "_json.make_encoder.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_json.make_encoder.__reduce__" => "Helper for pickle.",
    "_json.make_encoder.__reduce_ex__" => "Helper for pickle.",
    "_json.make_encoder.__repr__" => "Return repr(self).",
    "_json.make_encoder.__setattr__" => "Implement setattr(self, name, value).",
    "_json.make_encoder.__sizeof__" => "Size of object in memory, in bytes.",
    "_json.make_encoder.__str__" => "Return str(self).",
    "_json.make_encoder.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_json.make_encoder.default" => "default",
    "_json.make_encoder.encoder" => "encoder",
    "_json.make_encoder.indent" => "indent",
    "_json.make_encoder.item_separator" => "item_separator",
    "_json.make_encoder.key_separator" => "key_separator",
    "_json.make_encoder.markers" => "markers",
    "_json.make_encoder.skipkeys" => "skipkeys",
    "_json.make_encoder.sort_keys" => "sort_keys",
    "_json.make_scanner" => "JSON scanner object",
    "_json.make_scanner.__call__" => "Call self as a function.",
    "_json.make_scanner.__delattr__" => "Implement delattr(self, name).",
    "_json.make_scanner.__eq__" => "Return self==value.",
    "_json.make_scanner.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_json.make_scanner.__ge__" => "Return self>=value.",
    "_json.make_scanner.__getattribute__" => "Return getattr(self, name).",
    "_json.make_scanner.__getstate__" => "Helper for pickle.",
    "_json.make_scanner.__gt__" => "Return self>value.",
    "_json.make_scanner.__hash__" => "Return hash(self).",
    "_json.make_scanner.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_json.make_scanner.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_json.make_scanner.__le__" => "Return self<=value.",
    "_json.make_scanner.__lt__" => "Return self<value.",
    "_json.make_scanner.__ne__" => "Return self!=value.",
    "_json.make_scanner.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_json.make_scanner.__reduce__" => "Helper for pickle.",
    "_json.make_scanner.__reduce_ex__" => "Helper for pickle.",
    "_json.make_scanner.__repr__" => "Return repr(self).",
    "_json.make_scanner.__setattr__" => "Implement setattr(self, name, value).",
    "_json.make_scanner.__sizeof__" => "Size of object in memory, in bytes.",
    "_json.make_scanner.__str__" => "Return str(self).",
    "_json.make_scanner.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_json.make_scanner.object_hook" => "object_hook",
    "_json.make_scanner.parse_constant" => "parse_constant",
    "_json.make_scanner.parse_float" => "parse_float",
    "_json.make_scanner.parse_int" => "parse_int",
    "_json.make_scanner.strict" => "strict",
    "_json.scanstring" => "scanstring(string, end, strict=True) -> (string, end)\n\nScan the string s for a JSON string. End is the index of the\ncharacter in s after the quote that started the JSON string.\nUnescapes all valid JSON string escape sequences and raises ValueError\non attempt to decode an invalid string. If strict is False then literal\ncontrol characters are allowed in the string.\n\nReturns a tuple of the decoded string and the index of the character in s\nafter the end quote.",
    "_locale" => "Support for POSIX locales.",
    "_locale.getencoding" => "Get the current locale encoding.",
    "_locale.localeconv" => "Returns numeric and monetary locale-specific parameters.",
    "_locale.setlocale" => "Activates/queries locale processing.",
    "_locale.strcoll" => "Compares two strings according to the locale.",
    "_locale.strxfrm" => "Return a string that can be used as a key for locale-aware comparisons.",
    "_lsprof" => "Fast profiler",
    "_lsprof.Profiler" => "Profiler(timer=None, timeunit=None, subcalls=True, builtins=True)\n\nBuilds a profiler object using the specified timer function.\nThe default timer is a fast built-in one based on real time.\nFor custom timer functions returning integers, timeunit can\nbe a float specifying a scale (i.e. how long each integer unit\nis, in seconds).",
    "_lsprof.Profiler.__delattr__" => "Implement delattr(self, name).",
    "_lsprof.Profiler.__eq__" => "Return self==value.",
    "_lsprof.Profiler.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_lsprof.Profiler.__ge__" => "Return self>=value.",
    "_lsprof.Profiler.__getattribute__" => "Return getattr(self, name).",
    "_lsprof.Profiler.__getstate__" => "Helper for pickle.",
    "_lsprof.Profiler.__gt__" => "Return self>value.",
    "_lsprof.Profiler.__hash__" => "Return hash(self).",
    "_lsprof.Profiler.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_lsprof.Profiler.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_lsprof.Profiler.__le__" => "Return self<=value.",
    "_lsprof.Profiler.__lt__" => "Return self<value.",
    "_lsprof.Profiler.__ne__" => "Return self!=value.",
    "_lsprof.Profiler.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_lsprof.Profiler.__reduce__" => "Helper for pickle.",
    "_lsprof.Profiler.__reduce_ex__" => "Helper for pickle.",
    "_lsprof.Profiler.__repr__" => "Return repr(self).",
    "_lsprof.Profiler.__setattr__" => "Implement setattr(self, name, value).",
    "_lsprof.Profiler.__sizeof__" => "Size of object in memory, in bytes.",
    "_lsprof.Profiler.__str__" => "Return str(self).",
    "_lsprof.Profiler.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_lsprof.Profiler.clear" => "clear()\n\nClear all profiling information collected so far.",
    "_lsprof.Profiler.disable" => "disable()\n\nStop collecting profiling information.",
    "_lsprof.Profiler.enable" => "enable(subcalls=True, builtins=True)\n\nStart collecting profiling information.\nIf 'subcalls' is True, also records for each function\nstatistics separated according to its current caller.\nIf 'builtins' is True, records the time spent in\nbuilt-in functions separately from their caller.",
    "_lsprof.Profiler.getstats" => "list of profiler_entry objects.\n\ngetstats() -> list of profiler_entry objects\n\nReturn all information collected by the profiler.\nEach profiler_entry is a tuple-like object with the\nfollowing attributes:\n\n    code          code object\n    callcount     how many times this was called\n    reccallcount  how many times called recursively\n    totaltime     total time in this entry\n    inlinetime    inline time in this entry (not in subcalls)\n    calls         details of the calls\n\nThe calls attribute is either None or a list of\nprofiler_subentry objects:\n\n    code          called code object\n    callcount     how many times this is called\n    reccallcount  how many times this is called recursively\n    totaltime     total time spent in this call\n    inlinetime    inline time (not in further subcalls)",
    "_lsprof.profiler_entry.__add__" => "Return self+value.",
    "_lsprof.profiler_entry.__class_getitem__" => "See PEP 585",
    "_lsprof.profiler_entry.__contains__" => "Return bool(key in self).",
    "_lsprof.profiler_entry.__delattr__" => "Implement delattr(self, name).",
    "_lsprof.profiler_entry.__eq__" => "Return self==value.",
    "_lsprof.profiler_entry.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_lsprof.profiler_entry.__ge__" => "Return self>=value.",
    "_lsprof.profiler_entry.__getattribute__" => "Return getattr(self, name).",
    "_lsprof.profiler_entry.__getitem__" => "Return self[key].",
    "_lsprof.profiler_entry.__getstate__" => "Helper for pickle.",
    "_lsprof.profiler_entry.__gt__" => "Return self>value.",
    "_lsprof.profiler_entry.__hash__" => "Return hash(self).",
    "_lsprof.profiler_entry.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_lsprof.profiler_entry.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_lsprof.profiler_entry.__iter__" => "Implement iter(self).",
    "_lsprof.profiler_entry.__le__" => "Return self<=value.",
    "_lsprof.profiler_entry.__len__" => "Return len(self).",
    "_lsprof.profiler_entry.__lt__" => "Return self<value.",
    "_lsprof.profiler_entry.__mul__" => "Return self*value.",
    "_lsprof.profiler_entry.__ne__" => "Return self!=value.",
    "_lsprof.profiler_entry.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_lsprof.profiler_entry.__reduce_ex__" => "Helper for pickle.",
    "_lsprof.profiler_entry.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "_lsprof.profiler_entry.__repr__" => "Return repr(self).",
    "_lsprof.profiler_entry.__rmul__" => "Return value*self.",
    "_lsprof.profiler_entry.__setattr__" => "Implement setattr(self, name, value).",
    "_lsprof.profiler_entry.__sizeof__" => "Size of object in memory, in bytes.",
    "_lsprof.profiler_entry.__str__" => "Return str(self).",
    "_lsprof.profiler_entry.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_lsprof.profiler_entry.callcount" => "how many times this was called",
    "_lsprof.profiler_entry.calls" => "details of the calls",
    "_lsprof.profiler_entry.code" => "code object or built-in function name",
    "_lsprof.profiler_entry.count" => "Return number of occurrences of value.",
    "_lsprof.profiler_entry.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "_lsprof.profiler_entry.inlinetime" => "inline time in this entry (not in subcalls)",
    "_lsprof.profiler_entry.reccallcount" => "how many times called recursively",
    "_lsprof.profiler_entry.totaltime" => "total time in this entry",
    "_lsprof.profiler_subentry.__add__" => "Return self+value.",
    "_lsprof.profiler_subentry.__class_getitem__" => "See PEP 585",
    "_lsprof.profiler_subentry.__contains__" => "Return bool(key in self).",
    "_lsprof.profiler_subentry.__delattr__" => "Implement delattr(self, name).",
    "_lsprof.profiler_subentry.__eq__" => "Return self==value.",
    "_lsprof.profiler_subentry.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_lsprof.profiler_subentry.__ge__" => "Return self>=value.",
    "_lsprof.profiler_subentry.__getattribute__" => "Return getattr(self, name).",
    "_lsprof.profiler_subentry.__getitem__" => "Return self[key].",
    "_lsprof.profiler_subentry.__getstate__" => "Helper for pickle.",
    "_lsprof.profiler_subentry.__gt__" => "Return self>value.",
    "_lsprof.profiler_subentry.__hash__" => "Return hash(self).",
    "_lsprof.profiler_subentry.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_lsprof.profiler_subentry.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_lsprof.profiler_subentry.__iter__" => "Implement iter(self).",
    "_lsprof.profiler_subentry.__le__" => "Return self<=value.",
    "_lsprof.profiler_subentry.__len__" => "Return len(self).",
    "_lsprof.profiler_subentry.__lt__" => "Return self<value.",
    "_lsprof.profiler_subentry.__mul__" => "Return self*value.",
    "_lsprof.profiler_subentry.__ne__" => "Return self!=value.",
    "_lsprof.profiler_subentry.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_lsprof.profiler_subentry.__reduce_ex__" => "Helper for pickle.",
    "_lsprof.profiler_subentry.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "_lsprof.profiler_subentry.__repr__" => "Return repr(self).",
    "_lsprof.profiler_subentry.__rmul__" => "Return value*self.",
    "_lsprof.profiler_subentry.__setattr__" => "Implement setattr(self, name, value).",
    "_lsprof.profiler_subentry.__sizeof__" => "Size of object in memory, in bytes.",
    "_lsprof.profiler_subentry.__str__" => "Return str(self).",
    "_lsprof.profiler_subentry.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_lsprof.profiler_subentry.callcount" => "how many times this is called",
    "_lsprof.profiler_subentry.code" => "called code object or built-in function name",
    "_lsprof.profiler_subentry.count" => "Return number of occurrences of value.",
    "_lsprof.profiler_subentry.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "_lsprof.profiler_subentry.inlinetime" => "inline time (not in further subcalls)",
    "_lsprof.profiler_subentry.reccallcount" => "how many times this is called recursively",
    "_lsprof.profiler_subentry.totaltime" => "total time spent in this call",
    "_lzma.LZMACompressor" => "LZMACompressor(format=FORMAT_XZ, check=-1, preset=None, filters=None)\n\nCreate a compressor object for compressing data incrementally.\n\nformat specifies the container format to use for the output. This can\nbe FORMAT_XZ (default), FORMAT_ALONE, or FORMAT_RAW.\n\ncheck specifies the integrity check to use. For FORMAT_XZ, the default\nis CHECK_CRC64. FORMAT_ALONE and FORMAT_RAW do not support integrity\nchecks; for these formats, check must be omitted, or be CHECK_NONE.\n\nThe settings used by the compressor can be specified either as a\npreset compression level (with the 'preset' argument), or in detail\nas a custom filter chain (with the 'filters' argument). For FORMAT_XZ\nand FORMAT_ALONE, the default is to use the PRESET_DEFAULT preset\nlevel. For FORMAT_RAW, the caller must always specify a filter chain;\nthe raw compressor does not support preset compression levels.\n\npreset (if provided) should be an integer in the range 0-9, optionally\nOR-ed with the constant PRESET_EXTREME.\n\nfilters (if provided) should be a sequence of dicts. Each dict should\nhave an entry for \"id\" indicating the ID of the filter, plus\nadditional entries for options to the filter.\n\nFor one-shot compression, use the compress() function instead.",
    "_lzma.LZMACompressor.__delattr__" => "Implement delattr(self, name).",
    "_lzma.LZMACompressor.__eq__" => "Return self==value.",
    "_lzma.LZMACompressor.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_lzma.LZMACompressor.__ge__" => "Return self>=value.",
    "_lzma.LZMACompressor.__getattribute__" => "Return getattr(self, name).",
    "_lzma.LZMACompressor.__getstate__" => "Helper for pickle.",
    "_lzma.LZMACompressor.__gt__" => "Return self>value.",
    "_lzma.LZMACompressor.__hash__" => "Return hash(self).",
    "_lzma.LZMACompressor.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_lzma.LZMACompressor.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_lzma.LZMACompressor.__le__" => "Return self<=value.",
    "_lzma.LZMACompressor.__lt__" => "Return self<value.",
    "_lzma.LZMACompressor.__ne__" => "Return self!=value.",
    "_lzma.LZMACompressor.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_lzma.LZMACompressor.__reduce__" => "Helper for pickle.",
    "_lzma.LZMACompressor.__reduce_ex__" => "Helper for pickle.",
    "_lzma.LZMACompressor.__repr__" => "Return repr(self).",
    "_lzma.LZMACompressor.__setattr__" => "Implement setattr(self, name, value).",
    "_lzma.LZMACompressor.__sizeof__" => "Size of object in memory, in bytes.",
    "_lzma.LZMACompressor.__str__" => "Return str(self).",
    "_lzma.LZMACompressor.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_lzma.LZMACompressor.compress" => "Provide data to the compressor object.\n\nReturns a chunk of compressed data if possible, or b'' otherwise.\n\nWhen you have finished providing data to the compressor, call the\nflush() method to finish the compression process.",
    "_lzma.LZMACompressor.flush" => "Finish the compression process.\n\nReturns the compressed data left in internal buffers.\n\nThe compressor object may not be used after this method is called.",
    "_lzma.LZMADecompressor" => "Create a decompressor object for decompressing data incrementally.\n\n  format\n    Specifies the container format of the input stream.  If this is\n    FORMAT_AUTO (the default), the decompressor will automatically detect\n    whether the input is FORMAT_XZ or FORMAT_ALONE.  Streams created with\n    FORMAT_RAW cannot be autodetected.\n  memlimit\n    Limit the amount of memory used by the decompressor.  This will cause\n    decompression to fail if the input cannot be decompressed within the\n    given limit.\n  filters\n    A custom filter chain.  This argument is required for FORMAT_RAW, and\n    not accepted with any other format.  When provided, this should be a\n    sequence of dicts, each indicating the ID and options for a single\n    filter.\n\nFor one-shot decompression, use the decompress() function instead.",
    "_lzma.LZMADecompressor.__delattr__" => "Implement delattr(self, name).",
    "_lzma.LZMADecompressor.__eq__" => "Return self==value.",
    "_lzma.LZMADecompressor.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_lzma.LZMADecompressor.__ge__" => "Return self>=value.",
    "_lzma.LZMADecompressor.__getattribute__" => "Return getattr(self, name).",
    "_lzma.LZMADecompressor.__getstate__" => "Helper for pickle.",
    "_lzma.LZMADecompressor.__gt__" => "Return self>value.",
    "_lzma.LZMADecompressor.__hash__" => "Return hash(self).",
    "_lzma.LZMADecompressor.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_lzma.LZMADecompressor.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_lzma.LZMADecompressor.__le__" => "Return self<=value.",
    "_lzma.LZMADecompressor.__lt__" => "Return self<value.",
    "_lzma.LZMADecompressor.__ne__" => "Return self!=value.",
    "_lzma.LZMADecompressor.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_lzma.LZMADecompressor.__reduce__" => "Helper for pickle.",
    "_lzma.LZMADecompressor.__reduce_ex__" => "Helper for pickle.",
    "_lzma.LZMADecompressor.__repr__" => "Return repr(self).",
    "_lzma.LZMADecompressor.__setattr__" => "Implement setattr(self, name, value).",
    "_lzma.LZMADecompressor.__sizeof__" => "Size of object in memory, in bytes.",
    "_lzma.LZMADecompressor.__str__" => "Return str(self).",
    "_lzma.LZMADecompressor.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_lzma.LZMADecompressor.check" => "ID of the integrity check used by the input stream.",
    "_lzma.LZMADecompressor.decompress" => "Decompress *data*, returning uncompressed data as bytes.\n\nIf *max_length* is nonnegative, returns at most *max_length* bytes of\ndecompressed data. If this limit is reached and further output can be\nproduced, *self.needs_input* will be set to ``False``. In this case, the next\ncall to *decompress()* may provide *data* as b'' to obtain more of the output.\n\nIf all of the input data was decompressed and returned (either because this\nwas less than *max_length* bytes, or because *max_length* was negative),\n*self.needs_input* will be set to True.\n\nAttempting to decompress data after the end of stream is reached raises an\nEOFError.  Any data found after the end of the stream is ignored and saved in\nthe unused_data attribute.",
    "_lzma.LZMADecompressor.eof" => "True if the end-of-stream marker has been reached.",
    "_lzma.LZMADecompressor.needs_input" => "True if more input is needed before more decompressed data can be produced.",
    "_lzma.LZMADecompressor.unused_data" => "Data found after the end of the compressed stream.",
    "_lzma.LZMAError" => "Call to liblzma failed.",
    "_lzma.LZMAError.__cause__" => "exception cause",
    "_lzma.LZMAError.__context__" => "exception context",
    "_lzma.LZMAError.__delattr__" => "Implement delattr(self, name).",
    "_lzma.LZMAError.__eq__" => "Return self==value.",
    "_lzma.LZMAError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_lzma.LZMAError.__ge__" => "Return self>=value.",
    "_lzma.LZMAError.__getattribute__" => "Return getattr(self, name).",
    "_lzma.LZMAError.__getstate__" => "Helper for pickle.",
    "_lzma.LZMAError.__gt__" => "Return self>value.",
    "_lzma.LZMAError.__hash__" => "Return hash(self).",
    "_lzma.LZMAError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_lzma.LZMAError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_lzma.LZMAError.__le__" => "Return self<=value.",
    "_lzma.LZMAError.__lt__" => "Return self<value.",
    "_lzma.LZMAError.__ne__" => "Return self!=value.",
    "_lzma.LZMAError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_lzma.LZMAError.__reduce_ex__" => "Helper for pickle.",
    "_lzma.LZMAError.__repr__" => "Return repr(self).",
    "_lzma.LZMAError.__setattr__" => "Implement setattr(self, name, value).",
    "_lzma.LZMAError.__sizeof__" => "Size of object in memory, in bytes.",
    "_lzma.LZMAError.__str__" => "Return str(self).",
    "_lzma.LZMAError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_lzma.LZMAError.__weakref__" => "list of weak references to the object",
    "_lzma.LZMAError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_lzma.LZMAError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_lzma._decode_filter_properties" => "Return a bytes object encoding the options (properties) of the filter specified by *filter* (a dict).\n\nThe result does not include the filter ID itself, only the options.",
    "_lzma._encode_filter_properties" => "Return a bytes object encoding the options (properties) of the filter specified by *filter* (a dict).\n\nThe result does not include the filter ID itself, only the options.",
    "_lzma.is_check_supported" => "Test whether the given integrity check is supported.\n\nAlways returns True for CHECK_NONE and CHECK_CRC32.",
    "_md5.MD5Type.__delattr__" => "Implement delattr(self, name).",
    "_md5.MD5Type.__eq__" => "Return self==value.",
    "_md5.MD5Type.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_md5.MD5Type.__ge__" => "Return self>=value.",
    "_md5.MD5Type.__getattribute__" => "Return getattr(self, name).",
    "_md5.MD5Type.__getstate__" => "Helper for pickle.",
    "_md5.MD5Type.__gt__" => "Return self>value.",
    "_md5.MD5Type.__hash__" => "Return hash(self).",
    "_md5.MD5Type.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_md5.MD5Type.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_md5.MD5Type.__le__" => "Return self<=value.",
    "_md5.MD5Type.__lt__" => "Return self<value.",
    "_md5.MD5Type.__ne__" => "Return self!=value.",
    "_md5.MD5Type.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_md5.MD5Type.__reduce__" => "Helper for pickle.",
    "_md5.MD5Type.__reduce_ex__" => "Helper for pickle.",
    "_md5.MD5Type.__repr__" => "Return repr(self).",
    "_md5.MD5Type.__setattr__" => "Implement setattr(self, name, value).",
    "_md5.MD5Type.__sizeof__" => "Size of object in memory, in bytes.",
    "_md5.MD5Type.__str__" => "Return str(self).",
    "_md5.MD5Type.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_md5.MD5Type.copy" => "Return a copy of the hash object.",
    "_md5.MD5Type.digest" => "Return the digest value as a bytes object.",
    "_md5.MD5Type.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_md5.MD5Type.update" => "Update this hash object's state with the provided string.",
    "_md5.md5" => "Return a new MD5 hash object; optionally initialized with a string.",
    "_multibytecodec.MultibyteIncrementalDecoder.__delattr__" => "Implement delattr(self, name).",
    "_multibytecodec.MultibyteIncrementalDecoder.__eq__" => "Return self==value.",
    "_multibytecodec.MultibyteIncrementalDecoder.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_multibytecodec.MultibyteIncrementalDecoder.__ge__" => "Return self>=value.",
    "_multibytecodec.MultibyteIncrementalDecoder.__getattribute__" => "Return getattr(self, name).",
    "_multibytecodec.MultibyteIncrementalDecoder.__getstate__" => "Helper for pickle.",
    "_multibytecodec.MultibyteIncrementalDecoder.__gt__" => "Return self>value.",
    "_multibytecodec.MultibyteIncrementalDecoder.__hash__" => "Return hash(self).",
    "_multibytecodec.MultibyteIncrementalDecoder.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_multibytecodec.MultibyteIncrementalDecoder.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_multibytecodec.MultibyteIncrementalDecoder.__le__" => "Return self<=value.",
    "_multibytecodec.MultibyteIncrementalDecoder.__lt__" => "Return self<value.",
    "_multibytecodec.MultibyteIncrementalDecoder.__ne__" => "Return self!=value.",
    "_multibytecodec.MultibyteIncrementalDecoder.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_multibytecodec.MultibyteIncrementalDecoder.__reduce__" => "Helper for pickle.",
    "_multibytecodec.MultibyteIncrementalDecoder.__reduce_ex__" => "Helper for pickle.",
    "_multibytecodec.MultibyteIncrementalDecoder.__repr__" => "Return repr(self).",
    "_multibytecodec.MultibyteIncrementalDecoder.__setattr__" => "Implement setattr(self, name, value).",
    "_multibytecodec.MultibyteIncrementalDecoder.__sizeof__" => "Size of object in memory, in bytes.",
    "_multibytecodec.MultibyteIncrementalDecoder.__str__" => "Return str(self).",
    "_multibytecodec.MultibyteIncrementalDecoder.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_multibytecodec.MultibyteIncrementalDecoder.errors" => "how to treat errors",
    "_multibytecodec.MultibyteIncrementalEncoder.__delattr__" => "Implement delattr(self, name).",
    "_multibytecodec.MultibyteIncrementalEncoder.__eq__" => "Return self==value.",
    "_multibytecodec.MultibyteIncrementalEncoder.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_multibytecodec.MultibyteIncrementalEncoder.__ge__" => "Return self>=value.",
    "_multibytecodec.MultibyteIncrementalEncoder.__getattribute__" => "Return getattr(self, name).",
    "_multibytecodec.MultibyteIncrementalEncoder.__getstate__" => "Helper for pickle.",
    "_multibytecodec.MultibyteIncrementalEncoder.__gt__" => "Return self>value.",
    "_multibytecodec.MultibyteIncrementalEncoder.__hash__" => "Return hash(self).",
    "_multibytecodec.MultibyteIncrementalEncoder.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_multibytecodec.MultibyteIncrementalEncoder.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_multibytecodec.MultibyteIncrementalEncoder.__le__" => "Return self<=value.",
    "_multibytecodec.MultibyteIncrementalEncoder.__lt__" => "Return self<value.",
    "_multibytecodec.MultibyteIncrementalEncoder.__ne__" => "Return self!=value.",
    "_multibytecodec.MultibyteIncrementalEncoder.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_multibytecodec.MultibyteIncrementalEncoder.__reduce__" => "Helper for pickle.",
    "_multibytecodec.MultibyteIncrementalEncoder.__reduce_ex__" => "Helper for pickle.",
    "_multibytecodec.MultibyteIncrementalEncoder.__repr__" => "Return repr(self).",
    "_multibytecodec.MultibyteIncrementalEncoder.__setattr__" => "Implement setattr(self, name, value).",
    "_multibytecodec.MultibyteIncrementalEncoder.__sizeof__" => "Size of object in memory, in bytes.",
    "_multibytecodec.MultibyteIncrementalEncoder.__str__" => "Return str(self).",
    "_multibytecodec.MultibyteIncrementalEncoder.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_multibytecodec.MultibyteIncrementalEncoder.errors" => "how to treat errors",
    "_multibytecodec.MultibyteStreamReader.__delattr__" => "Implement delattr(self, name).",
    "_multibytecodec.MultibyteStreamReader.__eq__" => "Return self==value.",
    "_multibytecodec.MultibyteStreamReader.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_multibytecodec.MultibyteStreamReader.__ge__" => "Return self>=value.",
    "_multibytecodec.MultibyteStreamReader.__getattribute__" => "Return getattr(self, name).",
    "_multibytecodec.MultibyteStreamReader.__getstate__" => "Helper for pickle.",
    "_multibytecodec.MultibyteStreamReader.__gt__" => "Return self>value.",
    "_multibytecodec.MultibyteStreamReader.__hash__" => "Return hash(self).",
    "_multibytecodec.MultibyteStreamReader.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_multibytecodec.MultibyteStreamReader.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_multibytecodec.MultibyteStreamReader.__le__" => "Return self<=value.",
    "_multibytecodec.MultibyteStreamReader.__lt__" => "Return self<value.",
    "_multibytecodec.MultibyteStreamReader.__ne__" => "Return self!=value.",
    "_multibytecodec.MultibyteStreamReader.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_multibytecodec.MultibyteStreamReader.__reduce__" => "Helper for pickle.",
    "_multibytecodec.MultibyteStreamReader.__reduce_ex__" => "Helper for pickle.",
    "_multibytecodec.MultibyteStreamReader.__repr__" => "Return repr(self).",
    "_multibytecodec.MultibyteStreamReader.__setattr__" => "Implement setattr(self, name, value).",
    "_multibytecodec.MultibyteStreamReader.__sizeof__" => "Size of object in memory, in bytes.",
    "_multibytecodec.MultibyteStreamReader.__str__" => "Return str(self).",
    "_multibytecodec.MultibyteStreamReader.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_multibytecodec.MultibyteStreamReader.errors" => "how to treat errors",
    "_multibytecodec.MultibyteStreamWriter.__delattr__" => "Implement delattr(self, name).",
    "_multibytecodec.MultibyteStreamWriter.__eq__" => "Return self==value.",
    "_multibytecodec.MultibyteStreamWriter.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_multibytecodec.MultibyteStreamWriter.__ge__" => "Return self>=value.",
    "_multibytecodec.MultibyteStreamWriter.__getattribute__" => "Return getattr(self, name).",
    "_multibytecodec.MultibyteStreamWriter.__getstate__" => "Helper for pickle.",
    "_multibytecodec.MultibyteStreamWriter.__gt__" => "Return self>value.",
    "_multibytecodec.MultibyteStreamWriter.__hash__" => "Return hash(self).",
    "_multibytecodec.MultibyteStreamWriter.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_multibytecodec.MultibyteStreamWriter.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_multibytecodec.MultibyteStreamWriter.__le__" => "Return self<=value.",
    "_multibytecodec.MultibyteStreamWriter.__lt__" => "Return self<value.",
    "_multibytecodec.MultibyteStreamWriter.__ne__" => "Return self!=value.",
    "_multibytecodec.MultibyteStreamWriter.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_multibytecodec.MultibyteStreamWriter.__reduce__" => "Helper for pickle.",
    "_multibytecodec.MultibyteStreamWriter.__reduce_ex__" => "Helper for pickle.",
    "_multibytecodec.MultibyteStreamWriter.__repr__" => "Return repr(self).",
    "_multibytecodec.MultibyteStreamWriter.__setattr__" => "Implement setattr(self, name, value).",
    "_multibytecodec.MultibyteStreamWriter.__sizeof__" => "Size of object in memory, in bytes.",
    "_multibytecodec.MultibyteStreamWriter.__str__" => "Return str(self).",
    "_multibytecodec.MultibyteStreamWriter.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_multibytecodec.MultibyteStreamWriter.errors" => "how to treat errors",
    "_multiprocessing.SemLock" => "Semaphore/Mutex type",
    "_multiprocessing.SemLock.__delattr__" => "Implement delattr(self, name).",
    "_multiprocessing.SemLock.__enter__" => "Enter the semaphore/lock.",
    "_multiprocessing.SemLock.__eq__" => "Return self==value.",
    "_multiprocessing.SemLock.__exit__" => "Exit the semaphore/lock.",
    "_multiprocessing.SemLock.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_multiprocessing.SemLock.__ge__" => "Return self>=value.",
    "_multiprocessing.SemLock.__getattribute__" => "Return getattr(self, name).",
    "_multiprocessing.SemLock.__getstate__" => "Helper for pickle.",
    "_multiprocessing.SemLock.__gt__" => "Return self>value.",
    "_multiprocessing.SemLock.__hash__" => "Return hash(self).",
    "_multiprocessing.SemLock.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_multiprocessing.SemLock.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_multiprocessing.SemLock.__le__" => "Return self<=value.",
    "_multiprocessing.SemLock.__lt__" => "Return self<value.",
    "_multiprocessing.SemLock.__ne__" => "Return self!=value.",
    "_multiprocessing.SemLock.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_multiprocessing.SemLock.__reduce__" => "Helper for pickle.",
    "_multiprocessing.SemLock.__reduce_ex__" => "Helper for pickle.",
    "_multiprocessing.SemLock.__repr__" => "Return repr(self).",
    "_multiprocessing.SemLock.__setattr__" => "Implement setattr(self, name, value).",
    "_multiprocessing.SemLock.__sizeof__" => "Size of object in memory, in bytes.",
    "_multiprocessing.SemLock.__str__" => "Return str(self).",
    "_multiprocessing.SemLock.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_multiprocessing.SemLock._after_fork" => "Rezero the net acquisition count after fork().",
    "_multiprocessing.SemLock._count" => "Num of `acquire()`s minus num of `release()`s for this process.",
    "_multiprocessing.SemLock._get_value" => "Get the value of the semaphore.",
    "_multiprocessing.SemLock._is_mine" => "Whether the lock is owned by this thread.",
    "_multiprocessing.SemLock._is_zero" => "Return whether semaphore has value zero.",
    "_multiprocessing.SemLock.acquire" => "Acquire the semaphore/lock.",
    "_multiprocessing.SemLock.handle" => "",
    "_multiprocessing.SemLock.kind" => "",
    "_multiprocessing.SemLock.maxvalue" => "",
    "_multiprocessing.SemLock.name" => "",
    "_multiprocessing.SemLock.release" => "Release the semaphore/lock.",
    "_opcode" => "Opcode support module.",
    "_opcode.get_executor" => "Return the executor object at offset in code if exists, None otherwise.",
    "_opcode.get_intrinsic1_descs" => "Return a list of names of the unary intrinsics.",
    "_opcode.get_intrinsic2_descs" => "Return a list of names of the binary intrinsics.",
    "_opcode.get_nb_ops" => "Return array of symbols of binary ops.\n\nIndexed by the BINARY_OP oparg value.",
    "_opcode.get_specialization_stats" => "Return the specialization stats",
    "_opcode.has_arg" => "Return True if the opcode uses its oparg, False otherwise.",
    "_opcode.has_const" => "Return True if the opcode accesses a constant, False otherwise.",
    "_opcode.has_exc" => "Return True if the opcode sets an exception handler, False otherwise.",
    "_opcode.has_free" => "Return True if the opcode accesses a free variable, False otherwise.\n\nNote that 'free' in this context refers to names in the current scope\nthat are referenced by inner scopes or names in outer scopes that are\nreferenced from this scope. It does not include references to global\nor builtin scopes.",
    "_opcode.has_jump" => "Return True if the opcode has a jump target, False otherwise.",
    "_opcode.has_local" => "Return True if the opcode accesses a local variable, False otherwise.",
    "_opcode.has_name" => "Return True if the opcode accesses an attribute by name, False otherwise.",
    "_opcode.is_valid" => "Return True if opcode is valid, False otherwise.",
    "_opcode.stack_effect" => "Compute the stack effect of the opcode.",
    "_operator" => "Operator interface.\n\nThis module exports a set of functions implemented in C corresponding\nto the intrinsic operators of Python.  For example, operator.add(x, y)\nis equivalent to the expression x+y.  The function names are those\nused for special methods; variants without leading and trailing\n'__' are also provided for convenience.",
    "_operator._compare_digest" => "Return 'a == b'.\n\nThis function uses an approach designed to prevent\ntiming analysis, making it appropriate for cryptography.\n\na and b must both be of the same type: either str (ASCII only),\nor any bytes-like object.\n\nNote: If a and b are of different lengths, or if an error occurs,\na timing attack could theoretically reveal information about the\ntypes and lengths of a and b--but not their values.",
    "_operator.abs" => "Same as abs(a).",
    "_operator.add" => "Same as a + b.",
    "_operator.and_" => "Same as a & b.",
    "_operator.call" => "Same as obj(*args, **kwargs).",
    "_operator.concat" => "Same as a + b, for a and b sequences.",
    "_operator.contains" => "Same as b in a (note reversed operands).",
    "_operator.countOf" => "Return the number of items in a which are, or which equal, b.",
    "_operator.delitem" => "Same as del a[b].",
    "_operator.eq" => "Same as a == b.",
    "_operator.floordiv" => "Same as a // b.",
    "_operator.ge" => "Same as a >= b.",
    "_operator.getitem" => "Same as a[b].",
    "_operator.gt" => "Same as a > b.",
    "_operator.iadd" => "Same as a += b.",
    "_operator.iand" => "Same as a &= b.",
    "_operator.iconcat" => "Same as a += b, for a and b sequences.",
    "_operator.ifloordiv" => "Same as a //= b.",
    "_operator.ilshift" => "Same as a <<= b.",
    "_operator.imatmul" => "Same as a @= b.",
    "_operator.imod" => "Same as a %= b.",
    "_operator.imul" => "Same as a *= b.",
    "_operator.index" => "Same as a.__index__()",
    "_operator.indexOf" => "Return the first index of b in a.",
    "_operator.inv" => "Same as ~a.",
    "_operator.invert" => "Same as ~a.",
    "_operator.ior" => "Same as a |= b.",
    "_operator.ipow" => "Same as a **= b.",
    "_operator.irshift" => "Same as a >>= b.",
    "_operator.is_" => "Same as a is b.",
    "_operator.is_not" => "Same as a is not b.",
    "_operator.isub" => "Same as a -= b.",
    "_operator.itruediv" => "Same as a /= b.",
    "_operator.ixor" => "Same as a ^= b.",
    "_operator.le" => "Same as a <= b.",
    "_operator.length_hint" => "Return an estimate of the number of items in obj.\n\nThis is useful for presizing containers when building from an iterable.\n\nIf the object supports len(), the result will be exact.\nOtherwise, it may over- or under-estimate by an arbitrary amount.\nThe result will be an integer >= 0.",
    "_operator.lshift" => "Same as a << b.",
    "_operator.lt" => "Same as a < b.",
    "_operator.matmul" => "Same as a @ b.",
    "_operator.mod" => "Same as a % b.",
    "_operator.mul" => "Same as a * b.",
    "_operator.ne" => "Same as a != b.",
    "_operator.neg" => "Same as -a.",
    "_operator.not_" => "Same as not a.",
    "_operator.or_" => "Same as a | b.",
    "_operator.pos" => "Same as +a.",
    "_operator.pow" => "Same as a ** b.",
    "_operator.rshift" => "Same as a >> b.",
    "_operator.setitem" => "Same as a[b] = c.",
    "_operator.sub" => "Same as a - b.",
    "_operator.truediv" => "Same as a / b.",
    "_operator.truth" => "Return True if a is true, False otherwise.",
    "_operator.xor" => "Same as a ^ b.",
    "_overlapped.BindLocal" => "Bind a socket handle to an arbitrary local port.\n\nfamily should be AF_INET or AF_INET6.",
    "_overlapped.ConnectPipe" => "Connect to the pipe for asynchronous I/O (overlapped).",
    "_overlapped.CreateEvent" => "Create an event.\n\nEventAttributes must be None.",
    "_overlapped.CreateIoCompletionPort" => "Create a completion port or register a handle with a port.",
    "_overlapped.FormatMessage" => "Return error message for an error code.",
    "_overlapped.GetQueuedCompletionStatus" => "Get a message from completion port.\n\nWait for up to msecs milliseconds.",
    "_overlapped.Overlapped" => "OVERLAPPED structure wrapper.",
    "_overlapped.Overlapped.AcceptEx" => "Start overlapped wait for client to connect.",
    "_overlapped.Overlapped.ConnectEx" => "Start overlapped connect.\n\nclient_handle should be unbound.",
    "_overlapped.Overlapped.ConnectNamedPipe" => "Start overlapped wait for a client to connect.",
    "_overlapped.Overlapped.ReadFile" => "Start overlapped read.",
    "_overlapped.Overlapped.ReadFileInto" => "Start overlapped receive.",
    "_overlapped.Overlapped.TransmitFile" => "Transmit file data over a connected socket.",
    "_overlapped.Overlapped.WSARecv" => "Start overlapped receive.",
    "_overlapped.Overlapped.WSARecvFrom" => "Start overlapped receive.",
    "_overlapped.Overlapped.WSARecvFromInto" => "Start overlapped receive.",
    "_overlapped.Overlapped.WSARecvInto" => "Start overlapped receive.",
    "_overlapped.Overlapped.WSASend" => "Start overlapped send.",
    "_overlapped.Overlapped.WSASendTo" => "Start overlapped sendto over a connectionless (UDP) socket.",
    "_overlapped.Overlapped.WriteFile" => "Start overlapped write.",
    "_overlapped.Overlapped.__delattr__" => "Implement delattr(self, name).",
    "_overlapped.Overlapped.__eq__" => "Return self==value.",
    "_overlapped.Overlapped.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_overlapped.Overlapped.__ge__" => "Return self>=value.",
    "_overlapped.Overlapped.__getattribute__" => "Return getattr(self, name).",
    "_overlapped.Overlapped.__getstate__" => "Helper for pickle.",
    "_overlapped.Overlapped.__gt__" => "Return self>value.",
    "_overlapped.Overlapped.__hash__" => "Return hash(self).",
    "_overlapped.Overlapped.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_overlapped.Overlapped.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_overlapped.Overlapped.__le__" => "Return self<=value.",
    "_overlapped.Overlapped.__lt__" => "Return self<value.",
    "_overlapped.Overlapped.__ne__" => "Return self!=value.",
    "_overlapped.Overlapped.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_overlapped.Overlapped.__reduce__" => "Helper for pickle.",
    "_overlapped.Overlapped.__reduce_ex__" => "Helper for pickle.",
    "_overlapped.Overlapped.__repr__" => "Return repr(self).",
    "_overlapped.Overlapped.__setattr__" => "Implement setattr(self, name, value).",
    "_overlapped.Overlapped.__sizeof__" => "Size of object in memory, in bytes.",
    "_overlapped.Overlapped.__str__" => "Return str(self).",
    "_overlapped.Overlapped.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_overlapped.Overlapped.address" => "Address of overlapped structure",
    "_overlapped.Overlapped.cancel" => "Cancel overlapped operation.",
    "_overlapped.Overlapped.error" => "Error from last operation",
    "_overlapped.Overlapped.event" => "Overlapped event handle",
    "_overlapped.Overlapped.getresult" => "Retrieve result of operation.\n\nIf wait is true then it blocks until the operation is finished.  If wait\nis false and the operation is still pending then an error is raised.",
    "_overlapped.Overlapped.pending" => "Whether the operation is pending",
    "_overlapped.PostQueuedCompletionStatus" => "Post a message to completion port.",
    "_overlapped.RegisterWaitWithQueue" => "Register wait for Object; when complete CompletionPort is notified.",
    "_overlapped.ResetEvent" => "Reset event.",
    "_overlapped.SetEvent" => "Set event.",
    "_overlapped.UnregisterWait" => "Unregister wait handle.",
    "_overlapped.UnregisterWaitEx" => "Unregister wait handle.",
    "_overlapped.WSAConnect" => "Bind a remote address to a connectionless (UDP) socket.",
    "_pickle" => "Optimized C implementation for the Python pickle module.",
    "_pickle.PickleError.__cause__" => "exception cause",
    "_pickle.PickleError.__context__" => "exception context",
    "_pickle.PickleError.__delattr__" => "Implement delattr(self, name).",
    "_pickle.PickleError.__eq__" => "Return self==value.",
    "_pickle.PickleError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_pickle.PickleError.__ge__" => "Return self>=value.",
    "_pickle.PickleError.__getattribute__" => "Return getattr(self, name).",
    "_pickle.PickleError.__getstate__" => "Helper for pickle.",
    "_pickle.PickleError.__gt__" => "Return self>value.",
    "_pickle.PickleError.__hash__" => "Return hash(self).",
    "_pickle.PickleError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_pickle.PickleError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_pickle.PickleError.__le__" => "Return self<=value.",
    "_pickle.PickleError.__lt__" => "Return self<value.",
    "_pickle.PickleError.__ne__" => "Return self!=value.",
    "_pickle.PickleError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_pickle.PickleError.__reduce_ex__" => "Helper for pickle.",
    "_pickle.PickleError.__repr__" => "Return repr(self).",
    "_pickle.PickleError.__setattr__" => "Implement setattr(self, name, value).",
    "_pickle.PickleError.__sizeof__" => "Size of object in memory, in bytes.",
    "_pickle.PickleError.__str__" => "Return str(self).",
    "_pickle.PickleError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_pickle.PickleError.__weakref__" => "list of weak references to the object",
    "_pickle.PickleError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_pickle.PickleError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_pickle.Pickler" => "This takes a binary file for writing a pickle data stream.\n\nThe optional *protocol* argument tells the pickler to use the given\nprotocol; supported protocols are 0, 1, 2, 3, 4 and 5.  The default\nprotocol is 4. It was introduced in Python 3.4, and is incompatible\nwith previous versions.\n\nSpecifying a negative protocol version selects the highest protocol\nversion supported.  The higher the protocol used, the more recent the\nversion of Python needed to read the pickle produced.\n\nThe *file* argument must have a write() method that accepts a single\nbytes argument. It can thus be a file object opened for binary\nwriting, an io.BytesIO instance, or any other custom object that meets\nthis interface.\n\nIf *fix_imports* is True and protocol is less than 3, pickle will try\nto map the new Python 3 names to the old module names used in Python\n2, so that the pickle data stream is readable with Python 2.\n\nIf *buffer_callback* is None (the default), buffer views are\nserialized into *file* as part of the pickle stream.\n\nIf *buffer_callback* is not None, then it can be called any number\nof times with a buffer view.  If the callback returns a false value\n(such as None), the given buffer is out-of-band; otherwise the\nbuffer is serialized in-band, i.e. inside the pickle stream.\n\nIt is an error if *buffer_callback* is not None and *protocol*\nis None or smaller than 5.",
    "_pickle.Pickler.__delattr__" => "Implement delattr(self, name).",
    "_pickle.Pickler.__eq__" => "Return self==value.",
    "_pickle.Pickler.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_pickle.Pickler.__ge__" => "Return self>=value.",
    "_pickle.Pickler.__getattribute__" => "Return getattr(self, name).",
    "_pickle.Pickler.__getstate__" => "Helper for pickle.",
    "_pickle.Pickler.__gt__" => "Return self>value.",
    "_pickle.Pickler.__hash__" => "Return hash(self).",
    "_pickle.Pickler.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_pickle.Pickler.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_pickle.Pickler.__le__" => "Return self<=value.",
    "_pickle.Pickler.__lt__" => "Return self<value.",
    "_pickle.Pickler.__ne__" => "Return self!=value.",
    "_pickle.Pickler.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_pickle.Pickler.__reduce__" => "Helper for pickle.",
    "_pickle.Pickler.__reduce_ex__" => "Helper for pickle.",
    "_pickle.Pickler.__repr__" => "Return repr(self).",
    "_pickle.Pickler.__setattr__" => "Implement setattr(self, name, value).",
    "_pickle.Pickler.__sizeof__" => "Returns size in memory, in bytes.",
    "_pickle.Pickler.__str__" => "Return str(self).",
    "_pickle.Pickler.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_pickle.Pickler.clear_memo" => "Clears the pickler's \"memo\".\n\nThe memo is the data structure that remembers which objects the\npickler has already seen, so that shared or recursive objects are\npickled by reference and not by value.  This method is useful when\nre-using picklers.",
    "_pickle.Pickler.dump" => "Write a pickled representation of the given object to the open file.",
    "_pickle.PicklingError.__cause__" => "exception cause",
    "_pickle.PicklingError.__context__" => "exception context",
    "_pickle.PicklingError.__delattr__" => "Implement delattr(self, name).",
    "_pickle.PicklingError.__eq__" => "Return self==value.",
    "_pickle.PicklingError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_pickle.PicklingError.__ge__" => "Return self>=value.",
    "_pickle.PicklingError.__getattribute__" => "Return getattr(self, name).",
    "_pickle.PicklingError.__getstate__" => "Helper for pickle.",
    "_pickle.PicklingError.__gt__" => "Return self>value.",
    "_pickle.PicklingError.__hash__" => "Return hash(self).",
    "_pickle.PicklingError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_pickle.PicklingError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_pickle.PicklingError.__le__" => "Return self<=value.",
    "_pickle.PicklingError.__lt__" => "Return self<value.",
    "_pickle.PicklingError.__ne__" => "Return self!=value.",
    "_pickle.PicklingError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_pickle.PicklingError.__reduce_ex__" => "Helper for pickle.",
    "_pickle.PicklingError.__repr__" => "Return repr(self).",
    "_pickle.PicklingError.__setattr__" => "Implement setattr(self, name, value).",
    "_pickle.PicklingError.__sizeof__" => "Size of object in memory, in bytes.",
    "_pickle.PicklingError.__str__" => "Return str(self).",
    "_pickle.PicklingError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_pickle.PicklingError.__weakref__" => "list of weak references to the object",
    "_pickle.PicklingError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_pickle.PicklingError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_pickle.Unpickler" => "This takes a binary file for reading a pickle data stream.\n\nThe protocol version of the pickle is detected automatically, so no\nprotocol argument is needed.  Bytes past the pickled object's\nrepresentation are ignored.\n\nThe argument *file* must have two methods, a read() method that takes\nan integer argument, and a readline() method that requires no\narguments.  Both methods should return bytes.  Thus *file* can be a\nbinary file object opened for reading, an io.BytesIO object, or any\nother custom object that meets this interface.\n\nOptional keyword arguments are *fix_imports*, *encoding* and *errors*,\nwhich are used to control compatibility support for pickle stream\ngenerated by Python 2.  If *fix_imports* is True, pickle will try to\nmap the old Python 2 names to the new names used in Python 3.  The\n*encoding* and *errors* tell pickle how to decode 8-bit string\ninstances pickled by Python 2; these default to 'ASCII' and 'strict',\nrespectively.  The *encoding* can be 'bytes' to read these 8-bit\nstring instances as bytes objects.",
    "_pickle.Unpickler.__delattr__" => "Implement delattr(self, name).",
    "_pickle.Unpickler.__eq__" => "Return self==value.",
    "_pickle.Unpickler.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_pickle.Unpickler.__ge__" => "Return self>=value.",
    "_pickle.Unpickler.__getattribute__" => "Return getattr(self, name).",
    "_pickle.Unpickler.__getstate__" => "Helper for pickle.",
    "_pickle.Unpickler.__gt__" => "Return self>value.",
    "_pickle.Unpickler.__hash__" => "Return hash(self).",
    "_pickle.Unpickler.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_pickle.Unpickler.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_pickle.Unpickler.__le__" => "Return self<=value.",
    "_pickle.Unpickler.__lt__" => "Return self<value.",
    "_pickle.Unpickler.__ne__" => "Return self!=value.",
    "_pickle.Unpickler.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_pickle.Unpickler.__reduce__" => "Helper for pickle.",
    "_pickle.Unpickler.__reduce_ex__" => "Helper for pickle.",
    "_pickle.Unpickler.__repr__" => "Return repr(self).",
    "_pickle.Unpickler.__setattr__" => "Implement setattr(self, name, value).",
    "_pickle.Unpickler.__sizeof__" => "Returns size in memory, in bytes.",
    "_pickle.Unpickler.__str__" => "Return str(self).",
    "_pickle.Unpickler.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_pickle.Unpickler.find_class" => "Return an object from a specified module.\n\nIf necessary, the module will be imported. Subclasses may override\nthis method (e.g. to restrict unpickling of arbitrary classes and\nfunctions).\n\nThis method is called whenever a class or a function object is\nneeded.  Both arguments passed are str objects.",
    "_pickle.Unpickler.load" => "Load a pickle.\n\nRead a pickled object representation from the open file object given\nin the constructor, and return the reconstituted object hierarchy\nspecified therein.",
    "_pickle.UnpicklingError.__cause__" => "exception cause",
    "_pickle.UnpicklingError.__context__" => "exception context",
    "_pickle.UnpicklingError.__delattr__" => "Implement delattr(self, name).",
    "_pickle.UnpicklingError.__eq__" => "Return self==value.",
    "_pickle.UnpicklingError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_pickle.UnpicklingError.__ge__" => "Return self>=value.",
    "_pickle.UnpicklingError.__getattribute__" => "Return getattr(self, name).",
    "_pickle.UnpicklingError.__getstate__" => "Helper for pickle.",
    "_pickle.UnpicklingError.__gt__" => "Return self>value.",
    "_pickle.UnpicklingError.__hash__" => "Return hash(self).",
    "_pickle.UnpicklingError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_pickle.UnpicklingError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_pickle.UnpicklingError.__le__" => "Return self<=value.",
    "_pickle.UnpicklingError.__lt__" => "Return self<value.",
    "_pickle.UnpicklingError.__ne__" => "Return self!=value.",
    "_pickle.UnpicklingError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_pickle.UnpicklingError.__reduce_ex__" => "Helper for pickle.",
    "_pickle.UnpicklingError.__repr__" => "Return repr(self).",
    "_pickle.UnpicklingError.__setattr__" => "Implement setattr(self, name, value).",
    "_pickle.UnpicklingError.__sizeof__" => "Size of object in memory, in bytes.",
    "_pickle.UnpicklingError.__str__" => "Return str(self).",
    "_pickle.UnpicklingError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_pickle.UnpicklingError.__weakref__" => "list of weak references to the object",
    "_pickle.UnpicklingError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_pickle.UnpicklingError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_pickle.dump" => "Write a pickled representation of obj to the open file object file.\n\nThis is equivalent to ``Pickler(file, protocol).dump(obj)``, but may\nbe more efficient.\n\nThe optional *protocol* argument tells the pickler to use the given\nprotocol; supported protocols are 0, 1, 2, 3, 4 and 5.  The default\nprotocol is 4. It was introduced in Python 3.4, and is incompatible\nwith previous versions.\n\nSpecifying a negative protocol version selects the highest protocol\nversion supported.  The higher the protocol used, the more recent the\nversion of Python needed to read the pickle produced.\n\nThe *file* argument must have a write() method that accepts a single\nbytes argument.  It can thus be a file object opened for binary\nwriting, an io.BytesIO instance, or any other custom object that meets\nthis interface.\n\nIf *fix_imports* is True and protocol is less than 3, pickle will try\nto map the new Python 3 names to the old module names used in Python\n2, so that the pickle data stream is readable with Python 2.\n\nIf *buffer_callback* is None (the default), buffer views are serialized\ninto *file* as part of the pickle stream.  It is an error if\n*buffer_callback* is not None and *protocol* is None or smaller than 5.",
    "_pickle.dumps" => "Return the pickled representation of the object as a bytes object.\n\nThe optional *protocol* argument tells the pickler to use the given\nprotocol; supported protocols are 0, 1, 2, 3, 4 and 5.  The default\nprotocol is 4. It was introduced in Python 3.4, and is incompatible\nwith previous versions.\n\nSpecifying a negative protocol version selects the highest protocol\nversion supported.  The higher the protocol used, the more recent the\nversion of Python needed to read the pickle produced.\n\nIf *fix_imports* is True and *protocol* is less than 3, pickle will\ntry to map the new Python 3 names to the old module names used in\nPython 2, so that the pickle data stream is readable with Python 2.\n\nIf *buffer_callback* is None (the default), buffer views are serialized\ninto *file* as part of the pickle stream.  It is an error if\n*buffer_callback* is not None and *protocol* is None or smaller than 5.",
    "_pickle.load" => "Read and return an object from the pickle data stored in a file.\n\nThis is equivalent to ``Unpickler(file).load()``, but may be more\nefficient.\n\nThe protocol version of the pickle is detected automatically, so no\nprotocol argument is needed.  Bytes past the pickled object's\nrepresentation are ignored.\n\nThe argument *file* must have two methods, a read() method that takes\nan integer argument, and a readline() method that requires no\narguments.  Both methods should return bytes.  Thus *file* can be a\nbinary file object opened for reading, an io.BytesIO object, or any\nother custom object that meets this interface.\n\nOptional keyword arguments are *fix_imports*, *encoding* and *errors*,\nwhich are used to control compatibility support for pickle stream\ngenerated by Python 2.  If *fix_imports* is True, pickle will try to\nmap the old Python 2 names to the new names used in Python 3.  The\n*encoding* and *errors* tell pickle how to decode 8-bit string\ninstances pickled by Python 2; these default to 'ASCII' and 'strict',\nrespectively.  The *encoding* can be 'bytes' to read these 8-bit\nstring instances as bytes objects.",
    "_pickle.loads" => "Read and return an object from the given pickle data.\n\nThe protocol version of the pickle is detected automatically, so no\nprotocol argument is needed.  Bytes past the pickled object's\nrepresentation are ignored.\n\nOptional keyword arguments are *fix_imports*, *encoding* and *errors*,\nwhich are used to control compatibility support for pickle stream\ngenerated by Python 2.  If *fix_imports* is True, pickle will try to\nmap the old Python 2 names to the new names used in Python 3.  The\n*encoding* and *errors* tell pickle how to decode 8-bit string\ninstances pickled by Python 2; these default to 'ASCII' and 'strict',\nrespectively.  The *encoding* can be 'bytes' to read these 8-bit\nstring instances as bytes objects.",
    "_queue" => "C implementation of the Python queue module.\nThis module is an implementation detail, please do not use it directly.",
    "_queue.Empty" => "Exception raised by Queue.get(block=0)/get_nowait().",
    "_queue.Empty.__cause__" => "exception cause",
    "_queue.Empty.__context__" => "exception context",
    "_queue.Empty.__delattr__" => "Implement delattr(self, name).",
    "_queue.Empty.__eq__" => "Return self==value.",
    "_queue.Empty.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_queue.Empty.__ge__" => "Return self>=value.",
    "_queue.Empty.__getattribute__" => "Return getattr(self, name).",
    "_queue.Empty.__getstate__" => "Helper for pickle.",
    "_queue.Empty.__gt__" => "Return self>value.",
    "_queue.Empty.__hash__" => "Return hash(self).",
    "_queue.Empty.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_queue.Empty.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_queue.Empty.__le__" => "Return self<=value.",
    "_queue.Empty.__lt__" => "Return self<value.",
    "_queue.Empty.__ne__" => "Return self!=value.",
    "_queue.Empty.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_queue.Empty.__reduce_ex__" => "Helper for pickle.",
    "_queue.Empty.__repr__" => "Return repr(self).",
    "_queue.Empty.__setattr__" => "Implement setattr(self, name, value).",
    "_queue.Empty.__sizeof__" => "Size of object in memory, in bytes.",
    "_queue.Empty.__str__" => "Return str(self).",
    "_queue.Empty.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_queue.Empty.__weakref__" => "list of weak references to the object",
    "_queue.Empty.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_queue.Empty.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_queue.SimpleQueue" => "Simple, unbounded, reentrant FIFO queue.",
    "_queue.SimpleQueue.__class_getitem__" => "See PEP 585",
    "_queue.SimpleQueue.__delattr__" => "Implement delattr(self, name).",
    "_queue.SimpleQueue.__eq__" => "Return self==value.",
    "_queue.SimpleQueue.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_queue.SimpleQueue.__ge__" => "Return self>=value.",
    "_queue.SimpleQueue.__getattribute__" => "Return getattr(self, name).",
    "_queue.SimpleQueue.__getstate__" => "Helper for pickle.",
    "_queue.SimpleQueue.__gt__" => "Return self>value.",
    "_queue.SimpleQueue.__hash__" => "Return hash(self).",
    "_queue.SimpleQueue.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_queue.SimpleQueue.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_queue.SimpleQueue.__le__" => "Return self<=value.",
    "_queue.SimpleQueue.__lt__" => "Return self<value.",
    "_queue.SimpleQueue.__ne__" => "Return self!=value.",
    "_queue.SimpleQueue.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_queue.SimpleQueue.__reduce__" => "Helper for pickle.",
    "_queue.SimpleQueue.__reduce_ex__" => "Helper for pickle.",
    "_queue.SimpleQueue.__repr__" => "Return repr(self).",
    "_queue.SimpleQueue.__setattr__" => "Implement setattr(self, name, value).",
    "_queue.SimpleQueue.__sizeof__" => "Size of object in memory, in bytes.",
    "_queue.SimpleQueue.__str__" => "Return str(self).",
    "_queue.SimpleQueue.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_queue.SimpleQueue.empty" => "Return True if the queue is empty, False otherwise (not reliable!).",
    "_queue.SimpleQueue.get" => "Remove and return an item from the queue.\n\nIf optional args 'block' is true and 'timeout' is None (the default),\nblock if necessary until an item is available. If 'timeout' is\na non-negative number, it blocks at most 'timeout' seconds and raises\nthe Empty exception if no item was available within that time.\nOtherwise ('block' is false), return an item if one is immediately\navailable, else raise the Empty exception ('timeout' is ignored\nin that case).",
    "_queue.SimpleQueue.get_nowait" => "Remove and return an item from the queue without blocking.\n\nOnly get an item if one is immediately available. Otherwise\nraise the Empty exception.",
    "_queue.SimpleQueue.put" => "Put the item on the queue.\n\nThe optional 'block' and 'timeout' arguments are ignored, as this method\nnever blocks.  They are provided for compatibility with the Queue class.",
    "_queue.SimpleQueue.put_nowait" => "Put an item into the queue without blocking.\n\nThis is exactly equivalent to `put(item)` and is only provided\nfor compatibility with the Queue class.",
    "_queue.SimpleQueue.qsize" => "Return the approximate size of the queue (not reliable!).",
    "_random" => "Module implements the Mersenne Twister random number generator.",
    "_random.Random" => "Random() -> create a random number generator with its own internal state.",
    "_random.Random.__delattr__" => "Implement delattr(self, name).",
    "_random.Random.__eq__" => "Return self==value.",
    "_random.Random.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_random.Random.__ge__" => "Return self>=value.",
    "_random.Random.__getattribute__" => "Return getattr(self, name).",
    "_random.Random.__getstate__" => "Helper for pickle.",
    "_random.Random.__gt__" => "Return self>value.",
    "_random.Random.__hash__" => "Return hash(self).",
    "_random.Random.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_random.Random.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_random.Random.__le__" => "Return self<=value.",
    "_random.Random.__lt__" => "Return self<value.",
    "_random.Random.__ne__" => "Return self!=value.",
    "_random.Random.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_random.Random.__reduce__" => "Helper for pickle.",
    "_random.Random.__reduce_ex__" => "Helper for pickle.",
    "_random.Random.__repr__" => "Return repr(self).",
    "_random.Random.__setattr__" => "Implement setattr(self, name, value).",
    "_random.Random.__sizeof__" => "Size of object in memory, in bytes.",
    "_random.Random.__str__" => "Return str(self).",
    "_random.Random.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_random.Random.getrandbits" => "getrandbits(k) -> x.  Generates an int with k random bits.",
    "_random.Random.getstate" => "getstate() -> tuple containing the current state.",
    "_random.Random.random" => "random() -> x in the interval [0, 1).",
    "_random.Random.seed" => "seed([n]) -> None.\n\nDefaults to use urandom and falls back to a combination\nof the current time and the process identifier.",
    "_random.Random.setstate" => "setstate(state) -> None.  Restores generator state.",
    "_sha1.SHA1Type.__delattr__" => "Implement delattr(self, name).",
    "_sha1.SHA1Type.__eq__" => "Return self==value.",
    "_sha1.SHA1Type.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha1.SHA1Type.__ge__" => "Return self>=value.",
    "_sha1.SHA1Type.__getattribute__" => "Return getattr(self, name).",
    "_sha1.SHA1Type.__getstate__" => "Helper for pickle.",
    "_sha1.SHA1Type.__gt__" => "Return self>value.",
    "_sha1.SHA1Type.__hash__" => "Return hash(self).",
    "_sha1.SHA1Type.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha1.SHA1Type.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha1.SHA1Type.__le__" => "Return self<=value.",
    "_sha1.SHA1Type.__lt__" => "Return self<value.",
    "_sha1.SHA1Type.__ne__" => "Return self!=value.",
    "_sha1.SHA1Type.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha1.SHA1Type.__reduce__" => "Helper for pickle.",
    "_sha1.SHA1Type.__reduce_ex__" => "Helper for pickle.",
    "_sha1.SHA1Type.__repr__" => "Return repr(self).",
    "_sha1.SHA1Type.__setattr__" => "Implement setattr(self, name, value).",
    "_sha1.SHA1Type.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha1.SHA1Type.__str__" => "Return str(self).",
    "_sha1.SHA1Type.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha1.SHA1Type.copy" => "Return a copy of the hash object.",
    "_sha1.SHA1Type.digest" => "Return the digest value as a bytes object.",
    "_sha1.SHA1Type.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha1.SHA1Type.update" => "Update this hash object's state with the provided string.",
    "_sha1.sha1" => "Return a new SHA1 hash object; optionally initialized with a string.",
    "_sha2.SHA224Type.__delattr__" => "Implement delattr(self, name).",
    "_sha2.SHA224Type.__eq__" => "Return self==value.",
    "_sha2.SHA224Type.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha2.SHA224Type.__ge__" => "Return self>=value.",
    "_sha2.SHA224Type.__getattribute__" => "Return getattr(self, name).",
    "_sha2.SHA224Type.__getstate__" => "Helper for pickle.",
    "_sha2.SHA224Type.__gt__" => "Return self>value.",
    "_sha2.SHA224Type.__hash__" => "Return hash(self).",
    "_sha2.SHA224Type.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha2.SHA224Type.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha2.SHA224Type.__le__" => "Return self<=value.",
    "_sha2.SHA224Type.__lt__" => "Return self<value.",
    "_sha2.SHA224Type.__ne__" => "Return self!=value.",
    "_sha2.SHA224Type.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha2.SHA224Type.__reduce__" => "Helper for pickle.",
    "_sha2.SHA224Type.__reduce_ex__" => "Helper for pickle.",
    "_sha2.SHA224Type.__repr__" => "Return repr(self).",
    "_sha2.SHA224Type.__setattr__" => "Implement setattr(self, name, value).",
    "_sha2.SHA224Type.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha2.SHA224Type.__str__" => "Return str(self).",
    "_sha2.SHA224Type.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha2.SHA224Type.copy" => "Return a copy of the hash object.",
    "_sha2.SHA224Type.digest" => "Return the digest value as a bytes object.",
    "_sha2.SHA224Type.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha2.SHA224Type.update" => "Update this hash object's state with the provided string.",
    "_sha2.SHA256Type.__delattr__" => "Implement delattr(self, name).",
    "_sha2.SHA256Type.__eq__" => "Return self==value.",
    "_sha2.SHA256Type.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha2.SHA256Type.__ge__" => "Return self>=value.",
    "_sha2.SHA256Type.__getattribute__" => "Return getattr(self, name).",
    "_sha2.SHA256Type.__getstate__" => "Helper for pickle.",
    "_sha2.SHA256Type.__gt__" => "Return self>value.",
    "_sha2.SHA256Type.__hash__" => "Return hash(self).",
    "_sha2.SHA256Type.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha2.SHA256Type.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha2.SHA256Type.__le__" => "Return self<=value.",
    "_sha2.SHA256Type.__lt__" => "Return self<value.",
    "_sha2.SHA256Type.__ne__" => "Return self!=value.",
    "_sha2.SHA256Type.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha2.SHA256Type.__reduce__" => "Helper for pickle.",
    "_sha2.SHA256Type.__reduce_ex__" => "Helper for pickle.",
    "_sha2.SHA256Type.__repr__" => "Return repr(self).",
    "_sha2.SHA256Type.__setattr__" => "Implement setattr(self, name, value).",
    "_sha2.SHA256Type.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha2.SHA256Type.__str__" => "Return str(self).",
    "_sha2.SHA256Type.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha2.SHA256Type.copy" => "Return a copy of the hash object.",
    "_sha2.SHA256Type.digest" => "Return the digest value as a bytes object.",
    "_sha2.SHA256Type.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha2.SHA256Type.update" => "Update this hash object's state with the provided string.",
    "_sha2.SHA384Type.__delattr__" => "Implement delattr(self, name).",
    "_sha2.SHA384Type.__eq__" => "Return self==value.",
    "_sha2.SHA384Type.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha2.SHA384Type.__ge__" => "Return self>=value.",
    "_sha2.SHA384Type.__getattribute__" => "Return getattr(self, name).",
    "_sha2.SHA384Type.__getstate__" => "Helper for pickle.",
    "_sha2.SHA384Type.__gt__" => "Return self>value.",
    "_sha2.SHA384Type.__hash__" => "Return hash(self).",
    "_sha2.SHA384Type.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha2.SHA384Type.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha2.SHA384Type.__le__" => "Return self<=value.",
    "_sha2.SHA384Type.__lt__" => "Return self<value.",
    "_sha2.SHA384Type.__ne__" => "Return self!=value.",
    "_sha2.SHA384Type.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha2.SHA384Type.__reduce__" => "Helper for pickle.",
    "_sha2.SHA384Type.__reduce_ex__" => "Helper for pickle.",
    "_sha2.SHA384Type.__repr__" => "Return repr(self).",
    "_sha2.SHA384Type.__setattr__" => "Implement setattr(self, name, value).",
    "_sha2.SHA384Type.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha2.SHA384Type.__str__" => "Return str(self).",
    "_sha2.SHA384Type.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha2.SHA384Type.copy" => "Return a copy of the hash object.",
    "_sha2.SHA384Type.digest" => "Return the digest value as a bytes object.",
    "_sha2.SHA384Type.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha2.SHA384Type.update" => "Update this hash object's state with the provided string.",
    "_sha2.SHA512Type.__delattr__" => "Implement delattr(self, name).",
    "_sha2.SHA512Type.__eq__" => "Return self==value.",
    "_sha2.SHA512Type.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha2.SHA512Type.__ge__" => "Return self>=value.",
    "_sha2.SHA512Type.__getattribute__" => "Return getattr(self, name).",
    "_sha2.SHA512Type.__getstate__" => "Helper for pickle.",
    "_sha2.SHA512Type.__gt__" => "Return self>value.",
    "_sha2.SHA512Type.__hash__" => "Return hash(self).",
    "_sha2.SHA512Type.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha2.SHA512Type.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha2.SHA512Type.__le__" => "Return self<=value.",
    "_sha2.SHA512Type.__lt__" => "Return self<value.",
    "_sha2.SHA512Type.__ne__" => "Return self!=value.",
    "_sha2.SHA512Type.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha2.SHA512Type.__reduce__" => "Helper for pickle.",
    "_sha2.SHA512Type.__reduce_ex__" => "Helper for pickle.",
    "_sha2.SHA512Type.__repr__" => "Return repr(self).",
    "_sha2.SHA512Type.__setattr__" => "Implement setattr(self, name, value).",
    "_sha2.SHA512Type.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha2.SHA512Type.__str__" => "Return str(self).",
    "_sha2.SHA512Type.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha2.SHA512Type.copy" => "Return a copy of the hash object.",
    "_sha2.SHA512Type.digest" => "Return the digest value as a bytes object.",
    "_sha2.SHA512Type.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha2.SHA512Type.update" => "Update this hash object's state with the provided string.",
    "_sha2.sha224" => "Return a new SHA-224 hash object; optionally initialized with a string.",
    "_sha2.sha256" => "Return a new SHA-256 hash object; optionally initialized with a string.",
    "_sha2.sha384" => "Return a new SHA-384 hash object; optionally initialized with a string.",
    "_sha2.sha512" => "Return a new SHA-512 hash object; optionally initialized with a string.",
    "_sha3.sha3_224" => "sha3_224([data], *, usedforsecurity=True) -> SHA3 object\n\nReturn a new SHA3 hash object with a hashbit length of 28 bytes.",
    "_sha3.sha3_224.__delattr__" => "Implement delattr(self, name).",
    "_sha3.sha3_224.__eq__" => "Return self==value.",
    "_sha3.sha3_224.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha3.sha3_224.__ge__" => "Return self>=value.",
    "_sha3.sha3_224.__getattribute__" => "Return getattr(self, name).",
    "_sha3.sha3_224.__getstate__" => "Helper for pickle.",
    "_sha3.sha3_224.__gt__" => "Return self>value.",
    "_sha3.sha3_224.__hash__" => "Return hash(self).",
    "_sha3.sha3_224.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha3.sha3_224.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha3.sha3_224.__le__" => "Return self<=value.",
    "_sha3.sha3_224.__lt__" => "Return self<value.",
    "_sha3.sha3_224.__ne__" => "Return self!=value.",
    "_sha3.sha3_224.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha3.sha3_224.__reduce__" => "Helper for pickle.",
    "_sha3.sha3_224.__reduce_ex__" => "Helper for pickle.",
    "_sha3.sha3_224.__repr__" => "Return repr(self).",
    "_sha3.sha3_224.__setattr__" => "Implement setattr(self, name, value).",
    "_sha3.sha3_224.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha3.sha3_224.__str__" => "Return str(self).",
    "_sha3.sha3_224.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha3.sha3_224.copy" => "Return a copy of the hash object.",
    "_sha3.sha3_224.digest" => "Return the digest value as a bytes object.",
    "_sha3.sha3_224.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha3.sha3_224.update" => "Update this hash object's state with the provided bytes-like object.",
    "_sha3.sha3_256" => "sha3_256([data], *, usedforsecurity=True) -> SHA3 object\n\nReturn a new SHA3 hash object with a hashbit length of 32 bytes.",
    "_sha3.sha3_256.__delattr__" => "Implement delattr(self, name).",
    "_sha3.sha3_256.__eq__" => "Return self==value.",
    "_sha3.sha3_256.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha3.sha3_256.__ge__" => "Return self>=value.",
    "_sha3.sha3_256.__getattribute__" => "Return getattr(self, name).",
    "_sha3.sha3_256.__getstate__" => "Helper for pickle.",
    "_sha3.sha3_256.__gt__" => "Return self>value.",
    "_sha3.sha3_256.__hash__" => "Return hash(self).",
    "_sha3.sha3_256.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha3.sha3_256.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha3.sha3_256.__le__" => "Return self<=value.",
    "_sha3.sha3_256.__lt__" => "Return self<value.",
    "_sha3.sha3_256.__ne__" => "Return self!=value.",
    "_sha3.sha3_256.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha3.sha3_256.__reduce__" => "Helper for pickle.",
    "_sha3.sha3_256.__reduce_ex__" => "Helper for pickle.",
    "_sha3.sha3_256.__repr__" => "Return repr(self).",
    "_sha3.sha3_256.__setattr__" => "Implement setattr(self, name, value).",
    "_sha3.sha3_256.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha3.sha3_256.__str__" => "Return str(self).",
    "_sha3.sha3_256.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha3.sha3_256.copy" => "Return a copy of the hash object.",
    "_sha3.sha3_256.digest" => "Return the digest value as a bytes object.",
    "_sha3.sha3_256.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha3.sha3_256.update" => "Update this hash object's state with the provided bytes-like object.",
    "_sha3.sha3_384" => "sha3_384([data], *, usedforsecurity=True) -> SHA3 object\n\nReturn a new SHA3 hash object with a hashbit length of 48 bytes.",
    "_sha3.sha3_384.__delattr__" => "Implement delattr(self, name).",
    "_sha3.sha3_384.__eq__" => "Return self==value.",
    "_sha3.sha3_384.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha3.sha3_384.__ge__" => "Return self>=value.",
    "_sha3.sha3_384.__getattribute__" => "Return getattr(self, name).",
    "_sha3.sha3_384.__getstate__" => "Helper for pickle.",
    "_sha3.sha3_384.__gt__" => "Return self>value.",
    "_sha3.sha3_384.__hash__" => "Return hash(self).",
    "_sha3.sha3_384.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha3.sha3_384.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha3.sha3_384.__le__" => "Return self<=value.",
    "_sha3.sha3_384.__lt__" => "Return self<value.",
    "_sha3.sha3_384.__ne__" => "Return self!=value.",
    "_sha3.sha3_384.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha3.sha3_384.__reduce__" => "Helper for pickle.",
    "_sha3.sha3_384.__reduce_ex__" => "Helper for pickle.",
    "_sha3.sha3_384.__repr__" => "Return repr(self).",
    "_sha3.sha3_384.__setattr__" => "Implement setattr(self, name, value).",
    "_sha3.sha3_384.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha3.sha3_384.__str__" => "Return str(self).",
    "_sha3.sha3_384.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha3.sha3_384.copy" => "Return a copy of the hash object.",
    "_sha3.sha3_384.digest" => "Return the digest value as a bytes object.",
    "_sha3.sha3_384.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha3.sha3_384.update" => "Update this hash object's state with the provided bytes-like object.",
    "_sha3.sha3_512" => "sha3_512([data], *, usedforsecurity=True) -> SHA3 object\n\nReturn a new SHA3 hash object with a hashbit length of 64 bytes.",
    "_sha3.sha3_512.__delattr__" => "Implement delattr(self, name).",
    "_sha3.sha3_512.__eq__" => "Return self==value.",
    "_sha3.sha3_512.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha3.sha3_512.__ge__" => "Return self>=value.",
    "_sha3.sha3_512.__getattribute__" => "Return getattr(self, name).",
    "_sha3.sha3_512.__getstate__" => "Helper for pickle.",
    "_sha3.sha3_512.__gt__" => "Return self>value.",
    "_sha3.sha3_512.__hash__" => "Return hash(self).",
    "_sha3.sha3_512.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha3.sha3_512.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha3.sha3_512.__le__" => "Return self<=value.",
    "_sha3.sha3_512.__lt__" => "Return self<value.",
    "_sha3.sha3_512.__ne__" => "Return self!=value.",
    "_sha3.sha3_512.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha3.sha3_512.__reduce__" => "Helper for pickle.",
    "_sha3.sha3_512.__reduce_ex__" => "Helper for pickle.",
    "_sha3.sha3_512.__repr__" => "Return repr(self).",
    "_sha3.sha3_512.__setattr__" => "Implement setattr(self, name, value).",
    "_sha3.sha3_512.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha3.sha3_512.__str__" => "Return str(self).",
    "_sha3.sha3_512.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha3.sha3_512.copy" => "Return a copy of the hash object.",
    "_sha3.sha3_512.digest" => "Return the digest value as a bytes object.",
    "_sha3.sha3_512.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha3.sha3_512.update" => "Update this hash object's state with the provided bytes-like object.",
    "_sha3.shake_128" => "shake_128([data], *, usedforsecurity=True) -> SHAKE object\n\nReturn a new SHAKE hash object.",
    "_sha3.shake_128.__delattr__" => "Implement delattr(self, name).",
    "_sha3.shake_128.__eq__" => "Return self==value.",
    "_sha3.shake_128.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha3.shake_128.__ge__" => "Return self>=value.",
    "_sha3.shake_128.__getattribute__" => "Return getattr(self, name).",
    "_sha3.shake_128.__getstate__" => "Helper for pickle.",
    "_sha3.shake_128.__gt__" => "Return self>value.",
    "_sha3.shake_128.__hash__" => "Return hash(self).",
    "_sha3.shake_128.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha3.shake_128.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha3.shake_128.__le__" => "Return self<=value.",
    "_sha3.shake_128.__lt__" => "Return self<value.",
    "_sha3.shake_128.__ne__" => "Return self!=value.",
    "_sha3.shake_128.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha3.shake_128.__reduce__" => "Helper for pickle.",
    "_sha3.shake_128.__reduce_ex__" => "Helper for pickle.",
    "_sha3.shake_128.__repr__" => "Return repr(self).",
    "_sha3.shake_128.__setattr__" => "Implement setattr(self, name, value).",
    "_sha3.shake_128.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha3.shake_128.__str__" => "Return str(self).",
    "_sha3.shake_128.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha3.shake_128.copy" => "Return a copy of the hash object.",
    "_sha3.shake_128.digest" => "Return the digest value as a bytes object.",
    "_sha3.shake_128.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha3.shake_128.update" => "Update this hash object's state with the provided bytes-like object.",
    "_sha3.shake_256" => "shake_256([data], *, usedforsecurity=True) -> SHAKE object\n\nReturn a new SHAKE hash object.",
    "_sha3.shake_256.__delattr__" => "Implement delattr(self, name).",
    "_sha3.shake_256.__eq__" => "Return self==value.",
    "_sha3.shake_256.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_sha3.shake_256.__ge__" => "Return self>=value.",
    "_sha3.shake_256.__getattribute__" => "Return getattr(self, name).",
    "_sha3.shake_256.__getstate__" => "Helper for pickle.",
    "_sha3.shake_256.__gt__" => "Return self>value.",
    "_sha3.shake_256.__hash__" => "Return hash(self).",
    "_sha3.shake_256.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_sha3.shake_256.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_sha3.shake_256.__le__" => "Return self<=value.",
    "_sha3.shake_256.__lt__" => "Return self<value.",
    "_sha3.shake_256.__ne__" => "Return self!=value.",
    "_sha3.shake_256.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_sha3.shake_256.__reduce__" => "Helper for pickle.",
    "_sha3.shake_256.__reduce_ex__" => "Helper for pickle.",
    "_sha3.shake_256.__repr__" => "Return repr(self).",
    "_sha3.shake_256.__setattr__" => "Implement setattr(self, name, value).",
    "_sha3.shake_256.__sizeof__" => "Size of object in memory, in bytes.",
    "_sha3.shake_256.__str__" => "Return str(self).",
    "_sha3.shake_256.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_sha3.shake_256.copy" => "Return a copy of the hash object.",
    "_sha3.shake_256.digest" => "Return the digest value as a bytes object.",
    "_sha3.shake_256.hexdigest" => "Return the digest value as a string of hexadecimal digits.",
    "_sha3.shake_256.update" => "Update this hash object's state with the provided bytes-like object.",
    "_signal" => "This module provides mechanisms to use signal handlers in Python.\n\nFunctions:\n\nalarm() -- cause SIGALRM after a specified time [Unix only]\nsetitimer() -- cause a signal (described below) after a specified\n               float time and the timer may restart then [Unix only]\ngetitimer() -- get current value of timer [Unix only]\nsignal() -- set the action for a given signal\ngetsignal() -- get the signal action for a given signal\npause() -- wait until a signal arrives [Unix only]\ndefault_int_handler() -- default SIGINT handler\n\nsignal constants:\nSIG_DFL -- used to refer to the system default handler\nSIG_IGN -- used to ignore the signal\nNSIG -- number of defined signals\nSIGINT, SIGTERM, etc. -- signal numbers\n\nitimer constants:\nITIMER_REAL -- decrements in real time, and delivers SIGALRM upon\n               expiration\nITIMER_VIRTUAL -- decrements only when the process is executing,\n               and delivers SIGVTALRM upon expiration\nITIMER_PROF -- decrements both when the process is executing and\n               when the system is executing on behalf of the process.\n               Coupled with ITIMER_VIRTUAL, this timer is usually\n               used to profile the time spent by the application\n               in user and kernel space. SIGPROF is delivered upon\n               expiration.\n\n\n*** IMPORTANT NOTICE ***\nA signal handler function is called with two arguments:\nthe first is the signal number, the second is the interrupted stack frame.",
    "_signal.default_int_handler" => "The default handler for SIGINT installed by Python.\n\nIt raises KeyboardInterrupt.",
    "_signal.getsignal" => "Return the current action for the given signal.\n\nThe return value can be:\n  SIG_IGN -- if the signal is being ignored\n  SIG_DFL -- if the default action for the signal is in effect\n  None    -- if an unknown handler is in effect\n  anything else -- the callable Python object used as a handler",
    "_signal.raise_signal" => "Send a signal to the executing process.",
    "_signal.set_wakeup_fd" => "Sets the fd to be written to (with the signal number) when a signal comes in.\n\nA library can use this to wakeup select or poll.\nThe previous fd or -1 is returned.\n\nThe fd must be non-blocking.",
    "_signal.signal" => "Set the action for the given signal.\n\nThe action can be SIG_DFL, SIG_IGN, or a callable Python object.\nThe previous action is returned.  See getsignal() for possible return values.\n\n*** IMPORTANT NOTICE ***\nA signal handler function is called with two arguments:\nthe first is the signal number, the second is the interrupted stack frame.",
    "_signal.strsignal" => "Return the system description of the given signal.\n\nReturns the description of signal *signalnum*, such as \"Interrupt\"\nfor :const:`SIGINT`. Returns :const:`None` if *signalnum* has no\ndescription. Raises :exc:`ValueError` if *signalnum* is invalid.",
    "_signal.valid_signals" => "Return a set of valid signal numbers on this platform.\n\nThe signal numbers returned by this function can be safely passed to\nfunctions like `pthread_sigmask`.",
    "_socket" => "Implementation module for socket operations.\n\nSee the socket module for documentation.",
    "_socket.SocketType" => "socket(family=AF_INET, type=SOCK_STREAM, proto=0) -> socket object\nsocket(family=-1, type=-1, proto=-1, fileno=None) -> socket object\n\nOpen a socket of the given type.  The family argument specifies the\naddress family; it defaults to AF_INET.  The type argument specifies\nwhether this is a stream (SOCK_STREAM, this is the default)\nor datagram (SOCK_DGRAM) socket.  The protocol argument defaults to 0,\nspecifying the default protocol.  Keyword arguments are accepted.\nThe socket is created as non-inheritable.\n\nWhen a fileno is passed in, family, type and proto are auto-detected,\nunless they are explicitly set.\n\nA socket object represents one endpoint of a network connection.\n\nMethods of socket objects (keyword arguments not allowed):\n\n_accept() -- accept connection, returning new socket fd and client address\nbind(addr) -- bind the socket to a local address\nclose() -- close the socket\nconnect(addr) -- connect the socket to a remote address\nconnect_ex(addr) -- connect, return an error code instead of an exception\ndup() -- return a new socket fd duplicated from fileno()\nfileno() -- return underlying file descriptor\ngetpeername() -- return remote address [*]\ngetsockname() -- return local address\ngetsockopt(level, optname[, buflen]) -- get socket options\ngettimeout() -- return timeout or None\nlisten([n]) -- start listening for incoming connections\nrecv(buflen[, flags]) -- receive data\nrecv_into(buffer[, nbytes[, flags]]) -- receive data (into a buffer)\nrecvfrom(buflen[, flags]) -- receive data and sender's address\nrecvfrom_into(buffer[, nbytes, [, flags])\n  -- receive data and sender's address (into a buffer)\nsendall(data[, flags]) -- send all data\nsend(data[, flags]) -- send data, may not send all of it\nsendto(data[, flags], addr) -- send data to a given address\nsetblocking(bool) -- set or clear the blocking I/O flag\ngetblocking() -- return True if socket is blocking, False if non-blocking\nsetsockopt(level, optname, value[, optlen]) -- set socket options\nsettimeout(None | float) -- set or clear the timeout\nshutdown(how) -- shut down traffic in one or both directions\n\n [*] not available on all platforms!",
    "_socket.SocketType.__del__" => "Called when the instance is about to be destroyed.",
    "_socket.SocketType.__delattr__" => "Implement delattr(self, name).",
    "_socket.SocketType.__eq__" => "Return self==value.",
    "_socket.SocketType.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_socket.SocketType.__ge__" => "Return self>=value.",
    "_socket.SocketType.__getattribute__" => "Return getattr(self, name).",
    "_socket.SocketType.__getstate__" => "Helper for pickle.",
    "_socket.SocketType.__gt__" => "Return self>value.",
    "_socket.SocketType.__hash__" => "Return hash(self).",
    "_socket.SocketType.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_socket.SocketType.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_socket.SocketType.__le__" => "Return self<=value.",
    "_socket.SocketType.__lt__" => "Return self<value.",
    "_socket.SocketType.__ne__" => "Return self!=value.",
    "_socket.SocketType.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_socket.SocketType.__reduce__" => "Helper for pickle.",
    "_socket.SocketType.__reduce_ex__" => "Helper for pickle.",
    "_socket.SocketType.__repr__" => "Return repr(self).",
    "_socket.SocketType.__setattr__" => "Implement setattr(self, name, value).",
    "_socket.SocketType.__sizeof__" => "Size of object in memory, in bytes.",
    "_socket.SocketType.__str__" => "Return str(self).",
    "_socket.SocketType.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_socket.SocketType._accept" => "_accept() -> (integer, address info)\n\nWait for an incoming connection.  Return a new socket file descriptor\nrepresenting the connection, and the address of the client.\nFor IP sockets, the address info is a pair (hostaddr, port).",
    "_socket.SocketType.bind" => "bind(address)\n\nBind the socket to a local address.  For IP sockets, the address is a\npair (host, port); the host must refer to the local host. For raw packet\nsockets the address is a tuple (ifname, proto [,pkttype [,hatype [,addr]]])",
    "_socket.SocketType.close" => "close()\n\nClose the socket.  It cannot be used after this call.",
    "_socket.SocketType.connect" => "connect(address)\n\nConnect the socket to a remote address.  For IP sockets, the address\nis a pair (host, port).",
    "_socket.SocketType.connect_ex" => "connect_ex(address) -> errno\n\nThis is like connect(address), but returns an error code (the errno value)\ninstead of raising an exception when an error occurs.",
    "_socket.SocketType.detach" => "detach()\n\nClose the socket object without closing the underlying file descriptor.\nThe object cannot be used after this call, but the file descriptor\ncan be reused for other purposes.  The file descriptor is returned.",
    "_socket.SocketType.family" => "the socket family",
    "_socket.SocketType.fileno" => "fileno() -> integer\n\nReturn the integer file descriptor of the socket.",
    "_socket.SocketType.getblocking" => "getblocking()\n\nReturns True if socket is in blocking mode, or False if it\nis in non-blocking mode.",
    "_socket.SocketType.getpeername" => "getpeername() -> address info\n\nReturn the address of the remote endpoint.  For IP sockets, the address\ninfo is a pair (hostaddr, port).",
    "_socket.SocketType.getsockname" => "getsockname() -> address info\n\nReturn the address of the local endpoint. The format depends on the\naddress family. For IPv4 sockets, the address info is a pair\n(hostaddr, port). For IPv6 sockets, the address info is a 4-tuple\n(hostaddr, port, flowinfo, scope_id).",
    "_socket.SocketType.getsockopt" => "getsockopt(level, option[, buffersize]) -> value\n\nGet a socket option.  See the Unix manual for level and option.\nIf a nonzero buffersize argument is given, the return value is a\nstring of that length; otherwise it is an integer.",
    "_socket.SocketType.gettimeout" => "gettimeout() -> timeout\n\nReturns the timeout in seconds (float) associated with socket\noperations. A timeout of None indicates that timeouts on socket\noperations are disabled.",
    "_socket.SocketType.ioctl" => "ioctl(cmd, option) -> long\n\nControl the socket with WSAIoctl syscall. Currently supported 'cmd' values are\nSIO_RCVALL:  'option' must be one of the socket.RCVALL_* constants.\nSIO_KEEPALIVE_VALS:  'option' is a tuple of (onoff, timeout, interval).\nSIO_LOOPBACK_FAST_PATH: 'option' is a boolean value, and is disabled by default",
    "_socket.SocketType.listen" => "listen([backlog])\n\nEnable a server to accept connections.  If backlog is specified, it must be\nat least 0 (if it is lower, it is set to 0); it specifies the number of\nunaccepted connections that the system will allow before refusing new\nconnections. If not specified, a default reasonable value is chosen.",
    "_socket.SocketType.proto" => "the socket protocol",
    "_socket.SocketType.recv" => "recv(buffersize[, flags]) -> data\n\nReceive up to buffersize bytes from the socket.  For the optional flags\nargument, see the Unix manual.  When no data is available, block until\nat least one byte is available or until the remote end is closed.  When\nthe remote end is closed and all data is read, return the empty string.",
    "_socket.SocketType.recv_into" => "recv_into(buffer, [nbytes[, flags]]) -> nbytes_read\n\nA version of recv() that stores its data into a buffer rather than creating\na new string.  Receive up to buffersize bytes from the socket.  If buffersize\nis not specified (or 0), receive up to the size available in the given buffer.\n\nSee recv() for documentation about the flags.",
    "_socket.SocketType.recvfrom" => "recvfrom(buffersize[, flags]) -> (data, address info)\n\nLike recv(buffersize, flags) but also return the sender's address info.",
    "_socket.SocketType.recvfrom_into" => "recvfrom_into(buffer[, nbytes[, flags]]) -> (nbytes, address info)\n\nLike recv_into(buffer[, nbytes[, flags]]) but also return the sender's address info.",
    "_socket.SocketType.send" => "send(data[, flags]) -> count\n\nSend a data string to the socket.  For the optional flags\nargument, see the Unix manual.  Return the number of bytes\nsent; this may be less than len(data) if the network is busy.",
    "_socket.SocketType.sendall" => "sendall(data[, flags])\n\nSend a data string to the socket.  For the optional flags\nargument, see the Unix manual.  This calls send() repeatedly\nuntil all data is sent.  If an error occurs, it's impossible\nto tell how much data has been sent.",
    "_socket.SocketType.sendto" => "sendto(data[, flags], address) -> count\n\nLike send(data, flags) but allows specifying the destination address.\nFor IP sockets, the address is a pair (hostaddr, port).",
    "_socket.SocketType.setblocking" => "setblocking(flag)\n\nSet the socket to blocking (flag is true) or non-blocking (false).\nsetblocking(True) is equivalent to settimeout(None);\nsetblocking(False) is equivalent to settimeout(0.0).",
    "_socket.SocketType.setsockopt" => "setsockopt(level, option, value: int)\nsetsockopt(level, option, value: buffer)\nsetsockopt(level, option, None, optlen: int)\n\nSet a socket option.  See the Unix manual for level and option.\nThe value argument can either be an integer, a string buffer, or\nNone, optlen.",
    "_socket.SocketType.settimeout" => "settimeout(timeout)\n\nSet a timeout on socket operations.  'timeout' can be a float,\ngiving in seconds, or None.  Setting a timeout of None disables\nthe timeout feature and is equivalent to setblocking(1).\nSetting a timeout of zero is the same as setblocking(0).",
    "_socket.SocketType.share" => "share(process_id) -> bytes\n\nShare the socket with another process.  The target process id\nmust be provided and the resulting bytes object passed to the target\nprocess.  There the shared socket can be instantiated by calling\nsocket.fromshare().",
    "_socket.SocketType.shutdown" => "shutdown(flag)\n\nShut down the reading side of the socket (flag == SHUT_RD), the writing side\nof the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).",
    "_socket.SocketType.timeout" => "the socket timeout",
    "_socket.SocketType.type" => "the socket type",
    "_socket.close" => "close(integer) -> None\n\nClose an integer socket file descriptor.  This is like os.close(), but for\nsockets; on some platforms os.close() won't work for socket file descriptors.",
    "_socket.dup" => "dup(integer) -> integer\n\nDuplicate an integer socket file descriptor.  This is like os.dup(), but for\nsockets; on some platforms os.dup() won't work for socket file descriptors.",
    "_socket.getaddrinfo" => "getaddrinfo(host, port [, family, type, proto, flags])\n    -> list of (family, type, proto, canonname, sockaddr)\n\nResolve host and port into addrinfo struct.",
    "_socket.getdefaulttimeout" => "getdefaulttimeout() -> timeout\n\nReturns the default timeout in seconds (float) for new socket objects.\nA value of None indicates that new socket objects have no timeout.\nWhen the socket module is first imported, the default is None.",
    "_socket.gethostbyaddr" => "gethostbyaddr(host) -> (name, aliaslist, addresslist)\n\nReturn the true host name, a list of aliases, and a list of IP addresses,\nfor a host.  The host argument is a string giving a host name or IP number.",
    "_socket.gethostbyname" => "gethostbyname(host) -> address\n\nReturn the IP address (a string of the form '255.255.255.255') for a host.",
    "_socket.gethostbyname_ex" => "gethostbyname_ex(host) -> (name, aliaslist, addresslist)\n\nReturn the true host name, a list of aliases, and a list of IP addresses,\nfor a host.  The host argument is a string giving a host name or IP number.",
    "_socket.gethostname" => "gethostname() -> string\n\nReturn the current host name.",
    "_socket.getnameinfo" => "getnameinfo(sockaddr, flags) --> (host, port)\n\nGet host and port for a sockaddr.",
    "_socket.getprotobyname" => "getprotobyname(name) -> integer\n\nReturn the protocol number for the named protocol.  (Rarely used.)",
    "_socket.getservbyname" => "getservbyname(servicename[, protocolname]) -> integer\n\nReturn a port number from a service name and protocol name.\nThe optional protocol name, if given, should be 'tcp' or 'udp',\notherwise any protocol will match.",
    "_socket.getservbyport" => "getservbyport(port[, protocolname]) -> string\n\nReturn the service name from a port number and protocol name.\nThe optional protocol name, if given, should be 'tcp' or 'udp',\notherwise any protocol will match.",
    "_socket.htonl" => "htonl(integer) -> integer\n\nConvert a 32-bit integer from host to network byte order.",
    "_socket.htons" => "Convert a 16-bit unsigned integer from host to network byte order.",
    "_socket.if_indextoname" => "if_indextoname(if_index)\n\nReturns the interface name corresponding to the interface index if_index.",
    "_socket.if_nameindex" => "if_nameindex()\n\nReturns a list of network interface information (index, name) tuples.",
    "_socket.if_nametoindex" => "Returns the interface index corresponding to the interface name if_name.",
    "_socket.inet_aton" => "Convert an IP address in string format (123.45.67.89) to the 32-bit packed binary format used in low-level network functions.",
    "_socket.inet_ntoa" => "Convert an IP address from 32-bit packed binary format to string format.",
    "_socket.inet_ntop" => "inet_ntop(af, packed_ip) -> string formatted IP address\n\nConvert a packed IP address of the given family to string format.",
    "_socket.inet_pton" => "inet_pton(af, ip) -> packed IP address string\n\nConvert an IP address from string format to a packed string suitable\nfor use with low-level network functions.",
    "_socket.ntohl" => "ntohl(integer) -> integer\n\nConvert a 32-bit integer from network to host byte order.",
    "_socket.ntohs" => "Convert a 16-bit unsigned integer from network to host byte order.",
    "_socket.setdefaulttimeout" => "setdefaulttimeout(timeout)\n\nSet the default timeout in seconds (float) for new socket objects.\nA value of None indicates that new socket objects have no timeout.\nWhen the socket module is first imported, the default is None.",
    "_socket.socket" => "socket(family=AF_INET, type=SOCK_STREAM, proto=0) -> socket object\nsocket(family=-1, type=-1, proto=-1, fileno=None) -> socket object\n\nOpen a socket of the given type.  The family argument specifies the\naddress family; it defaults to AF_INET.  The type argument specifies\nwhether this is a stream (SOCK_STREAM, this is the default)\nor datagram (SOCK_DGRAM) socket.  The protocol argument defaults to 0,\nspecifying the default protocol.  Keyword arguments are accepted.\nThe socket is created as non-inheritable.\n\nWhen a fileno is passed in, family, type and proto are auto-detected,\nunless they are explicitly set.\n\nA socket object represents one endpoint of a network connection.\n\nMethods of socket objects (keyword arguments not allowed):\n\n_accept() -- accept connection, returning new socket fd and client address\nbind(addr) -- bind the socket to a local address\nclose() -- close the socket\nconnect(addr) -- connect the socket to a remote address\nconnect_ex(addr) -- connect, return an error code instead of an exception\ndup() -- return a new socket fd duplicated from fileno()\nfileno() -- return underlying file descriptor\ngetpeername() -- return remote address [*]\ngetsockname() -- return local address\ngetsockopt(level, optname[, buflen]) -- get socket options\ngettimeout() -- return timeout or None\nlisten([n]) -- start listening for incoming connections\nrecv(buflen[, flags]) -- receive data\nrecv_into(buffer[, nbytes[, flags]]) -- receive data (into a buffer)\nrecvfrom(buflen[, flags]) -- receive data and sender's address\nrecvfrom_into(buffer[, nbytes, [, flags])\n  -- receive data and sender's address (into a buffer)\nsendall(data[, flags]) -- send all data\nsend(data[, flags]) -- send data, may not send all of it\nsendto(data[, flags], addr) -- send data to a given address\nsetblocking(bool) -- set or clear the blocking I/O flag\ngetblocking() -- return True if socket is blocking, False if non-blocking\nsetsockopt(level, optname, value[, optlen]) -- set socket options\nsettimeout(None | float) -- set or clear the timeout\nshutdown(how) -- shut down traffic in one or both directions\n\n [*] not available on all platforms!",
    "_socket.socket.__del__" => "Called when the instance is about to be destroyed.",
    "_socket.socket.__delattr__" => "Implement delattr(self, name).",
    "_socket.socket.__eq__" => "Return self==value.",
    "_socket.socket.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_socket.socket.__ge__" => "Return self>=value.",
    "_socket.socket.__getattribute__" => "Return getattr(self, name).",
    "_socket.socket.__getstate__" => "Helper for pickle.",
    "_socket.socket.__gt__" => "Return self>value.",
    "_socket.socket.__hash__" => "Return hash(self).",
    "_socket.socket.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_socket.socket.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_socket.socket.__le__" => "Return self<=value.",
    "_socket.socket.__lt__" => "Return self<value.",
    "_socket.socket.__ne__" => "Return self!=value.",
    "_socket.socket.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_socket.socket.__reduce__" => "Helper for pickle.",
    "_socket.socket.__reduce_ex__" => "Helper for pickle.",
    "_socket.socket.__repr__" => "Return repr(self).",
    "_socket.socket.__setattr__" => "Implement setattr(self, name, value).",
    "_socket.socket.__sizeof__" => "Size of object in memory, in bytes.",
    "_socket.socket.__str__" => "Return str(self).",
    "_socket.socket.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_socket.socket._accept" => "_accept() -> (integer, address info)\n\nWait for an incoming connection.  Return a new socket file descriptor\nrepresenting the connection, and the address of the client.\nFor IP sockets, the address info is a pair (hostaddr, port).",
    "_socket.socket.bind" => "bind(address)\n\nBind the socket to a local address.  For IP sockets, the address is a\npair (host, port); the host must refer to the local host. For raw packet\nsockets the address is a tuple (ifname, proto [,pkttype [,hatype [,addr]]])",
    "_socket.socket.close" => "close()\n\nClose the socket.  It cannot be used after this call.",
    "_socket.socket.connect" => "connect(address)\n\nConnect the socket to a remote address.  For IP sockets, the address\nis a pair (host, port).",
    "_socket.socket.connect_ex" => "connect_ex(address) -> errno\n\nThis is like connect(address), but returns an error code (the errno value)\ninstead of raising an exception when an error occurs.",
    "_socket.socket.detach" => "detach()\n\nClose the socket object without closing the underlying file descriptor.\nThe object cannot be used after this call, but the file descriptor\ncan be reused for other purposes.  The file descriptor is returned.",
    "_socket.socket.family" => "the socket family",
    "_socket.socket.fileno" => "fileno() -> integer\n\nReturn the integer file descriptor of the socket.",
    "_socket.socket.getblocking" => "getblocking()\n\nReturns True if socket is in blocking mode, or False if it\nis in non-blocking mode.",
    "_socket.socket.getpeername" => "getpeername() -> address info\n\nReturn the address of the remote endpoint.  For IP sockets, the address\ninfo is a pair (hostaddr, port).",
    "_socket.socket.getsockname" => "getsockname() -> address info\n\nReturn the address of the local endpoint. The format depends on the\naddress family. For IPv4 sockets, the address info is a pair\n(hostaddr, port). For IPv6 sockets, the address info is a 4-tuple\n(hostaddr, port, flowinfo, scope_id).",
    "_socket.socket.getsockopt" => "getsockopt(level, option[, buffersize]) -> value\n\nGet a socket option.  See the Unix manual for level and option.\nIf a nonzero buffersize argument is given, the return value is a\nstring of that length; otherwise it is an integer.",
    "_socket.socket.gettimeout" => "gettimeout() -> timeout\n\nReturns the timeout in seconds (float) associated with socket\noperations. A timeout of None indicates that timeouts on socket\noperations are disabled.",
    "_socket.socket.ioctl" => "ioctl(cmd, option) -> long\n\nControl the socket with WSAIoctl syscall. Currently supported 'cmd' values are\nSIO_RCVALL:  'option' must be one of the socket.RCVALL_* constants.\nSIO_KEEPALIVE_VALS:  'option' is a tuple of (onoff, timeout, interval).\nSIO_LOOPBACK_FAST_PATH: 'option' is a boolean value, and is disabled by default",
    "_socket.socket.listen" => "listen([backlog])\n\nEnable a server to accept connections.  If backlog is specified, it must be\nat least 0 (if it is lower, it is set to 0); it specifies the number of\nunaccepted connections that the system will allow before refusing new\nconnections. If not specified, a default reasonable value is chosen.",
    "_socket.socket.proto" => "the socket protocol",
    "_socket.socket.recv" => "recv(buffersize[, flags]) -> data\n\nReceive up to buffersize bytes from the socket.  For the optional flags\nargument, see the Unix manual.  When no data is available, block until\nat least one byte is available or until the remote end is closed.  When\nthe remote end is closed and all data is read, return the empty string.",
    "_socket.socket.recv_into" => "recv_into(buffer, [nbytes[, flags]]) -> nbytes_read\n\nA version of recv() that stores its data into a buffer rather than creating\na new string.  Receive up to buffersize bytes from the socket.  If buffersize\nis not specified (or 0), receive up to the size available in the given buffer.\n\nSee recv() for documentation about the flags.",
    "_socket.socket.recvfrom" => "recvfrom(buffersize[, flags]) -> (data, address info)\n\nLike recv(buffersize, flags) but also return the sender's address info.",
    "_socket.socket.recvfrom_into" => "recvfrom_into(buffer[, nbytes[, flags]]) -> (nbytes, address info)\n\nLike recv_into(buffer[, nbytes[, flags]]) but also return the sender's address info.",
    "_socket.socket.send" => "send(data[, flags]) -> count\n\nSend a data string to the socket.  For the optional flags\nargument, see the Unix manual.  Return the number of bytes\nsent; this may be less than len(data) if the network is busy.",
    "_socket.socket.sendall" => "sendall(data[, flags])\n\nSend a data string to the socket.  For the optional flags\nargument, see the Unix manual.  This calls send() repeatedly\nuntil all data is sent.  If an error occurs, it's impossible\nto tell how much data has been sent.",
    "_socket.socket.sendto" => "sendto(data[, flags], address) -> count\n\nLike send(data, flags) but allows specifying the destination address.\nFor IP sockets, the address is a pair (hostaddr, port).",
    "_socket.socket.setblocking" => "setblocking(flag)\n\nSet the socket to blocking (flag is true) or non-blocking (false).\nsetblocking(True) is equivalent to settimeout(None);\nsetblocking(False) is equivalent to settimeout(0.0).",
    "_socket.socket.setsockopt" => "setsockopt(level, option, value: int)\nsetsockopt(level, option, value: buffer)\nsetsockopt(level, option, None, optlen: int)\n\nSet a socket option.  See the Unix manual for level and option.\nThe value argument can either be an integer, a string buffer, or\nNone, optlen.",
    "_socket.socket.settimeout" => "settimeout(timeout)\n\nSet a timeout on socket operations.  'timeout' can be a float,\ngiving in seconds, or None.  Setting a timeout of None disables\nthe timeout feature and is equivalent to setblocking(1).\nSetting a timeout of zero is the same as setblocking(0).",
    "_socket.socket.share" => "share(process_id) -> bytes\n\nShare the socket with another process.  The target process id\nmust be provided and the resulting bytes object passed to the target\nprocess.  There the shared socket can be instantiated by calling\nsocket.fromshare().",
    "_socket.socket.shutdown" => "shutdown(flag)\n\nShut down the reading side of the socket (flag == SHUT_RD), the writing side\nof the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).",
    "_socket.socket.timeout" => "the socket timeout",
    "_socket.socket.type" => "the socket type",
    "_sqlite3.adapt" => "Adapt given object to given protocol.",
    "_sqlite3.complete_statement" => "Checks if a string contains a complete SQL statement.",
    "_sqlite3.connect" => "Open a connection to the SQLite database file 'database'.\n\nYou can use \":memory:\" to open a database connection to a database that\nresides in RAM instead of on disk.\n\nNote: Passing more than 1 positional argument to _sqlite3.connect() is\ndeprecated. Parameters 'timeout', 'detect_types', 'isolation_level',\n'check_same_thread', 'factory', 'cached_statements' and 'uri' will\nbecome keyword-only parameters in Python 3.15.",
    "_sqlite3.enable_callback_tracebacks" => "Enable or disable callback functions throwing errors to stderr.",
    "_sqlite3.register_adapter" => "Register a function to adapt Python objects to SQLite values.",
    "_sqlite3.register_converter" => "Register a function to convert SQLite values to Python objects.",
    "_sre.template" => "template\n  A list containing interleaved literal strings (str or bytes) and group\n  indices (int), as returned by re._parser.parse_template():\n      [literal1, group1, ..., literalN, groupN]",
    "_ssl" => "Implementation module for SSL socket operations.  See the socket module\nfor documentation.",
    "_ssl.Certificate.__delattr__" => "Implement delattr(self, name).",
    "_ssl.Certificate.__eq__" => "Return self==value.",
    "_ssl.Certificate.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_ssl.Certificate.__ge__" => "Return self>=value.",
    "_ssl.Certificate.__getattribute__" => "Return getattr(self, name).",
    "_ssl.Certificate.__getstate__" => "Helper for pickle.",
    "_ssl.Certificate.__gt__" => "Return self>value.",
    "_ssl.Certificate.__hash__" => "Return hash(self).",
    "_ssl.Certificate.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_ssl.Certificate.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_ssl.Certificate.__le__" => "Return self<=value.",
    "_ssl.Certificate.__lt__" => "Return self<value.",
    "_ssl.Certificate.__ne__" => "Return self!=value.",
    "_ssl.Certificate.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_ssl.Certificate.__reduce__" => "Helper for pickle.",
    "_ssl.Certificate.__reduce_ex__" => "Helper for pickle.",
    "_ssl.Certificate.__repr__" => "Return repr(self).",
    "_ssl.Certificate.__setattr__" => "Implement setattr(self, name, value).",
    "_ssl.Certificate.__sizeof__" => "Size of object in memory, in bytes.",
    "_ssl.Certificate.__str__" => "Return str(self).",
    "_ssl.Certificate.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_ssl.MemoryBIO.__delattr__" => "Implement delattr(self, name).",
    "_ssl.MemoryBIO.__eq__" => "Return self==value.",
    "_ssl.MemoryBIO.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_ssl.MemoryBIO.__ge__" => "Return self>=value.",
    "_ssl.MemoryBIO.__getattribute__" => "Return getattr(self, name).",
    "_ssl.MemoryBIO.__getstate__" => "Helper for pickle.",
    "_ssl.MemoryBIO.__gt__" => "Return self>value.",
    "_ssl.MemoryBIO.__hash__" => "Return hash(self).",
    "_ssl.MemoryBIO.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_ssl.MemoryBIO.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_ssl.MemoryBIO.__le__" => "Return self<=value.",
    "_ssl.MemoryBIO.__lt__" => "Return self<value.",
    "_ssl.MemoryBIO.__ne__" => "Return self!=value.",
    "_ssl.MemoryBIO.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_ssl.MemoryBIO.__reduce__" => "Helper for pickle.",
    "_ssl.MemoryBIO.__reduce_ex__" => "Helper for pickle.",
    "_ssl.MemoryBIO.__repr__" => "Return repr(self).",
    "_ssl.MemoryBIO.__setattr__" => "Implement setattr(self, name, value).",
    "_ssl.MemoryBIO.__sizeof__" => "Size of object in memory, in bytes.",
    "_ssl.MemoryBIO.__str__" => "Return str(self).",
    "_ssl.MemoryBIO.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_ssl.MemoryBIO.eof" => "Whether the memory BIO is at EOF.",
    "_ssl.MemoryBIO.pending" => "The number of bytes pending in the memory BIO.",
    "_ssl.MemoryBIO.read" => "Read up to size bytes from the memory BIO.\n\nIf size is not specified, read the entire buffer.\nIf the return value is an empty bytes instance, this means either\nEOF or that no data is available. Use the \"eof\" property to\ndistinguish between the two.",
    "_ssl.MemoryBIO.write" => "Writes the bytes b into the memory BIO.\n\nReturns the number of bytes written.",
    "_ssl.MemoryBIO.write_eof" => "Write an EOF marker to the memory BIO.\n\nWhen all data has been read, the \"eof\" property will be True.",
    "_ssl.RAND_add" => "Mix string into the OpenSSL PRNG state.\n\nentropy (a float) is a lower bound on the entropy contained in\nstring.  See RFC 4086.",
    "_ssl.RAND_bytes" => "Generate n cryptographically strong pseudo-random bytes.",
    "_ssl.RAND_status" => "Returns True if the OpenSSL PRNG has been seeded with enough data and False if not.\n\nIt is necessary to seed the PRNG with RAND_add() on some platforms before\nusing the ssl() function.",
    "_ssl.SSLSession.__delattr__" => "Implement delattr(self, name).",
    "_ssl.SSLSession.__eq__" => "Return self==value.",
    "_ssl.SSLSession.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_ssl.SSLSession.__ge__" => "Return self>=value.",
    "_ssl.SSLSession.__getattribute__" => "Return getattr(self, name).",
    "_ssl.SSLSession.__getstate__" => "Helper for pickle.",
    "_ssl.SSLSession.__gt__" => "Return self>value.",
    "_ssl.SSLSession.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_ssl.SSLSession.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_ssl.SSLSession.__le__" => "Return self<=value.",
    "_ssl.SSLSession.__lt__" => "Return self<value.",
    "_ssl.SSLSession.__ne__" => "Return self!=value.",
    "_ssl.SSLSession.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_ssl.SSLSession.__reduce__" => "Helper for pickle.",
    "_ssl.SSLSession.__reduce_ex__" => "Helper for pickle.",
    "_ssl.SSLSession.__repr__" => "Return repr(self).",
    "_ssl.SSLSession.__setattr__" => "Implement setattr(self, name, value).",
    "_ssl.SSLSession.__sizeof__" => "Size of object in memory, in bytes.",
    "_ssl.SSLSession.__str__" => "Return str(self).",
    "_ssl.SSLSession.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_ssl.SSLSession.has_ticket" => "Does the session contain a ticket?",
    "_ssl.SSLSession.id" => "Session ID.",
    "_ssl.SSLSession.ticket_lifetime_hint" => "Ticket life time hint.",
    "_ssl.SSLSession.time" => "Session creation time (seconds since epoch).",
    "_ssl.SSLSession.timeout" => "Session timeout (delta in seconds).",
    "_ssl._SSLContext.__delattr__" => "Implement delattr(self, name).",
    "_ssl._SSLContext.__eq__" => "Return self==value.",
    "_ssl._SSLContext.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_ssl._SSLContext.__ge__" => "Return self>=value.",
    "_ssl._SSLContext.__getattribute__" => "Return getattr(self, name).",
    "_ssl._SSLContext.__getstate__" => "Helper for pickle.",
    "_ssl._SSLContext.__gt__" => "Return self>value.",
    "_ssl._SSLContext.__hash__" => "Return hash(self).",
    "_ssl._SSLContext.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_ssl._SSLContext.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_ssl._SSLContext.__le__" => "Return self<=value.",
    "_ssl._SSLContext.__lt__" => "Return self<value.",
    "_ssl._SSLContext.__ne__" => "Return self!=value.",
    "_ssl._SSLContext.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_ssl._SSLContext.__reduce__" => "Helper for pickle.",
    "_ssl._SSLContext.__reduce_ex__" => "Helper for pickle.",
    "_ssl._SSLContext.__repr__" => "Return repr(self).",
    "_ssl._SSLContext.__setattr__" => "Implement setattr(self, name, value).",
    "_ssl._SSLContext.__sizeof__" => "Size of object in memory, in bytes.",
    "_ssl._SSLContext.__str__" => "Return str(self).",
    "_ssl._SSLContext.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_ssl._SSLContext.cert_store_stats" => "Returns quantities of loaded X.509 certificates.\n\nX.509 certificates with a CA extension and certificate revocation lists\ninside the context's cert store.\n\nNOTE: Certificates in a capath directory aren't loaded unless they have\nbeen used at least once.",
    "_ssl._SSLContext.get_ca_certs" => "Returns a list of dicts with information of loaded CA certs.\n\nIf the optional argument is True, returns a DER-encoded copy of the CA\ncertificate.\n\nNOTE: Certificates in a capath directory aren't loaded unless they have\nbeen used at least once.",
    "_ssl._SSLContext.num_tickets" => "Control the number of TLSv1.3 session tickets.",
    "_ssl._SSLContext.security_level" => "The current security level.",
    "_ssl._SSLContext.sni_callback" => "Set a callback that will be called when a server name is provided by the SSL/TLS client in the SNI extension.\n\nIf the argument is None then the callback is disabled. The method is called\nwith the SSLSocket, the server name as a string, and the SSLContext object.\n\nSee RFC 6066 for details of the SNI extension.",
    "_ssl._SSLSocket.__delattr__" => "Implement delattr(self, name).",
    "_ssl._SSLSocket.__eq__" => "Return self==value.",
    "_ssl._SSLSocket.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_ssl._SSLSocket.__ge__" => "Return self>=value.",
    "_ssl._SSLSocket.__getattribute__" => "Return getattr(self, name).",
    "_ssl._SSLSocket.__getstate__" => "Helper for pickle.",
    "_ssl._SSLSocket.__gt__" => "Return self>value.",
    "_ssl._SSLSocket.__hash__" => "Return hash(self).",
    "_ssl._SSLSocket.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_ssl._SSLSocket.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_ssl._SSLSocket.__le__" => "Return self<=value.",
    "_ssl._SSLSocket.__lt__" => "Return self<value.",
    "_ssl._SSLSocket.__ne__" => "Return self!=value.",
    "_ssl._SSLSocket.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_ssl._SSLSocket.__reduce__" => "Helper for pickle.",
    "_ssl._SSLSocket.__reduce_ex__" => "Helper for pickle.",
    "_ssl._SSLSocket.__repr__" => "Return repr(self).",
    "_ssl._SSLSocket.__setattr__" => "Implement setattr(self, name, value).",
    "_ssl._SSLSocket.__sizeof__" => "Size of object in memory, in bytes.",
    "_ssl._SSLSocket.__str__" => "Return str(self).",
    "_ssl._SSLSocket.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_ssl._SSLSocket.context" => "This changes the context associated with the SSLSocket.\n\nThis is typically used from within a callback function set by the sni_callback\non the SSLContext to change the certificate information associated with the\nSSLSocket before the cryptographic exchange handshake messages.",
    "_ssl._SSLSocket.get_channel_binding" => "Get channel binding data for current connection.\n\nRaise ValueError if the requested `cb_type` is not supported.  Return bytes\nof the data or None if the data is not available (e.g. before the handshake).\nOnly 'tls-unique' channel binding data from RFC 5929 is supported.",
    "_ssl._SSLSocket.getpeercert" => "Returns the certificate for the peer.\n\nIf no certificate was provided, returns None.  If a certificate was\nprovided, but not validated, returns an empty dictionary.  Otherwise\nreturns a dict containing information about the peer certificate.\n\nIf the optional argument is True, returns a DER-encoded copy of the\npeer certificate, or None if no certificate was provided.  This will\nreturn the certificate even if it wasn't validated.",
    "_ssl._SSLSocket.owner" => "The Python-level owner of this object.\n\nPassed as \"self\" in servername callback.",
    "_ssl._SSLSocket.pending" => "Returns the number of already decrypted bytes available for read, pending on the connection.",
    "_ssl._SSLSocket.read" => "read(size, [buffer])\nRead up to size bytes from the SSL socket.",
    "_ssl._SSLSocket.server_hostname" => "The currently set server hostname (for SNI).",
    "_ssl._SSLSocket.server_side" => "Whether this is a server-side socket.",
    "_ssl._SSLSocket.session" => "The underlying SSLSession object.",
    "_ssl._SSLSocket.session_reused" => "Was the client session reused during handshake?",
    "_ssl._SSLSocket.shutdown" => "Does the SSL shutdown handshake with the remote end.",
    "_ssl._SSLSocket.verify_client_post_handshake" => "Initiate TLS 1.3 post-handshake authentication",
    "_ssl._SSLSocket.write" => "Writes the bytes-like object b into the SSL object.\n\nReturns the number of bytes written.",
    "_ssl.enum_certificates" => "Retrieve certificates from Windows' cert store.\n\nstore_name may be one of 'CA', 'ROOT' or 'MY'.  The system may provide\nmore cert storages, too.  The function returns a list of (bytes,\nencoding_type, trust) tuples.  The encoding_type flag can be interpreted\nwith X509_ASN_ENCODING or PKCS_7_ASN_ENCODING. The trust setting is either\na set of OIDs or the boolean True.",
    "_ssl.enum_crls" => "Retrieve CRLs from Windows' cert store.\n\nstore_name may be one of 'CA', 'ROOT' or 'MY'.  The system may provide\nmore cert storages, too.  The function returns a list of (bytes,\nencoding_type) tuples.  The encoding_type flag can be interpreted with\nX509_ASN_ENCODING or PKCS_7_ASN_ENCODING.",
    "_ssl.get_default_verify_paths" => "Return search paths and environment vars that are used by SSLContext's set_default_verify_paths() to load default CAs.\n\nThe values are 'cert_file_env', 'cert_file', 'cert_dir_env', 'cert_dir'.",
    "_ssl.nid2obj" => "Lookup NID, short name, long name and OID of an ASN1_OBJECT by NID.",
    "_ssl.txt2obj" => "Lookup NID, short name, long name and OID of an ASN1_OBJECT.\n\nBy default objects are looked up by OID. With name=True short and\nlong name are also matched.",
    "_stat" => "S_IFMT_: file type bits\nS_IFDIR: directory\nS_IFCHR: character device\nS_IFBLK: block device\nS_IFREG: regular file\nS_IFIFO: fifo (named pipe)\nS_IFLNK: symbolic link\nS_IFSOCK: socket file\nS_IFDOOR: door\nS_IFPORT: event port\nS_IFWHT: whiteout\n\nS_ISUID: set UID bit\nS_ISGID: set GID bit\nS_ENFMT: file locking enforcement\nS_ISVTX: sticky bit\nS_IREAD: Unix V7 synonym for S_IRUSR\nS_IWRITE: Unix V7 synonym for S_IWUSR\nS_IEXEC: Unix V7 synonym for S_IXUSR\nS_IRWXU: mask for owner permissions\nS_IRUSR: read by owner\nS_IWUSR: write by owner\nS_IXUSR: execute by owner\nS_IRWXG: mask for group permissions\nS_IRGRP: read by group\nS_IWGRP: write by group\nS_IXGRP: execute by group\nS_IRWXO: mask for others (not in group) permissions\nS_IROTH: read by others\nS_IWOTH: write by others\nS_IXOTH: execute by others\n\nUF_SETTABLE: mask of owner changable flags\nUF_NODUMP: do not dump file\nUF_IMMUTABLE: file may not be changed\nUF_APPEND: file may only be appended to\nUF_OPAQUE: directory is opaque when viewed through a union stack\nUF_NOUNLINK: file may not be renamed or deleted\nUF_COMPRESSED: macOS: file is hfs-compressed\nUF_TRACKED: used for dealing with document IDs\nUF_DATAVAULT: entitlement required for reading and writing\nUF_HIDDEN: macOS: file should not be displayed\nSF_SETTABLE: mask of super user changeable flags\nSF_ARCHIVED: file may be archived\nSF_IMMUTABLE: file may not be changed\nSF_APPEND: file may only be appended to\nSF_RESTRICTED: entitlement required for writing\nSF_NOUNLINK: file may not be renamed or deleted\nSF_SNAPSHOT: file is a snapshot file\nSF_FIRMLINK: file is a firmlink\nSF_DATALESS: file is a dataless object\n\nOn macOS:\nSF_SUPPORTED: mask of super user supported flags\nSF_SYNTHETIC: mask of read-only synthetic flags\n\nST_MODE\nST_INO\nST_DEV\nST_NLINK\nST_UID\nST_GID\nST_SIZE\nST_ATIME\nST_MTIME\nST_CTIME\n\nFILE_ATTRIBUTE_*: Windows file attribute constants\n                   (only present on Windows)",
    "_stat.S_IFMT" => "Return the portion of the file's mode that describes the file type.",
    "_stat.S_IMODE" => "Return the portion of the file's mode that can be set by os.chmod().",
    "_stat.S_ISBLK" => "S_ISBLK(mode) -> bool\n\nReturn True if mode is from a block special device file.",
    "_stat.S_ISCHR" => "S_ISCHR(mode) -> bool\n\nReturn True if mode is from a character special device file.",
    "_stat.S_ISDIR" => "S_ISDIR(mode) -> bool\n\nReturn True if mode is from a directory.",
    "_stat.S_ISDOOR" => "S_ISDOOR(mode) -> bool\n\nReturn True if mode is from a door.",
    "_stat.S_ISFIFO" => "S_ISFIFO(mode) -> bool\n\nReturn True if mode is from a FIFO (named pipe).",
    "_stat.S_ISLNK" => "S_ISLNK(mode) -> bool\n\nReturn True if mode is from a symbolic link.",
    "_stat.S_ISPORT" => "S_ISPORT(mode) -> bool\n\nReturn True if mode is from an event port.",
    "_stat.S_ISREG" => "S_ISREG(mode) -> bool\n\nReturn True if mode is from a regular file.",
    "_stat.S_ISSOCK" => "S_ISSOCK(mode) -> bool\n\nReturn True if mode is from a socket.",
    "_stat.S_ISWHT" => "S_ISWHT(mode) -> bool\n\nReturn True if mode is from a whiteout.",
    "_stat.filemode" => "Convert a file's mode to a string of the form '-rwxrwxrwx'",
    "_statistics" => "Accelerators for the statistics module.",
    "_string" => "string helper module",
    "_string.formatter_field_name_split" => "split the argument as a field name",
    "_string.formatter_parser" => "parse the argument as a format string",
    "_struct" => "Functions to convert between Python values and C structs.\nPython bytes objects are used to hold the data representing the C struct\nand also as format strings (explained below) to describe the layout of data\nin the C struct.\n\nThe optional first format char indicates byte order, size and alignment:\n  @: native order, size & alignment (default)\n  =: native order, std. size & alignment\n  <: little-endian, std. size & alignment\n  >: big-endian, std. size & alignment\n  !: same as >\n\nThe remaining chars indicate types of args and must match exactly;\nthese can be preceded by a decimal repeat count:\n  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;\n  ?: _Bool (requires C99; if not available, char is used instead)\n  h:short; H:unsigned short; i:int; I:unsigned int;\n  l:long; L:unsigned long; f:float; d:double; e:half-float.\nSpecial cases (preceding decimal count indicates length):\n  s:string (array of char); p: pascal string (with count byte).\nSpecial cases (only available in native format):\n  n:ssize_t; N:size_t;\n  P:an integer type that is wide enough to hold a pointer.\nSpecial case (not in native mode unless 'long long' in platform C):\n  q:long long; Q:unsigned long long\nWhitespace between formats is ignored.\n\nThe variable struct.error is an exception raised on errors.",
    "_struct.Struct" => "Struct(fmt) --> compiled struct object",
    "_struct.Struct.__delattr__" => "Implement delattr(self, name).",
    "_struct.Struct.__eq__" => "Return self==value.",
    "_struct.Struct.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_struct.Struct.__ge__" => "Return self>=value.",
    "_struct.Struct.__getattribute__" => "Return getattr(self, name).",
    "_struct.Struct.__getstate__" => "Helper for pickle.",
    "_struct.Struct.__gt__" => "Return self>value.",
    "_struct.Struct.__hash__" => "Return hash(self).",
    "_struct.Struct.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_struct.Struct.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_struct.Struct.__le__" => "Return self<=value.",
    "_struct.Struct.__lt__" => "Return self<value.",
    "_struct.Struct.__ne__" => "Return self!=value.",
    "_struct.Struct.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_struct.Struct.__reduce__" => "Helper for pickle.",
    "_struct.Struct.__reduce_ex__" => "Helper for pickle.",
    "_struct.Struct.__repr__" => "Return repr(self).",
    "_struct.Struct.__setattr__" => "Implement setattr(self, name, value).",
    "_struct.Struct.__sizeof__" => "S.__sizeof__() -> size of S in memory, in bytes",
    "_struct.Struct.__str__" => "Return str(self).",
    "_struct.Struct.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_struct.Struct.format" => "struct format string",
    "_struct.Struct.iter_unpack" => "Return an iterator yielding tuples.\n\nTuples are unpacked from the given bytes source, like a repeated\ninvocation of unpack_from().\n\nRequires that the bytes length be a multiple of the struct size.",
    "_struct.Struct.pack" => "S.pack(v1, v2, ...) -> bytes\n\nReturn a bytes object containing values v1, v2, ... packed according\nto the format string S.format.  See help(struct) for more on format\nstrings.",
    "_struct.Struct.pack_into" => "S.pack_into(buffer, offset, v1, v2, ...)\n\nPack the values v1, v2, ... according to the format string S.format\nand write the packed bytes into the writable buffer buf starting at\noffset.  Note that the offset is a required argument.  See\nhelp(struct) for more on format strings.",
    "_struct.Struct.size" => "struct size in bytes",
    "_struct.Struct.unpack" => "Return a tuple containing unpacked values.\n\nUnpack according to the format string Struct.format. The buffer's size\nin bytes must be Struct.size.\n\nSee help(struct) for more on format strings.",
    "_struct.Struct.unpack_from" => "Return a tuple containing unpacked values.\n\nValues are unpacked according to the format string Struct.format.\n\nThe buffer's size in bytes, starting at position offset, must be\nat least Struct.size.\n\nSee help(struct) for more on format strings.",
    "_struct._clearcache" => "Clear the internal cache.",
    "_struct.calcsize" => "Return size in bytes of the struct described by the format string.",
    "_struct.iter_unpack" => "Return an iterator yielding tuples unpacked from the given bytes.\n\nThe bytes are unpacked according to the format string, like\na repeated invocation of unpack_from().\n\nRequires that the bytes length be a multiple of the format struct size.",
    "_struct.pack" => "pack(format, v1, v2, ...) -> bytes\n\nReturn a bytes object containing the values v1, v2, ... packed according\nto the format string.  See help(struct) for more on format strings.",
    "_struct.pack_into" => "pack_into(format, buffer, offset, v1, v2, ...)\n\nPack the values v1, v2, ... according to the format string and write\nthe packed bytes into the writable buffer buf starting at offset.  Note\nthat the offset is a required argument.  See help(struct) for more\non format strings.",
    "_struct.unpack" => "Return a tuple containing values unpacked according to the format string.\n\nThe buffer's size in bytes must be calcsize(format).\n\nSee help(struct) for more on format strings.",
    "_struct.unpack_from" => "Return a tuple containing values unpacked according to the format string.\n\nThe buffer's size, minus offset, must be at least calcsize(format).\n\nSee help(struct) for more on format strings.",
    "_suggestions._generate_suggestions" => "Returns the candidate in candidates that's closest to item",
    "_symtable.symtable" => "Return symbol and scope dictionaries used internally by compiler.",
    "_sysconfig" => "A helper for the sysconfig module.",
    "_sysconfig.config_vars" => "Returns a dictionary containing build variables intended to be exposed by sysconfig.",
    "_thread" => "This module provides primitive operations to write multi-threaded programs.\nThe 'threading' module provides a more convenient interface.",
    "_thread.LockType" => "A lock object is a synchronization primitive.  To create a lock,\ncall threading.Lock().  Methods are:\n\nacquire() -- lock the lock, possibly blocking until it can be obtained\nrelease() -- unlock of the lock\nlocked() -- test whether the lock is currently locked\n\nA lock is not owned by the thread that locked it; another thread may\nunlock it.  A thread attempting to lock a lock that it has already locked\nwill block until another thread unlocks it.  Deadlocks may ensue.",
    "_thread.LockType.__delattr__" => "Implement delattr(self, name).",
    "_thread.LockType.__enter__" => "Lock the lock.",
    "_thread.LockType.__eq__" => "Return self==value.",
    "_thread.LockType.__exit__" => "Release the lock.",
    "_thread.LockType.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_thread.LockType.__ge__" => "Return self>=value.",
    "_thread.LockType.__getattribute__" => "Return getattr(self, name).",
    "_thread.LockType.__getstate__" => "Helper for pickle.",
    "_thread.LockType.__gt__" => "Return self>value.",
    "_thread.LockType.__hash__" => "Return hash(self).",
    "_thread.LockType.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_thread.LockType.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_thread.LockType.__le__" => "Return self<=value.",
    "_thread.LockType.__lt__" => "Return self<value.",
    "_thread.LockType.__ne__" => "Return self!=value.",
    "_thread.LockType.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_thread.LockType.__reduce__" => "Helper for pickle.",
    "_thread.LockType.__reduce_ex__" => "Helper for pickle.",
    "_thread.LockType.__repr__" => "Return repr(self).",
    "_thread.LockType.__setattr__" => "Implement setattr(self, name, value).",
    "_thread.LockType.__sizeof__" => "Size of object in memory, in bytes.",
    "_thread.LockType.__str__" => "Return str(self).",
    "_thread.LockType.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_thread.LockType.acquire" => "Lock the lock.  Without argument, this blocks if the lock is already\nlocked (even by the same thread), waiting for another thread to release\nthe lock, and return True once the lock is acquired.\nWith an argument, this will only block if the argument is true,\nand the return value reflects whether the lock is acquired.\nThe blocking operation is interruptible.",
    "_thread.LockType.acquire_lock" => "An obsolete synonym of acquire().",
    "_thread.LockType.locked" => "Return whether the lock is in the locked state.",
    "_thread.LockType.locked_lock" => "An obsolete synonym of locked().",
    "_thread.LockType.release" => "Release the lock, allowing another thread that is blocked waiting for\nthe lock to acquire the lock.  The lock must be in the locked state,\nbut it needn't be locked by the same thread that unlocks it.",
    "_thread.LockType.release_lock" => "An obsolete synonym of release().",
    "_thread.RLock.__delattr__" => "Implement delattr(self, name).",
    "_thread.RLock.__enter__" => "Lock the lock.",
    "_thread.RLock.__eq__" => "Return self==value.",
    "_thread.RLock.__exit__" => "Release the lock.",
    "_thread.RLock.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_thread.RLock.__ge__" => "Return self>=value.",
    "_thread.RLock.__getattribute__" => "Return getattr(self, name).",
    "_thread.RLock.__getstate__" => "Helper for pickle.",
    "_thread.RLock.__gt__" => "Return self>value.",
    "_thread.RLock.__hash__" => "Return hash(self).",
    "_thread.RLock.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_thread.RLock.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_thread.RLock.__le__" => "Return self<=value.",
    "_thread.RLock.__lt__" => "Return self<value.",
    "_thread.RLock.__ne__" => "Return self!=value.",
    "_thread.RLock.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_thread.RLock.__reduce__" => "Helper for pickle.",
    "_thread.RLock.__reduce_ex__" => "Helper for pickle.",
    "_thread.RLock.__repr__" => "Return repr(self).",
    "_thread.RLock.__setattr__" => "Implement setattr(self, name, value).",
    "_thread.RLock.__sizeof__" => "Size of object in memory, in bytes.",
    "_thread.RLock.__str__" => "Return str(self).",
    "_thread.RLock.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_thread.RLock._acquire_restore" => "For internal use by `threading.Condition`.",
    "_thread.RLock._is_owned" => "For internal use by `threading.Condition`.",
    "_thread.RLock._recursion_count" => "For internal use by reentrancy checks.",
    "_thread.RLock._release_save" => "For internal use by `threading.Condition`.",
    "_thread.RLock.acquire" => "Lock the lock.  `blocking` indicates whether we should wait\nfor the lock to be available or not.  If `blocking` is False\nand another thread holds the lock, the method will return False\nimmediately.  If `blocking` is True and another thread holds\nthe lock, the method will wait for the lock to be released,\ntake it and then return True.\n(note: the blocking operation is interruptible.)\n\nIn all other cases, the method will return True immediately.\nPrecisely, if the current thread already holds the lock, its\ninternal counter is simply incremented. If nobody holds the lock,\nthe lock is taken and its internal counter initialized to 1.",
    "_thread.RLock.release" => "Release the lock, allowing another thread that is blocked waiting for\nthe lock to acquire the lock.  The lock must be in the locked state,\nand must be locked by the same thread that unlocks it; otherwise a\n`RuntimeError` is raised.\n\nDo note that if the lock was acquire()d several times in a row by the\ncurrent thread, release() needs to be called as many times for the lock\nto be available for other threads.",
    "_thread._ExceptHookArgs" => "ExceptHookArgs\n\nType used to pass arguments to threading.excepthook.",
    "_thread._ExceptHookArgs.__add__" => "Return self+value.",
    "_thread._ExceptHookArgs.__class_getitem__" => "See PEP 585",
    "_thread._ExceptHookArgs.__contains__" => "Return bool(key in self).",
    "_thread._ExceptHookArgs.__delattr__" => "Implement delattr(self, name).",
    "_thread._ExceptHookArgs.__eq__" => "Return self==value.",
    "_thread._ExceptHookArgs.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_thread._ExceptHookArgs.__ge__" => "Return self>=value.",
    "_thread._ExceptHookArgs.__getattribute__" => "Return getattr(self, name).",
    "_thread._ExceptHookArgs.__getitem__" => "Return self[key].",
    "_thread._ExceptHookArgs.__getstate__" => "Helper for pickle.",
    "_thread._ExceptHookArgs.__gt__" => "Return self>value.",
    "_thread._ExceptHookArgs.__hash__" => "Return hash(self).",
    "_thread._ExceptHookArgs.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_thread._ExceptHookArgs.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_thread._ExceptHookArgs.__iter__" => "Implement iter(self).",
    "_thread._ExceptHookArgs.__le__" => "Return self<=value.",
    "_thread._ExceptHookArgs.__len__" => "Return len(self).",
    "_thread._ExceptHookArgs.__lt__" => "Return self<value.",
    "_thread._ExceptHookArgs.__mul__" => "Return self*value.",
    "_thread._ExceptHookArgs.__ne__" => "Return self!=value.",
    "_thread._ExceptHookArgs.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_thread._ExceptHookArgs.__reduce_ex__" => "Helper for pickle.",
    "_thread._ExceptHookArgs.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "_thread._ExceptHookArgs.__repr__" => "Return repr(self).",
    "_thread._ExceptHookArgs.__rmul__" => "Return value*self.",
    "_thread._ExceptHookArgs.__setattr__" => "Implement setattr(self, name, value).",
    "_thread._ExceptHookArgs.__sizeof__" => "Size of object in memory, in bytes.",
    "_thread._ExceptHookArgs.__str__" => "Return str(self).",
    "_thread._ExceptHookArgs.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_thread._ExceptHookArgs.count" => "Return number of occurrences of value.",
    "_thread._ExceptHookArgs.exc_traceback" => "Exception traceback",
    "_thread._ExceptHookArgs.exc_type" => "Exception type",
    "_thread._ExceptHookArgs.exc_value" => "Exception value",
    "_thread._ExceptHookArgs.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "_thread._ExceptHookArgs.thread" => "Thread",
    "_thread._ThreadHandle.__delattr__" => "Implement delattr(self, name).",
    "_thread._ThreadHandle.__eq__" => "Return self==value.",
    "_thread._ThreadHandle.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_thread._ThreadHandle.__ge__" => "Return self>=value.",
    "_thread._ThreadHandle.__getattribute__" => "Return getattr(self, name).",
    "_thread._ThreadHandle.__getstate__" => "Helper for pickle.",
    "_thread._ThreadHandle.__gt__" => "Return self>value.",
    "_thread._ThreadHandle.__hash__" => "Return hash(self).",
    "_thread._ThreadHandle.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_thread._ThreadHandle.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_thread._ThreadHandle.__le__" => "Return self<=value.",
    "_thread._ThreadHandle.__lt__" => "Return self<value.",
    "_thread._ThreadHandle.__ne__" => "Return self!=value.",
    "_thread._ThreadHandle.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_thread._ThreadHandle.__reduce__" => "Helper for pickle.",
    "_thread._ThreadHandle.__reduce_ex__" => "Helper for pickle.",
    "_thread._ThreadHandle.__repr__" => "Return repr(self).",
    "_thread._ThreadHandle.__setattr__" => "Implement setattr(self, name, value).",
    "_thread._ThreadHandle.__sizeof__" => "Size of object in memory, in bytes.",
    "_thread._ThreadHandle.__str__" => "Return str(self).",
    "_thread._ThreadHandle.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_thread._count" => "Return the number of currently running Python threads, excluding\nthe main thread. The returned number comprises all threads created\nthrough `start_new_thread()` as well as `threading.Thread`, and not\nyet finished.\n\nThis function is meant for internal and specialized purposes only.\nIn most applications `threading.enumerate()` should be used instead.",
    "_thread._excepthook" => "Handle uncaught Thread.run() exception.",
    "_thread._get_main_thread_ident" => "Internal only. Return a non-zero integer that uniquely identifies the main thread\nof the main interpreter.",
    "_thread._is_main_interpreter" => "Return True if the current interpreter is the main Python interpreter.",
    "_thread._local" => "Thread-local data",
    "_thread._local.__delattr__" => "Implement delattr(self, name).",
    "_thread._local.__eq__" => "Return self==value.",
    "_thread._local.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_thread._local.__ge__" => "Return self>=value.",
    "_thread._local.__getattribute__" => "Return getattr(self, name).",
    "_thread._local.__getstate__" => "Helper for pickle.",
    "_thread._local.__gt__" => "Return self>value.",
    "_thread._local.__hash__" => "Return hash(self).",
    "_thread._local.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_thread._local.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_thread._local.__le__" => "Return self<=value.",
    "_thread._local.__lt__" => "Return self<value.",
    "_thread._local.__ne__" => "Return self!=value.",
    "_thread._local.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_thread._local.__reduce__" => "Helper for pickle.",
    "_thread._local.__reduce_ex__" => "Helper for pickle.",
    "_thread._local.__repr__" => "Return repr(self).",
    "_thread._local.__setattr__" => "Implement setattr(self, name, value).",
    "_thread._local.__sizeof__" => "Size of object in memory, in bytes.",
    "_thread._local.__str__" => "Return str(self).",
    "_thread._local.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_thread._make_thread_handle" => "Internal only. Make a thread handle for threads not spawned\nby the _thread or threading module.",
    "_thread._shutdown" => "Wait for all non-daemon threads (other than the calling thread) to stop.",
    "_thread.allocate" => "An obsolete synonym of allocate_lock().",
    "_thread.allocate_lock" => "Create a new lock object. See help(type(threading.Lock())) for\ninformation about locks.",
    "_thread.daemon_threads_allowed" => "Return True if daemon threads are allowed in the current interpreter,\nand False otherwise.",
    "_thread.exit" => "This is synonymous to ``raise SystemExit''.  It will cause the current\nthread to exit silently unless the exception is caught.",
    "_thread.exit_thread" => "An obsolete synonym of exit().",
    "_thread.get_ident" => "Return a non-zero integer that uniquely identifies the current thread\namongst other threads that exist simultaneously.\nThis may be used to identify per-thread resources.\nEven though on some platforms threads identities may appear to be\nallocated consecutive numbers starting at 1, this behavior should not\nbe relied upon, and the number should be seen purely as a magic cookie.\nA thread's identity may be reused for another thread after it exits.",
    "_thread.get_native_id" => "Return a non-negative integer identifying the thread as reported\nby the OS (kernel). This may be used to uniquely identify a\nparticular thread within a system.",
    "_thread.interrupt_main" => "Simulate the arrival of the given signal in the main thread,\nwhere the corresponding signal handler will be executed.\nIf *signum* is omitted, SIGINT is assumed.\nA subthread can use this function to interrupt the main thread.\n\nNote: the default signal handler for SIGINT raises ``KeyboardInterrupt``.",
    "_thread.lock" => "A lock object is a synchronization primitive.  To create a lock,\ncall threading.Lock().  Methods are:\n\nacquire() -- lock the lock, possibly blocking until it can be obtained\nrelease() -- unlock of the lock\nlocked() -- test whether the lock is currently locked\n\nA lock is not owned by the thread that locked it; another thread may\nunlock it.  A thread attempting to lock a lock that it has already locked\nwill block until another thread unlocks it.  Deadlocks may ensue.",
    "_thread.lock.__delattr__" => "Implement delattr(self, name).",
    "_thread.lock.__enter__" => "Lock the lock.",
    "_thread.lock.__eq__" => "Return self==value.",
    "_thread.lock.__exit__" => "Release the lock.",
    "_thread.lock.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_thread.lock.__ge__" => "Return self>=value.",
    "_thread.lock.__getattribute__" => "Return getattr(self, name).",
    "_thread.lock.__getstate__" => "Helper for pickle.",
    "_thread.lock.__gt__" => "Return self>value.",
    "_thread.lock.__hash__" => "Return hash(self).",
    "_thread.lock.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_thread.lock.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_thread.lock.__le__" => "Return self<=value.",
    "_thread.lock.__lt__" => "Return self<value.",
    "_thread.lock.__ne__" => "Return self!=value.",
    "_thread.lock.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_thread.lock.__reduce__" => "Helper for pickle.",
    "_thread.lock.__reduce_ex__" => "Helper for pickle.",
    "_thread.lock.__repr__" => "Return repr(self).",
    "_thread.lock.__setattr__" => "Implement setattr(self, name, value).",
    "_thread.lock.__sizeof__" => "Size of object in memory, in bytes.",
    "_thread.lock.__str__" => "Return str(self).",
    "_thread.lock.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_thread.lock.acquire" => "Lock the lock.  Without argument, this blocks if the lock is already\nlocked (even by the same thread), waiting for another thread to release\nthe lock, and return True once the lock is acquired.\nWith an argument, this will only block if the argument is true,\nand the return value reflects whether the lock is acquired.\nThe blocking operation is interruptible.",
    "_thread.lock.acquire_lock" => "An obsolete synonym of acquire().",
    "_thread.lock.locked" => "Return whether the lock is in the locked state.",
    "_thread.lock.locked_lock" => "An obsolete synonym of locked().",
    "_thread.lock.release" => "Release the lock, allowing another thread that is blocked waiting for\nthe lock to acquire the lock.  The lock must be in the locked state,\nbut it needn't be locked by the same thread that unlocks it.",
    "_thread.lock.release_lock" => "An obsolete synonym of release().",
    "_thread.stack_size" => "Return the thread stack size used when creating new threads.  The\noptional size argument specifies the stack size (in bytes) to be used\nfor subsequently created threads, and must be 0 (use platform or\nconfigured default) or a positive integer value of at least 32,768 (32k).\nIf changing the thread stack size is unsupported, a ThreadError\nexception is raised.  If the specified size is invalid, a ValueError\nexception is raised, and the stack size is unmodified.  32k bytes\n currently the minimum supported stack size value to guarantee\nsufficient stack space for the interpreter itself.\n\nNote that some platforms may have particular restrictions on values for\nthe stack size, such as requiring a minimum stack size larger than 32 KiB or\nrequiring allocation in multiples of the system memory page size\n- platform documentation should be referred to for more information\n(4 KiB pages are common; using multiples of 4096 for the stack size is\nthe suggested approach in the absence of more specific information).",
    "_thread.start_joinable_thread" => "*For internal use only*: start a new thread.\n\nLike start_new_thread(), this starts a new thread calling the given function.\nUnlike start_new_thread(), this returns a handle object with methods to join\nor detach the given thread.\nThis function is not for third-party code, please use the\n`threading` module instead. During finalization the runtime will not wait for\nthe thread to exit if daemon is True. If handle is provided it must be a\nnewly created thread._ThreadHandle instance.",
    "_thread.start_new" => "An obsolete synonym of start_new_thread().",
    "_thread.start_new_thread" => "Start a new thread and return its identifier.\n\nThe thread will call the function with positional arguments from the\ntuple args and keyword arguments taken from the optional dictionary\nkwargs.  The thread exits when the function returns; the return value\nis ignored.  The thread will also exit when the function raises an\nunhandled exception; a stack trace will be printed unless the exception\nis SystemExit.",
    "_tkinter.TclError.__cause__" => "exception cause",
    "_tkinter.TclError.__context__" => "exception context",
    "_tkinter.TclError.__delattr__" => "Implement delattr(self, name).",
    "_tkinter.TclError.__eq__" => "Return self==value.",
    "_tkinter.TclError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_tkinter.TclError.__ge__" => "Return self>=value.",
    "_tkinter.TclError.__getattribute__" => "Return getattr(self, name).",
    "_tkinter.TclError.__getstate__" => "Helper for pickle.",
    "_tkinter.TclError.__gt__" => "Return self>value.",
    "_tkinter.TclError.__hash__" => "Return hash(self).",
    "_tkinter.TclError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_tkinter.TclError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_tkinter.TclError.__le__" => "Return self<=value.",
    "_tkinter.TclError.__lt__" => "Return self<value.",
    "_tkinter.TclError.__ne__" => "Return self!=value.",
    "_tkinter.TclError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_tkinter.TclError.__reduce_ex__" => "Helper for pickle.",
    "_tkinter.TclError.__repr__" => "Return repr(self).",
    "_tkinter.TclError.__setattr__" => "Implement setattr(self, name, value).",
    "_tkinter.TclError.__sizeof__" => "Size of object in memory, in bytes.",
    "_tkinter.TclError.__str__" => "Return str(self).",
    "_tkinter.TclError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_tkinter.TclError.__weakref__" => "list of weak references to the object",
    "_tkinter.TclError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "_tkinter.TclError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "_tkinter.Tcl_Obj.__delattr__" => "Implement delattr(self, name).",
    "_tkinter.Tcl_Obj.__eq__" => "Return self==value.",
    "_tkinter.Tcl_Obj.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_tkinter.Tcl_Obj.__ge__" => "Return self>=value.",
    "_tkinter.Tcl_Obj.__getattribute__" => "Return getattr(self, name).",
    "_tkinter.Tcl_Obj.__getstate__" => "Helper for pickle.",
    "_tkinter.Tcl_Obj.__gt__" => "Return self>value.",
    "_tkinter.Tcl_Obj.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_tkinter.Tcl_Obj.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_tkinter.Tcl_Obj.__le__" => "Return self<=value.",
    "_tkinter.Tcl_Obj.__lt__" => "Return self<value.",
    "_tkinter.Tcl_Obj.__ne__" => "Return self!=value.",
    "_tkinter.Tcl_Obj.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_tkinter.Tcl_Obj.__reduce__" => "Helper for pickle.",
    "_tkinter.Tcl_Obj.__reduce_ex__" => "Helper for pickle.",
    "_tkinter.Tcl_Obj.__repr__" => "Return repr(self).",
    "_tkinter.Tcl_Obj.__setattr__" => "Implement setattr(self, name, value).",
    "_tkinter.Tcl_Obj.__sizeof__" => "Size of object in memory, in bytes.",
    "_tkinter.Tcl_Obj.__str__" => "Return str(self).",
    "_tkinter.Tcl_Obj.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_tkinter.Tcl_Obj.string" => "the string representation of this object, either as str or bytes",
    "_tkinter.Tcl_Obj.typename" => "name of the Tcl type",
    "_tkinter.TkappType.__delattr__" => "Implement delattr(self, name).",
    "_tkinter.TkappType.__eq__" => "Return self==value.",
    "_tkinter.TkappType.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_tkinter.TkappType.__ge__" => "Return self>=value.",
    "_tkinter.TkappType.__getattribute__" => "Return getattr(self, name).",
    "_tkinter.TkappType.__getstate__" => "Helper for pickle.",
    "_tkinter.TkappType.__gt__" => "Return self>value.",
    "_tkinter.TkappType.__hash__" => "Return hash(self).",
    "_tkinter.TkappType.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_tkinter.TkappType.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_tkinter.TkappType.__le__" => "Return self<=value.",
    "_tkinter.TkappType.__lt__" => "Return self<value.",
    "_tkinter.TkappType.__ne__" => "Return self!=value.",
    "_tkinter.TkappType.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_tkinter.TkappType.__reduce__" => "Helper for pickle.",
    "_tkinter.TkappType.__reduce_ex__" => "Helper for pickle.",
    "_tkinter.TkappType.__repr__" => "Return repr(self).",
    "_tkinter.TkappType.__setattr__" => "Implement setattr(self, name, value).",
    "_tkinter.TkappType.__sizeof__" => "Size of object in memory, in bytes.",
    "_tkinter.TkappType.__str__" => "Return str(self).",
    "_tkinter.TkappType.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_tkinter.TkappType.gettrace" => "Get the tracing function.",
    "_tkinter.TkappType.settrace" => "Set the tracing function.",
    "_tkinter.TkttType.__delattr__" => "Implement delattr(self, name).",
    "_tkinter.TkttType.__eq__" => "Return self==value.",
    "_tkinter.TkttType.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_tkinter.TkttType.__ge__" => "Return self>=value.",
    "_tkinter.TkttType.__getattribute__" => "Return getattr(self, name).",
    "_tkinter.TkttType.__getstate__" => "Helper for pickle.",
    "_tkinter.TkttType.__gt__" => "Return self>value.",
    "_tkinter.TkttType.__hash__" => "Return hash(self).",
    "_tkinter.TkttType.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_tkinter.TkttType.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_tkinter.TkttType.__le__" => "Return self<=value.",
    "_tkinter.TkttType.__lt__" => "Return self<value.",
    "_tkinter.TkttType.__ne__" => "Return self!=value.",
    "_tkinter.TkttType.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_tkinter.TkttType.__reduce__" => "Helper for pickle.",
    "_tkinter.TkttType.__reduce_ex__" => "Helper for pickle.",
    "_tkinter.TkttType.__repr__" => "Return repr(self).",
    "_tkinter.TkttType.__setattr__" => "Implement setattr(self, name, value).",
    "_tkinter.TkttType.__sizeof__" => "Size of object in memory, in bytes.",
    "_tkinter.TkttType.__str__" => "Return str(self).",
    "_tkinter.TkttType.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_tkinter.create" => "wantTk\n  if false, then Tk_Init() doesn't get called\nsync\n  if true, then pass -sync to wish\nuse\n  if not None, then pass -use to wish",
    "_tkinter.getbusywaitinterval" => "Return the current busy-wait interval between successive calls to Tcl_DoOneEvent in a threaded Python interpreter.",
    "_tkinter.setbusywaitinterval" => "Set the busy-wait interval in milliseconds between successive calls to Tcl_DoOneEvent in a threaded Python interpreter.\n\nIt should be set to a divisor of the maximum time between frames in an animation.",
    "_tokenize.TokenizerIter.__delattr__" => "Implement delattr(self, name).",
    "_tokenize.TokenizerIter.__eq__" => "Return self==value.",
    "_tokenize.TokenizerIter.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_tokenize.TokenizerIter.__ge__" => "Return self>=value.",
    "_tokenize.TokenizerIter.__getattribute__" => "Return getattr(self, name).",
    "_tokenize.TokenizerIter.__getstate__" => "Helper for pickle.",
    "_tokenize.TokenizerIter.__gt__" => "Return self>value.",
    "_tokenize.TokenizerIter.__hash__" => "Return hash(self).",
    "_tokenize.TokenizerIter.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_tokenize.TokenizerIter.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_tokenize.TokenizerIter.__iter__" => "Implement iter(self).",
    "_tokenize.TokenizerIter.__le__" => "Return self<=value.",
    "_tokenize.TokenizerIter.__lt__" => "Return self<value.",
    "_tokenize.TokenizerIter.__ne__" => "Return self!=value.",
    "_tokenize.TokenizerIter.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_tokenize.TokenizerIter.__next__" => "Implement next(self).",
    "_tokenize.TokenizerIter.__reduce__" => "Helper for pickle.",
    "_tokenize.TokenizerIter.__reduce_ex__" => "Helper for pickle.",
    "_tokenize.TokenizerIter.__repr__" => "Return repr(self).",
    "_tokenize.TokenizerIter.__setattr__" => "Implement setattr(self, name, value).",
    "_tokenize.TokenizerIter.__sizeof__" => "Size of object in memory, in bytes.",
    "_tokenize.TokenizerIter.__str__" => "Return str(self).",
    "_tokenize.TokenizerIter.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_tracemalloc" => "Debug module to trace memory blocks allocated by Python.",
    "_tracemalloc._get_object_traceback" => "Get the traceback where the Python object obj was allocated.\n\nReturn a tuple of (filename: str, lineno: int) tuples.\nReturn None if the tracemalloc module is disabled or did not\ntrace the allocation of the object.",
    "_tracemalloc._get_traces" => "Get traces of all memory blocks allocated by Python.\n\nReturn a list of (size: int, traceback: tuple) tuples.\ntraceback is a tuple of (filename: str, lineno: int) tuples.\n\nReturn an empty list if the tracemalloc module is disabled.",
    "_tracemalloc.clear_traces" => "Clear traces of memory blocks allocated by Python.",
    "_tracemalloc.get_traceback_limit" => "Get the maximum number of frames stored in the traceback of a trace.\n\nBy default, a trace of an allocated memory block only stores\nthe most recent frame: the limit is 1.",
    "_tracemalloc.get_traced_memory" => "Get the current size and peak size of memory blocks traced by tracemalloc.\n\nReturns a tuple: (current: int, peak: int).",
    "_tracemalloc.get_tracemalloc_memory" => "Get the memory usage in bytes of the tracemalloc module.\n\nThis memory is used internally to trace memory allocations.",
    "_tracemalloc.is_tracing" => "Return True if the tracemalloc module is tracing Python memory allocations.",
    "_tracemalloc.reset_peak" => "Set the peak size of memory blocks traced by tracemalloc to the current size.\n\nDo nothing if the tracemalloc module is not tracing memory allocations.",
    "_tracemalloc.start" => "Start tracing Python memory allocations.\n\nAlso set the maximum number of frames stored in the traceback of a\ntrace to nframe.",
    "_tracemalloc.stop" => "Stop tracing Python memory allocations.\n\nAlso clear traces of memory blocks allocated by Python.",
    "_typing" => "Primitives and accelerators for the typing module.",
    "_warnings" => "_warnings provides basic warning filtering support.\nIt is a helper module to speed up interpreter start-up.",
    "_warnings.warn" => "Issue a warning, or maybe ignore it or raise an exception.\n\nmessage\n  Text of the warning message.\ncategory\n  The Warning category subclass. Defaults to UserWarning.\nstacklevel\n  How far up the call stack to make this warning appear. A value of 2 for\n  example attributes the warning to the caller of the code calling warn().\nsource\n  If supplied, the destroyed object which emitted a ResourceWarning\nskip_file_prefixes\n  An optional tuple of module filename prefixes indicating frames to skip\n  during stacklevel computations for stack frame attribution.",
    "_warnings.warn_explicit" => "Issue a warning, or maybe ignore it or raise an exception.",
    "_weakref" => "Weak-reference support module.",
    "_weakref._remove_dead_weakref" => "Atomically remove key from dict if it points to a dead weakref.",
    "_weakref.getweakrefcount" => "Return the number of weak references to 'object'.",
    "_weakref.getweakrefs" => "Return a list of all weak reference objects pointing to 'object'.",
    "_weakref.proxy" => "Create a proxy object that weakly references 'object'.\n\n'callback', if given, is called with a reference to the\nproxy when 'object' is about to be finalized.",
    "_winapi.BatchedWaitForMultipleObjects" => "Supports a larger number of handles than WaitForMultipleObjects\n\nNote that the handles may be waited on other threads, which could cause\nissues for objects like mutexes that become associated with the thread\nthat was waiting for them. Objects may also be left signalled, even if\nthe wait fails.\n\nIt is recommended to use WaitForMultipleObjects whenever possible, and\nonly switch to BatchedWaitForMultipleObjects for scenarios where you\ncontrol all the handles involved, such as your own thread pool or\nfiles, and all wait objects are left unmodified by a wait (for example,\nmanual reset events, threads, and files/pipes).\n\nOverlapped handles returned from this module use manual reset events.",
    "_winapi.CloseHandle" => "Close handle.",
    "_winapi.CopyFile2" => "Copies a file from one name to a new name.\n\nThis is implemented using the CopyFile2 API, which preserves all stat\nand metadata information apart from security attributes.\n\nprogress_routine is reserved for future use, but is currently not\nimplemented. Its value is ignored.",
    "_winapi.CreatePipe" => "Create an anonymous pipe.\n\n  pipe_attrs\n    Ignored internally, can be None.\n\nReturns a 2-tuple of handles, to the read and write ends of the pipe.",
    "_winapi.CreateProcess" => "Create a new process and its primary thread.\n\n  command_line\n    Can be str or None\n  proc_attrs\n    Ignored internally, can be None.\n  thread_attrs\n    Ignored internally, can be None.\n\nThe return value is a tuple of the process handle, thread handle,\nprocess ID, and thread ID.",
    "_winapi.DuplicateHandle" => "Return a duplicate handle object.\n\nThe duplicate handle refers to the same object as the original\nhandle. Therefore, any changes to the object are reflected\nthrough both handles.",
    "_winapi.GetACP" => "Get the current Windows ANSI code page identifier.",
    "_winapi.GetCurrentProcess" => "Return a handle object for the current process.",
    "_winapi.GetExitCodeProcess" => "Return the termination status of the specified process.",
    "_winapi.GetLongPathName" => "Return the long version of the provided path.\n\nIf the path is already in its long form, returns the same value.\n\nThe path must already be a 'str'. If the type is not known, use\nos.fsdecode before calling this function.",
    "_winapi.GetModuleFileName" => "Return the fully-qualified path for the file that contains module.\n\nThe module must have been loaded by the current process.\n\nThe module parameter should be a handle to the loaded module\nwhose path is being requested. If this parameter is 0,\nGetModuleFileName retrieves the path of the executable file\nof the current process.",
    "_winapi.GetShortPathName" => "Return the short version of the provided path.\n\nIf the path is already in its short form, returns the same value.\n\nThe path must already be a 'str'. If the type is not known, use\nos.fsdecode before calling this function.",
    "_winapi.GetStdHandle" => "Return a handle to the specified standard device.\n\n  std_handle\n    One of STD_INPUT_HANDLE, STD_OUTPUT_HANDLE, or STD_ERROR_HANDLE.\n\nThe integer associated with the handle object is returned.",
    "_winapi.GetVersion" => "Return the version number of the current operating system.",
    "_winapi.Overlapped" => "OVERLAPPED structure wrapper",
    "_winapi.Overlapped.__delattr__" => "Implement delattr(self, name).",
    "_winapi.Overlapped.__eq__" => "Return self==value.",
    "_winapi.Overlapped.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "_winapi.Overlapped.__ge__" => "Return self>=value.",
    "_winapi.Overlapped.__getattribute__" => "Return getattr(self, name).",
    "_winapi.Overlapped.__getstate__" => "Helper for pickle.",
    "_winapi.Overlapped.__gt__" => "Return self>value.",
    "_winapi.Overlapped.__hash__" => "Return hash(self).",
    "_winapi.Overlapped.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "_winapi.Overlapped.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "_winapi.Overlapped.__le__" => "Return self<=value.",
    "_winapi.Overlapped.__lt__" => "Return self<value.",
    "_winapi.Overlapped.__ne__" => "Return self!=value.",
    "_winapi.Overlapped.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "_winapi.Overlapped.__reduce__" => "Helper for pickle.",
    "_winapi.Overlapped.__reduce_ex__" => "Helper for pickle.",
    "_winapi.Overlapped.__repr__" => "Return repr(self).",
    "_winapi.Overlapped.__setattr__" => "Implement setattr(self, name, value).",
    "_winapi.Overlapped.__sizeof__" => "Size of object in memory, in bytes.",
    "_winapi.Overlapped.__str__" => "Return str(self).",
    "_winapi.Overlapped.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "_winapi.Overlapped.event" => "overlapped event handle",
    "_winapi.TerminateProcess" => "Terminate the specified process and all of its threads.",
    "_winapi.WaitForSingleObject" => "Wait for a single object.\n\nWait until the specified object is in the signaled state or\nthe time-out interval elapses. The timeout value is specified\nin milliseconds.",
    "_winapi._mimetypes_read_windows_registry" => "Optimized function for reading all known MIME types from the registry.\n\n*on_type_read* is a callable taking *type* and *ext* arguments, as for\nMimeTypes.add_type.",
    "_wmi.exec_query" => "Runs a WMI query against the local machine.\n\nThis returns a single string with 'name=value' pairs in a flat array separated\nby null characters.",
    "_zoneinfo" => "C implementation of the zoneinfo module",
    "array" => "This module defines an object type which can efficiently represent\nan array of basic values: characters, integers, floating-point\nnumbers.  Arrays are sequence types and behave very much like lists,\nexcept that the type of objects stored in them is constrained.",
    "array.ArrayType" => "array(typecode [, initializer]) -> array\n\nReturn a new array whose items are restricted by typecode, and\ninitialized from the optional initializer value, which must be a list,\nstring or iterable over elements of the appropriate type.\n\nArrays represent basic values and behave very much like lists, except\nthe type of objects stored in them is constrained. The type is specified\nat object creation time by using a type code, which is a single character.\nThe following type codes are defined:\n\n    Type code   C Type             Minimum size in bytes\n    'b'         signed integer     1\n    'B'         unsigned integer   1\n    'u'         Unicode character  2 (see note)\n    'h'         signed integer     2\n    'H'         unsigned integer   2\n    'i'         signed integer     2\n    'I'         unsigned integer   2\n    'l'         signed integer     4\n    'L'         unsigned integer   4\n    'q'         signed integer     8 (see note)\n    'Q'         unsigned integer   8 (see note)\n    'f'         floating-point     4\n    'd'         floating-point     8\n\nNOTE: The 'u' typecode corresponds to Python's unicode character. On\nnarrow builds this is 2-bytes on wide builds this is 4-bytes.\n\nNOTE: The 'q' and 'Q' type codes are only available if the platform\nC compiler used to build Python supports 'long long', or, on Windows,\n'__int64'.\n\nMethods:\n\nappend() -- append a new item to the end of the array\nbuffer_info() -- return information giving the current memory info\nbyteswap() -- byteswap all the items of the array\ncount() -- return number of occurrences of an object\nextend() -- extend array by appending multiple elements from an iterable\nfromfile() -- read items from a file object\nfromlist() -- append items from the list\nfrombytes() -- append items from the string\nindex() -- return index of first occurrence of an object\ninsert() -- insert a new item into the array at a provided position\npop() -- remove and return item (default last)\nremove() -- remove first occurrence of an object\nreverse() -- reverse the order of the items in the array\ntofile() -- write all items to a file object\ntolist() -- return the array converted to an ordinary list\ntobytes() -- return the array converted to a string\n\nAttributes:\n\ntypecode -- the typecode character used to create the array\nitemsize -- the length in bytes of one array item",
    "array.ArrayType.__add__" => "Return self+value.",
    "array.ArrayType.__buffer__" => "Return a buffer object that exposes the underlying memory of the object.",
    "array.ArrayType.__class_getitem__" => "See PEP 585",
    "array.ArrayType.__contains__" => "Return bool(key in self).",
    "array.ArrayType.__copy__" => "Return a copy of the array.",
    "array.ArrayType.__deepcopy__" => "Return a copy of the array.",
    "array.ArrayType.__delattr__" => "Implement delattr(self, name).",
    "array.ArrayType.__delitem__" => "Delete self[key].",
    "array.ArrayType.__eq__" => "Return self==value.",
    "array.ArrayType.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "array.ArrayType.__ge__" => "Return self>=value.",
    "array.ArrayType.__getattribute__" => "Return getattr(self, name).",
    "array.ArrayType.__getitem__" => "Return self[key].",
    "array.ArrayType.__getstate__" => "Helper for pickle.",
    "array.ArrayType.__gt__" => "Return self>value.",
    "array.ArrayType.__iadd__" => "Implement self+=value.",
    "array.ArrayType.__imul__" => "Implement self*=value.",
    "array.ArrayType.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "array.ArrayType.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "array.ArrayType.__iter__" => "Implement iter(self).",
    "array.ArrayType.__le__" => "Return self<=value.",
    "array.ArrayType.__len__" => "Return len(self).",
    "array.ArrayType.__lt__" => "Return self<value.",
    "array.ArrayType.__mul__" => "Return self*value.",
    "array.ArrayType.__ne__" => "Return self!=value.",
    "array.ArrayType.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "array.ArrayType.__reduce__" => "Helper for pickle.",
    "array.ArrayType.__reduce_ex__" => "Return state information for pickling.",
    "array.ArrayType.__release_buffer__" => "Release the buffer object that exposes the underlying memory of the object.",
    "array.ArrayType.__repr__" => "Return repr(self).",
    "array.ArrayType.__rmul__" => "Return value*self.",
    "array.ArrayType.__setattr__" => "Implement setattr(self, name, value).",
    "array.ArrayType.__setitem__" => "Set self[key] to value.",
    "array.ArrayType.__sizeof__" => "Size of the array in memory, in bytes.",
    "array.ArrayType.__str__" => "Return str(self).",
    "array.ArrayType.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "array.ArrayType.append" => "Append new value v to the end of the array.",
    "array.ArrayType.buffer_info" => "Return a tuple (address, length) giving the current memory address and the length in items of the buffer used to hold array's contents.\n\nThe length should be multiplied by the itemsize attribute to calculate\nthe buffer length in bytes.",
    "array.ArrayType.byteswap" => "Byteswap all items of the array.\n\nIf the items in the array are not 1, 2, 4, or 8 bytes in size, RuntimeError is\nraised.",
    "array.ArrayType.clear" => "Remove all items from the array.",
    "array.ArrayType.count" => "Return number of occurrences of v in the array.",
    "array.ArrayType.extend" => "Append items to the end of the array.",
    "array.ArrayType.frombytes" => "Appends items from the string, interpreting it as an array of machine values, as if it had been read from a file using the fromfile() method.",
    "array.ArrayType.fromfile" => "Read n objects from the file object f and append them to the end of the array.",
    "array.ArrayType.fromlist" => "Append items to array from list.",
    "array.ArrayType.fromunicode" => "Extends this array with data from the unicode string ustr.\n\nThe array must be a unicode type array; otherwise a ValueError is raised.\nUse array.frombytes(ustr.encode(...)) to append Unicode data to an array of\nsome other type.",
    "array.ArrayType.index" => "Return index of first occurrence of v in the array.\n\nRaise ValueError if the value is not present.",
    "array.ArrayType.insert" => "Insert a new item v into the array before position i.",
    "array.ArrayType.itemsize" => "the size, in bytes, of one array item",
    "array.ArrayType.pop" => "Return the i-th element and delete it from the array.\n\ni defaults to -1.",
    "array.ArrayType.remove" => "Remove the first occurrence of v in the array.",
    "array.ArrayType.reverse" => "Reverse the order of the items in the array.",
    "array.ArrayType.tobytes" => "Convert the array to an array of machine values and return the bytes representation.",
    "array.ArrayType.tofile" => "Write all items (as machine values) to the file object f.",
    "array.ArrayType.tolist" => "Convert array to an ordinary list with the same items.",
    "array.ArrayType.tounicode" => "Extends this array with data from the unicode string ustr.\n\nConvert the array to a unicode string.  The array must be a unicode type array;\notherwise a ValueError is raised.  Use array.tobytes().decode() to obtain a\nunicode string from an array of some other type.",
    "array.ArrayType.typecode" => "the typecode character used to create the array",
    "array._array_reconstructor" => "Internal. Used for pickling support.",
    "array.array" => "array(typecode [, initializer]) -> array\n\nReturn a new array whose items are restricted by typecode, and\ninitialized from the optional initializer value, which must be a list,\nstring or iterable over elements of the appropriate type.\n\nArrays represent basic values and behave very much like lists, except\nthe type of objects stored in them is constrained. The type is specified\nat object creation time by using a type code, which is a single character.\nThe following type codes are defined:\n\n    Type code   C Type             Minimum size in bytes\n    'b'         signed integer     1\n    'B'         unsigned integer   1\n    'u'         Unicode character  2 (see note)\n    'h'         signed integer     2\n    'H'         unsigned integer   2\n    'i'         signed integer     2\n    'I'         unsigned integer   2\n    'l'         signed integer     4\n    'L'         unsigned integer   4\n    'q'         signed integer     8 (see note)\n    'Q'         unsigned integer   8 (see note)\n    'f'         floating-point     4\n    'd'         floating-point     8\n\nNOTE: The 'u' typecode corresponds to Python's unicode character. On\nnarrow builds this is 2-bytes on wide builds this is 4-bytes.\n\nNOTE: The 'q' and 'Q' type codes are only available if the platform\nC compiler used to build Python supports 'long long', or, on Windows,\n'__int64'.\n\nMethods:\n\nappend() -- append a new item to the end of the array\nbuffer_info() -- return information giving the current memory info\nbyteswap() -- byteswap all the items of the array\ncount() -- return number of occurrences of an object\nextend() -- extend array by appending multiple elements from an iterable\nfromfile() -- read items from a file object\nfromlist() -- append items from the list\nfrombytes() -- append items from the string\nindex() -- return index of first occurrence of an object\ninsert() -- insert a new item into the array at a provided position\npop() -- remove and return item (default last)\nremove() -- remove first occurrence of an object\nreverse() -- reverse the order of the items in the array\ntofile() -- write all items to a file object\ntolist() -- return the array converted to an ordinary list\ntobytes() -- return the array converted to a string\n\nAttributes:\n\ntypecode -- the typecode character used to create the array\nitemsize -- the length in bytes of one array item",
    "array.array.__add__" => "Return self+value.",
    "array.array.__buffer__" => "Return a buffer object that exposes the underlying memory of the object.",
    "array.array.__class_getitem__" => "See PEP 585",
    "array.array.__contains__" => "Return bool(key in self).",
    "array.array.__copy__" => "Return a copy of the array.",
    "array.array.__deepcopy__" => "Return a copy of the array.",
    "array.array.__delattr__" => "Implement delattr(self, name).",
    "array.array.__delitem__" => "Delete self[key].",
    "array.array.__eq__" => "Return self==value.",
    "array.array.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "array.array.__ge__" => "Return self>=value.",
    "array.array.__getattribute__" => "Return getattr(self, name).",
    "array.array.__getitem__" => "Return self[key].",
    "array.array.__getstate__" => "Helper for pickle.",
    "array.array.__gt__" => "Return self>value.",
    "array.array.__iadd__" => "Implement self+=value.",
    "array.array.__imul__" => "Implement self*=value.",
    "array.array.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "array.array.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "array.array.__iter__" => "Implement iter(self).",
    "array.array.__le__" => "Return self<=value.",
    "array.array.__len__" => "Return len(self).",
    "array.array.__lt__" => "Return self<value.",
    "array.array.__mul__" => "Return self*value.",
    "array.array.__ne__" => "Return self!=value.",
    "array.array.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "array.array.__reduce__" => "Helper for pickle.",
    "array.array.__reduce_ex__" => "Return state information for pickling.",
    "array.array.__release_buffer__" => "Release the buffer object that exposes the underlying memory of the object.",
    "array.array.__repr__" => "Return repr(self).",
    "array.array.__rmul__" => "Return value*self.",
    "array.array.__setattr__" => "Implement setattr(self, name, value).",
    "array.array.__setitem__" => "Set self[key] to value.",
    "array.array.__sizeof__" => "Size of the array in memory, in bytes.",
    "array.array.__str__" => "Return str(self).",
    "array.array.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "array.array.append" => "Append new value v to the end of the array.",
    "array.array.buffer_info" => "Return a tuple (address, length) giving the current memory address and the length in items of the buffer used to hold array's contents.\n\nThe length should be multiplied by the itemsize attribute to calculate\nthe buffer length in bytes.",
    "array.array.byteswap" => "Byteswap all items of the array.\n\nIf the items in the array are not 1, 2, 4, or 8 bytes in size, RuntimeError is\nraised.",
    "array.array.clear" => "Remove all items from the array.",
    "array.array.count" => "Return number of occurrences of v in the array.",
    "array.array.extend" => "Append items to the end of the array.",
    "array.array.frombytes" => "Appends items from the string, interpreting it as an array of machine values, as if it had been read from a file using the fromfile() method.",
    "array.array.fromfile" => "Read n objects from the file object f and append them to the end of the array.",
    "array.array.fromlist" => "Append items to array from list.",
    "array.array.fromunicode" => "Extends this array with data from the unicode string ustr.\n\nThe array must be a unicode type array; otherwise a ValueError is raised.\nUse array.frombytes(ustr.encode(...)) to append Unicode data to an array of\nsome other type.",
    "array.array.index" => "Return index of first occurrence of v in the array.\n\nRaise ValueError if the value is not present.",
    "array.array.insert" => "Insert a new item v into the array before position i.",
    "array.array.itemsize" => "the size, in bytes, of one array item",
    "array.array.pop" => "Return the i-th element and delete it from the array.\n\ni defaults to -1.",
    "array.array.remove" => "Remove the first occurrence of v in the array.",
    "array.array.reverse" => "Reverse the order of the items in the array.",
    "array.array.tobytes" => "Convert the array to an array of machine values and return the bytes representation.",
    "array.array.tofile" => "Write all items (as machine values) to the file object f.",
    "array.array.tolist" => "Convert array to an ordinary list with the same items.",
    "array.array.tounicode" => "Extends this array with data from the unicode string ustr.\n\nConvert the array to a unicode string.  The array must be a unicode type array;\notherwise a ValueError is raised.  Use array.tobytes().decode() to obtain a\nunicode string from an array of some other type.",
    "array.array.typecode" => "the typecode character used to create the array",
    "atexit" => "allow programmer to define multiple exit functions to be executed\nupon normal program termination.\n\nTwo public functions, register and unregister, are defined.",
    "atexit._clear" => "Clear the list of previously registered exit functions.",
    "atexit._ncallbacks" => "Return the number of registered exit functions.",
    "atexit._run_exitfuncs" => "Run all registered exit functions.\n\nIf a callback raises an exception, it is logged with sys.unraisablehook.",
    "atexit.register" => "Register a function to be executed upon normal program termination\n\nfunc - function to be called at exit\nargs - optional arguments to pass to func\nkwargs - optional keyword arguments to pass to func\n\nfunc is returned to facilitate usage as a decorator.",
    "atexit.unregister" => "Unregister an exit function which was previously registered using\natexit.register\n\n    func - function to be unregistered",
    "binascii" => "Conversion between binary data and ASCII",
    "binascii.Error.__cause__" => "exception cause",
    "binascii.Error.__context__" => "exception context",
    "binascii.Error.__delattr__" => "Implement delattr(self, name).",
    "binascii.Error.__eq__" => "Return self==value.",
    "binascii.Error.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "binascii.Error.__ge__" => "Return self>=value.",
    "binascii.Error.__getattribute__" => "Return getattr(self, name).",
    "binascii.Error.__getstate__" => "Helper for pickle.",
    "binascii.Error.__gt__" => "Return self>value.",
    "binascii.Error.__hash__" => "Return hash(self).",
    "binascii.Error.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "binascii.Error.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "binascii.Error.__le__" => "Return self<=value.",
    "binascii.Error.__lt__" => "Return self<value.",
    "binascii.Error.__ne__" => "Return self!=value.",
    "binascii.Error.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "binascii.Error.__reduce_ex__" => "Helper for pickle.",
    "binascii.Error.__repr__" => "Return repr(self).",
    "binascii.Error.__setattr__" => "Implement setattr(self, name, value).",
    "binascii.Error.__sizeof__" => "Size of object in memory, in bytes.",
    "binascii.Error.__str__" => "Return str(self).",
    "binascii.Error.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "binascii.Error.__weakref__" => "list of weak references to the object",
    "binascii.Error.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "binascii.Error.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "binascii.Incomplete.__cause__" => "exception cause",
    "binascii.Incomplete.__context__" => "exception context",
    "binascii.Incomplete.__delattr__" => "Implement delattr(self, name).",
    "binascii.Incomplete.__eq__" => "Return self==value.",
    "binascii.Incomplete.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "binascii.Incomplete.__ge__" => "Return self>=value.",
    "binascii.Incomplete.__getattribute__" => "Return getattr(self, name).",
    "binascii.Incomplete.__getstate__" => "Helper for pickle.",
    "binascii.Incomplete.__gt__" => "Return self>value.",
    "binascii.Incomplete.__hash__" => "Return hash(self).",
    "binascii.Incomplete.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "binascii.Incomplete.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "binascii.Incomplete.__le__" => "Return self<=value.",
    "binascii.Incomplete.__lt__" => "Return self<value.",
    "binascii.Incomplete.__ne__" => "Return self!=value.",
    "binascii.Incomplete.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "binascii.Incomplete.__reduce_ex__" => "Helper for pickle.",
    "binascii.Incomplete.__repr__" => "Return repr(self).",
    "binascii.Incomplete.__setattr__" => "Implement setattr(self, name, value).",
    "binascii.Incomplete.__sizeof__" => "Size of object in memory, in bytes.",
    "binascii.Incomplete.__str__" => "Return str(self).",
    "binascii.Incomplete.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "binascii.Incomplete.__weakref__" => "list of weak references to the object",
    "binascii.Incomplete.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "binascii.Incomplete.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "binascii.a2b_base64" => "Decode a line of base64 data.\n\nstrict_mode\n  When set to True, bytes that are not part of the base64 standard are not allowed.\n  The same applies to excess data after padding (= / ==).",
    "binascii.a2b_hex" => "Binary data of hexadecimal representation.\n\nhexstr must contain an even number of hex digits (upper or lower case).\nThis function is also available as \"unhexlify()\".",
    "binascii.a2b_qp" => "Decode a string of qp-encoded data.",
    "binascii.a2b_uu" => "Decode a line of uuencoded data.",
    "binascii.b2a_base64" => "Base64-code line of data.",
    "binascii.b2a_hex" => "Hexadecimal representation of binary data.\n\n  sep\n    An optional single character or byte to separate hex bytes.\n  bytes_per_sep\n    How many bytes between separators.  Positive values count from the\n    right, negative values count from the left.\n\nThe return value is a bytes object.  This function is also\navailable as \"hexlify()\".\n\nExample:\n>>> binascii.b2a_hex(b'\\xb9\\x01\\xef')\nb'b901ef'\n>>> binascii.hexlify(b'\\xb9\\x01\\xef', ':')\nb'b9:01:ef'\n>>> binascii.b2a_hex(b'\\xb9\\x01\\xef', b'_', 2)\nb'b9_01ef'",
    "binascii.b2a_qp" => "Encode a string using quoted-printable encoding.\n\nOn encoding, when istext is set, newlines are not encoded, and white\nspace at end of lines is.  When istext is not set, \\r and \\n (CR/LF)\nare both encoded.  When quotetabs is set, space and tabs are encoded.",
    "binascii.b2a_uu" => "Uuencode line of data.",
    "binascii.crc32" => "Compute CRC-32 incrementally.",
    "binascii.crc_hqx" => "Compute CRC-CCITT incrementally.",
    "binascii.hexlify" => "Hexadecimal representation of binary data.\n\n  sep\n    An optional single character or byte to separate hex bytes.\n  bytes_per_sep\n    How many bytes between separators.  Positive values count from the\n    right, negative values count from the left.\n\nThe return value is a bytes object.  This function is also\navailable as \"b2a_hex()\".",
    "binascii.unhexlify" => "Binary data of hexadecimal representation.\n\nhexstr must contain an even number of hex digits (upper or lower case).",
    "builtins" => "Built-in functions, types, exceptions, and other objects.\n\nThis module provides direct access to all 'built-in'\nidentifiers of Python; for example, builtins.len is\nthe full name for the built-in function len().\n\nThis module is not normally accessed explicitly by most\napplications, but can be useful in modules that provide\nobjects with the same name as a built-in value, but in\nwhich the built-in of that name is also needed.",
    "builtins.ArithmeticError" => "Base class for arithmetic errors.",
    "builtins.ArithmeticError.__cause__" => "exception cause",
    "builtins.ArithmeticError.__context__" => "exception context",
    "builtins.ArithmeticError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ArithmeticError.__eq__" => "Return self==value.",
    "builtins.ArithmeticError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ArithmeticError.__ge__" => "Return self>=value.",
    "builtins.ArithmeticError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ArithmeticError.__getstate__" => "Helper for pickle.",
    "builtins.ArithmeticError.__gt__" => "Return self>value.",
    "builtins.ArithmeticError.__hash__" => "Return hash(self).",
    "builtins.ArithmeticError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ArithmeticError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ArithmeticError.__le__" => "Return self<=value.",
    "builtins.ArithmeticError.__lt__" => "Return self<value.",
    "builtins.ArithmeticError.__ne__" => "Return self!=value.",
    "builtins.ArithmeticError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ArithmeticError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ArithmeticError.__repr__" => "Return repr(self).",
    "builtins.ArithmeticError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ArithmeticError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ArithmeticError.__str__" => "Return str(self).",
    "builtins.ArithmeticError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ArithmeticError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ArithmeticError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.AssertionError" => "Assertion failed.",
    "builtins.AssertionError.__cause__" => "exception cause",
    "builtins.AssertionError.__context__" => "exception context",
    "builtins.AssertionError.__delattr__" => "Implement delattr(self, name).",
    "builtins.AssertionError.__eq__" => "Return self==value.",
    "builtins.AssertionError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.AssertionError.__ge__" => "Return self>=value.",
    "builtins.AssertionError.__getattribute__" => "Return getattr(self, name).",
    "builtins.AssertionError.__getstate__" => "Helper for pickle.",
    "builtins.AssertionError.__gt__" => "Return self>value.",
    "builtins.AssertionError.__hash__" => "Return hash(self).",
    "builtins.AssertionError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.AssertionError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.AssertionError.__le__" => "Return self<=value.",
    "builtins.AssertionError.__lt__" => "Return self<value.",
    "builtins.AssertionError.__ne__" => "Return self!=value.",
    "builtins.AssertionError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.AssertionError.__reduce_ex__" => "Helper for pickle.",
    "builtins.AssertionError.__repr__" => "Return repr(self).",
    "builtins.AssertionError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.AssertionError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.AssertionError.__str__" => "Return str(self).",
    "builtins.AssertionError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.AssertionError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.AssertionError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.AttributeError" => "Attribute not found.",
    "builtins.AttributeError.__cause__" => "exception cause",
    "builtins.AttributeError.__context__" => "exception context",
    "builtins.AttributeError.__delattr__" => "Implement delattr(self, name).",
    "builtins.AttributeError.__eq__" => "Return self==value.",
    "builtins.AttributeError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.AttributeError.__ge__" => "Return self>=value.",
    "builtins.AttributeError.__getattribute__" => "Return getattr(self, name).",
    "builtins.AttributeError.__gt__" => "Return self>value.",
    "builtins.AttributeError.__hash__" => "Return hash(self).",
    "builtins.AttributeError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.AttributeError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.AttributeError.__le__" => "Return self<=value.",
    "builtins.AttributeError.__lt__" => "Return self<value.",
    "builtins.AttributeError.__ne__" => "Return self!=value.",
    "builtins.AttributeError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.AttributeError.__reduce_ex__" => "Helper for pickle.",
    "builtins.AttributeError.__repr__" => "Return repr(self).",
    "builtins.AttributeError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.AttributeError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.AttributeError.__str__" => "Return str(self).",
    "builtins.AttributeError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.AttributeError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.AttributeError.name" => "attribute name",
    "builtins.AttributeError.obj" => "object",
    "builtins.AttributeError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.BaseException" => "Common base class for all exceptions",
    "builtins.BaseException.__cause__" => "exception cause",
    "builtins.BaseException.__context__" => "exception context",
    "builtins.BaseException.__delattr__" => "Implement delattr(self, name).",
    "builtins.BaseException.__eq__" => "Return self==value.",
    "builtins.BaseException.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.BaseException.__ge__" => "Return self>=value.",
    "builtins.BaseException.__getattribute__" => "Return getattr(self, name).",
    "builtins.BaseException.__getstate__" => "Helper for pickle.",
    "builtins.BaseException.__gt__" => "Return self>value.",
    "builtins.BaseException.__hash__" => "Return hash(self).",
    "builtins.BaseException.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.BaseException.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.BaseException.__le__" => "Return self<=value.",
    "builtins.BaseException.__lt__" => "Return self<value.",
    "builtins.BaseException.__ne__" => "Return self!=value.",
    "builtins.BaseException.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.BaseException.__reduce_ex__" => "Helper for pickle.",
    "builtins.BaseException.__repr__" => "Return repr(self).",
    "builtins.BaseException.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.BaseException.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.BaseException.__str__" => "Return str(self).",
    "builtins.BaseException.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.BaseException.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.BaseException.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.BaseExceptionGroup" => "A combination of multiple unrelated exceptions.",
    "builtins.BaseExceptionGroup.__cause__" => "exception cause",
    "builtins.BaseExceptionGroup.__class_getitem__" => "See PEP 585",
    "builtins.BaseExceptionGroup.__context__" => "exception context",
    "builtins.BaseExceptionGroup.__delattr__" => "Implement delattr(self, name).",
    "builtins.BaseExceptionGroup.__eq__" => "Return self==value.",
    "builtins.BaseExceptionGroup.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.BaseExceptionGroup.__ge__" => "Return self>=value.",
    "builtins.BaseExceptionGroup.__getattribute__" => "Return getattr(self, name).",
    "builtins.BaseExceptionGroup.__getstate__" => "Helper for pickle.",
    "builtins.BaseExceptionGroup.__gt__" => "Return self>value.",
    "builtins.BaseExceptionGroup.__hash__" => "Return hash(self).",
    "builtins.BaseExceptionGroup.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.BaseExceptionGroup.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.BaseExceptionGroup.__le__" => "Return self<=value.",
    "builtins.BaseExceptionGroup.__lt__" => "Return self<value.",
    "builtins.BaseExceptionGroup.__ne__" => "Return self!=value.",
    "builtins.BaseExceptionGroup.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.BaseExceptionGroup.__reduce_ex__" => "Helper for pickle.",
    "builtins.BaseExceptionGroup.__repr__" => "Return repr(self).",
    "builtins.BaseExceptionGroup.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.BaseExceptionGroup.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.BaseExceptionGroup.__str__" => "Return str(self).",
    "builtins.BaseExceptionGroup.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.BaseExceptionGroup.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.BaseExceptionGroup.exceptions" => "nested exceptions",
    "builtins.BaseExceptionGroup.message" => "exception message",
    "builtins.BaseExceptionGroup.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.BlockingIOError" => "I/O operation would block.",
    "builtins.BlockingIOError.__cause__" => "exception cause",
    "builtins.BlockingIOError.__context__" => "exception context",
    "builtins.BlockingIOError.__delattr__" => "Implement delattr(self, name).",
    "builtins.BlockingIOError.__eq__" => "Return self==value.",
    "builtins.BlockingIOError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.BlockingIOError.__ge__" => "Return self>=value.",
    "builtins.BlockingIOError.__getattribute__" => "Return getattr(self, name).",
    "builtins.BlockingIOError.__getstate__" => "Helper for pickle.",
    "builtins.BlockingIOError.__gt__" => "Return self>value.",
    "builtins.BlockingIOError.__hash__" => "Return hash(self).",
    "builtins.BlockingIOError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.BlockingIOError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.BlockingIOError.__le__" => "Return self<=value.",
    "builtins.BlockingIOError.__lt__" => "Return self<value.",
    "builtins.BlockingIOError.__ne__" => "Return self!=value.",
    "builtins.BlockingIOError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.BlockingIOError.__reduce_ex__" => "Helper for pickle.",
    "builtins.BlockingIOError.__repr__" => "Return repr(self).",
    "builtins.BlockingIOError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.BlockingIOError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.BlockingIOError.__str__" => "Return str(self).",
    "builtins.BlockingIOError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.BlockingIOError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.BlockingIOError.errno" => "POSIX exception code",
    "builtins.BlockingIOError.filename" => "exception filename",
    "builtins.BlockingIOError.filename2" => "second exception filename",
    "builtins.BlockingIOError.strerror" => "exception strerror",
    "builtins.BlockingIOError.winerror" => "Win32 exception code",
    "builtins.BlockingIOError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.BrokenPipeError" => "Broken pipe.",
    "builtins.BrokenPipeError.__cause__" => "exception cause",
    "builtins.BrokenPipeError.__context__" => "exception context",
    "builtins.BrokenPipeError.__delattr__" => "Implement delattr(self, name).",
    "builtins.BrokenPipeError.__eq__" => "Return self==value.",
    "builtins.BrokenPipeError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.BrokenPipeError.__ge__" => "Return self>=value.",
    "builtins.BrokenPipeError.__getattribute__" => "Return getattr(self, name).",
    "builtins.BrokenPipeError.__getstate__" => "Helper for pickle.",
    "builtins.BrokenPipeError.__gt__" => "Return self>value.",
    "builtins.BrokenPipeError.__hash__" => "Return hash(self).",
    "builtins.BrokenPipeError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.BrokenPipeError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.BrokenPipeError.__le__" => "Return self<=value.",
    "builtins.BrokenPipeError.__lt__" => "Return self<value.",
    "builtins.BrokenPipeError.__ne__" => "Return self!=value.",
    "builtins.BrokenPipeError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.BrokenPipeError.__reduce_ex__" => "Helper for pickle.",
    "builtins.BrokenPipeError.__repr__" => "Return repr(self).",
    "builtins.BrokenPipeError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.BrokenPipeError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.BrokenPipeError.__str__" => "Return str(self).",
    "builtins.BrokenPipeError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.BrokenPipeError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.BrokenPipeError.errno" => "POSIX exception code",
    "builtins.BrokenPipeError.filename" => "exception filename",
    "builtins.BrokenPipeError.filename2" => "second exception filename",
    "builtins.BrokenPipeError.strerror" => "exception strerror",
    "builtins.BrokenPipeError.winerror" => "Win32 exception code",
    "builtins.BrokenPipeError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.BufferError" => "Buffer error.",
    "builtins.BufferError.__cause__" => "exception cause",
    "builtins.BufferError.__context__" => "exception context",
    "builtins.BufferError.__delattr__" => "Implement delattr(self, name).",
    "builtins.BufferError.__eq__" => "Return self==value.",
    "builtins.BufferError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.BufferError.__ge__" => "Return self>=value.",
    "builtins.BufferError.__getattribute__" => "Return getattr(self, name).",
    "builtins.BufferError.__getstate__" => "Helper for pickle.",
    "builtins.BufferError.__gt__" => "Return self>value.",
    "builtins.BufferError.__hash__" => "Return hash(self).",
    "builtins.BufferError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.BufferError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.BufferError.__le__" => "Return self<=value.",
    "builtins.BufferError.__lt__" => "Return self<value.",
    "builtins.BufferError.__ne__" => "Return self!=value.",
    "builtins.BufferError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.BufferError.__reduce_ex__" => "Helper for pickle.",
    "builtins.BufferError.__repr__" => "Return repr(self).",
    "builtins.BufferError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.BufferError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.BufferError.__str__" => "Return str(self).",
    "builtins.BufferError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.BufferError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.BufferError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.BytesWarning" => "Base class for warnings about bytes and buffer related problems, mostly\nrelated to conversion from str or comparing to str.",
    "builtins.BytesWarning.__cause__" => "exception cause",
    "builtins.BytesWarning.__context__" => "exception context",
    "builtins.BytesWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.BytesWarning.__eq__" => "Return self==value.",
    "builtins.BytesWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.BytesWarning.__ge__" => "Return self>=value.",
    "builtins.BytesWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.BytesWarning.__getstate__" => "Helper for pickle.",
    "builtins.BytesWarning.__gt__" => "Return self>value.",
    "builtins.BytesWarning.__hash__" => "Return hash(self).",
    "builtins.BytesWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.BytesWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.BytesWarning.__le__" => "Return self<=value.",
    "builtins.BytesWarning.__lt__" => "Return self<value.",
    "builtins.BytesWarning.__ne__" => "Return self!=value.",
    "builtins.BytesWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.BytesWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.BytesWarning.__repr__" => "Return repr(self).",
    "builtins.BytesWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.BytesWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.BytesWarning.__str__" => "Return str(self).",
    "builtins.BytesWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.BytesWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.BytesWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ChildProcessError" => "Child process error.",
    "builtins.ChildProcessError.__cause__" => "exception cause",
    "builtins.ChildProcessError.__context__" => "exception context",
    "builtins.ChildProcessError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ChildProcessError.__eq__" => "Return self==value.",
    "builtins.ChildProcessError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ChildProcessError.__ge__" => "Return self>=value.",
    "builtins.ChildProcessError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ChildProcessError.__getstate__" => "Helper for pickle.",
    "builtins.ChildProcessError.__gt__" => "Return self>value.",
    "builtins.ChildProcessError.__hash__" => "Return hash(self).",
    "builtins.ChildProcessError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ChildProcessError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ChildProcessError.__le__" => "Return self<=value.",
    "builtins.ChildProcessError.__lt__" => "Return self<value.",
    "builtins.ChildProcessError.__ne__" => "Return self!=value.",
    "builtins.ChildProcessError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ChildProcessError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ChildProcessError.__repr__" => "Return repr(self).",
    "builtins.ChildProcessError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ChildProcessError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ChildProcessError.__str__" => "Return str(self).",
    "builtins.ChildProcessError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ChildProcessError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ChildProcessError.errno" => "POSIX exception code",
    "builtins.ChildProcessError.filename" => "exception filename",
    "builtins.ChildProcessError.filename2" => "second exception filename",
    "builtins.ChildProcessError.strerror" => "exception strerror",
    "builtins.ChildProcessError.winerror" => "Win32 exception code",
    "builtins.ChildProcessError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ConnectionAbortedError" => "Connection aborted.",
    "builtins.ConnectionAbortedError.__cause__" => "exception cause",
    "builtins.ConnectionAbortedError.__context__" => "exception context",
    "builtins.ConnectionAbortedError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ConnectionAbortedError.__eq__" => "Return self==value.",
    "builtins.ConnectionAbortedError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ConnectionAbortedError.__ge__" => "Return self>=value.",
    "builtins.ConnectionAbortedError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ConnectionAbortedError.__getstate__" => "Helper for pickle.",
    "builtins.ConnectionAbortedError.__gt__" => "Return self>value.",
    "builtins.ConnectionAbortedError.__hash__" => "Return hash(self).",
    "builtins.ConnectionAbortedError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ConnectionAbortedError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ConnectionAbortedError.__le__" => "Return self<=value.",
    "builtins.ConnectionAbortedError.__lt__" => "Return self<value.",
    "builtins.ConnectionAbortedError.__ne__" => "Return self!=value.",
    "builtins.ConnectionAbortedError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ConnectionAbortedError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ConnectionAbortedError.__repr__" => "Return repr(self).",
    "builtins.ConnectionAbortedError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ConnectionAbortedError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ConnectionAbortedError.__str__" => "Return str(self).",
    "builtins.ConnectionAbortedError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ConnectionAbortedError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ConnectionAbortedError.errno" => "POSIX exception code",
    "builtins.ConnectionAbortedError.filename" => "exception filename",
    "builtins.ConnectionAbortedError.filename2" => "second exception filename",
    "builtins.ConnectionAbortedError.strerror" => "exception strerror",
    "builtins.ConnectionAbortedError.winerror" => "Win32 exception code",
    "builtins.ConnectionAbortedError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ConnectionError" => "Connection error.",
    "builtins.ConnectionError.__cause__" => "exception cause",
    "builtins.ConnectionError.__context__" => "exception context",
    "builtins.ConnectionError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ConnectionError.__eq__" => "Return self==value.",
    "builtins.ConnectionError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ConnectionError.__ge__" => "Return self>=value.",
    "builtins.ConnectionError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ConnectionError.__getstate__" => "Helper for pickle.",
    "builtins.ConnectionError.__gt__" => "Return self>value.",
    "builtins.ConnectionError.__hash__" => "Return hash(self).",
    "builtins.ConnectionError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ConnectionError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ConnectionError.__le__" => "Return self<=value.",
    "builtins.ConnectionError.__lt__" => "Return self<value.",
    "builtins.ConnectionError.__ne__" => "Return self!=value.",
    "builtins.ConnectionError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ConnectionError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ConnectionError.__repr__" => "Return repr(self).",
    "builtins.ConnectionError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ConnectionError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ConnectionError.__str__" => "Return str(self).",
    "builtins.ConnectionError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ConnectionError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ConnectionError.errno" => "POSIX exception code",
    "builtins.ConnectionError.filename" => "exception filename",
    "builtins.ConnectionError.filename2" => "second exception filename",
    "builtins.ConnectionError.strerror" => "exception strerror",
    "builtins.ConnectionError.winerror" => "Win32 exception code",
    "builtins.ConnectionError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ConnectionRefusedError" => "Connection refused.",
    "builtins.ConnectionRefusedError.__cause__" => "exception cause",
    "builtins.ConnectionRefusedError.__context__" => "exception context",
    "builtins.ConnectionRefusedError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ConnectionRefusedError.__eq__" => "Return self==value.",
    "builtins.ConnectionRefusedError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ConnectionRefusedError.__ge__" => "Return self>=value.",
    "builtins.ConnectionRefusedError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ConnectionRefusedError.__getstate__" => "Helper for pickle.",
    "builtins.ConnectionRefusedError.__gt__" => "Return self>value.",
    "builtins.ConnectionRefusedError.__hash__" => "Return hash(self).",
    "builtins.ConnectionRefusedError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ConnectionRefusedError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ConnectionRefusedError.__le__" => "Return self<=value.",
    "builtins.ConnectionRefusedError.__lt__" => "Return self<value.",
    "builtins.ConnectionRefusedError.__ne__" => "Return self!=value.",
    "builtins.ConnectionRefusedError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ConnectionRefusedError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ConnectionRefusedError.__repr__" => "Return repr(self).",
    "builtins.ConnectionRefusedError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ConnectionRefusedError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ConnectionRefusedError.__str__" => "Return str(self).",
    "builtins.ConnectionRefusedError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ConnectionRefusedError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ConnectionRefusedError.errno" => "POSIX exception code",
    "builtins.ConnectionRefusedError.filename" => "exception filename",
    "builtins.ConnectionRefusedError.filename2" => "second exception filename",
    "builtins.ConnectionRefusedError.strerror" => "exception strerror",
    "builtins.ConnectionRefusedError.winerror" => "Win32 exception code",
    "builtins.ConnectionRefusedError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ConnectionResetError" => "Connection reset.",
    "builtins.ConnectionResetError.__cause__" => "exception cause",
    "builtins.ConnectionResetError.__context__" => "exception context",
    "builtins.ConnectionResetError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ConnectionResetError.__eq__" => "Return self==value.",
    "builtins.ConnectionResetError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ConnectionResetError.__ge__" => "Return self>=value.",
    "builtins.ConnectionResetError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ConnectionResetError.__getstate__" => "Helper for pickle.",
    "builtins.ConnectionResetError.__gt__" => "Return self>value.",
    "builtins.ConnectionResetError.__hash__" => "Return hash(self).",
    "builtins.ConnectionResetError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ConnectionResetError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ConnectionResetError.__le__" => "Return self<=value.",
    "builtins.ConnectionResetError.__lt__" => "Return self<value.",
    "builtins.ConnectionResetError.__ne__" => "Return self!=value.",
    "builtins.ConnectionResetError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ConnectionResetError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ConnectionResetError.__repr__" => "Return repr(self).",
    "builtins.ConnectionResetError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ConnectionResetError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ConnectionResetError.__str__" => "Return str(self).",
    "builtins.ConnectionResetError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ConnectionResetError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ConnectionResetError.errno" => "POSIX exception code",
    "builtins.ConnectionResetError.filename" => "exception filename",
    "builtins.ConnectionResetError.filename2" => "second exception filename",
    "builtins.ConnectionResetError.strerror" => "exception strerror",
    "builtins.ConnectionResetError.winerror" => "Win32 exception code",
    "builtins.ConnectionResetError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.DeprecationWarning" => "Base class for warnings about deprecated features.",
    "builtins.DeprecationWarning.__cause__" => "exception cause",
    "builtins.DeprecationWarning.__context__" => "exception context",
    "builtins.DeprecationWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.DeprecationWarning.__eq__" => "Return self==value.",
    "builtins.DeprecationWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.DeprecationWarning.__ge__" => "Return self>=value.",
    "builtins.DeprecationWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.DeprecationWarning.__getstate__" => "Helper for pickle.",
    "builtins.DeprecationWarning.__gt__" => "Return self>value.",
    "builtins.DeprecationWarning.__hash__" => "Return hash(self).",
    "builtins.DeprecationWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.DeprecationWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.DeprecationWarning.__le__" => "Return self<=value.",
    "builtins.DeprecationWarning.__lt__" => "Return self<value.",
    "builtins.DeprecationWarning.__ne__" => "Return self!=value.",
    "builtins.DeprecationWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.DeprecationWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.DeprecationWarning.__repr__" => "Return repr(self).",
    "builtins.DeprecationWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.DeprecationWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.DeprecationWarning.__str__" => "Return str(self).",
    "builtins.DeprecationWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.DeprecationWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.DeprecationWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.EOFError" => "Read beyond end of file.",
    "builtins.EOFError.__cause__" => "exception cause",
    "builtins.EOFError.__context__" => "exception context",
    "builtins.EOFError.__delattr__" => "Implement delattr(self, name).",
    "builtins.EOFError.__eq__" => "Return self==value.",
    "builtins.EOFError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.EOFError.__ge__" => "Return self>=value.",
    "builtins.EOFError.__getattribute__" => "Return getattr(self, name).",
    "builtins.EOFError.__getstate__" => "Helper for pickle.",
    "builtins.EOFError.__gt__" => "Return self>value.",
    "builtins.EOFError.__hash__" => "Return hash(self).",
    "builtins.EOFError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.EOFError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.EOFError.__le__" => "Return self<=value.",
    "builtins.EOFError.__lt__" => "Return self<value.",
    "builtins.EOFError.__ne__" => "Return self!=value.",
    "builtins.EOFError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.EOFError.__reduce_ex__" => "Helper for pickle.",
    "builtins.EOFError.__repr__" => "Return repr(self).",
    "builtins.EOFError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.EOFError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.EOFError.__str__" => "Return str(self).",
    "builtins.EOFError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.EOFError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.EOFError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.EncodingWarning" => "Base class for warnings about encodings.",
    "builtins.EncodingWarning.__cause__" => "exception cause",
    "builtins.EncodingWarning.__context__" => "exception context",
    "builtins.EncodingWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.EncodingWarning.__eq__" => "Return self==value.",
    "builtins.EncodingWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.EncodingWarning.__ge__" => "Return self>=value.",
    "builtins.EncodingWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.EncodingWarning.__getstate__" => "Helper for pickle.",
    "builtins.EncodingWarning.__gt__" => "Return self>value.",
    "builtins.EncodingWarning.__hash__" => "Return hash(self).",
    "builtins.EncodingWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.EncodingWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.EncodingWarning.__le__" => "Return self<=value.",
    "builtins.EncodingWarning.__lt__" => "Return self<value.",
    "builtins.EncodingWarning.__ne__" => "Return self!=value.",
    "builtins.EncodingWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.EncodingWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.EncodingWarning.__repr__" => "Return repr(self).",
    "builtins.EncodingWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.EncodingWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.EncodingWarning.__str__" => "Return str(self).",
    "builtins.EncodingWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.EncodingWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.EncodingWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.EnvironmentError" => "Base class for I/O related errors.",
    "builtins.EnvironmentError.__cause__" => "exception cause",
    "builtins.EnvironmentError.__context__" => "exception context",
    "builtins.EnvironmentError.__delattr__" => "Implement delattr(self, name).",
    "builtins.EnvironmentError.__eq__" => "Return self==value.",
    "builtins.EnvironmentError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.EnvironmentError.__ge__" => "Return self>=value.",
    "builtins.EnvironmentError.__getattribute__" => "Return getattr(self, name).",
    "builtins.EnvironmentError.__getstate__" => "Helper for pickle.",
    "builtins.EnvironmentError.__gt__" => "Return self>value.",
    "builtins.EnvironmentError.__hash__" => "Return hash(self).",
    "builtins.EnvironmentError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.EnvironmentError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.EnvironmentError.__le__" => "Return self<=value.",
    "builtins.EnvironmentError.__lt__" => "Return self<value.",
    "builtins.EnvironmentError.__ne__" => "Return self!=value.",
    "builtins.EnvironmentError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.EnvironmentError.__reduce_ex__" => "Helper for pickle.",
    "builtins.EnvironmentError.__repr__" => "Return repr(self).",
    "builtins.EnvironmentError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.EnvironmentError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.EnvironmentError.__str__" => "Return str(self).",
    "builtins.EnvironmentError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.EnvironmentError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.EnvironmentError.errno" => "POSIX exception code",
    "builtins.EnvironmentError.filename" => "exception filename",
    "builtins.EnvironmentError.filename2" => "second exception filename",
    "builtins.EnvironmentError.strerror" => "exception strerror",
    "builtins.EnvironmentError.winerror" => "Win32 exception code",
    "builtins.EnvironmentError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.Exception" => "Common base class for all non-exit exceptions.",
    "builtins.Exception.__cause__" => "exception cause",
    "builtins.Exception.__context__" => "exception context",
    "builtins.Exception.__delattr__" => "Implement delattr(self, name).",
    "builtins.Exception.__eq__" => "Return self==value.",
    "builtins.Exception.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.Exception.__ge__" => "Return self>=value.",
    "builtins.Exception.__getattribute__" => "Return getattr(self, name).",
    "builtins.Exception.__getstate__" => "Helper for pickle.",
    "builtins.Exception.__gt__" => "Return self>value.",
    "builtins.Exception.__hash__" => "Return hash(self).",
    "builtins.Exception.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.Exception.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.Exception.__le__" => "Return self<=value.",
    "builtins.Exception.__lt__" => "Return self<value.",
    "builtins.Exception.__ne__" => "Return self!=value.",
    "builtins.Exception.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.Exception.__reduce_ex__" => "Helper for pickle.",
    "builtins.Exception.__repr__" => "Return repr(self).",
    "builtins.Exception.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.Exception.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.Exception.__str__" => "Return str(self).",
    "builtins.Exception.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.Exception.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.Exception.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ExceptionGroup.__cause__" => "exception cause",
    "builtins.ExceptionGroup.__class_getitem__" => "See PEP 585",
    "builtins.ExceptionGroup.__context__" => "exception context",
    "builtins.ExceptionGroup.__delattr__" => "Implement delattr(self, name).",
    "builtins.ExceptionGroup.__eq__" => "Return self==value.",
    "builtins.ExceptionGroup.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ExceptionGroup.__ge__" => "Return self>=value.",
    "builtins.ExceptionGroup.__getattribute__" => "Return getattr(self, name).",
    "builtins.ExceptionGroup.__getstate__" => "Helper for pickle.",
    "builtins.ExceptionGroup.__gt__" => "Return self>value.",
    "builtins.ExceptionGroup.__hash__" => "Return hash(self).",
    "builtins.ExceptionGroup.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ExceptionGroup.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ExceptionGroup.__le__" => "Return self<=value.",
    "builtins.ExceptionGroup.__lt__" => "Return self<value.",
    "builtins.ExceptionGroup.__ne__" => "Return self!=value.",
    "builtins.ExceptionGroup.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ExceptionGroup.__reduce_ex__" => "Helper for pickle.",
    "builtins.ExceptionGroup.__repr__" => "Return repr(self).",
    "builtins.ExceptionGroup.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ExceptionGroup.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ExceptionGroup.__str__" => "Return str(self).",
    "builtins.ExceptionGroup.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ExceptionGroup.__weakref__" => "list of weak references to the object",
    "builtins.ExceptionGroup.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ExceptionGroup.exceptions" => "nested exceptions",
    "builtins.ExceptionGroup.message" => "exception message",
    "builtins.ExceptionGroup.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.FileExistsError" => "File already exists.",
    "builtins.FileExistsError.__cause__" => "exception cause",
    "builtins.FileExistsError.__context__" => "exception context",
    "builtins.FileExistsError.__delattr__" => "Implement delattr(self, name).",
    "builtins.FileExistsError.__eq__" => "Return self==value.",
    "builtins.FileExistsError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.FileExistsError.__ge__" => "Return self>=value.",
    "builtins.FileExistsError.__getattribute__" => "Return getattr(self, name).",
    "builtins.FileExistsError.__getstate__" => "Helper for pickle.",
    "builtins.FileExistsError.__gt__" => "Return self>value.",
    "builtins.FileExistsError.__hash__" => "Return hash(self).",
    "builtins.FileExistsError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.FileExistsError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.FileExistsError.__le__" => "Return self<=value.",
    "builtins.FileExistsError.__lt__" => "Return self<value.",
    "builtins.FileExistsError.__ne__" => "Return self!=value.",
    "builtins.FileExistsError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.FileExistsError.__reduce_ex__" => "Helper for pickle.",
    "builtins.FileExistsError.__repr__" => "Return repr(self).",
    "builtins.FileExistsError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.FileExistsError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.FileExistsError.__str__" => "Return str(self).",
    "builtins.FileExistsError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.FileExistsError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.FileExistsError.errno" => "POSIX exception code",
    "builtins.FileExistsError.filename" => "exception filename",
    "builtins.FileExistsError.filename2" => "second exception filename",
    "builtins.FileExistsError.strerror" => "exception strerror",
    "builtins.FileExistsError.winerror" => "Win32 exception code",
    "builtins.FileExistsError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.FileNotFoundError" => "File not found.",
    "builtins.FileNotFoundError.__cause__" => "exception cause",
    "builtins.FileNotFoundError.__context__" => "exception context",
    "builtins.FileNotFoundError.__delattr__" => "Implement delattr(self, name).",
    "builtins.FileNotFoundError.__eq__" => "Return self==value.",
    "builtins.FileNotFoundError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.FileNotFoundError.__ge__" => "Return self>=value.",
    "builtins.FileNotFoundError.__getattribute__" => "Return getattr(self, name).",
    "builtins.FileNotFoundError.__getstate__" => "Helper for pickle.",
    "builtins.FileNotFoundError.__gt__" => "Return self>value.",
    "builtins.FileNotFoundError.__hash__" => "Return hash(self).",
    "builtins.FileNotFoundError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.FileNotFoundError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.FileNotFoundError.__le__" => "Return self<=value.",
    "builtins.FileNotFoundError.__lt__" => "Return self<value.",
    "builtins.FileNotFoundError.__ne__" => "Return self!=value.",
    "builtins.FileNotFoundError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.FileNotFoundError.__reduce_ex__" => "Helper for pickle.",
    "builtins.FileNotFoundError.__repr__" => "Return repr(self).",
    "builtins.FileNotFoundError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.FileNotFoundError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.FileNotFoundError.__str__" => "Return str(self).",
    "builtins.FileNotFoundError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.FileNotFoundError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.FileNotFoundError.errno" => "POSIX exception code",
    "builtins.FileNotFoundError.filename" => "exception filename",
    "builtins.FileNotFoundError.filename2" => "second exception filename",
    "builtins.FileNotFoundError.strerror" => "exception strerror",
    "builtins.FileNotFoundError.winerror" => "Win32 exception code",
    "builtins.FileNotFoundError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.FloatingPointError" => "Floating-point operation failed.",
    "builtins.FloatingPointError.__cause__" => "exception cause",
    "builtins.FloatingPointError.__context__" => "exception context",
    "builtins.FloatingPointError.__delattr__" => "Implement delattr(self, name).",
    "builtins.FloatingPointError.__eq__" => "Return self==value.",
    "builtins.FloatingPointError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.FloatingPointError.__ge__" => "Return self>=value.",
    "builtins.FloatingPointError.__getattribute__" => "Return getattr(self, name).",
    "builtins.FloatingPointError.__getstate__" => "Helper for pickle.",
    "builtins.FloatingPointError.__gt__" => "Return self>value.",
    "builtins.FloatingPointError.__hash__" => "Return hash(self).",
    "builtins.FloatingPointError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.FloatingPointError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.FloatingPointError.__le__" => "Return self<=value.",
    "builtins.FloatingPointError.__lt__" => "Return self<value.",
    "builtins.FloatingPointError.__ne__" => "Return self!=value.",
    "builtins.FloatingPointError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.FloatingPointError.__reduce_ex__" => "Helper for pickle.",
    "builtins.FloatingPointError.__repr__" => "Return repr(self).",
    "builtins.FloatingPointError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.FloatingPointError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.FloatingPointError.__str__" => "Return str(self).",
    "builtins.FloatingPointError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.FloatingPointError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.FloatingPointError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.FutureWarning" => "Base class for warnings about constructs that will change semantically\nin the future.",
    "builtins.FutureWarning.__cause__" => "exception cause",
    "builtins.FutureWarning.__context__" => "exception context",
    "builtins.FutureWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.FutureWarning.__eq__" => "Return self==value.",
    "builtins.FutureWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.FutureWarning.__ge__" => "Return self>=value.",
    "builtins.FutureWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.FutureWarning.__getstate__" => "Helper for pickle.",
    "builtins.FutureWarning.__gt__" => "Return self>value.",
    "builtins.FutureWarning.__hash__" => "Return hash(self).",
    "builtins.FutureWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.FutureWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.FutureWarning.__le__" => "Return self<=value.",
    "builtins.FutureWarning.__lt__" => "Return self<value.",
    "builtins.FutureWarning.__ne__" => "Return self!=value.",
    "builtins.FutureWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.FutureWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.FutureWarning.__repr__" => "Return repr(self).",
    "builtins.FutureWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.FutureWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.FutureWarning.__str__" => "Return str(self).",
    "builtins.FutureWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.FutureWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.FutureWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.GeneratorExit" => "Request that a generator exit.",
    "builtins.GeneratorExit.__cause__" => "exception cause",
    "builtins.GeneratorExit.__context__" => "exception context",
    "builtins.GeneratorExit.__delattr__" => "Implement delattr(self, name).",
    "builtins.GeneratorExit.__eq__" => "Return self==value.",
    "builtins.GeneratorExit.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.GeneratorExit.__ge__" => "Return self>=value.",
    "builtins.GeneratorExit.__getattribute__" => "Return getattr(self, name).",
    "builtins.GeneratorExit.__getstate__" => "Helper for pickle.",
    "builtins.GeneratorExit.__gt__" => "Return self>value.",
    "builtins.GeneratorExit.__hash__" => "Return hash(self).",
    "builtins.GeneratorExit.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.GeneratorExit.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.GeneratorExit.__le__" => "Return self<=value.",
    "builtins.GeneratorExit.__lt__" => "Return self<value.",
    "builtins.GeneratorExit.__ne__" => "Return self!=value.",
    "builtins.GeneratorExit.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.GeneratorExit.__reduce_ex__" => "Helper for pickle.",
    "builtins.GeneratorExit.__repr__" => "Return repr(self).",
    "builtins.GeneratorExit.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.GeneratorExit.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.GeneratorExit.__str__" => "Return str(self).",
    "builtins.GeneratorExit.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.GeneratorExit.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.GeneratorExit.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.IOError" => "Base class for I/O related errors.",
    "builtins.IOError.__cause__" => "exception cause",
    "builtins.IOError.__context__" => "exception context",
    "builtins.IOError.__delattr__" => "Implement delattr(self, name).",
    "builtins.IOError.__eq__" => "Return self==value.",
    "builtins.IOError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.IOError.__ge__" => "Return self>=value.",
    "builtins.IOError.__getattribute__" => "Return getattr(self, name).",
    "builtins.IOError.__getstate__" => "Helper for pickle.",
    "builtins.IOError.__gt__" => "Return self>value.",
    "builtins.IOError.__hash__" => "Return hash(self).",
    "builtins.IOError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.IOError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.IOError.__le__" => "Return self<=value.",
    "builtins.IOError.__lt__" => "Return self<value.",
    "builtins.IOError.__ne__" => "Return self!=value.",
    "builtins.IOError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.IOError.__reduce_ex__" => "Helper for pickle.",
    "builtins.IOError.__repr__" => "Return repr(self).",
    "builtins.IOError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.IOError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.IOError.__str__" => "Return str(self).",
    "builtins.IOError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.IOError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.IOError.errno" => "POSIX exception code",
    "builtins.IOError.filename" => "exception filename",
    "builtins.IOError.filename2" => "second exception filename",
    "builtins.IOError.strerror" => "exception strerror",
    "builtins.IOError.winerror" => "Win32 exception code",
    "builtins.IOError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ImportError" => "Import can't find module, or can't find name in module.",
    "builtins.ImportError.__cause__" => "exception cause",
    "builtins.ImportError.__context__" => "exception context",
    "builtins.ImportError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ImportError.__eq__" => "Return self==value.",
    "builtins.ImportError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ImportError.__ge__" => "Return self>=value.",
    "builtins.ImportError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ImportError.__getstate__" => "Helper for pickle.",
    "builtins.ImportError.__gt__" => "Return self>value.",
    "builtins.ImportError.__hash__" => "Return hash(self).",
    "builtins.ImportError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ImportError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ImportError.__le__" => "Return self<=value.",
    "builtins.ImportError.__lt__" => "Return self<value.",
    "builtins.ImportError.__ne__" => "Return self!=value.",
    "builtins.ImportError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ImportError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ImportError.__repr__" => "Return repr(self).",
    "builtins.ImportError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ImportError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ImportError.__str__" => "Return str(self).",
    "builtins.ImportError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ImportError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ImportError.msg" => "exception message",
    "builtins.ImportError.name" => "module name",
    "builtins.ImportError.name_from" => "name imported from module",
    "builtins.ImportError.path" => "module path",
    "builtins.ImportError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ImportWarning" => "Base class for warnings about probable mistakes in module imports",
    "builtins.ImportWarning.__cause__" => "exception cause",
    "builtins.ImportWarning.__context__" => "exception context",
    "builtins.ImportWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.ImportWarning.__eq__" => "Return self==value.",
    "builtins.ImportWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ImportWarning.__ge__" => "Return self>=value.",
    "builtins.ImportWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.ImportWarning.__getstate__" => "Helper for pickle.",
    "builtins.ImportWarning.__gt__" => "Return self>value.",
    "builtins.ImportWarning.__hash__" => "Return hash(self).",
    "builtins.ImportWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ImportWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ImportWarning.__le__" => "Return self<=value.",
    "builtins.ImportWarning.__lt__" => "Return self<value.",
    "builtins.ImportWarning.__ne__" => "Return self!=value.",
    "builtins.ImportWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ImportWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.ImportWarning.__repr__" => "Return repr(self).",
    "builtins.ImportWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ImportWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ImportWarning.__str__" => "Return str(self).",
    "builtins.ImportWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ImportWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ImportWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.IndentationError" => "Improper indentation.",
    "builtins.IndentationError.__cause__" => "exception cause",
    "builtins.IndentationError.__context__" => "exception context",
    "builtins.IndentationError.__delattr__" => "Implement delattr(self, name).",
    "builtins.IndentationError.__eq__" => "Return self==value.",
    "builtins.IndentationError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.IndentationError.__ge__" => "Return self>=value.",
    "builtins.IndentationError.__getattribute__" => "Return getattr(self, name).",
    "builtins.IndentationError.__getstate__" => "Helper for pickle.",
    "builtins.IndentationError.__gt__" => "Return self>value.",
    "builtins.IndentationError.__hash__" => "Return hash(self).",
    "builtins.IndentationError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.IndentationError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.IndentationError.__le__" => "Return self<=value.",
    "builtins.IndentationError.__lt__" => "Return self<value.",
    "builtins.IndentationError.__ne__" => "Return self!=value.",
    "builtins.IndentationError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.IndentationError.__reduce_ex__" => "Helper for pickle.",
    "builtins.IndentationError.__repr__" => "Return repr(self).",
    "builtins.IndentationError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.IndentationError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.IndentationError.__str__" => "Return str(self).",
    "builtins.IndentationError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.IndentationError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.IndentationError.end_lineno" => "exception end lineno",
    "builtins.IndentationError.end_offset" => "exception end offset",
    "builtins.IndentationError.filename" => "exception filename",
    "builtins.IndentationError.lineno" => "exception lineno",
    "builtins.IndentationError.msg" => "exception msg",
    "builtins.IndentationError.offset" => "exception offset",
    "builtins.IndentationError.print_file_and_line" => "exception print_file_and_line",
    "builtins.IndentationError.text" => "exception text",
    "builtins.IndentationError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.IndexError" => "Sequence index out of range.",
    "builtins.IndexError.__cause__" => "exception cause",
    "builtins.IndexError.__context__" => "exception context",
    "builtins.IndexError.__delattr__" => "Implement delattr(self, name).",
    "builtins.IndexError.__eq__" => "Return self==value.",
    "builtins.IndexError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.IndexError.__ge__" => "Return self>=value.",
    "builtins.IndexError.__getattribute__" => "Return getattr(self, name).",
    "builtins.IndexError.__getstate__" => "Helper for pickle.",
    "builtins.IndexError.__gt__" => "Return self>value.",
    "builtins.IndexError.__hash__" => "Return hash(self).",
    "builtins.IndexError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.IndexError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.IndexError.__le__" => "Return self<=value.",
    "builtins.IndexError.__lt__" => "Return self<value.",
    "builtins.IndexError.__ne__" => "Return self!=value.",
    "builtins.IndexError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.IndexError.__reduce_ex__" => "Helper for pickle.",
    "builtins.IndexError.__repr__" => "Return repr(self).",
    "builtins.IndexError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.IndexError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.IndexError.__str__" => "Return str(self).",
    "builtins.IndexError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.IndexError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.IndexError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.InterruptedError" => "Interrupted by signal.",
    "builtins.InterruptedError.__cause__" => "exception cause",
    "builtins.InterruptedError.__context__" => "exception context",
    "builtins.InterruptedError.__delattr__" => "Implement delattr(self, name).",
    "builtins.InterruptedError.__eq__" => "Return self==value.",
    "builtins.InterruptedError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.InterruptedError.__ge__" => "Return self>=value.",
    "builtins.InterruptedError.__getattribute__" => "Return getattr(self, name).",
    "builtins.InterruptedError.__getstate__" => "Helper for pickle.",
    "builtins.InterruptedError.__gt__" => "Return self>value.",
    "builtins.InterruptedError.__hash__" => "Return hash(self).",
    "builtins.InterruptedError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.InterruptedError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.InterruptedError.__le__" => "Return self<=value.",
    "builtins.InterruptedError.__lt__" => "Return self<value.",
    "builtins.InterruptedError.__ne__" => "Return self!=value.",
    "builtins.InterruptedError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.InterruptedError.__reduce_ex__" => "Helper for pickle.",
    "builtins.InterruptedError.__repr__" => "Return repr(self).",
    "builtins.InterruptedError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.InterruptedError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.InterruptedError.__str__" => "Return str(self).",
    "builtins.InterruptedError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.InterruptedError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.InterruptedError.errno" => "POSIX exception code",
    "builtins.InterruptedError.filename" => "exception filename",
    "builtins.InterruptedError.filename2" => "second exception filename",
    "builtins.InterruptedError.strerror" => "exception strerror",
    "builtins.InterruptedError.winerror" => "Win32 exception code",
    "builtins.InterruptedError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.IsADirectoryError" => "Operation doesn't work on directories.",
    "builtins.IsADirectoryError.__cause__" => "exception cause",
    "builtins.IsADirectoryError.__context__" => "exception context",
    "builtins.IsADirectoryError.__delattr__" => "Implement delattr(self, name).",
    "builtins.IsADirectoryError.__eq__" => "Return self==value.",
    "builtins.IsADirectoryError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.IsADirectoryError.__ge__" => "Return self>=value.",
    "builtins.IsADirectoryError.__getattribute__" => "Return getattr(self, name).",
    "builtins.IsADirectoryError.__getstate__" => "Helper for pickle.",
    "builtins.IsADirectoryError.__gt__" => "Return self>value.",
    "builtins.IsADirectoryError.__hash__" => "Return hash(self).",
    "builtins.IsADirectoryError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.IsADirectoryError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.IsADirectoryError.__le__" => "Return self<=value.",
    "builtins.IsADirectoryError.__lt__" => "Return self<value.",
    "builtins.IsADirectoryError.__ne__" => "Return self!=value.",
    "builtins.IsADirectoryError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.IsADirectoryError.__reduce_ex__" => "Helper for pickle.",
    "builtins.IsADirectoryError.__repr__" => "Return repr(self).",
    "builtins.IsADirectoryError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.IsADirectoryError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.IsADirectoryError.__str__" => "Return str(self).",
    "builtins.IsADirectoryError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.IsADirectoryError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.IsADirectoryError.errno" => "POSIX exception code",
    "builtins.IsADirectoryError.filename" => "exception filename",
    "builtins.IsADirectoryError.filename2" => "second exception filename",
    "builtins.IsADirectoryError.strerror" => "exception strerror",
    "builtins.IsADirectoryError.winerror" => "Win32 exception code",
    "builtins.IsADirectoryError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.KeyError" => "Mapping key not found.",
    "builtins.KeyError.__cause__" => "exception cause",
    "builtins.KeyError.__context__" => "exception context",
    "builtins.KeyError.__delattr__" => "Implement delattr(self, name).",
    "builtins.KeyError.__eq__" => "Return self==value.",
    "builtins.KeyError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.KeyError.__ge__" => "Return self>=value.",
    "builtins.KeyError.__getattribute__" => "Return getattr(self, name).",
    "builtins.KeyError.__getstate__" => "Helper for pickle.",
    "builtins.KeyError.__gt__" => "Return self>value.",
    "builtins.KeyError.__hash__" => "Return hash(self).",
    "builtins.KeyError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.KeyError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.KeyError.__le__" => "Return self<=value.",
    "builtins.KeyError.__lt__" => "Return self<value.",
    "builtins.KeyError.__ne__" => "Return self!=value.",
    "builtins.KeyError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.KeyError.__reduce_ex__" => "Helper for pickle.",
    "builtins.KeyError.__repr__" => "Return repr(self).",
    "builtins.KeyError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.KeyError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.KeyError.__str__" => "Return str(self).",
    "builtins.KeyError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.KeyError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.KeyError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.KeyboardInterrupt" => "Program interrupted by user.",
    "builtins.KeyboardInterrupt.__cause__" => "exception cause",
    "builtins.KeyboardInterrupt.__context__" => "exception context",
    "builtins.KeyboardInterrupt.__delattr__" => "Implement delattr(self, name).",
    "builtins.KeyboardInterrupt.__eq__" => "Return self==value.",
    "builtins.KeyboardInterrupt.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.KeyboardInterrupt.__ge__" => "Return self>=value.",
    "builtins.KeyboardInterrupt.__getattribute__" => "Return getattr(self, name).",
    "builtins.KeyboardInterrupt.__getstate__" => "Helper for pickle.",
    "builtins.KeyboardInterrupt.__gt__" => "Return self>value.",
    "builtins.KeyboardInterrupt.__hash__" => "Return hash(self).",
    "builtins.KeyboardInterrupt.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.KeyboardInterrupt.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.KeyboardInterrupt.__le__" => "Return self<=value.",
    "builtins.KeyboardInterrupt.__lt__" => "Return self<value.",
    "builtins.KeyboardInterrupt.__ne__" => "Return self!=value.",
    "builtins.KeyboardInterrupt.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.KeyboardInterrupt.__reduce_ex__" => "Helper for pickle.",
    "builtins.KeyboardInterrupt.__repr__" => "Return repr(self).",
    "builtins.KeyboardInterrupt.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.KeyboardInterrupt.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.KeyboardInterrupt.__str__" => "Return str(self).",
    "builtins.KeyboardInterrupt.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.KeyboardInterrupt.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.KeyboardInterrupt.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.LookupError" => "Base class for lookup errors.",
    "builtins.LookupError.__cause__" => "exception cause",
    "builtins.LookupError.__context__" => "exception context",
    "builtins.LookupError.__delattr__" => "Implement delattr(self, name).",
    "builtins.LookupError.__eq__" => "Return self==value.",
    "builtins.LookupError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.LookupError.__ge__" => "Return self>=value.",
    "builtins.LookupError.__getattribute__" => "Return getattr(self, name).",
    "builtins.LookupError.__getstate__" => "Helper for pickle.",
    "builtins.LookupError.__gt__" => "Return self>value.",
    "builtins.LookupError.__hash__" => "Return hash(self).",
    "builtins.LookupError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.LookupError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.LookupError.__le__" => "Return self<=value.",
    "builtins.LookupError.__lt__" => "Return self<value.",
    "builtins.LookupError.__ne__" => "Return self!=value.",
    "builtins.LookupError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.LookupError.__reduce_ex__" => "Helper for pickle.",
    "builtins.LookupError.__repr__" => "Return repr(self).",
    "builtins.LookupError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.LookupError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.LookupError.__str__" => "Return str(self).",
    "builtins.LookupError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.LookupError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.LookupError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.MemoryError" => "Out of memory.",
    "builtins.MemoryError.__cause__" => "exception cause",
    "builtins.MemoryError.__context__" => "exception context",
    "builtins.MemoryError.__delattr__" => "Implement delattr(self, name).",
    "builtins.MemoryError.__eq__" => "Return self==value.",
    "builtins.MemoryError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.MemoryError.__ge__" => "Return self>=value.",
    "builtins.MemoryError.__getattribute__" => "Return getattr(self, name).",
    "builtins.MemoryError.__getstate__" => "Helper for pickle.",
    "builtins.MemoryError.__gt__" => "Return self>value.",
    "builtins.MemoryError.__hash__" => "Return hash(self).",
    "builtins.MemoryError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.MemoryError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.MemoryError.__le__" => "Return self<=value.",
    "builtins.MemoryError.__lt__" => "Return self<value.",
    "builtins.MemoryError.__ne__" => "Return self!=value.",
    "builtins.MemoryError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.MemoryError.__reduce_ex__" => "Helper for pickle.",
    "builtins.MemoryError.__repr__" => "Return repr(self).",
    "builtins.MemoryError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.MemoryError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.MemoryError.__str__" => "Return str(self).",
    "builtins.MemoryError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.MemoryError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.MemoryError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ModuleNotFoundError" => "Module not found.",
    "builtins.ModuleNotFoundError.__cause__" => "exception cause",
    "builtins.ModuleNotFoundError.__context__" => "exception context",
    "builtins.ModuleNotFoundError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ModuleNotFoundError.__eq__" => "Return self==value.",
    "builtins.ModuleNotFoundError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ModuleNotFoundError.__ge__" => "Return self>=value.",
    "builtins.ModuleNotFoundError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ModuleNotFoundError.__getstate__" => "Helper for pickle.",
    "builtins.ModuleNotFoundError.__gt__" => "Return self>value.",
    "builtins.ModuleNotFoundError.__hash__" => "Return hash(self).",
    "builtins.ModuleNotFoundError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ModuleNotFoundError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ModuleNotFoundError.__le__" => "Return self<=value.",
    "builtins.ModuleNotFoundError.__lt__" => "Return self<value.",
    "builtins.ModuleNotFoundError.__ne__" => "Return self!=value.",
    "builtins.ModuleNotFoundError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ModuleNotFoundError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ModuleNotFoundError.__repr__" => "Return repr(self).",
    "builtins.ModuleNotFoundError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ModuleNotFoundError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ModuleNotFoundError.__str__" => "Return str(self).",
    "builtins.ModuleNotFoundError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ModuleNotFoundError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ModuleNotFoundError.msg" => "exception message",
    "builtins.ModuleNotFoundError.name" => "module name",
    "builtins.ModuleNotFoundError.name_from" => "name imported from module",
    "builtins.ModuleNotFoundError.path" => "module path",
    "builtins.ModuleNotFoundError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.NameError" => "Name not found globally.",
    "builtins.NameError.__cause__" => "exception cause",
    "builtins.NameError.__context__" => "exception context",
    "builtins.NameError.__delattr__" => "Implement delattr(self, name).",
    "builtins.NameError.__eq__" => "Return self==value.",
    "builtins.NameError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.NameError.__ge__" => "Return self>=value.",
    "builtins.NameError.__getattribute__" => "Return getattr(self, name).",
    "builtins.NameError.__getstate__" => "Helper for pickle.",
    "builtins.NameError.__gt__" => "Return self>value.",
    "builtins.NameError.__hash__" => "Return hash(self).",
    "builtins.NameError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.NameError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.NameError.__le__" => "Return self<=value.",
    "builtins.NameError.__lt__" => "Return self<value.",
    "builtins.NameError.__ne__" => "Return self!=value.",
    "builtins.NameError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.NameError.__reduce_ex__" => "Helper for pickle.",
    "builtins.NameError.__repr__" => "Return repr(self).",
    "builtins.NameError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.NameError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.NameError.__str__" => "Return str(self).",
    "builtins.NameError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.NameError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.NameError.name" => "name",
    "builtins.NameError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.NoneType" => "The type of the None singleton.",
    "builtins.NoneType.__bool__" => "True if self else False",
    "builtins.NoneType.__delattr__" => "Implement delattr(self, name).",
    "builtins.NoneType.__eq__" => "Return self==value.",
    "builtins.NoneType.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.NoneType.__ge__" => "Return self>=value.",
    "builtins.NoneType.__getattribute__" => "Return getattr(self, name).",
    "builtins.NoneType.__getstate__" => "Helper for pickle.",
    "builtins.NoneType.__gt__" => "Return self>value.",
    "builtins.NoneType.__hash__" => "Return hash(self).",
    "builtins.NoneType.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.NoneType.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.NoneType.__le__" => "Return self<=value.",
    "builtins.NoneType.__lt__" => "Return self<value.",
    "builtins.NoneType.__ne__" => "Return self!=value.",
    "builtins.NoneType.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.NoneType.__reduce__" => "Helper for pickle.",
    "builtins.NoneType.__reduce_ex__" => "Helper for pickle.",
    "builtins.NoneType.__repr__" => "Return repr(self).",
    "builtins.NoneType.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.NoneType.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.NoneType.__str__" => "Return str(self).",
    "builtins.NoneType.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.NotADirectoryError" => "Operation only works on directories.",
    "builtins.NotADirectoryError.__cause__" => "exception cause",
    "builtins.NotADirectoryError.__context__" => "exception context",
    "builtins.NotADirectoryError.__delattr__" => "Implement delattr(self, name).",
    "builtins.NotADirectoryError.__eq__" => "Return self==value.",
    "builtins.NotADirectoryError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.NotADirectoryError.__ge__" => "Return self>=value.",
    "builtins.NotADirectoryError.__getattribute__" => "Return getattr(self, name).",
    "builtins.NotADirectoryError.__getstate__" => "Helper for pickle.",
    "builtins.NotADirectoryError.__gt__" => "Return self>value.",
    "builtins.NotADirectoryError.__hash__" => "Return hash(self).",
    "builtins.NotADirectoryError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.NotADirectoryError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.NotADirectoryError.__le__" => "Return self<=value.",
    "builtins.NotADirectoryError.__lt__" => "Return self<value.",
    "builtins.NotADirectoryError.__ne__" => "Return self!=value.",
    "builtins.NotADirectoryError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.NotADirectoryError.__reduce_ex__" => "Helper for pickle.",
    "builtins.NotADirectoryError.__repr__" => "Return repr(self).",
    "builtins.NotADirectoryError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.NotADirectoryError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.NotADirectoryError.__str__" => "Return str(self).",
    "builtins.NotADirectoryError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.NotADirectoryError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.NotADirectoryError.errno" => "POSIX exception code",
    "builtins.NotADirectoryError.filename" => "exception filename",
    "builtins.NotADirectoryError.filename2" => "second exception filename",
    "builtins.NotADirectoryError.strerror" => "exception strerror",
    "builtins.NotADirectoryError.winerror" => "Win32 exception code",
    "builtins.NotADirectoryError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.NotImplementedError" => "Method or function hasn't been implemented yet.",
    "builtins.NotImplementedError.__cause__" => "exception cause",
    "builtins.NotImplementedError.__context__" => "exception context",
    "builtins.NotImplementedError.__delattr__" => "Implement delattr(self, name).",
    "builtins.NotImplementedError.__eq__" => "Return self==value.",
    "builtins.NotImplementedError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.NotImplementedError.__ge__" => "Return self>=value.",
    "builtins.NotImplementedError.__getattribute__" => "Return getattr(self, name).",
    "builtins.NotImplementedError.__getstate__" => "Helper for pickle.",
    "builtins.NotImplementedError.__gt__" => "Return self>value.",
    "builtins.NotImplementedError.__hash__" => "Return hash(self).",
    "builtins.NotImplementedError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.NotImplementedError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.NotImplementedError.__le__" => "Return self<=value.",
    "builtins.NotImplementedError.__lt__" => "Return self<value.",
    "builtins.NotImplementedError.__ne__" => "Return self!=value.",
    "builtins.NotImplementedError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.NotImplementedError.__reduce_ex__" => "Helper for pickle.",
    "builtins.NotImplementedError.__repr__" => "Return repr(self).",
    "builtins.NotImplementedError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.NotImplementedError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.NotImplementedError.__str__" => "Return str(self).",
    "builtins.NotImplementedError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.NotImplementedError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.NotImplementedError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.OSError" => "Base class for I/O related errors.",
    "builtins.OSError.__cause__" => "exception cause",
    "builtins.OSError.__context__" => "exception context",
    "builtins.OSError.__delattr__" => "Implement delattr(self, name).",
    "builtins.OSError.__eq__" => "Return self==value.",
    "builtins.OSError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.OSError.__ge__" => "Return self>=value.",
    "builtins.OSError.__getattribute__" => "Return getattr(self, name).",
    "builtins.OSError.__getstate__" => "Helper for pickle.",
    "builtins.OSError.__gt__" => "Return self>value.",
    "builtins.OSError.__hash__" => "Return hash(self).",
    "builtins.OSError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.OSError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.OSError.__le__" => "Return self<=value.",
    "builtins.OSError.__lt__" => "Return self<value.",
    "builtins.OSError.__ne__" => "Return self!=value.",
    "builtins.OSError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.OSError.__reduce_ex__" => "Helper for pickle.",
    "builtins.OSError.__repr__" => "Return repr(self).",
    "builtins.OSError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.OSError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.OSError.__str__" => "Return str(self).",
    "builtins.OSError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.OSError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.OSError.errno" => "POSIX exception code",
    "builtins.OSError.filename" => "exception filename",
    "builtins.OSError.filename2" => "second exception filename",
    "builtins.OSError.strerror" => "exception strerror",
    "builtins.OSError.winerror" => "Win32 exception code",
    "builtins.OSError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.OverflowError" => "Result too large to be represented.",
    "builtins.OverflowError.__cause__" => "exception cause",
    "builtins.OverflowError.__context__" => "exception context",
    "builtins.OverflowError.__delattr__" => "Implement delattr(self, name).",
    "builtins.OverflowError.__eq__" => "Return self==value.",
    "builtins.OverflowError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.OverflowError.__ge__" => "Return self>=value.",
    "builtins.OverflowError.__getattribute__" => "Return getattr(self, name).",
    "builtins.OverflowError.__getstate__" => "Helper for pickle.",
    "builtins.OverflowError.__gt__" => "Return self>value.",
    "builtins.OverflowError.__hash__" => "Return hash(self).",
    "builtins.OverflowError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.OverflowError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.OverflowError.__le__" => "Return self<=value.",
    "builtins.OverflowError.__lt__" => "Return self<value.",
    "builtins.OverflowError.__ne__" => "Return self!=value.",
    "builtins.OverflowError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.OverflowError.__reduce_ex__" => "Helper for pickle.",
    "builtins.OverflowError.__repr__" => "Return repr(self).",
    "builtins.OverflowError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.OverflowError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.OverflowError.__str__" => "Return str(self).",
    "builtins.OverflowError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.OverflowError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.OverflowError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.PendingDeprecationWarning" => "Base class for warnings about features which will be deprecated\nin the future.",
    "builtins.PendingDeprecationWarning.__cause__" => "exception cause",
    "builtins.PendingDeprecationWarning.__context__" => "exception context",
    "builtins.PendingDeprecationWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.PendingDeprecationWarning.__eq__" => "Return self==value.",
    "builtins.PendingDeprecationWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.PendingDeprecationWarning.__ge__" => "Return self>=value.",
    "builtins.PendingDeprecationWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.PendingDeprecationWarning.__getstate__" => "Helper for pickle.",
    "builtins.PendingDeprecationWarning.__gt__" => "Return self>value.",
    "builtins.PendingDeprecationWarning.__hash__" => "Return hash(self).",
    "builtins.PendingDeprecationWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.PendingDeprecationWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.PendingDeprecationWarning.__le__" => "Return self<=value.",
    "builtins.PendingDeprecationWarning.__lt__" => "Return self<value.",
    "builtins.PendingDeprecationWarning.__ne__" => "Return self!=value.",
    "builtins.PendingDeprecationWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.PendingDeprecationWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.PendingDeprecationWarning.__repr__" => "Return repr(self).",
    "builtins.PendingDeprecationWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.PendingDeprecationWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.PendingDeprecationWarning.__str__" => "Return str(self).",
    "builtins.PendingDeprecationWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.PendingDeprecationWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.PendingDeprecationWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.PermissionError" => "Not enough permissions.",
    "builtins.PermissionError.__cause__" => "exception cause",
    "builtins.PermissionError.__context__" => "exception context",
    "builtins.PermissionError.__delattr__" => "Implement delattr(self, name).",
    "builtins.PermissionError.__eq__" => "Return self==value.",
    "builtins.PermissionError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.PermissionError.__ge__" => "Return self>=value.",
    "builtins.PermissionError.__getattribute__" => "Return getattr(self, name).",
    "builtins.PermissionError.__getstate__" => "Helper for pickle.",
    "builtins.PermissionError.__gt__" => "Return self>value.",
    "builtins.PermissionError.__hash__" => "Return hash(self).",
    "builtins.PermissionError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.PermissionError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.PermissionError.__le__" => "Return self<=value.",
    "builtins.PermissionError.__lt__" => "Return self<value.",
    "builtins.PermissionError.__ne__" => "Return self!=value.",
    "builtins.PermissionError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.PermissionError.__reduce_ex__" => "Helper for pickle.",
    "builtins.PermissionError.__repr__" => "Return repr(self).",
    "builtins.PermissionError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.PermissionError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.PermissionError.__str__" => "Return str(self).",
    "builtins.PermissionError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.PermissionError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.PermissionError.errno" => "POSIX exception code",
    "builtins.PermissionError.filename" => "exception filename",
    "builtins.PermissionError.filename2" => "second exception filename",
    "builtins.PermissionError.strerror" => "exception strerror",
    "builtins.PermissionError.winerror" => "Win32 exception code",
    "builtins.PermissionError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ProcessLookupError" => "Process not found.",
    "builtins.ProcessLookupError.__cause__" => "exception cause",
    "builtins.ProcessLookupError.__context__" => "exception context",
    "builtins.ProcessLookupError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ProcessLookupError.__eq__" => "Return self==value.",
    "builtins.ProcessLookupError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ProcessLookupError.__ge__" => "Return self>=value.",
    "builtins.ProcessLookupError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ProcessLookupError.__getstate__" => "Helper for pickle.",
    "builtins.ProcessLookupError.__gt__" => "Return self>value.",
    "builtins.ProcessLookupError.__hash__" => "Return hash(self).",
    "builtins.ProcessLookupError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ProcessLookupError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ProcessLookupError.__le__" => "Return self<=value.",
    "builtins.ProcessLookupError.__lt__" => "Return self<value.",
    "builtins.ProcessLookupError.__ne__" => "Return self!=value.",
    "builtins.ProcessLookupError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ProcessLookupError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ProcessLookupError.__repr__" => "Return repr(self).",
    "builtins.ProcessLookupError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ProcessLookupError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ProcessLookupError.__str__" => "Return str(self).",
    "builtins.ProcessLookupError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ProcessLookupError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ProcessLookupError.errno" => "POSIX exception code",
    "builtins.ProcessLookupError.filename" => "exception filename",
    "builtins.ProcessLookupError.filename2" => "second exception filename",
    "builtins.ProcessLookupError.strerror" => "exception strerror",
    "builtins.ProcessLookupError.winerror" => "Win32 exception code",
    "builtins.ProcessLookupError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.PythonFinalizationError" => "Operation blocked during Python finalization.",
    "builtins.PythonFinalizationError.__cause__" => "exception cause",
    "builtins.PythonFinalizationError.__context__" => "exception context",
    "builtins.PythonFinalizationError.__delattr__" => "Implement delattr(self, name).",
    "builtins.PythonFinalizationError.__eq__" => "Return self==value.",
    "builtins.PythonFinalizationError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.PythonFinalizationError.__ge__" => "Return self>=value.",
    "builtins.PythonFinalizationError.__getattribute__" => "Return getattr(self, name).",
    "builtins.PythonFinalizationError.__getstate__" => "Helper for pickle.",
    "builtins.PythonFinalizationError.__gt__" => "Return self>value.",
    "builtins.PythonFinalizationError.__hash__" => "Return hash(self).",
    "builtins.PythonFinalizationError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.PythonFinalizationError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.PythonFinalizationError.__le__" => "Return self<=value.",
    "builtins.PythonFinalizationError.__lt__" => "Return self<value.",
    "builtins.PythonFinalizationError.__ne__" => "Return self!=value.",
    "builtins.PythonFinalizationError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.PythonFinalizationError.__reduce_ex__" => "Helper for pickle.",
    "builtins.PythonFinalizationError.__repr__" => "Return repr(self).",
    "builtins.PythonFinalizationError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.PythonFinalizationError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.PythonFinalizationError.__str__" => "Return str(self).",
    "builtins.PythonFinalizationError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.PythonFinalizationError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.PythonFinalizationError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.RecursionError" => "Recursion limit exceeded.",
    "builtins.RecursionError.__cause__" => "exception cause",
    "builtins.RecursionError.__context__" => "exception context",
    "builtins.RecursionError.__delattr__" => "Implement delattr(self, name).",
    "builtins.RecursionError.__eq__" => "Return self==value.",
    "builtins.RecursionError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.RecursionError.__ge__" => "Return self>=value.",
    "builtins.RecursionError.__getattribute__" => "Return getattr(self, name).",
    "builtins.RecursionError.__getstate__" => "Helper for pickle.",
    "builtins.RecursionError.__gt__" => "Return self>value.",
    "builtins.RecursionError.__hash__" => "Return hash(self).",
    "builtins.RecursionError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.RecursionError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.RecursionError.__le__" => "Return self<=value.",
    "builtins.RecursionError.__lt__" => "Return self<value.",
    "builtins.RecursionError.__ne__" => "Return self!=value.",
    "builtins.RecursionError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.RecursionError.__reduce_ex__" => "Helper for pickle.",
    "builtins.RecursionError.__repr__" => "Return repr(self).",
    "builtins.RecursionError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.RecursionError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.RecursionError.__str__" => "Return str(self).",
    "builtins.RecursionError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.RecursionError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.RecursionError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ReferenceError" => "Weak ref proxy used after referent went away.",
    "builtins.ReferenceError.__cause__" => "exception cause",
    "builtins.ReferenceError.__context__" => "exception context",
    "builtins.ReferenceError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ReferenceError.__eq__" => "Return self==value.",
    "builtins.ReferenceError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ReferenceError.__ge__" => "Return self>=value.",
    "builtins.ReferenceError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ReferenceError.__getstate__" => "Helper for pickle.",
    "builtins.ReferenceError.__gt__" => "Return self>value.",
    "builtins.ReferenceError.__hash__" => "Return hash(self).",
    "builtins.ReferenceError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ReferenceError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ReferenceError.__le__" => "Return self<=value.",
    "builtins.ReferenceError.__lt__" => "Return self<value.",
    "builtins.ReferenceError.__ne__" => "Return self!=value.",
    "builtins.ReferenceError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ReferenceError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ReferenceError.__repr__" => "Return repr(self).",
    "builtins.ReferenceError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ReferenceError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ReferenceError.__str__" => "Return str(self).",
    "builtins.ReferenceError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ReferenceError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ReferenceError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ResourceWarning" => "Base class for warnings about resource usage.",
    "builtins.ResourceWarning.__cause__" => "exception cause",
    "builtins.ResourceWarning.__context__" => "exception context",
    "builtins.ResourceWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.ResourceWarning.__eq__" => "Return self==value.",
    "builtins.ResourceWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ResourceWarning.__ge__" => "Return self>=value.",
    "builtins.ResourceWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.ResourceWarning.__getstate__" => "Helper for pickle.",
    "builtins.ResourceWarning.__gt__" => "Return self>value.",
    "builtins.ResourceWarning.__hash__" => "Return hash(self).",
    "builtins.ResourceWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ResourceWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ResourceWarning.__le__" => "Return self<=value.",
    "builtins.ResourceWarning.__lt__" => "Return self<value.",
    "builtins.ResourceWarning.__ne__" => "Return self!=value.",
    "builtins.ResourceWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ResourceWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.ResourceWarning.__repr__" => "Return repr(self).",
    "builtins.ResourceWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ResourceWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ResourceWarning.__str__" => "Return str(self).",
    "builtins.ResourceWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ResourceWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ResourceWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.RuntimeError" => "Unspecified run-time error.",
    "builtins.RuntimeError.__cause__" => "exception cause",
    "builtins.RuntimeError.__context__" => "exception context",
    "builtins.RuntimeError.__delattr__" => "Implement delattr(self, name).",
    "builtins.RuntimeError.__eq__" => "Return self==value.",
    "builtins.RuntimeError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.RuntimeError.__ge__" => "Return self>=value.",
    "builtins.RuntimeError.__getattribute__" => "Return getattr(self, name).",
    "builtins.RuntimeError.__getstate__" => "Helper for pickle.",
    "builtins.RuntimeError.__gt__" => "Return self>value.",
    "builtins.RuntimeError.__hash__" => "Return hash(self).",
    "builtins.RuntimeError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.RuntimeError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.RuntimeError.__le__" => "Return self<=value.",
    "builtins.RuntimeError.__lt__" => "Return self<value.",
    "builtins.RuntimeError.__ne__" => "Return self!=value.",
    "builtins.RuntimeError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.RuntimeError.__reduce_ex__" => "Helper for pickle.",
    "builtins.RuntimeError.__repr__" => "Return repr(self).",
    "builtins.RuntimeError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.RuntimeError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.RuntimeError.__str__" => "Return str(self).",
    "builtins.RuntimeError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.RuntimeError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.RuntimeError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.RuntimeWarning" => "Base class for warnings about dubious runtime behavior.",
    "builtins.RuntimeWarning.__cause__" => "exception cause",
    "builtins.RuntimeWarning.__context__" => "exception context",
    "builtins.RuntimeWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.RuntimeWarning.__eq__" => "Return self==value.",
    "builtins.RuntimeWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.RuntimeWarning.__ge__" => "Return self>=value.",
    "builtins.RuntimeWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.RuntimeWarning.__getstate__" => "Helper for pickle.",
    "builtins.RuntimeWarning.__gt__" => "Return self>value.",
    "builtins.RuntimeWarning.__hash__" => "Return hash(self).",
    "builtins.RuntimeWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.RuntimeWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.RuntimeWarning.__le__" => "Return self<=value.",
    "builtins.RuntimeWarning.__lt__" => "Return self<value.",
    "builtins.RuntimeWarning.__ne__" => "Return self!=value.",
    "builtins.RuntimeWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.RuntimeWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.RuntimeWarning.__repr__" => "Return repr(self).",
    "builtins.RuntimeWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.RuntimeWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.RuntimeWarning.__str__" => "Return str(self).",
    "builtins.RuntimeWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.RuntimeWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.RuntimeWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.StopAsyncIteration" => "Signal the end from iterator.__anext__().",
    "builtins.StopAsyncIteration.__cause__" => "exception cause",
    "builtins.StopAsyncIteration.__context__" => "exception context",
    "builtins.StopAsyncIteration.__delattr__" => "Implement delattr(self, name).",
    "builtins.StopAsyncIteration.__eq__" => "Return self==value.",
    "builtins.StopAsyncIteration.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.StopAsyncIteration.__ge__" => "Return self>=value.",
    "builtins.StopAsyncIteration.__getattribute__" => "Return getattr(self, name).",
    "builtins.StopAsyncIteration.__getstate__" => "Helper for pickle.",
    "builtins.StopAsyncIteration.__gt__" => "Return self>value.",
    "builtins.StopAsyncIteration.__hash__" => "Return hash(self).",
    "builtins.StopAsyncIteration.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.StopAsyncIteration.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.StopAsyncIteration.__le__" => "Return self<=value.",
    "builtins.StopAsyncIteration.__lt__" => "Return self<value.",
    "builtins.StopAsyncIteration.__ne__" => "Return self!=value.",
    "builtins.StopAsyncIteration.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.StopAsyncIteration.__reduce_ex__" => "Helper for pickle.",
    "builtins.StopAsyncIteration.__repr__" => "Return repr(self).",
    "builtins.StopAsyncIteration.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.StopAsyncIteration.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.StopAsyncIteration.__str__" => "Return str(self).",
    "builtins.StopAsyncIteration.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.StopAsyncIteration.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.StopAsyncIteration.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.StopIteration" => "Signal the end from iterator.__next__().",
    "builtins.StopIteration.__cause__" => "exception cause",
    "builtins.StopIteration.__context__" => "exception context",
    "builtins.StopIteration.__delattr__" => "Implement delattr(self, name).",
    "builtins.StopIteration.__eq__" => "Return self==value.",
    "builtins.StopIteration.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.StopIteration.__ge__" => "Return self>=value.",
    "builtins.StopIteration.__getattribute__" => "Return getattr(self, name).",
    "builtins.StopIteration.__getstate__" => "Helper for pickle.",
    "builtins.StopIteration.__gt__" => "Return self>value.",
    "builtins.StopIteration.__hash__" => "Return hash(self).",
    "builtins.StopIteration.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.StopIteration.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.StopIteration.__le__" => "Return self<=value.",
    "builtins.StopIteration.__lt__" => "Return self<value.",
    "builtins.StopIteration.__ne__" => "Return self!=value.",
    "builtins.StopIteration.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.StopIteration.__reduce_ex__" => "Helper for pickle.",
    "builtins.StopIteration.__repr__" => "Return repr(self).",
    "builtins.StopIteration.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.StopIteration.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.StopIteration.__str__" => "Return str(self).",
    "builtins.StopIteration.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.StopIteration.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.StopIteration.value" => "generator return value",
    "builtins.StopIteration.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.SyntaxError" => "Invalid syntax.",
    "builtins.SyntaxError.__cause__" => "exception cause",
    "builtins.SyntaxError.__context__" => "exception context",
    "builtins.SyntaxError.__delattr__" => "Implement delattr(self, name).",
    "builtins.SyntaxError.__eq__" => "Return self==value.",
    "builtins.SyntaxError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.SyntaxError.__ge__" => "Return self>=value.",
    "builtins.SyntaxError.__getattribute__" => "Return getattr(self, name).",
    "builtins.SyntaxError.__getstate__" => "Helper for pickle.",
    "builtins.SyntaxError.__gt__" => "Return self>value.",
    "builtins.SyntaxError.__hash__" => "Return hash(self).",
    "builtins.SyntaxError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.SyntaxError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.SyntaxError.__le__" => "Return self<=value.",
    "builtins.SyntaxError.__lt__" => "Return self<value.",
    "builtins.SyntaxError.__ne__" => "Return self!=value.",
    "builtins.SyntaxError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.SyntaxError.__reduce_ex__" => "Helper for pickle.",
    "builtins.SyntaxError.__repr__" => "Return repr(self).",
    "builtins.SyntaxError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.SyntaxError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.SyntaxError.__str__" => "Return str(self).",
    "builtins.SyntaxError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.SyntaxError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.SyntaxError.end_lineno" => "exception end lineno",
    "builtins.SyntaxError.end_offset" => "exception end offset",
    "builtins.SyntaxError.filename" => "exception filename",
    "builtins.SyntaxError.lineno" => "exception lineno",
    "builtins.SyntaxError.msg" => "exception msg",
    "builtins.SyntaxError.offset" => "exception offset",
    "builtins.SyntaxError.print_file_and_line" => "exception print_file_and_line",
    "builtins.SyntaxError.text" => "exception text",
    "builtins.SyntaxError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.SyntaxWarning" => "Base class for warnings about dubious syntax.",
    "builtins.SyntaxWarning.__cause__" => "exception cause",
    "builtins.SyntaxWarning.__context__" => "exception context",
    "builtins.SyntaxWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.SyntaxWarning.__eq__" => "Return self==value.",
    "builtins.SyntaxWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.SyntaxWarning.__ge__" => "Return self>=value.",
    "builtins.SyntaxWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.SyntaxWarning.__getstate__" => "Helper for pickle.",
    "builtins.SyntaxWarning.__gt__" => "Return self>value.",
    "builtins.SyntaxWarning.__hash__" => "Return hash(self).",
    "builtins.SyntaxWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.SyntaxWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.SyntaxWarning.__le__" => "Return self<=value.",
    "builtins.SyntaxWarning.__lt__" => "Return self<value.",
    "builtins.SyntaxWarning.__ne__" => "Return self!=value.",
    "builtins.SyntaxWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.SyntaxWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.SyntaxWarning.__repr__" => "Return repr(self).",
    "builtins.SyntaxWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.SyntaxWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.SyntaxWarning.__str__" => "Return str(self).",
    "builtins.SyntaxWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.SyntaxWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.SyntaxWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.SystemError" => "Internal error in the Python interpreter.\n\nPlease report this to the Python maintainer, along with the traceback,\nthe Python version, and the hardware/OS platform and version.",
    "builtins.SystemError.__cause__" => "exception cause",
    "builtins.SystemError.__context__" => "exception context",
    "builtins.SystemError.__delattr__" => "Implement delattr(self, name).",
    "builtins.SystemError.__eq__" => "Return self==value.",
    "builtins.SystemError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.SystemError.__ge__" => "Return self>=value.",
    "builtins.SystemError.__getattribute__" => "Return getattr(self, name).",
    "builtins.SystemError.__getstate__" => "Helper for pickle.",
    "builtins.SystemError.__gt__" => "Return self>value.",
    "builtins.SystemError.__hash__" => "Return hash(self).",
    "builtins.SystemError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.SystemError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.SystemError.__le__" => "Return self<=value.",
    "builtins.SystemError.__lt__" => "Return self<value.",
    "builtins.SystemError.__ne__" => "Return self!=value.",
    "builtins.SystemError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.SystemError.__reduce_ex__" => "Helper for pickle.",
    "builtins.SystemError.__repr__" => "Return repr(self).",
    "builtins.SystemError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.SystemError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.SystemError.__str__" => "Return str(self).",
    "builtins.SystemError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.SystemError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.SystemError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.SystemExit" => "Request to exit from the interpreter.",
    "builtins.SystemExit.__cause__" => "exception cause",
    "builtins.SystemExit.__context__" => "exception context",
    "builtins.SystemExit.__delattr__" => "Implement delattr(self, name).",
    "builtins.SystemExit.__eq__" => "Return self==value.",
    "builtins.SystemExit.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.SystemExit.__ge__" => "Return self>=value.",
    "builtins.SystemExit.__getattribute__" => "Return getattr(self, name).",
    "builtins.SystemExit.__getstate__" => "Helper for pickle.",
    "builtins.SystemExit.__gt__" => "Return self>value.",
    "builtins.SystemExit.__hash__" => "Return hash(self).",
    "builtins.SystemExit.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.SystemExit.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.SystemExit.__le__" => "Return self<=value.",
    "builtins.SystemExit.__lt__" => "Return self<value.",
    "builtins.SystemExit.__ne__" => "Return self!=value.",
    "builtins.SystemExit.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.SystemExit.__reduce_ex__" => "Helper for pickle.",
    "builtins.SystemExit.__repr__" => "Return repr(self).",
    "builtins.SystemExit.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.SystemExit.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.SystemExit.__str__" => "Return str(self).",
    "builtins.SystemExit.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.SystemExit.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.SystemExit.code" => "exception code",
    "builtins.SystemExit.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.TabError" => "Improper mixture of spaces and tabs.",
    "builtins.TabError.__cause__" => "exception cause",
    "builtins.TabError.__context__" => "exception context",
    "builtins.TabError.__delattr__" => "Implement delattr(self, name).",
    "builtins.TabError.__eq__" => "Return self==value.",
    "builtins.TabError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.TabError.__ge__" => "Return self>=value.",
    "builtins.TabError.__getattribute__" => "Return getattr(self, name).",
    "builtins.TabError.__getstate__" => "Helper for pickle.",
    "builtins.TabError.__gt__" => "Return self>value.",
    "builtins.TabError.__hash__" => "Return hash(self).",
    "builtins.TabError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.TabError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.TabError.__le__" => "Return self<=value.",
    "builtins.TabError.__lt__" => "Return self<value.",
    "builtins.TabError.__ne__" => "Return self!=value.",
    "builtins.TabError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.TabError.__reduce_ex__" => "Helper for pickle.",
    "builtins.TabError.__repr__" => "Return repr(self).",
    "builtins.TabError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.TabError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.TabError.__str__" => "Return str(self).",
    "builtins.TabError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.TabError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.TabError.end_lineno" => "exception end lineno",
    "builtins.TabError.end_offset" => "exception end offset",
    "builtins.TabError.filename" => "exception filename",
    "builtins.TabError.lineno" => "exception lineno",
    "builtins.TabError.msg" => "exception msg",
    "builtins.TabError.offset" => "exception offset",
    "builtins.TabError.print_file_and_line" => "exception print_file_and_line",
    "builtins.TabError.text" => "exception text",
    "builtins.TabError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.TimeoutError" => "Timeout expired.",
    "builtins.TimeoutError.__cause__" => "exception cause",
    "builtins.TimeoutError.__context__" => "exception context",
    "builtins.TimeoutError.__delattr__" => "Implement delattr(self, name).",
    "builtins.TimeoutError.__eq__" => "Return self==value.",
    "builtins.TimeoutError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.TimeoutError.__ge__" => "Return self>=value.",
    "builtins.TimeoutError.__getattribute__" => "Return getattr(self, name).",
    "builtins.TimeoutError.__getstate__" => "Helper for pickle.",
    "builtins.TimeoutError.__gt__" => "Return self>value.",
    "builtins.TimeoutError.__hash__" => "Return hash(self).",
    "builtins.TimeoutError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.TimeoutError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.TimeoutError.__le__" => "Return self<=value.",
    "builtins.TimeoutError.__lt__" => "Return self<value.",
    "builtins.TimeoutError.__ne__" => "Return self!=value.",
    "builtins.TimeoutError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.TimeoutError.__reduce_ex__" => "Helper for pickle.",
    "builtins.TimeoutError.__repr__" => "Return repr(self).",
    "builtins.TimeoutError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.TimeoutError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.TimeoutError.__str__" => "Return str(self).",
    "builtins.TimeoutError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.TimeoutError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.TimeoutError.errno" => "POSIX exception code",
    "builtins.TimeoutError.filename" => "exception filename",
    "builtins.TimeoutError.filename2" => "second exception filename",
    "builtins.TimeoutError.strerror" => "exception strerror",
    "builtins.TimeoutError.winerror" => "Win32 exception code",
    "builtins.TimeoutError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.TypeError" => "Inappropriate argument type.",
    "builtins.TypeError.__cause__" => "exception cause",
    "builtins.TypeError.__context__" => "exception context",
    "builtins.TypeError.__delattr__" => "Implement delattr(self, name).",
    "builtins.TypeError.__eq__" => "Return self==value.",
    "builtins.TypeError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.TypeError.__ge__" => "Return self>=value.",
    "builtins.TypeError.__getattribute__" => "Return getattr(self, name).",
    "builtins.TypeError.__getstate__" => "Helper for pickle.",
    "builtins.TypeError.__gt__" => "Return self>value.",
    "builtins.TypeError.__hash__" => "Return hash(self).",
    "builtins.TypeError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.TypeError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.TypeError.__le__" => "Return self<=value.",
    "builtins.TypeError.__lt__" => "Return self<value.",
    "builtins.TypeError.__ne__" => "Return self!=value.",
    "builtins.TypeError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.TypeError.__reduce_ex__" => "Helper for pickle.",
    "builtins.TypeError.__repr__" => "Return repr(self).",
    "builtins.TypeError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.TypeError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.TypeError.__str__" => "Return str(self).",
    "builtins.TypeError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.TypeError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.TypeError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.UnboundLocalError" => "Local name referenced but not bound to a value.",
    "builtins.UnboundLocalError.__cause__" => "exception cause",
    "builtins.UnboundLocalError.__context__" => "exception context",
    "builtins.UnboundLocalError.__delattr__" => "Implement delattr(self, name).",
    "builtins.UnboundLocalError.__eq__" => "Return self==value.",
    "builtins.UnboundLocalError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.UnboundLocalError.__ge__" => "Return self>=value.",
    "builtins.UnboundLocalError.__getattribute__" => "Return getattr(self, name).",
    "builtins.UnboundLocalError.__getstate__" => "Helper for pickle.",
    "builtins.UnboundLocalError.__gt__" => "Return self>value.",
    "builtins.UnboundLocalError.__hash__" => "Return hash(self).",
    "builtins.UnboundLocalError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.UnboundLocalError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.UnboundLocalError.__le__" => "Return self<=value.",
    "builtins.UnboundLocalError.__lt__" => "Return self<value.",
    "builtins.UnboundLocalError.__ne__" => "Return self!=value.",
    "builtins.UnboundLocalError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.UnboundLocalError.__reduce_ex__" => "Helper for pickle.",
    "builtins.UnboundLocalError.__repr__" => "Return repr(self).",
    "builtins.UnboundLocalError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.UnboundLocalError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.UnboundLocalError.__str__" => "Return str(self).",
    "builtins.UnboundLocalError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.UnboundLocalError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.UnboundLocalError.name" => "name",
    "builtins.UnboundLocalError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.UnicodeDecodeError" => "Unicode decoding error.",
    "builtins.UnicodeDecodeError.__cause__" => "exception cause",
    "builtins.UnicodeDecodeError.__context__" => "exception context",
    "builtins.UnicodeDecodeError.__delattr__" => "Implement delattr(self, name).",
    "builtins.UnicodeDecodeError.__eq__" => "Return self==value.",
    "builtins.UnicodeDecodeError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.UnicodeDecodeError.__ge__" => "Return self>=value.",
    "builtins.UnicodeDecodeError.__getattribute__" => "Return getattr(self, name).",
    "builtins.UnicodeDecodeError.__getstate__" => "Helper for pickle.",
    "builtins.UnicodeDecodeError.__gt__" => "Return self>value.",
    "builtins.UnicodeDecodeError.__hash__" => "Return hash(self).",
    "builtins.UnicodeDecodeError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.UnicodeDecodeError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.UnicodeDecodeError.__le__" => "Return self<=value.",
    "builtins.UnicodeDecodeError.__lt__" => "Return self<value.",
    "builtins.UnicodeDecodeError.__ne__" => "Return self!=value.",
    "builtins.UnicodeDecodeError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.UnicodeDecodeError.__reduce_ex__" => "Helper for pickle.",
    "builtins.UnicodeDecodeError.__repr__" => "Return repr(self).",
    "builtins.UnicodeDecodeError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.UnicodeDecodeError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.UnicodeDecodeError.__str__" => "Return str(self).",
    "builtins.UnicodeDecodeError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.UnicodeDecodeError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.UnicodeDecodeError.encoding" => "exception encoding",
    "builtins.UnicodeDecodeError.end" => "exception end",
    "builtins.UnicodeDecodeError.object" => "exception object",
    "builtins.UnicodeDecodeError.reason" => "exception reason",
    "builtins.UnicodeDecodeError.start" => "exception start",
    "builtins.UnicodeDecodeError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.UnicodeEncodeError" => "Unicode encoding error.",
    "builtins.UnicodeEncodeError.__cause__" => "exception cause",
    "builtins.UnicodeEncodeError.__context__" => "exception context",
    "builtins.UnicodeEncodeError.__delattr__" => "Implement delattr(self, name).",
    "builtins.UnicodeEncodeError.__eq__" => "Return self==value.",
    "builtins.UnicodeEncodeError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.UnicodeEncodeError.__ge__" => "Return self>=value.",
    "builtins.UnicodeEncodeError.__getattribute__" => "Return getattr(self, name).",
    "builtins.UnicodeEncodeError.__getstate__" => "Helper for pickle.",
    "builtins.UnicodeEncodeError.__gt__" => "Return self>value.",
    "builtins.UnicodeEncodeError.__hash__" => "Return hash(self).",
    "builtins.UnicodeEncodeError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.UnicodeEncodeError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.UnicodeEncodeError.__le__" => "Return self<=value.",
    "builtins.UnicodeEncodeError.__lt__" => "Return self<value.",
    "builtins.UnicodeEncodeError.__ne__" => "Return self!=value.",
    "builtins.UnicodeEncodeError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.UnicodeEncodeError.__reduce_ex__" => "Helper for pickle.",
    "builtins.UnicodeEncodeError.__repr__" => "Return repr(self).",
    "builtins.UnicodeEncodeError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.UnicodeEncodeError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.UnicodeEncodeError.__str__" => "Return str(self).",
    "builtins.UnicodeEncodeError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.UnicodeEncodeError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.UnicodeEncodeError.encoding" => "exception encoding",
    "builtins.UnicodeEncodeError.end" => "exception end",
    "builtins.UnicodeEncodeError.object" => "exception object",
    "builtins.UnicodeEncodeError.reason" => "exception reason",
    "builtins.UnicodeEncodeError.start" => "exception start",
    "builtins.UnicodeEncodeError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.UnicodeError" => "Unicode related error.",
    "builtins.UnicodeError.__cause__" => "exception cause",
    "builtins.UnicodeError.__context__" => "exception context",
    "builtins.UnicodeError.__delattr__" => "Implement delattr(self, name).",
    "builtins.UnicodeError.__eq__" => "Return self==value.",
    "builtins.UnicodeError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.UnicodeError.__ge__" => "Return self>=value.",
    "builtins.UnicodeError.__getattribute__" => "Return getattr(self, name).",
    "builtins.UnicodeError.__getstate__" => "Helper for pickle.",
    "builtins.UnicodeError.__gt__" => "Return self>value.",
    "builtins.UnicodeError.__hash__" => "Return hash(self).",
    "builtins.UnicodeError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.UnicodeError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.UnicodeError.__le__" => "Return self<=value.",
    "builtins.UnicodeError.__lt__" => "Return self<value.",
    "builtins.UnicodeError.__ne__" => "Return self!=value.",
    "builtins.UnicodeError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.UnicodeError.__reduce_ex__" => "Helper for pickle.",
    "builtins.UnicodeError.__repr__" => "Return repr(self).",
    "builtins.UnicodeError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.UnicodeError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.UnicodeError.__str__" => "Return str(self).",
    "builtins.UnicodeError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.UnicodeError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.UnicodeError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.UnicodeTranslateError" => "Unicode translation error.",
    "builtins.UnicodeTranslateError.__cause__" => "exception cause",
    "builtins.UnicodeTranslateError.__context__" => "exception context",
    "builtins.UnicodeTranslateError.__delattr__" => "Implement delattr(self, name).",
    "builtins.UnicodeTranslateError.__eq__" => "Return self==value.",
    "builtins.UnicodeTranslateError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.UnicodeTranslateError.__ge__" => "Return self>=value.",
    "builtins.UnicodeTranslateError.__getattribute__" => "Return getattr(self, name).",
    "builtins.UnicodeTranslateError.__getstate__" => "Helper for pickle.",
    "builtins.UnicodeTranslateError.__gt__" => "Return self>value.",
    "builtins.UnicodeTranslateError.__hash__" => "Return hash(self).",
    "builtins.UnicodeTranslateError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.UnicodeTranslateError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.UnicodeTranslateError.__le__" => "Return self<=value.",
    "builtins.UnicodeTranslateError.__lt__" => "Return self<value.",
    "builtins.UnicodeTranslateError.__ne__" => "Return self!=value.",
    "builtins.UnicodeTranslateError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.UnicodeTranslateError.__reduce_ex__" => "Helper for pickle.",
    "builtins.UnicodeTranslateError.__repr__" => "Return repr(self).",
    "builtins.UnicodeTranslateError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.UnicodeTranslateError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.UnicodeTranslateError.__str__" => "Return str(self).",
    "builtins.UnicodeTranslateError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.UnicodeTranslateError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.UnicodeTranslateError.encoding" => "exception encoding",
    "builtins.UnicodeTranslateError.end" => "exception end",
    "builtins.UnicodeTranslateError.object" => "exception object",
    "builtins.UnicodeTranslateError.reason" => "exception reason",
    "builtins.UnicodeTranslateError.start" => "exception start",
    "builtins.UnicodeTranslateError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.UnicodeWarning" => "Base class for warnings about Unicode related problems, mostly\nrelated to conversion problems.",
    "builtins.UnicodeWarning.__cause__" => "exception cause",
    "builtins.UnicodeWarning.__context__" => "exception context",
    "builtins.UnicodeWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.UnicodeWarning.__eq__" => "Return self==value.",
    "builtins.UnicodeWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.UnicodeWarning.__ge__" => "Return self>=value.",
    "builtins.UnicodeWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.UnicodeWarning.__getstate__" => "Helper for pickle.",
    "builtins.UnicodeWarning.__gt__" => "Return self>value.",
    "builtins.UnicodeWarning.__hash__" => "Return hash(self).",
    "builtins.UnicodeWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.UnicodeWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.UnicodeWarning.__le__" => "Return self<=value.",
    "builtins.UnicodeWarning.__lt__" => "Return self<value.",
    "builtins.UnicodeWarning.__ne__" => "Return self!=value.",
    "builtins.UnicodeWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.UnicodeWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.UnicodeWarning.__repr__" => "Return repr(self).",
    "builtins.UnicodeWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.UnicodeWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.UnicodeWarning.__str__" => "Return str(self).",
    "builtins.UnicodeWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.UnicodeWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.UnicodeWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.UserWarning" => "Base class for warnings generated by user code.",
    "builtins.UserWarning.__cause__" => "exception cause",
    "builtins.UserWarning.__context__" => "exception context",
    "builtins.UserWarning.__delattr__" => "Implement delattr(self, name).",
    "builtins.UserWarning.__eq__" => "Return self==value.",
    "builtins.UserWarning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.UserWarning.__ge__" => "Return self>=value.",
    "builtins.UserWarning.__getattribute__" => "Return getattr(self, name).",
    "builtins.UserWarning.__getstate__" => "Helper for pickle.",
    "builtins.UserWarning.__gt__" => "Return self>value.",
    "builtins.UserWarning.__hash__" => "Return hash(self).",
    "builtins.UserWarning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.UserWarning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.UserWarning.__le__" => "Return self<=value.",
    "builtins.UserWarning.__lt__" => "Return self<value.",
    "builtins.UserWarning.__ne__" => "Return self!=value.",
    "builtins.UserWarning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.UserWarning.__reduce_ex__" => "Helper for pickle.",
    "builtins.UserWarning.__repr__" => "Return repr(self).",
    "builtins.UserWarning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.UserWarning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.UserWarning.__str__" => "Return str(self).",
    "builtins.UserWarning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.UserWarning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.UserWarning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ValueError" => "Inappropriate argument value (of correct type).",
    "builtins.ValueError.__cause__" => "exception cause",
    "builtins.ValueError.__context__" => "exception context",
    "builtins.ValueError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ValueError.__eq__" => "Return self==value.",
    "builtins.ValueError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ValueError.__ge__" => "Return self>=value.",
    "builtins.ValueError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ValueError.__getstate__" => "Helper for pickle.",
    "builtins.ValueError.__gt__" => "Return self>value.",
    "builtins.ValueError.__hash__" => "Return hash(self).",
    "builtins.ValueError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ValueError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ValueError.__le__" => "Return self<=value.",
    "builtins.ValueError.__lt__" => "Return self<value.",
    "builtins.ValueError.__ne__" => "Return self!=value.",
    "builtins.ValueError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ValueError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ValueError.__repr__" => "Return repr(self).",
    "builtins.ValueError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ValueError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ValueError.__str__" => "Return str(self).",
    "builtins.ValueError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ValueError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ValueError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.Warning" => "Base class for warning categories.",
    "builtins.Warning.__cause__" => "exception cause",
    "builtins.Warning.__context__" => "exception context",
    "builtins.Warning.__delattr__" => "Implement delattr(self, name).",
    "builtins.Warning.__eq__" => "Return self==value.",
    "builtins.Warning.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.Warning.__ge__" => "Return self>=value.",
    "builtins.Warning.__getattribute__" => "Return getattr(self, name).",
    "builtins.Warning.__getstate__" => "Helper for pickle.",
    "builtins.Warning.__gt__" => "Return self>value.",
    "builtins.Warning.__hash__" => "Return hash(self).",
    "builtins.Warning.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.Warning.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.Warning.__le__" => "Return self<=value.",
    "builtins.Warning.__lt__" => "Return self<value.",
    "builtins.Warning.__ne__" => "Return self!=value.",
    "builtins.Warning.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.Warning.__reduce_ex__" => "Helper for pickle.",
    "builtins.Warning.__repr__" => "Return repr(self).",
    "builtins.Warning.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.Warning.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.Warning.__str__" => "Return str(self).",
    "builtins.Warning.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.Warning.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.Warning.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.WindowsError" => "Base class for I/O related errors.",
    "builtins.WindowsError.__cause__" => "exception cause",
    "builtins.WindowsError.__context__" => "exception context",
    "builtins.WindowsError.__delattr__" => "Implement delattr(self, name).",
    "builtins.WindowsError.__eq__" => "Return self==value.",
    "builtins.WindowsError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.WindowsError.__ge__" => "Return self>=value.",
    "builtins.WindowsError.__getattribute__" => "Return getattr(self, name).",
    "builtins.WindowsError.__getstate__" => "Helper for pickle.",
    "builtins.WindowsError.__gt__" => "Return self>value.",
    "builtins.WindowsError.__hash__" => "Return hash(self).",
    "builtins.WindowsError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.WindowsError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.WindowsError.__le__" => "Return self<=value.",
    "builtins.WindowsError.__lt__" => "Return self<value.",
    "builtins.WindowsError.__ne__" => "Return self!=value.",
    "builtins.WindowsError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.WindowsError.__reduce_ex__" => "Helper for pickle.",
    "builtins.WindowsError.__repr__" => "Return repr(self).",
    "builtins.WindowsError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.WindowsError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.WindowsError.__str__" => "Return str(self).",
    "builtins.WindowsError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.WindowsError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.WindowsError.errno" => "POSIX exception code",
    "builtins.WindowsError.filename" => "exception filename",
    "builtins.WindowsError.filename2" => "second exception filename",
    "builtins.WindowsError.strerror" => "exception strerror",
    "builtins.WindowsError.winerror" => "Win32 exception code",
    "builtins.WindowsError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.ZeroDivisionError" => "Second argument to a division or modulo operation was zero.",
    "builtins.ZeroDivisionError.__cause__" => "exception cause",
    "builtins.ZeroDivisionError.__context__" => "exception context",
    "builtins.ZeroDivisionError.__delattr__" => "Implement delattr(self, name).",
    "builtins.ZeroDivisionError.__eq__" => "Return self==value.",
    "builtins.ZeroDivisionError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.ZeroDivisionError.__ge__" => "Return self>=value.",
    "builtins.ZeroDivisionError.__getattribute__" => "Return getattr(self, name).",
    "builtins.ZeroDivisionError.__getstate__" => "Helper for pickle.",
    "builtins.ZeroDivisionError.__gt__" => "Return self>value.",
    "builtins.ZeroDivisionError.__hash__" => "Return hash(self).",
    "builtins.ZeroDivisionError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.ZeroDivisionError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.ZeroDivisionError.__le__" => "Return self<=value.",
    "builtins.ZeroDivisionError.__lt__" => "Return self<value.",
    "builtins.ZeroDivisionError.__ne__" => "Return self!=value.",
    "builtins.ZeroDivisionError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.ZeroDivisionError.__reduce_ex__" => "Helper for pickle.",
    "builtins.ZeroDivisionError.__repr__" => "Return repr(self).",
    "builtins.ZeroDivisionError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.ZeroDivisionError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.ZeroDivisionError.__str__" => "Return str(self).",
    "builtins.ZeroDivisionError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.ZeroDivisionError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins.ZeroDivisionError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins._IncompleteInputError" => "incomplete input.",
    "builtins._IncompleteInputError.__cause__" => "exception cause",
    "builtins._IncompleteInputError.__context__" => "exception context",
    "builtins._IncompleteInputError.__delattr__" => "Implement delattr(self, name).",
    "builtins._IncompleteInputError.__eq__" => "Return self==value.",
    "builtins._IncompleteInputError.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins._IncompleteInputError.__ge__" => "Return self>=value.",
    "builtins._IncompleteInputError.__getattribute__" => "Return getattr(self, name).",
    "builtins._IncompleteInputError.__getstate__" => "Helper for pickle.",
    "builtins._IncompleteInputError.__gt__" => "Return self>value.",
    "builtins._IncompleteInputError.__hash__" => "Return hash(self).",
    "builtins._IncompleteInputError.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins._IncompleteInputError.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins._IncompleteInputError.__le__" => "Return self<=value.",
    "builtins._IncompleteInputError.__lt__" => "Return self<value.",
    "builtins._IncompleteInputError.__ne__" => "Return self!=value.",
    "builtins._IncompleteInputError.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins._IncompleteInputError.__reduce_ex__" => "Helper for pickle.",
    "builtins._IncompleteInputError.__repr__" => "Return repr(self).",
    "builtins._IncompleteInputError.__setattr__" => "Implement setattr(self, name, value).",
    "builtins._IncompleteInputError.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins._IncompleteInputError.__str__" => "Return str(self).",
    "builtins._IncompleteInputError.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins._IncompleteInputError.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "builtins._IncompleteInputError.end_lineno" => "exception end lineno",
    "builtins._IncompleteInputError.end_offset" => "exception end offset",
    "builtins._IncompleteInputError.filename" => "exception filename",
    "builtins._IncompleteInputError.lineno" => "exception lineno",
    "builtins._IncompleteInputError.msg" => "exception msg",
    "builtins._IncompleteInputError.offset" => "exception offset",
    "builtins._IncompleteInputError.print_file_and_line" => "exception print_file_and_line",
    "builtins._IncompleteInputError.text" => "exception text",
    "builtins._IncompleteInputError.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
    "builtins.__build_class__" => "__build_class__(func, name, /, *bases, [metaclass], **kwds) -> class\n\nInternal helper function used by the class statement.",
    "builtins.__import__" => "Import a module.\n\nBecause this function is meant for use by the Python\ninterpreter and not for general use, it is better to use\nimportlib.import_module() to programmatically import a module.\n\nThe globals argument is only used to determine the context;\nthey are not modified.  The locals argument is unused.  The fromlist\nshould be a list of names to emulate ``from name import ...``, or an\nempty list to emulate ``import name``.\nWhen importing a module from a package, note that __import__('A.B', ...)\nreturns package A when fromlist is empty, but its submodule B when\nfromlist is not empty.  The level argument is used to determine whether to\nperform absolute or relative imports: 0 is absolute, while a positive number\nis the number of parent directories to search relative to the current module.",
    "builtins.abs" => "Return the absolute value of the argument.",
    "builtins.aiter" => "Return an AsyncIterator for an AsyncIterable object.",
    "builtins.all" => "Return True if bool(x) is True for all values x in the iterable.\n\nIf the iterable is empty, return True.",
    "builtins.anext" => "Return the next item from the async iterator.\n\nIf default is given and the async iterator is exhausted,\nit is returned instead of raising StopAsyncIteration.",
    "builtins.any" => "Return True if bool(x) is True for any x in the iterable.\n\nIf the iterable is empty, return False.",
    "builtins.ascii" => "Return an ASCII-only representation of an object.\n\nAs repr(), return a string containing a printable representation of an\nobject, but escape the non-ASCII characters in the string returned by\nrepr() using \\\\x, \\\\u or \\\\U escapes. This generates a string similar\nto that returned by repr() in Python 2.",
    "builtins.bin" => "Return the binary representation of an integer.\n\n>>> bin(2796202)\n'0b1010101010101010101010'",
    "builtins.bool" => "Returns True when the argument is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.",
    "builtins.bool.__abs__" => "abs(self)",
    "builtins.bool.__add__" => "Return self+value.",
    "builtins.bool.__and__" => "Return self&value.",
    "builtins.bool.__bool__" => "True if self else False",
    "builtins.bool.__ceil__" => "Ceiling of an Integral returns itself.",
    "builtins.bool.__delattr__" => "Implement delattr(self, name).",
    "builtins.bool.__divmod__" => "Return divmod(self, value).",
    "builtins.bool.__eq__" => "Return self==value.",
    "builtins.bool.__float__" => "float(self)",
    "builtins.bool.__floor__" => "Flooring an Integral returns itself.",
    "builtins.bool.__floordiv__" => "Return self//value.",
    "builtins.bool.__format__" => "Convert to a string according to format_spec.",
    "builtins.bool.__ge__" => "Return self>=value.",
    "builtins.bool.__getattribute__" => "Return getattr(self, name).",
    "builtins.bool.__getstate__" => "Helper for pickle.",
    "builtins.bool.__gt__" => "Return self>value.",
    "builtins.bool.__hash__" => "Return hash(self).",
    "builtins.bool.__index__" => "Return self converted to an integer, if self is suitable for use as an index into a list.",
    "builtins.bool.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.bool.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.bool.__int__" => "int(self)",
    "builtins.bool.__invert__" => "~self",
    "builtins.bool.__le__" => "Return self<=value.",
    "builtins.bool.__lshift__" => "Return self<<value.",
    "builtins.bool.__lt__" => "Return self<value.",
    "builtins.bool.__mod__" => "Return self%value.",
    "builtins.bool.__mul__" => "Return self*value.",
    "builtins.bool.__ne__" => "Return self!=value.",
    "builtins.bool.__neg__" => "-self",
    "builtins.bool.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.bool.__or__" => "Return self|value.",
    "builtins.bool.__pos__" => "+self",
    "builtins.bool.__pow__" => "Return pow(self, value, mod).",
    "builtins.bool.__radd__" => "Return value+self.",
    "builtins.bool.__rand__" => "Return value&self.",
    "builtins.bool.__rdivmod__" => "Return divmod(value, self).",
    "builtins.bool.__reduce__" => "Helper for pickle.",
    "builtins.bool.__reduce_ex__" => "Helper for pickle.",
    "builtins.bool.__repr__" => "Return repr(self).",
    "builtins.bool.__rfloordiv__" => "Return value//self.",
    "builtins.bool.__rlshift__" => "Return value<<self.",
    "builtins.bool.__rmod__" => "Return value%self.",
    "builtins.bool.__rmul__" => "Return value*self.",
    "builtins.bool.__ror__" => "Return value|self.",
    "builtins.bool.__round__" => "Rounding an Integral returns itself.\n\nRounding with an ndigits argument also returns an integer.",
    "builtins.bool.__rpow__" => "Return pow(value, self, mod).",
    "builtins.bool.__rrshift__" => "Return value>>self.",
    "builtins.bool.__rshift__" => "Return self>>value.",
    "builtins.bool.__rsub__" => "Return value-self.",
    "builtins.bool.__rtruediv__" => "Return value/self.",
    "builtins.bool.__rxor__" => "Return value^self.",
    "builtins.bool.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.bool.__sizeof__" => "Returns size in memory, in bytes.",
    "builtins.bool.__str__" => "Return str(self).",
    "builtins.bool.__sub__" => "Return self-value.",
    "builtins.bool.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.bool.__truediv__" => "Return self/value.",
    "builtins.bool.__trunc__" => "Truncating an Integral returns itself.",
    "builtins.bool.__xor__" => "Return self^value.",
    "builtins.bool.as_integer_ratio" => "Return a pair of integers, whose ratio is equal to the original int.\n\nThe ratio is in lowest terms and has a positive denominator.\n\n>>> (10).as_integer_ratio()\n(10, 1)\n>>> (-10).as_integer_ratio()\n(-10, 1)\n>>> (0).as_integer_ratio()\n(0, 1)",
    "builtins.bool.bit_count" => "Number of ones in the binary representation of the absolute value of self.\n\nAlso known as the population count.\n\n>>> bin(13)\n'0b1101'\n>>> (13).bit_count()\n3",
    "builtins.bool.bit_length" => "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
    "builtins.bool.conjugate" => "Returns self, the complex conjugate of any int.",
    "builtins.bool.denominator" => "the denominator of a rational number in lowest terms",
    "builtins.bool.from_bytes" => "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  sys.byteorder as the byte order value.  Default is to use 'big'.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
    "builtins.bool.imag" => "the imaginary part of a complex number",
    "builtins.bool.is_integer" => "Returns True. Exists for duck type compatibility with float.is_integer.",
    "builtins.bool.numerator" => "the numerator of a rational number in lowest terms",
    "builtins.bool.real" => "the real part of a complex number",
    "builtins.bool.to_bytes" => "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.  Default\n  is length 1.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  sys.byteorder as the byte order value.  Default is to use 'big'.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
    "builtins.breakpoint" => "Call sys.breakpointhook(*args, **kws).  sys.breakpointhook() must accept\nwhatever arguments are passed.\n\nBy default, this drops you into the pdb debugger.",
    "builtins.bytearray" => "bytearray(iterable_of_ints) -> bytearray\nbytearray(string, encoding[, errors]) -> bytearray\nbytearray(bytes_or_buffer) -> mutable copy of bytes_or_buffer\nbytearray(int) -> bytes array of size given by the parameter initialized with null bytes\nbytearray() -> empty bytes array\n\nConstruct a mutable bytearray object from:\n  - an iterable yielding integers in range(256)\n  - a text string encoded using the specified encoding\n  - a bytes or a buffer object\n  - any object implementing the buffer API.\n  - an integer",
    "builtins.bytearray.__add__" => "Return self+value.",
    "builtins.bytearray.__alloc__" => "B.__alloc__() -> int\n\nReturn the number of bytes actually allocated.",
    "builtins.bytearray.__buffer__" => "Return a buffer object that exposes the underlying memory of the object.",
    "builtins.bytearray.__contains__" => "Return bool(key in self).",
    "builtins.bytearray.__delattr__" => "Implement delattr(self, name).",
    "builtins.bytearray.__delitem__" => "Delete self[key].",
    "builtins.bytearray.__eq__" => "Return self==value.",
    "builtins.bytearray.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.bytearray.__ge__" => "Return self>=value.",
    "builtins.bytearray.__getattribute__" => "Return getattr(self, name).",
    "builtins.bytearray.__getitem__" => "Return self[key].",
    "builtins.bytearray.__getstate__" => "Helper for pickle.",
    "builtins.bytearray.__gt__" => "Return self>value.",
    "builtins.bytearray.__iadd__" => "Implement self+=value.",
    "builtins.bytearray.__imul__" => "Implement self*=value.",
    "builtins.bytearray.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.bytearray.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.bytearray.__iter__" => "Implement iter(self).",
    "builtins.bytearray.__le__" => "Return self<=value.",
    "builtins.bytearray.__len__" => "Return len(self).",
    "builtins.bytearray.__lt__" => "Return self<value.",
    "builtins.bytearray.__mod__" => "Return self%value.",
    "builtins.bytearray.__mul__" => "Return self*value.",
    "builtins.bytearray.__ne__" => "Return self!=value.",
    "builtins.bytearray.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.bytearray.__reduce__" => "Return state information for pickling.",
    "builtins.bytearray.__reduce_ex__" => "Return state information for pickling.",
    "builtins.bytearray.__release_buffer__" => "Release the buffer object that exposes the underlying memory of the object.",
    "builtins.bytearray.__repr__" => "Return repr(self).",
    "builtins.bytearray.__rmod__" => "Return value%self.",
    "builtins.bytearray.__rmul__" => "Return value*self.",
    "builtins.bytearray.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.bytearray.__setitem__" => "Set self[key] to value.",
    "builtins.bytearray.__sizeof__" => "Returns the size of the bytearray object in memory, in bytes.",
    "builtins.bytearray.__str__" => "Return str(self).",
    "builtins.bytearray.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.bytearray.append" => "Append a single item to the end of the bytearray.\n\nitem\n  The item to be appended.",
    "builtins.bytearray.capitalize" => "B.capitalize() -> copy of B\n\nReturn a copy of B with only its first character capitalized (ASCII)\nand the rest lower-cased.",
    "builtins.bytearray.center" => "Return a centered string of length width.\n\nPadding is done using the specified fill character.",
    "builtins.bytearray.clear" => "Remove all items from the bytearray.",
    "builtins.bytearray.copy" => "Return a copy of B.",
    "builtins.bytearray.count" => "Return the number of non-overlapping occurrences of subsection 'sub' in bytes B[start:end].\n\nstart\n  Optional start position. Default: start of the bytes.\nend\n  Optional stop position. Default: end of the bytes.",
    "builtins.bytearray.decode" => "Decode the bytearray using the codec registered for encoding.\n\nencoding\n  The encoding with which to decode the bytearray.\nerrors\n  The error handling scheme to use for the handling of decoding errors.\n  The default is 'strict' meaning that decoding errors raise a\n  UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n  as well as any other name registered with codecs.register_error that\n  can handle UnicodeDecodeErrors.",
    "builtins.bytearray.endswith" => "Return True if the bytearray ends with the specified suffix, False otherwise.\n\nsuffix\n  A bytes or a tuple of bytes to try.\nstart\n  Optional start position. Default: start of the bytearray.\nend\n  Optional stop position. Default: end of the bytearray.",
    "builtins.bytearray.expandtabs" => "Return a copy where all tab characters are expanded using spaces.\n\nIf tabsize is not given, a tab size of 8 characters is assumed.",
    "builtins.bytearray.extend" => "Append all the items from the iterator or sequence to the end of the bytearray.\n\niterable_of_ints\n  The iterable of items to append.",
    "builtins.bytearray.find" => "Return the lowest index in B where subsection 'sub' is found, such that 'sub' is contained within B[start:end].\n\n  start\n    Optional start position. Default: start of the bytes.\n  end\n    Optional stop position. Default: end of the bytes.\n\nReturn -1 on failure.",
    "builtins.bytearray.fromhex" => "Create a bytearray object from a string of hexadecimal numbers.\n\nSpaces between two numbers are accepted.\nExample: bytearray.fromhex('B9 01EF') -> bytearray(b'\\\\xb9\\\\x01\\\\xef')",
    "builtins.bytearray.hex" => "Create a string of hexadecimal numbers from a bytearray object.\n\n  sep\n    An optional single character or byte to separate hex bytes.\n  bytes_per_sep\n    How many bytes between separators.  Positive values count from the\n    right, negative values count from the left.\n\nExample:\n>>> value = bytearray([0xb9, 0x01, 0xef])\n>>> value.hex()\n'b901ef'\n>>> value.hex(':')\n'b9:01:ef'\n>>> value.hex(':', 2)\n'b9:01ef'\n>>> value.hex(':', -2)\n'b901:ef'",
    "builtins.bytearray.index" => "Return the lowest index in B where subsection 'sub' is found, such that 'sub' is contained within B[start:end].\n\n  start\n    Optional start position. Default: start of the bytes.\n  end\n    Optional stop position. Default: end of the bytes.\n\nRaise ValueError if the subsection is not found.",
    "builtins.bytearray.insert" => "Insert a single item into the bytearray before the given index.\n\nindex\n  The index where the value is to be inserted.\nitem\n  The item to be inserted.",
    "builtins.bytearray.isalnum" => "B.isalnum() -> bool\n\nReturn True if all characters in B are alphanumeric\nand there is at least one character in B, False otherwise.",
    "builtins.bytearray.isalpha" => "B.isalpha() -> bool\n\nReturn True if all characters in B are alphabetic\nand there is at least one character in B, False otherwise.",
    "builtins.bytearray.isascii" => "B.isascii() -> bool\n\nReturn True if B is empty or all characters in B are ASCII,\nFalse otherwise.",
    "builtins.bytearray.isdigit" => "B.isdigit() -> bool\n\nReturn True if all characters in B are digits\nand there is at least one character in B, False otherwise.",
    "builtins.bytearray.islower" => "B.islower() -> bool\n\nReturn True if all cased characters in B are lowercase and there is\nat least one cased character in B, False otherwise.",
    "builtins.bytearray.isspace" => "B.isspace() -> bool\n\nReturn True if all characters in B are whitespace\nand there is at least one character in B, False otherwise.",
    "builtins.bytearray.istitle" => "B.istitle() -> bool\n\nReturn True if B is a titlecased string and there is at least one\ncharacter in B, i.e. uppercase characters may only follow uncased\ncharacters and lowercase characters only cased ones. Return False\notherwise.",
    "builtins.bytearray.isupper" => "B.isupper() -> bool\n\nReturn True if all cased characters in B are uppercase and there is\nat least one cased character in B, False otherwise.",
    "builtins.bytearray.join" => "Concatenate any number of bytes/bytearray objects.\n\nThe bytearray whose method is called is inserted in between each pair.\n\nThe result is returned as a new bytearray object.",
    "builtins.bytearray.ljust" => "Return a left-justified string of length width.\n\nPadding is done using the specified fill character.",
    "builtins.bytearray.lower" => "B.lower() -> copy of B\n\nReturn a copy of B with all ASCII characters converted to lowercase.",
    "builtins.bytearray.lstrip" => "Strip leading bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading ASCII whitespace.",
    "builtins.bytearray.maketrans" => "Return a translation table usable for the bytes or bytearray translate method.\n\nThe returned table will be one where each byte in frm is mapped to the byte at\nthe same position in to.\n\nThe bytes objects frm and to must be of the same length.",
    "builtins.bytearray.partition" => "Partition the bytearray into three parts using the given separator.\n\nThis will search for the separator sep in the bytearray. If the separator is\nfound, returns a 3-tuple containing the part before the separator, the\nseparator itself, and the part after it as new bytearray objects.\n\nIf the separator is not found, returns a 3-tuple containing the copy of the\noriginal bytearray object and two empty bytearray objects.",
    "builtins.bytearray.pop" => "Remove and return a single item from B.\n\n  index\n    The index from where to remove the item.\n    -1 (the default value) means remove the last item.\n\nIf no index argument is given, will pop the last item.",
    "builtins.bytearray.remove" => "Remove the first occurrence of a value in the bytearray.\n\nvalue\n  The value to remove.",
    "builtins.bytearray.removeprefix" => "Return a bytearray with the given prefix string removed if present.\n\nIf the bytearray starts with the prefix string, return\nbytearray[len(prefix):].  Otherwise, return a copy of the original\nbytearray.",
    "builtins.bytearray.removesuffix" => "Return a bytearray with the given suffix string removed if present.\n\nIf the bytearray ends with the suffix string and that suffix is not\nempty, return bytearray[:-len(suffix)].  Otherwise, return a copy of\nthe original bytearray.",
    "builtins.bytearray.replace" => "Return a copy with all occurrences of substring old replaced by new.\n\n  count\n    Maximum number of occurrences to replace.\n    -1 (the default value) means replace all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplaced.",
    "builtins.bytearray.reverse" => "Reverse the order of the values in B in place.",
    "builtins.bytearray.rfind" => "Return the highest index in B where subsection 'sub' is found, such that 'sub' is contained within B[start:end].\n\n  start\n    Optional start position. Default: start of the bytes.\n  end\n    Optional stop position. Default: end of the bytes.\n\nReturn -1 on failure.",
    "builtins.bytearray.rindex" => "Return the highest index in B where subsection 'sub' is found, such that 'sub' is contained within B[start:end].\n\n  start\n    Optional start position. Default: start of the bytes.\n  end\n    Optional stop position. Default: end of the bytes.\n\nRaise ValueError if the subsection is not found.",
    "builtins.bytearray.rjust" => "Return a right-justified string of length width.\n\nPadding is done using the specified fill character.",
    "builtins.bytearray.rpartition" => "Partition the bytearray into three parts using the given separator.\n\nThis will search for the separator sep in the bytearray, starting at the end.\nIf the separator is found, returns a 3-tuple containing the part before the\nseparator, the separator itself, and the part after it as new bytearray\nobjects.\n\nIf the separator is not found, returns a 3-tuple containing two empty bytearray\nobjects and the copy of the original bytearray object.",
    "builtins.bytearray.rsplit" => "Return a list of the sections in the bytearray, using sep as the delimiter.\n\n  sep\n    The delimiter according which to split the bytearray.\n    None (the default value) means split on ASCII whitespace characters\n    (space, tab, return, newline, formfeed, vertical tab).\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit.\n\nSplitting is done starting at the end of the bytearray and working to the front.",
    "builtins.bytearray.rstrip" => "Strip trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip trailing ASCII whitespace.",
    "builtins.bytearray.split" => "Return a list of the sections in the bytearray, using sep as the delimiter.\n\nsep\n  The delimiter according which to split the bytearray.\n  None (the default value) means split on ASCII whitespace characters\n  (space, tab, return, newline, formfeed, vertical tab).\nmaxsplit\n  Maximum number of splits to do.\n  -1 (the default value) means no limit.",
    "builtins.bytearray.splitlines" => "Return a list of the lines in the bytearray, breaking at line boundaries.\n\nLine breaks are not included in the resulting list unless keepends is given and\ntrue.",
    "builtins.bytearray.startswith" => "Return True if the bytearray starts with the specified prefix, False otherwise.\n\nprefix\n  A bytes or a tuple of bytes to try.\nstart\n  Optional start position. Default: start of the bytearray.\nend\n  Optional stop position. Default: end of the bytearray.",
    "builtins.bytearray.strip" => "Strip leading and trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading and trailing ASCII whitespace.",
    "builtins.bytearray.swapcase" => "B.swapcase() -> copy of B\n\nReturn a copy of B with uppercase ASCII characters converted\nto lowercase ASCII and vice versa.",
    "builtins.bytearray.title" => "B.title() -> copy of B\n\nReturn a titlecased version of B, i.e. ASCII words start with uppercase\ncharacters, all remaining cased characters have lowercase.",
    "builtins.bytearray.translate" => "Return a copy with each character mapped by the given translation table.\n\n  table\n    Translation table, which must be a bytes object of length 256.\n\nAll characters occurring in the optional argument delete are removed.\nThe remaining characters are mapped through the given translation table.",
    "builtins.bytearray.upper" => "B.upper() -> copy of B\n\nReturn a copy of B with all ASCII characters converted to uppercase.",
    "builtins.bytearray.zfill" => "Pad a numeric string with zeros on the left, to fill a field of the given width.\n\nThe original string is never truncated.",
    "builtins.bytearray_iterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.bytearray_iterator.__eq__" => "Return self==value.",
    "builtins.bytearray_iterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.bytearray_iterator.__ge__" => "Return self>=value.",
    "builtins.bytearray_iterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.bytearray_iterator.__getstate__" => "Helper for pickle.",
    "builtins.bytearray_iterator.__gt__" => "Return self>value.",
    "builtins.bytearray_iterator.__hash__" => "Return hash(self).",
    "builtins.bytearray_iterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.bytearray_iterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.bytearray_iterator.__iter__" => "Implement iter(self).",
    "builtins.bytearray_iterator.__le__" => "Return self<=value.",
    "builtins.bytearray_iterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.bytearray_iterator.__lt__" => "Return self<value.",
    "builtins.bytearray_iterator.__ne__" => "Return self!=value.",
    "builtins.bytearray_iterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.bytearray_iterator.__next__" => "Implement next(self).",
    "builtins.bytearray_iterator.__reduce__" => "Return state information for pickling.",
    "builtins.bytearray_iterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.bytearray_iterator.__repr__" => "Return repr(self).",
    "builtins.bytearray_iterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.bytearray_iterator.__setstate__" => "Set state information for unpickling.",
    "builtins.bytearray_iterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.bytearray_iterator.__str__" => "Return str(self).",
    "builtins.bytearray_iterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.bytes" => "bytes(iterable_of_ints) -> bytes\nbytes(string, encoding[, errors]) -> bytes\nbytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer\nbytes(int) -> bytes object of size given by the parameter initialized with null bytes\nbytes() -> empty bytes object\n\nConstruct an immutable array of bytes from:\n  - an iterable yielding integers in range(256)\n  - a text string encoded using the specified encoding\n  - any object implementing the buffer API.\n  - an integer",
    "builtins.bytes.__add__" => "Return self+value.",
    "builtins.bytes.__buffer__" => "Return a buffer object that exposes the underlying memory of the object.",
    "builtins.bytes.__bytes__" => "Convert this value to exact type bytes.",
    "builtins.bytes.__contains__" => "Return bool(key in self).",
    "builtins.bytes.__delattr__" => "Implement delattr(self, name).",
    "builtins.bytes.__eq__" => "Return self==value.",
    "builtins.bytes.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.bytes.__ge__" => "Return self>=value.",
    "builtins.bytes.__getattribute__" => "Return getattr(self, name).",
    "builtins.bytes.__getitem__" => "Return self[key].",
    "builtins.bytes.__getstate__" => "Helper for pickle.",
    "builtins.bytes.__gt__" => "Return self>value.",
    "builtins.bytes.__hash__" => "Return hash(self).",
    "builtins.bytes.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.bytes.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.bytes.__iter__" => "Implement iter(self).",
    "builtins.bytes.__le__" => "Return self<=value.",
    "builtins.bytes.__len__" => "Return len(self).",
    "builtins.bytes.__lt__" => "Return self<value.",
    "builtins.bytes.__mod__" => "Return self%value.",
    "builtins.bytes.__mul__" => "Return self*value.",
    "builtins.bytes.__ne__" => "Return self!=value.",
    "builtins.bytes.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.bytes.__reduce__" => "Helper for pickle.",
    "builtins.bytes.__reduce_ex__" => "Helper for pickle.",
    "builtins.bytes.__repr__" => "Return repr(self).",
    "builtins.bytes.__rmod__" => "Return value%self.",
    "builtins.bytes.__rmul__" => "Return value*self.",
    "builtins.bytes.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.bytes.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.bytes.__str__" => "Return str(self).",
    "builtins.bytes.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.bytes.capitalize" => "B.capitalize() -> copy of B\n\nReturn a copy of B with only its first character capitalized (ASCII)\nand the rest lower-cased.",
    "builtins.bytes.center" => "Return a centered string of length width.\n\nPadding is done using the specified fill character.",
    "builtins.bytes.count" => "Return the number of non-overlapping occurrences of subsection 'sub' in bytes B[start:end].\n\nstart\n  Optional start position. Default: start of the bytes.\nend\n  Optional stop position. Default: end of the bytes.",
    "builtins.bytes.decode" => "Decode the bytes using the codec registered for encoding.\n\nencoding\n  The encoding with which to decode the bytes.\nerrors\n  The error handling scheme to use for the handling of decoding errors.\n  The default is 'strict' meaning that decoding errors raise a\n  UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n  as well as any other name registered with codecs.register_error that\n  can handle UnicodeDecodeErrors.",
    "builtins.bytes.endswith" => "Return True if the bytes ends with the specified suffix, False otherwise.\n\nsuffix\n  A bytes or a tuple of bytes to try.\nstart\n  Optional start position. Default: start of the bytes.\nend\n  Optional stop position. Default: end of the bytes.",
    "builtins.bytes.expandtabs" => "Return a copy where all tab characters are expanded using spaces.\n\nIf tabsize is not given, a tab size of 8 characters is assumed.",
    "builtins.bytes.find" => "Return the lowest index in B where subsection 'sub' is found, such that 'sub' is contained within B[start,end].\n\n  start\n    Optional start position. Default: start of the bytes.\n  end\n    Optional stop position. Default: end of the bytes.\n\nReturn -1 on failure.",
    "builtins.bytes.fromhex" => "Create a bytes object from a string of hexadecimal numbers.\n\nSpaces between two numbers are accepted.\nExample: bytes.fromhex('B9 01EF') -> b'\\\\xb9\\\\x01\\\\xef'.",
    "builtins.bytes.hex" => "Create a string of hexadecimal numbers from a bytes object.\n\n  sep\n    An optional single character or byte to separate hex bytes.\n  bytes_per_sep\n    How many bytes between separators.  Positive values count from the\n    right, negative values count from the left.\n\nExample:\n>>> value = b'\\xb9\\x01\\xef'\n>>> value.hex()\n'b901ef'\n>>> value.hex(':')\n'b9:01:ef'\n>>> value.hex(':', 2)\n'b9:01ef'\n>>> value.hex(':', -2)\n'b901:ef'",
    "builtins.bytes.index" => "Return the lowest index in B where subsection 'sub' is found, such that 'sub' is contained within B[start,end].\n\n  start\n    Optional start position. Default: start of the bytes.\n  end\n    Optional stop position. Default: end of the bytes.\n\nRaise ValueError if the subsection is not found.",
    "builtins.bytes.isalnum" => "B.isalnum() -> bool\n\nReturn True if all characters in B are alphanumeric\nand there is at least one character in B, False otherwise.",
    "builtins.bytes.isalpha" => "B.isalpha() -> bool\n\nReturn True if all characters in B are alphabetic\nand there is at least one character in B, False otherwise.",
    "builtins.bytes.isascii" => "B.isascii() -> bool\n\nReturn True if B is empty or all characters in B are ASCII,\nFalse otherwise.",
    "builtins.bytes.isdigit" => "B.isdigit() -> bool\n\nReturn True if all characters in B are digits\nand there is at least one character in B, False otherwise.",
    "builtins.bytes.islower" => "B.islower() -> bool\n\nReturn True if all cased characters in B are lowercase and there is\nat least one cased character in B, False otherwise.",
    "builtins.bytes.isspace" => "B.isspace() -> bool\n\nReturn True if all characters in B are whitespace\nand there is at least one character in B, False otherwise.",
    "builtins.bytes.istitle" => "B.istitle() -> bool\n\nReturn True if B is a titlecased string and there is at least one\ncharacter in B, i.e. uppercase characters may only follow uncased\ncharacters and lowercase characters only cased ones. Return False\notherwise.",
    "builtins.bytes.isupper" => "B.isupper() -> bool\n\nReturn True if all cased characters in B are uppercase and there is\nat least one cased character in B, False otherwise.",
    "builtins.bytes.join" => "Concatenate any number of bytes objects.\n\nThe bytes whose method is called is inserted in between each pair.\n\nThe result is returned as a new bytes object.\n\nExample: b'.'.join([b'ab', b'pq', b'rs']) -> b'ab.pq.rs'.",
    "builtins.bytes.ljust" => "Return a left-justified string of length width.\n\nPadding is done using the specified fill character.",
    "builtins.bytes.lower" => "B.lower() -> copy of B\n\nReturn a copy of B with all ASCII characters converted to lowercase.",
    "builtins.bytes.lstrip" => "Strip leading bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading  ASCII whitespace.",
    "builtins.bytes.maketrans" => "Return a translation table usable for the bytes or bytearray translate method.\n\nThe returned table will be one where each byte in frm is mapped to the byte at\nthe same position in to.\n\nThe bytes objects frm and to must be of the same length.",
    "builtins.bytes.partition" => "Partition the bytes into three parts using the given separator.\n\nThis will search for the separator sep in the bytes. If the separator is found,\nreturns a 3-tuple containing the part before the separator, the separator\nitself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing the original bytes\nobject and two empty bytes objects.",
    "builtins.bytes.removeprefix" => "Return a bytes object with the given prefix string removed if present.\n\nIf the bytes starts with the prefix string, return bytes[len(prefix):].\nOtherwise, return a copy of the original bytes.",
    "builtins.bytes.removesuffix" => "Return a bytes object with the given suffix string removed if present.\n\nIf the bytes ends with the suffix string and that suffix is not empty,\nreturn bytes[:-len(prefix)].  Otherwise, return a copy of the original\nbytes.",
    "builtins.bytes.replace" => "Return a copy with all occurrences of substring old replaced by new.\n\n  count\n    Maximum number of occurrences to replace.\n    -1 (the default value) means replace all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplaced.",
    "builtins.bytes.rfind" => "Return the highest index in B where subsection 'sub' is found, such that 'sub' is contained within B[start,end].\n\n  start\n    Optional start position. Default: start of the bytes.\n  end\n    Optional stop position. Default: end of the bytes.\n\nReturn -1 on failure.",
    "builtins.bytes.rindex" => "Return the highest index in B where subsection 'sub' is found, such that 'sub' is contained within B[start,end].\n\n  start\n    Optional start position. Default: start of the bytes.\n  end\n    Optional stop position. Default: end of the bytes.\n\nRaise ValueError if the subsection is not found.",
    "builtins.bytes.rjust" => "Return a right-justified string of length width.\n\nPadding is done using the specified fill character.",
    "builtins.bytes.rpartition" => "Partition the bytes into three parts using the given separator.\n\nThis will search for the separator sep in the bytes, starting at the end. If\nthe separator is found, returns a 3-tuple containing the part before the\nseparator, the separator itself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing two empty bytes\nobjects and the original bytes object.",
    "builtins.bytes.rsplit" => "Return a list of the sections in the bytes, using sep as the delimiter.\n\n  sep\n    The delimiter according which to split the bytes.\n    None (the default value) means split on ASCII whitespace characters\n    (space, tab, return, newline, formfeed, vertical tab).\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit.\n\nSplitting is done starting at the end of the bytes and working to the front.",
    "builtins.bytes.rstrip" => "Strip trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip trailing ASCII whitespace.",
    "builtins.bytes.split" => "Return a list of the sections in the bytes, using sep as the delimiter.\n\nsep\n  The delimiter according which to split the bytes.\n  None (the default value) means split on ASCII whitespace characters\n  (space, tab, return, newline, formfeed, vertical tab).\nmaxsplit\n  Maximum number of splits to do.\n  -1 (the default value) means no limit.",
    "builtins.bytes.splitlines" => "Return a list of the lines in the bytes, breaking at line boundaries.\n\nLine breaks are not included in the resulting list unless keepends is given and\ntrue.",
    "builtins.bytes.startswith" => "Return True if the bytes starts with the specified prefix, False otherwise.\n\nprefix\n  A bytes or a tuple of bytes to try.\nstart\n  Optional start position. Default: start of the bytes.\nend\n  Optional stop position. Default: end of the bytes.",
    "builtins.bytes.strip" => "Strip leading and trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading and trailing ASCII whitespace.",
    "builtins.bytes.swapcase" => "B.swapcase() -> copy of B\n\nReturn a copy of B with uppercase ASCII characters converted\nto lowercase ASCII and vice versa.",
    "builtins.bytes.title" => "B.title() -> copy of B\n\nReturn a titlecased version of B, i.e. ASCII words start with uppercase\ncharacters, all remaining cased characters have lowercase.",
    "builtins.bytes.translate" => "Return a copy with each character mapped by the given translation table.\n\n  table\n    Translation table, which must be a bytes object of length 256.\n\nAll characters occurring in the optional argument delete are removed.\nThe remaining characters are mapped through the given translation table.",
    "builtins.bytes.upper" => "B.upper() -> copy of B\n\nReturn a copy of B with all ASCII characters converted to uppercase.",
    "builtins.bytes.zfill" => "Pad a numeric string with zeros on the left, to fill a field of the given width.\n\nThe original string is never truncated.",
    "builtins.bytes_iterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.bytes_iterator.__eq__" => "Return self==value.",
    "builtins.bytes_iterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.bytes_iterator.__ge__" => "Return self>=value.",
    "builtins.bytes_iterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.bytes_iterator.__getstate__" => "Helper for pickle.",
    "builtins.bytes_iterator.__gt__" => "Return self>value.",
    "builtins.bytes_iterator.__hash__" => "Return hash(self).",
    "builtins.bytes_iterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.bytes_iterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.bytes_iterator.__iter__" => "Implement iter(self).",
    "builtins.bytes_iterator.__le__" => "Return self<=value.",
    "builtins.bytes_iterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.bytes_iterator.__lt__" => "Return self<value.",
    "builtins.bytes_iterator.__ne__" => "Return self!=value.",
    "builtins.bytes_iterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.bytes_iterator.__next__" => "Implement next(self).",
    "builtins.bytes_iterator.__reduce__" => "Return state information for pickling.",
    "builtins.bytes_iterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.bytes_iterator.__repr__" => "Return repr(self).",
    "builtins.bytes_iterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.bytes_iterator.__setstate__" => "Set state information for unpickling.",
    "builtins.bytes_iterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.bytes_iterator.__str__" => "Return str(self).",
    "builtins.bytes_iterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.callable" => "Return whether the object is callable (i.e., some kind of function).\n\nNote that classes are callable, as are instances of classes with a\n__call__() method.",
    "builtins.chr" => "Return a Unicode string of one character with ordinal i; 0 <= i <= 0x10ffff.",
    "builtins.classmethod" => "Convert a function to be a class method.\n\nA class method receives the class as implicit first argument,\njust like an instance method receives the instance.\nTo declare a class method, use this idiom:\n\n  class C:\n      @classmethod\n      def f(cls, arg1, arg2, argN):\n          ...\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()).  The instance is ignored except for its class.\nIf a class method is called for a derived class, the derived class\nobject is passed as the implied first argument.\n\nClass methods are different than C++ or Java static methods.\nIf you want those, see the staticmethod builtin.",
    "builtins.classmethod.__delattr__" => "Implement delattr(self, name).",
    "builtins.classmethod.__eq__" => "Return self==value.",
    "builtins.classmethod.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.classmethod.__ge__" => "Return self>=value.",
    "builtins.classmethod.__get__" => "Return an attribute of instance, which is of type owner.",
    "builtins.classmethod.__getattribute__" => "Return getattr(self, name).",
    "builtins.classmethod.__getstate__" => "Helper for pickle.",
    "builtins.classmethod.__gt__" => "Return self>value.",
    "builtins.classmethod.__hash__" => "Return hash(self).",
    "builtins.classmethod.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.classmethod.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.classmethod.__le__" => "Return self<=value.",
    "builtins.classmethod.__lt__" => "Return self<value.",
    "builtins.classmethod.__ne__" => "Return self!=value.",
    "builtins.classmethod.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.classmethod.__reduce__" => "Helper for pickle.",
    "builtins.classmethod.__reduce_ex__" => "Helper for pickle.",
    "builtins.classmethod.__repr__" => "Return repr(self).",
    "builtins.classmethod.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.classmethod.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.classmethod.__str__" => "Return str(self).",
    "builtins.classmethod.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.compile" => "Compile source into a code object that can be executed by exec() or eval().\n\nThe source code may represent a Python module, statement or expression.\nThe filename will be used for run-time error messages.\nThe mode must be 'exec' to compile a module, 'single' to compile a\nsingle (interactive) statement, or 'eval' to compile an expression.\nThe flags argument, if present, controls which future statements influence\nthe compilation of the code.\nThe dont_inherit argument, if true, stops the compilation inheriting\nthe effects of any future statements in effect in the code calling\ncompile; if absent or false these statements do influence the compilation,\nin addition to any features explicitly specified.",
    "builtins.complex" => "Create a complex number from a string or numbers.\n\nIf a string is given, parse it as a complex number.\nIf a single number is given, convert it to a complex number.\nIf the 'real' or 'imag' arguments are given, create a complex number\nwith the specified real and imaginary components.",
    "builtins.complex.__abs__" => "abs(self)",
    "builtins.complex.__add__" => "Return self+value.",
    "builtins.complex.__bool__" => "True if self else False",
    "builtins.complex.__complex__" => "Convert this value to exact type complex.",
    "builtins.complex.__delattr__" => "Implement delattr(self, name).",
    "builtins.complex.__eq__" => "Return self==value.",
    "builtins.complex.__format__" => "Convert to a string according to format_spec.",
    "builtins.complex.__ge__" => "Return self>=value.",
    "builtins.complex.__getattribute__" => "Return getattr(self, name).",
    "builtins.complex.__getstate__" => "Helper for pickle.",
    "builtins.complex.__gt__" => "Return self>value.",
    "builtins.complex.__hash__" => "Return hash(self).",
    "builtins.complex.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.complex.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.complex.__le__" => "Return self<=value.",
    "builtins.complex.__lt__" => "Return self<value.",
    "builtins.complex.__mul__" => "Return self*value.",
    "builtins.complex.__ne__" => "Return self!=value.",
    "builtins.complex.__neg__" => "-self",
    "builtins.complex.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.complex.__pos__" => "+self",
    "builtins.complex.__pow__" => "Return pow(self, value, mod).",
    "builtins.complex.__radd__" => "Return value+self.",
    "builtins.complex.__reduce__" => "Helper for pickle.",
    "builtins.complex.__reduce_ex__" => "Helper for pickle.",
    "builtins.complex.__repr__" => "Return repr(self).",
    "builtins.complex.__rmul__" => "Return value*self.",
    "builtins.complex.__rpow__" => "Return pow(value, self, mod).",
    "builtins.complex.__rsub__" => "Return value-self.",
    "builtins.complex.__rtruediv__" => "Return value/self.",
    "builtins.complex.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.complex.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.complex.__str__" => "Return str(self).",
    "builtins.complex.__sub__" => "Return self-value.",
    "builtins.complex.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.complex.__truediv__" => "Return self/value.",
    "builtins.complex.conjugate" => "Return the complex conjugate of its argument. (3-4j).conjugate() == 3+4j.",
    "builtins.complex.imag" => "the imaginary part of a complex number",
    "builtins.complex.real" => "the real part of a complex number",
    "builtins.delattr" => "Deletes the named attribute from the given object.\n\ndelattr(x, 'y') is equivalent to ``del x.y``",
    "builtins.dict" => "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)",
    "builtins.dict.__class_getitem__" => "See PEP 585",
    "builtins.dict.__contains__" => "True if the dictionary has the specified key, else False.",
    "builtins.dict.__delattr__" => "Implement delattr(self, name).",
    "builtins.dict.__delitem__" => "Delete self[key].",
    "builtins.dict.__eq__" => "Return self==value.",
    "builtins.dict.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.dict.__ge__" => "Return self>=value.",
    "builtins.dict.__getattribute__" => "Return getattr(self, name).",
    "builtins.dict.__getitem__" => "Return self[key].",
    "builtins.dict.__getstate__" => "Helper for pickle.",
    "builtins.dict.__gt__" => "Return self>value.",
    "builtins.dict.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.dict.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.dict.__ior__" => "Return self|=value.",
    "builtins.dict.__iter__" => "Implement iter(self).",
    "builtins.dict.__le__" => "Return self<=value.",
    "builtins.dict.__len__" => "Return len(self).",
    "builtins.dict.__lt__" => "Return self<value.",
    "builtins.dict.__ne__" => "Return self!=value.",
    "builtins.dict.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.dict.__or__" => "Return self|value.",
    "builtins.dict.__reduce__" => "Helper for pickle.",
    "builtins.dict.__reduce_ex__" => "Helper for pickle.",
    "builtins.dict.__repr__" => "Return repr(self).",
    "builtins.dict.__reversed__" => "Return a reverse iterator over the dict keys.",
    "builtins.dict.__ror__" => "Return value|self.",
    "builtins.dict.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.dict.__setitem__" => "Set self[key] to value.",
    "builtins.dict.__sizeof__" => "Return the size of the dict in memory, in bytes.",
    "builtins.dict.__str__" => "Return str(self).",
    "builtins.dict.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.dict.clear" => "Remove all items from the dict.",
    "builtins.dict.copy" => "Return a shallow copy of the dict.",
    "builtins.dict.fromkeys" => "Create a new dictionary with keys from iterable and values set to value.",
    "builtins.dict.get" => "Return the value for key if key is in the dictionary, else default.",
    "builtins.dict.items" => "Return a set-like object providing a view on the dict's items.",
    "builtins.dict.keys" => "Return a set-like object providing a view on the dict's keys.",
    "builtins.dict.pop" => "D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n\nIf the key is not found, return the default if given; otherwise,\nraise a KeyError.",
    "builtins.dict.popitem" => "Remove and return a (key, value) pair as a 2-tuple.\n\nPairs are returned in LIFO (last-in, first-out) order.\nRaises KeyError if the dict is empty.",
    "builtins.dict.setdefault" => "Insert key with a value of default if key is not in the dictionary.\n\nReturn the value for key if key is in the dictionary, else default.",
    "builtins.dict.update" => "D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.\nIf E is present and has a .keys() method, then does:  for k in E.keys(): D[k] = E[k]\nIf E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v\nIn either case, this is followed by: for k in F:  D[k] = F[k]",
    "builtins.dict.values" => "Return an object providing a view on the dict's values.",
    "builtins.dict_itemiterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.dict_itemiterator.__eq__" => "Return self==value.",
    "builtins.dict_itemiterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.dict_itemiterator.__ge__" => "Return self>=value.",
    "builtins.dict_itemiterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.dict_itemiterator.__getstate__" => "Helper for pickle.",
    "builtins.dict_itemiterator.__gt__" => "Return self>value.",
    "builtins.dict_itemiterator.__hash__" => "Return hash(self).",
    "builtins.dict_itemiterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.dict_itemiterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.dict_itemiterator.__iter__" => "Implement iter(self).",
    "builtins.dict_itemiterator.__le__" => "Return self<=value.",
    "builtins.dict_itemiterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.dict_itemiterator.__lt__" => "Return self<value.",
    "builtins.dict_itemiterator.__ne__" => "Return self!=value.",
    "builtins.dict_itemiterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.dict_itemiterator.__next__" => "Implement next(self).",
    "builtins.dict_itemiterator.__reduce__" => "Return state information for pickling.",
    "builtins.dict_itemiterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.dict_itemiterator.__repr__" => "Return repr(self).",
    "builtins.dict_itemiterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.dict_itemiterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.dict_itemiterator.__str__" => "Return str(self).",
    "builtins.dict_itemiterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.dict_items.__and__" => "Return self&value.",
    "builtins.dict_items.__contains__" => "Return bool(key in self).",
    "builtins.dict_items.__delattr__" => "Implement delattr(self, name).",
    "builtins.dict_items.__eq__" => "Return self==value.",
    "builtins.dict_items.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.dict_items.__ge__" => "Return self>=value.",
    "builtins.dict_items.__getattribute__" => "Return getattr(self, name).",
    "builtins.dict_items.__getstate__" => "Helper for pickle.",
    "builtins.dict_items.__gt__" => "Return self>value.",
    "builtins.dict_items.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.dict_items.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.dict_items.__iter__" => "Implement iter(self).",
    "builtins.dict_items.__le__" => "Return self<=value.",
    "builtins.dict_items.__len__" => "Return len(self).",
    "builtins.dict_items.__lt__" => "Return self<value.",
    "builtins.dict_items.__ne__" => "Return self!=value.",
    "builtins.dict_items.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.dict_items.__or__" => "Return self|value.",
    "builtins.dict_items.__rand__" => "Return value&self.",
    "builtins.dict_items.__reduce__" => "Helper for pickle.",
    "builtins.dict_items.__reduce_ex__" => "Helper for pickle.",
    "builtins.dict_items.__repr__" => "Return repr(self).",
    "builtins.dict_items.__reversed__" => "Return a reverse iterator over the dict items.",
    "builtins.dict_items.__ror__" => "Return value|self.",
    "builtins.dict_items.__rsub__" => "Return value-self.",
    "builtins.dict_items.__rxor__" => "Return value^self.",
    "builtins.dict_items.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.dict_items.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.dict_items.__str__" => "Return str(self).",
    "builtins.dict_items.__sub__" => "Return self-value.",
    "builtins.dict_items.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.dict_items.__xor__" => "Return self^value.",
    "builtins.dict_items.isdisjoint" => "Return True if the view and the given iterable have a null intersection.",
    "builtins.dict_items.mapping" => "dictionary that this view refers to",
    "builtins.dict_keyiterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.dict_keyiterator.__eq__" => "Return self==value.",
    "builtins.dict_keyiterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.dict_keyiterator.__ge__" => "Return self>=value.",
    "builtins.dict_keyiterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.dict_keyiterator.__getstate__" => "Helper for pickle.",
    "builtins.dict_keyiterator.__gt__" => "Return self>value.",
    "builtins.dict_keyiterator.__hash__" => "Return hash(self).",
    "builtins.dict_keyiterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.dict_keyiterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.dict_keyiterator.__iter__" => "Implement iter(self).",
    "builtins.dict_keyiterator.__le__" => "Return self<=value.",
    "builtins.dict_keyiterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.dict_keyiterator.__lt__" => "Return self<value.",
    "builtins.dict_keyiterator.__ne__" => "Return self!=value.",
    "builtins.dict_keyiterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.dict_keyiterator.__next__" => "Implement next(self).",
    "builtins.dict_keyiterator.__reduce__" => "Return state information for pickling.",
    "builtins.dict_keyiterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.dict_keyiterator.__repr__" => "Return repr(self).",
    "builtins.dict_keyiterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.dict_keyiterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.dict_keyiterator.__str__" => "Return str(self).",
    "builtins.dict_keyiterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.dict_valueiterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.dict_valueiterator.__eq__" => "Return self==value.",
    "builtins.dict_valueiterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.dict_valueiterator.__ge__" => "Return self>=value.",
    "builtins.dict_valueiterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.dict_valueiterator.__getstate__" => "Helper for pickle.",
    "builtins.dict_valueiterator.__gt__" => "Return self>value.",
    "builtins.dict_valueiterator.__hash__" => "Return hash(self).",
    "builtins.dict_valueiterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.dict_valueiterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.dict_valueiterator.__iter__" => "Implement iter(self).",
    "builtins.dict_valueiterator.__le__" => "Return self<=value.",
    "builtins.dict_valueiterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.dict_valueiterator.__lt__" => "Return self<value.",
    "builtins.dict_valueiterator.__ne__" => "Return self!=value.",
    "builtins.dict_valueiterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.dict_valueiterator.__next__" => "Implement next(self).",
    "builtins.dict_valueiterator.__reduce__" => "Return state information for pickling.",
    "builtins.dict_valueiterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.dict_valueiterator.__repr__" => "Return repr(self).",
    "builtins.dict_valueiterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.dict_valueiterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.dict_valueiterator.__str__" => "Return str(self).",
    "builtins.dict_valueiterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.dict_values.__delattr__" => "Implement delattr(self, name).",
    "builtins.dict_values.__eq__" => "Return self==value.",
    "builtins.dict_values.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.dict_values.__ge__" => "Return self>=value.",
    "builtins.dict_values.__getattribute__" => "Return getattr(self, name).",
    "builtins.dict_values.__getstate__" => "Helper for pickle.",
    "builtins.dict_values.__gt__" => "Return self>value.",
    "builtins.dict_values.__hash__" => "Return hash(self).",
    "builtins.dict_values.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.dict_values.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.dict_values.__iter__" => "Implement iter(self).",
    "builtins.dict_values.__le__" => "Return self<=value.",
    "builtins.dict_values.__len__" => "Return len(self).",
    "builtins.dict_values.__lt__" => "Return self<value.",
    "builtins.dict_values.__ne__" => "Return self!=value.",
    "builtins.dict_values.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.dict_values.__reduce__" => "Helper for pickle.",
    "builtins.dict_values.__reduce_ex__" => "Helper for pickle.",
    "builtins.dict_values.__repr__" => "Return repr(self).",
    "builtins.dict_values.__reversed__" => "Return a reverse iterator over the dict values.",
    "builtins.dict_values.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.dict_values.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.dict_values.__str__" => "Return str(self).",
    "builtins.dict_values.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.dict_values.mapping" => "dictionary that this view refers to",
    "builtins.dir" => "dir([object]) -> list of strings\n\nIf called without an argument, return the names in the current scope.\nElse, return an alphabetized list of names comprising (some of) the attributes\nof the given object, and of attributes reachable from it.\nIf the object supplies a method named __dir__, it will be used; otherwise\nthe default dir() logic is used and returns:\n  for a module object: the module's attributes.\n  for a class object:  its attributes, and recursively the attributes\n    of its bases.\n  for any other object: its attributes, its class's attributes, and\n    recursively the attributes of its class's base classes.",
    "builtins.divmod" => "Return the tuple (x//y, x%y).  Invariant: div*y + mod == x.",
    "builtins.enumerate" => "Return an enumerate object.\n\n  iterable\n    an object supporting iteration\n\nThe enumerate object yields pairs containing a count (from start, which\ndefaults to zero) and a value yielded by the iterable argument.\n\nenumerate is useful for obtaining an indexed list:\n    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...",
    "builtins.enumerate.__class_getitem__" => "See PEP 585",
    "builtins.enumerate.__delattr__" => "Implement delattr(self, name).",
    "builtins.enumerate.__eq__" => "Return self==value.",
    "builtins.enumerate.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.enumerate.__ge__" => "Return self>=value.",
    "builtins.enumerate.__getattribute__" => "Return getattr(self, name).",
    "builtins.enumerate.__getstate__" => "Helper for pickle.",
    "builtins.enumerate.__gt__" => "Return self>value.",
    "builtins.enumerate.__hash__" => "Return hash(self).",
    "builtins.enumerate.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.enumerate.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.enumerate.__iter__" => "Implement iter(self).",
    "builtins.enumerate.__le__" => "Return self<=value.",
    "builtins.enumerate.__lt__" => "Return self<value.",
    "builtins.enumerate.__ne__" => "Return self!=value.",
    "builtins.enumerate.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.enumerate.__next__" => "Implement next(self).",
    "builtins.enumerate.__reduce__" => "Return state information for pickling.",
    "builtins.enumerate.__reduce_ex__" => "Helper for pickle.",
    "builtins.enumerate.__repr__" => "Return repr(self).",
    "builtins.enumerate.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.enumerate.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.enumerate.__str__" => "Return str(self).",
    "builtins.enumerate.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.eval" => "Evaluate the given source in the context of globals and locals.\n\nThe source may be a string representing a Python expression\nor a code object as returned by compile().\nThe globals must be a dictionary and locals can be any mapping,\ndefaulting to the current globals and locals.\nIf only globals is given, locals defaults to it.",
    "builtins.exec" => "Execute the given source in the context of globals and locals.\n\nThe source may be a string representing one or more Python statements\nor a code object as returned by compile().\nThe globals must be a dictionary and locals can be any mapping,\ndefaulting to the current globals and locals.\nIf only globals is given, locals defaults to it.\nThe closure must be a tuple of cellvars, and can only be used\nwhen source is a code object requiring exactly that many cellvars.",
    "builtins.filter" => "Return an iterator yielding those items of iterable for which function(item)\nis true. If function is None, return the items that are true.",
    "builtins.filter.__delattr__" => "Implement delattr(self, name).",
    "builtins.filter.__eq__" => "Return self==value.",
    "builtins.filter.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.filter.__ge__" => "Return self>=value.",
    "builtins.filter.__getattribute__" => "Return getattr(self, name).",
    "builtins.filter.__getstate__" => "Helper for pickle.",
    "builtins.filter.__gt__" => "Return self>value.",
    "builtins.filter.__hash__" => "Return hash(self).",
    "builtins.filter.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.filter.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.filter.__iter__" => "Implement iter(self).",
    "builtins.filter.__le__" => "Return self<=value.",
    "builtins.filter.__lt__" => "Return self<value.",
    "builtins.filter.__ne__" => "Return self!=value.",
    "builtins.filter.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.filter.__next__" => "Implement next(self).",
    "builtins.filter.__reduce__" => "Return state information for pickling.",
    "builtins.filter.__reduce_ex__" => "Helper for pickle.",
    "builtins.filter.__repr__" => "Return repr(self).",
    "builtins.filter.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.filter.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.filter.__str__" => "Return str(self).",
    "builtins.filter.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.float" => "Convert a string or number to a floating-point number, if possible.",
    "builtins.float.__abs__" => "abs(self)",
    "builtins.float.__add__" => "Return self+value.",
    "builtins.float.__bool__" => "True if self else False",
    "builtins.float.__ceil__" => "Return the ceiling as an Integral.",
    "builtins.float.__delattr__" => "Implement delattr(self, name).",
    "builtins.float.__divmod__" => "Return divmod(self, value).",
    "builtins.float.__eq__" => "Return self==value.",
    "builtins.float.__float__" => "float(self)",
    "builtins.float.__floor__" => "Return the floor as an Integral.",
    "builtins.float.__floordiv__" => "Return self//value.",
    "builtins.float.__format__" => "Formats the float according to format_spec.",
    "builtins.float.__ge__" => "Return self>=value.",
    "builtins.float.__getattribute__" => "Return getattr(self, name).",
    "builtins.float.__getformat__" => "You probably don't want to use this function.\n\n  typestr\n    Must be 'double' or 'float'.\n\nIt exists mainly to be used in Python's test suite.\n\nThis function returns whichever of 'unknown', 'IEEE, big-endian' or 'IEEE,\nlittle-endian' best describes the format of floating-point numbers used by the\nC type named by typestr.",
    "builtins.float.__getstate__" => "Helper for pickle.",
    "builtins.float.__gt__" => "Return self>value.",
    "builtins.float.__hash__" => "Return hash(self).",
    "builtins.float.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.float.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.float.__int__" => "int(self)",
    "builtins.float.__le__" => "Return self<=value.",
    "builtins.float.__lt__" => "Return self<value.",
    "builtins.float.__mod__" => "Return self%value.",
    "builtins.float.__mul__" => "Return self*value.",
    "builtins.float.__ne__" => "Return self!=value.",
    "builtins.float.__neg__" => "-self",
    "builtins.float.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.float.__pos__" => "+self",
    "builtins.float.__pow__" => "Return pow(self, value, mod).",
    "builtins.float.__radd__" => "Return value+self.",
    "builtins.float.__rdivmod__" => "Return divmod(value, self).",
    "builtins.float.__reduce__" => "Helper for pickle.",
    "builtins.float.__reduce_ex__" => "Helper for pickle.",
    "builtins.float.__repr__" => "Return repr(self).",
    "builtins.float.__rfloordiv__" => "Return value//self.",
    "builtins.float.__rmod__" => "Return value%self.",
    "builtins.float.__rmul__" => "Return value*self.",
    "builtins.float.__round__" => "Return the Integral closest to x, rounding half toward even.\n\nWhen an argument is passed, work like built-in round(x, ndigits).",
    "builtins.float.__rpow__" => "Return pow(value, self, mod).",
    "builtins.float.__rsub__" => "Return value-self.",
    "builtins.float.__rtruediv__" => "Return value/self.",
    "builtins.float.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.float.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.float.__str__" => "Return str(self).",
    "builtins.float.__sub__" => "Return self-value.",
    "builtins.float.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.float.__truediv__" => "Return self/value.",
    "builtins.float.__trunc__" => "Return the Integral closest to x between 0 and x.",
    "builtins.float.as_integer_ratio" => "Return a pair of integers, whose ratio is exactly equal to the original float.\n\nThe ratio is in lowest terms and has a positive denominator.  Raise\nOverflowError on infinities and a ValueError on NaNs.\n\n>>> (10.0).as_integer_ratio()\n(10, 1)\n>>> (0.0).as_integer_ratio()\n(0, 1)\n>>> (-.25).as_integer_ratio()\n(-1, 4)",
    "builtins.float.conjugate" => "Return self, the complex conjugate of any float.",
    "builtins.float.fromhex" => "Create a floating-point number from a hexadecimal string.\n\n>>> float.fromhex('0x1.ffffp10')\n2047.984375\n>>> float.fromhex('-0x1p-1074')\n-5e-324",
    "builtins.float.hex" => "Return a hexadecimal representation of a floating-point number.\n\n>>> (-0.1).hex()\n'-0x1.999999999999ap-4'\n>>> 3.14159.hex()\n'0x1.921f9f01b866ep+1'",
    "builtins.float.imag" => "the imaginary part of a complex number",
    "builtins.float.is_integer" => "Return True if the float is an integer.",
    "builtins.float.real" => "the real part of a complex number",
    "builtins.format" => "Return type(value).__format__(value, format_spec)\n\nMany built-in types implement format_spec according to the\nFormat Specification Mini-language. See help('FORMATTING').\n\nIf type(value) does not supply a method named __format__\nand format_spec is empty, then str(value) is returned.\nSee also help('SPECIALMETHODS').",
    "builtins.frozenset" => "Build an immutable unordered collection of unique elements.",
    "builtins.frozenset.__and__" => "Return self&value.",
    "builtins.frozenset.__class_getitem__" => "See PEP 585",
    "builtins.frozenset.__contains__" => "x.__contains__(y) <==> y in x.",
    "builtins.frozenset.__delattr__" => "Implement delattr(self, name).",
    "builtins.frozenset.__eq__" => "Return self==value.",
    "builtins.frozenset.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.frozenset.__ge__" => "Return self>=value.",
    "builtins.frozenset.__getattribute__" => "Return getattr(self, name).",
    "builtins.frozenset.__getstate__" => "Helper for pickle.",
    "builtins.frozenset.__gt__" => "Return self>value.",
    "builtins.frozenset.__hash__" => "Return hash(self).",
    "builtins.frozenset.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.frozenset.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.frozenset.__iter__" => "Implement iter(self).",
    "builtins.frozenset.__le__" => "Return self<=value.",
    "builtins.frozenset.__len__" => "Return len(self).",
    "builtins.frozenset.__lt__" => "Return self<value.",
    "builtins.frozenset.__ne__" => "Return self!=value.",
    "builtins.frozenset.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.frozenset.__or__" => "Return self|value.",
    "builtins.frozenset.__rand__" => "Return value&self.",
    "builtins.frozenset.__reduce__" => "Return state information for pickling.",
    "builtins.frozenset.__reduce_ex__" => "Helper for pickle.",
    "builtins.frozenset.__repr__" => "Return repr(self).",
    "builtins.frozenset.__ror__" => "Return value|self.",
    "builtins.frozenset.__rsub__" => "Return value-self.",
    "builtins.frozenset.__rxor__" => "Return value^self.",
    "builtins.frozenset.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.frozenset.__sizeof__" => "S.__sizeof__() -> size of S in memory, in bytes.",
    "builtins.frozenset.__str__" => "Return str(self).",
    "builtins.frozenset.__sub__" => "Return self-value.",
    "builtins.frozenset.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.frozenset.__xor__" => "Return self^value.",
    "builtins.frozenset.copy" => "Return a shallow copy of a set.",
    "builtins.frozenset.difference" => "Return a new set with elements in the set that are not in the others.",
    "builtins.frozenset.intersection" => "Return a new set with elements common to the set and all others.",
    "builtins.frozenset.isdisjoint" => "Return True if two sets have a null intersection.",
    "builtins.frozenset.issubset" => "Report whether another set contains this set.",
    "builtins.frozenset.issuperset" => "Report whether this set contains another set.",
    "builtins.frozenset.symmetric_difference" => "Return a new set with elements in either the set or other but not both.",
    "builtins.frozenset.union" => "Return a new set with elements from the set and all others.",
    "builtins.function" => "Create a function object.\n\ncode\n  a code object\nglobals\n  the globals dictionary\nname\n  a string that overrides the name from the code object\nargdefs\n  a tuple that specifies the default argument values\nclosure\n  a tuple that supplies the bindings for free variables\nkwdefaults\n  a dictionary that specifies the default keyword argument values",
    "builtins.function.__call__" => "Call self as a function.",
    "builtins.function.__delattr__" => "Implement delattr(self, name).",
    "builtins.function.__eq__" => "Return self==value.",
    "builtins.function.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.function.__ge__" => "Return self>=value.",
    "builtins.function.__get__" => "Return an attribute of instance, which is of type owner.",
    "builtins.function.__getattribute__" => "Return getattr(self, name).",
    "builtins.function.__getstate__" => "Helper for pickle.",
    "builtins.function.__gt__" => "Return self>value.",
    "builtins.function.__hash__" => "Return hash(self).",
    "builtins.function.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.function.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.function.__le__" => "Return self<=value.",
    "builtins.function.__lt__" => "Return self<value.",
    "builtins.function.__ne__" => "Return self!=value.",
    "builtins.function.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.function.__reduce__" => "Helper for pickle.",
    "builtins.function.__reduce_ex__" => "Helper for pickle.",
    "builtins.function.__repr__" => "Return repr(self).",
    "builtins.function.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.function.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.function.__str__" => "Return str(self).",
    "builtins.function.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.function.__type_params__" => "Get the declared type parameters for a function.",
    "builtins.getattr" => "getattr(object, name[, default]) -> value\n\nGet a named attribute from an object; getattr(x, 'y') is equivalent to x.y.\nWhen a default argument is given, it is returned when the attribute doesn't\nexist; without it, an exception is raised in that case.",
    "builtins.globals" => "Return the dictionary containing the current scope's global variables.\n\nNOTE: Updates to this dictionary *will* affect name lookups in the current\nglobal scope and vice-versa.",
    "builtins.hasattr" => "Return whether the object has an attribute with the given name.\n\nThis is done by calling getattr(obj, name) and catching AttributeError.",
    "builtins.hash" => "Return the hash value for the given object.\n\nTwo objects that compare equal must also have the same hash value, but the\nreverse is not necessarily true.",
    "builtins.hex" => "Return the hexadecimal representation of an integer.\n\n>>> hex(12648430)\n'0xc0ffee'",
    "builtins.id" => "Return the identity of an object.\n\nThis is guaranteed to be unique among simultaneously existing objects.\n(CPython uses the object's memory address.)",
    "builtins.input" => "Read a string from standard input.  The trailing newline is stripped.\n\nThe prompt string, if given, is printed to standard output without a\ntrailing newline before reading input.\n\nIf the user hits EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return), raise EOFError.\nOn *nix systems, readline is used if available.",
    "builtins.int" => "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating-point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
    "builtins.int.__abs__" => "abs(self)",
    "builtins.int.__add__" => "Return self+value.",
    "builtins.int.__and__" => "Return self&value.",
    "builtins.int.__bool__" => "True if self else False",
    "builtins.int.__ceil__" => "Ceiling of an Integral returns itself.",
    "builtins.int.__delattr__" => "Implement delattr(self, name).",
    "builtins.int.__divmod__" => "Return divmod(self, value).",
    "builtins.int.__eq__" => "Return self==value.",
    "builtins.int.__float__" => "float(self)",
    "builtins.int.__floor__" => "Flooring an Integral returns itself.",
    "builtins.int.__floordiv__" => "Return self//value.",
    "builtins.int.__format__" => "Convert to a string according to format_spec.",
    "builtins.int.__ge__" => "Return self>=value.",
    "builtins.int.__getattribute__" => "Return getattr(self, name).",
    "builtins.int.__getstate__" => "Helper for pickle.",
    "builtins.int.__gt__" => "Return self>value.",
    "builtins.int.__hash__" => "Return hash(self).",
    "builtins.int.__index__" => "Return self converted to an integer, if self is suitable for use as an index into a list.",
    "builtins.int.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.int.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.int.__int__" => "int(self)",
    "builtins.int.__invert__" => "~self",
    "builtins.int.__le__" => "Return self<=value.",
    "builtins.int.__lshift__" => "Return self<<value.",
    "builtins.int.__lt__" => "Return self<value.",
    "builtins.int.__mod__" => "Return self%value.",
    "builtins.int.__mul__" => "Return self*value.",
    "builtins.int.__ne__" => "Return self!=value.",
    "builtins.int.__neg__" => "-self",
    "builtins.int.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.int.__or__" => "Return self|value.",
    "builtins.int.__pos__" => "+self",
    "builtins.int.__pow__" => "Return pow(self, value, mod).",
    "builtins.int.__radd__" => "Return value+self.",
    "builtins.int.__rand__" => "Return value&self.",
    "builtins.int.__rdivmod__" => "Return divmod(value, self).",
    "builtins.int.__reduce__" => "Helper for pickle.",
    "builtins.int.__reduce_ex__" => "Helper for pickle.",
    "builtins.int.__repr__" => "Return repr(self).",
    "builtins.int.__rfloordiv__" => "Return value//self.",
    "builtins.int.__rlshift__" => "Return value<<self.",
    "builtins.int.__rmod__" => "Return value%self.",
    "builtins.int.__rmul__" => "Return value*self.",
    "builtins.int.__ror__" => "Return value|self.",
    "builtins.int.__round__" => "Rounding an Integral returns itself.\n\nRounding with an ndigits argument also returns an integer.",
    "builtins.int.__rpow__" => "Return pow(value, self, mod).",
    "builtins.int.__rrshift__" => "Return value>>self.",
    "builtins.int.__rshift__" => "Return self>>value.",
    "builtins.int.__rsub__" => "Return value-self.",
    "builtins.int.__rtruediv__" => "Return value/self.",
    "builtins.int.__rxor__" => "Return value^self.",
    "builtins.int.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.int.__sizeof__" => "Returns size in memory, in bytes.",
    "builtins.int.__str__" => "Return str(self).",
    "builtins.int.__sub__" => "Return self-value.",
    "builtins.int.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.int.__truediv__" => "Return self/value.",
    "builtins.int.__trunc__" => "Truncating an Integral returns itself.",
    "builtins.int.__xor__" => "Return self^value.",
    "builtins.int.as_integer_ratio" => "Return a pair of integers, whose ratio is equal to the original int.\n\nThe ratio is in lowest terms and has a positive denominator.\n\n>>> (10).as_integer_ratio()\n(10, 1)\n>>> (-10).as_integer_ratio()\n(-10, 1)\n>>> (0).as_integer_ratio()\n(0, 1)",
    "builtins.int.bit_count" => "Number of ones in the binary representation of the absolute value of self.\n\nAlso known as the population count.\n\n>>> bin(13)\n'0b1101'\n>>> (13).bit_count()\n3",
    "builtins.int.bit_length" => "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
    "builtins.int.conjugate" => "Returns self, the complex conjugate of any int.",
    "builtins.int.denominator" => "the denominator of a rational number in lowest terms",
    "builtins.int.from_bytes" => "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  sys.byteorder as the byte order value.  Default is to use 'big'.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
    "builtins.int.imag" => "the imaginary part of a complex number",
    "builtins.int.is_integer" => "Returns True. Exists for duck type compatibility with float.is_integer.",
    "builtins.int.numerator" => "the numerator of a rational number in lowest terms",
    "builtins.int.real" => "the real part of a complex number",
    "builtins.int.to_bytes" => "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.  Default\n  is length 1.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  sys.byteorder as the byte order value.  Default is to use 'big'.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
    "builtins.isinstance" => "Return whether an object is an instance of a class or of a subclass thereof.\n\nA tuple, as in ``isinstance(x, (A, B, ...))``, may be given as the target to\ncheck against. This is equivalent to ``isinstance(x, A) or isinstance(x, B)\nor ...`` etc.",
    "builtins.issubclass" => "Return whether 'cls' is derived from another class or is the same class.\n\nA tuple, as in ``issubclass(x, (A, B, ...))``, may be given as the target to\ncheck against. This is equivalent to ``issubclass(x, A) or issubclass(x, B)\nor ...``.",
    "builtins.iter" => "iter(iterable) -> iterator\niter(callable, sentinel) -> iterator\n\nGet an iterator from an object.  In the first form, the argument must\nsupply its own iterator, or be a sequence.\nIn the second form, the callable is called until it returns the sentinel.",
    "builtins.len" => "Return the number of items in a container.",
    "builtins.list" => "Built-in mutable sequence.\n\nIf no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.",
    "builtins.list.__add__" => "Return self+value.",
    "builtins.list.__class_getitem__" => "See PEP 585",
    "builtins.list.__contains__" => "Return bool(key in self).",
    "builtins.list.__delattr__" => "Implement delattr(self, name).",
    "builtins.list.__delitem__" => "Delete self[key].",
    "builtins.list.__eq__" => "Return self==value.",
    "builtins.list.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.list.__ge__" => "Return self>=value.",
    "builtins.list.__getattribute__" => "Return getattr(self, name).",
    "builtins.list.__getitem__" => "Return self[index].",
    "builtins.list.__getstate__" => "Helper for pickle.",
    "builtins.list.__gt__" => "Return self>value.",
    "builtins.list.__iadd__" => "Implement self+=value.",
    "builtins.list.__imul__" => "Implement self*=value.",
    "builtins.list.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.list.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.list.__iter__" => "Implement iter(self).",
    "builtins.list.__le__" => "Return self<=value.",
    "builtins.list.__len__" => "Return len(self).",
    "builtins.list.__lt__" => "Return self<value.",
    "builtins.list.__mul__" => "Return self*value.",
    "builtins.list.__ne__" => "Return self!=value.",
    "builtins.list.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.list.__reduce__" => "Helper for pickle.",
    "builtins.list.__reduce_ex__" => "Helper for pickle.",
    "builtins.list.__repr__" => "Return repr(self).",
    "builtins.list.__reversed__" => "Return a reverse iterator over the list.",
    "builtins.list.__rmul__" => "Return value*self.",
    "builtins.list.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.list.__setitem__" => "Set self[key] to value.",
    "builtins.list.__sizeof__" => "Return the size of the list in memory, in bytes.",
    "builtins.list.__str__" => "Return str(self).",
    "builtins.list.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.list.append" => "Append object to the end of the list.",
    "builtins.list.clear" => "Remove all items from list.",
    "builtins.list.copy" => "Return a shallow copy of the list.",
    "builtins.list.count" => "Return number of occurrences of value.",
    "builtins.list.extend" => "Extend list by appending elements from the iterable.",
    "builtins.list.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "builtins.list.insert" => "Insert object before index.",
    "builtins.list.pop" => "Remove and return item at index (default last).\n\nRaises IndexError if list is empty or index is out of range.",
    "builtins.list.remove" => "Remove first occurrence of value.\n\nRaises ValueError if the value is not present.",
    "builtins.list.reverse" => "Reverse *IN PLACE*.",
    "builtins.list.sort" => "Sort the list in ascending order and return None.\n\nThe sort is in-place (i.e. the list itself is modified) and stable (i.e. the\norder of two equal elements is maintained).\n\nIf a key function is given, apply it once to each list item and sort them,\nascending or descending, according to their function values.\n\nThe reverse flag can be set to sort in descending order.",
    "builtins.list_iterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.list_iterator.__eq__" => "Return self==value.",
    "builtins.list_iterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.list_iterator.__ge__" => "Return self>=value.",
    "builtins.list_iterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.list_iterator.__getstate__" => "Helper for pickle.",
    "builtins.list_iterator.__gt__" => "Return self>value.",
    "builtins.list_iterator.__hash__" => "Return hash(self).",
    "builtins.list_iterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.list_iterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.list_iterator.__iter__" => "Implement iter(self).",
    "builtins.list_iterator.__le__" => "Return self<=value.",
    "builtins.list_iterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.list_iterator.__lt__" => "Return self<value.",
    "builtins.list_iterator.__ne__" => "Return self!=value.",
    "builtins.list_iterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.list_iterator.__next__" => "Implement next(self).",
    "builtins.list_iterator.__reduce__" => "Return state information for pickling.",
    "builtins.list_iterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.list_iterator.__repr__" => "Return repr(self).",
    "builtins.list_iterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.list_iterator.__setstate__" => "Set state information for unpickling.",
    "builtins.list_iterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.list_iterator.__str__" => "Return str(self).",
    "builtins.list_iterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.locals" => "Return a dictionary containing the current scope's local variables.\n\nNOTE: Whether or not updates to this dictionary will affect name lookups in\nthe local scope and vice-versa is *implementation dependent* and not\ncovered by any backwards compatibility guarantees.",
    "builtins.map" => "Make an iterator that computes the function using arguments from\neach of the iterables.  Stops when the shortest iterable is exhausted.",
    "builtins.map.__delattr__" => "Implement delattr(self, name).",
    "builtins.map.__eq__" => "Return self==value.",
    "builtins.map.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.map.__ge__" => "Return self>=value.",
    "builtins.map.__getattribute__" => "Return getattr(self, name).",
    "builtins.map.__getstate__" => "Helper for pickle.",
    "builtins.map.__gt__" => "Return self>value.",
    "builtins.map.__hash__" => "Return hash(self).",
    "builtins.map.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.map.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.map.__iter__" => "Implement iter(self).",
    "builtins.map.__le__" => "Return self<=value.",
    "builtins.map.__lt__" => "Return self<value.",
    "builtins.map.__ne__" => "Return self!=value.",
    "builtins.map.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.map.__next__" => "Implement next(self).",
    "builtins.map.__reduce__" => "Return state information for pickling.",
    "builtins.map.__reduce_ex__" => "Helper for pickle.",
    "builtins.map.__repr__" => "Return repr(self).",
    "builtins.map.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.map.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.map.__str__" => "Return str(self).",
    "builtins.map.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.max" => "max(iterable, *[, default=obj, key=func]) -> value\nmax(arg1, arg2, *args, *[, key=func]) -> value\n\nWith a single iterable argument, return its biggest item. The\ndefault keyword-only argument specifies an object to return if\nthe provided iterable is empty.\nWith two or more positional arguments, return the largest argument.",
    "builtins.memory_iterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.memory_iterator.__eq__" => "Return self==value.",
    "builtins.memory_iterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.memory_iterator.__ge__" => "Return self>=value.",
    "builtins.memory_iterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.memory_iterator.__getstate__" => "Helper for pickle.",
    "builtins.memory_iterator.__gt__" => "Return self>value.",
    "builtins.memory_iterator.__hash__" => "Return hash(self).",
    "builtins.memory_iterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.memory_iterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.memory_iterator.__iter__" => "Implement iter(self).",
    "builtins.memory_iterator.__le__" => "Return self<=value.",
    "builtins.memory_iterator.__lt__" => "Return self<value.",
    "builtins.memory_iterator.__ne__" => "Return self!=value.",
    "builtins.memory_iterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.memory_iterator.__next__" => "Implement next(self).",
    "builtins.memory_iterator.__reduce__" => "Helper for pickle.",
    "builtins.memory_iterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.memory_iterator.__repr__" => "Return repr(self).",
    "builtins.memory_iterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.memory_iterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.memory_iterator.__str__" => "Return str(self).",
    "builtins.memory_iterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.memoryview" => "Create a new memoryview object which references the given object.",
    "builtins.memoryview.__buffer__" => "Return a buffer object that exposes the underlying memory of the object.",
    "builtins.memoryview.__delattr__" => "Implement delattr(self, name).",
    "builtins.memoryview.__delitem__" => "Delete self[key].",
    "builtins.memoryview.__eq__" => "Return self==value.",
    "builtins.memoryview.__exit__" => "Release the underlying buffer exposed by the memoryview object.",
    "builtins.memoryview.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.memoryview.__ge__" => "Return self>=value.",
    "builtins.memoryview.__getattribute__" => "Return getattr(self, name).",
    "builtins.memoryview.__getitem__" => "Return self[key].",
    "builtins.memoryview.__getstate__" => "Helper for pickle.",
    "builtins.memoryview.__gt__" => "Return self>value.",
    "builtins.memoryview.__hash__" => "Return hash(self).",
    "builtins.memoryview.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.memoryview.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.memoryview.__iter__" => "Implement iter(self).",
    "builtins.memoryview.__le__" => "Return self<=value.",
    "builtins.memoryview.__len__" => "Return len(self).",
    "builtins.memoryview.__lt__" => "Return self<value.",
    "builtins.memoryview.__ne__" => "Return self!=value.",
    "builtins.memoryview.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.memoryview.__reduce__" => "Helper for pickle.",
    "builtins.memoryview.__reduce_ex__" => "Helper for pickle.",
    "builtins.memoryview.__release_buffer__" => "Release the buffer object that exposes the underlying memory of the object.",
    "builtins.memoryview.__repr__" => "Return repr(self).",
    "builtins.memoryview.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.memoryview.__setitem__" => "Set self[key] to value.",
    "builtins.memoryview.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.memoryview.__str__" => "Return str(self).",
    "builtins.memoryview.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.memoryview._from_flags" => "Create a new memoryview object which references the given object.",
    "builtins.memoryview.c_contiguous" => "A bool indicating whether the memory is C contiguous.",
    "builtins.memoryview.cast" => "Cast a memoryview to a new format or shape.",
    "builtins.memoryview.contiguous" => "A bool indicating whether the memory is contiguous.",
    "builtins.memoryview.f_contiguous" => "A bool indicating whether the memory is Fortran contiguous.",
    "builtins.memoryview.format" => "A string containing the format (in struct module style)\nfor each element in the view.",
    "builtins.memoryview.hex" => "Return the data in the buffer as a str of hexadecimal numbers.\n\n  sep\n    An optional single character or byte to separate hex bytes.\n  bytes_per_sep\n    How many bytes between separators.  Positive values count from the\n    right, negative values count from the left.\n\nExample:\n>>> value = memoryview(b'\\xb9\\x01\\xef')\n>>> value.hex()\n'b901ef'\n>>> value.hex(':')\n'b9:01:ef'\n>>> value.hex(':', 2)\n'b9:01ef'\n>>> value.hex(':', -2)\n'b901:ef'",
    "builtins.memoryview.itemsize" => "The size in bytes of each element of the memoryview.",
    "builtins.memoryview.nbytes" => "The amount of space in bytes that the array would use in\na contiguous representation.",
    "builtins.memoryview.ndim" => "An integer indicating how many dimensions of a multi-dimensional\narray the memory represents.",
    "builtins.memoryview.obj" => "The underlying object of the memoryview.",
    "builtins.memoryview.readonly" => "A bool indicating whether the memory is read only.",
    "builtins.memoryview.release" => "Release the underlying buffer exposed by the memoryview object.",
    "builtins.memoryview.shape" => "A tuple of ndim integers giving the shape of the memory\nas an N-dimensional array.",
    "builtins.memoryview.strides" => "A tuple of ndim integers giving the size in bytes to access\neach element for each dimension of the array.",
    "builtins.memoryview.suboffsets" => "A tuple of integers used internally for PIL-style arrays.",
    "builtins.memoryview.tobytes" => "Return the data in the buffer as a byte string.\n\nOrder can be {'C', 'F', 'A'}. When order is 'C' or 'F', the data of the\noriginal array is converted to C or Fortran order. For contiguous views,\n'A' returns an exact copy of the physical memory. In particular, in-memory\nFortran order is preserved. For non-contiguous views, the data is converted\nto C first. order=None is the same as order='C'.",
    "builtins.memoryview.tolist" => "Return the data in the buffer as a list of elements.",
    "builtins.memoryview.toreadonly" => "Return a readonly version of the memoryview.",
    "builtins.min" => "min(iterable, *[, default=obj, key=func]) -> value\nmin(arg1, arg2, *args, *[, key=func]) -> value\n\nWith a single iterable argument, return its smallest item. The\ndefault keyword-only argument specifies an object to return if\nthe provided iterable is empty.\nWith two or more positional arguments, return the smallest argument.",
    "builtins.next" => "next(iterator[, default])\n\nReturn the next item from the iterator. If default is given and the iterator\nis exhausted, it is returned instead of raising StopIteration.",
    "builtins.object" => "The base class of the class hierarchy.\n\nWhen called, it accepts no arguments and returns a new featureless\ninstance that has no instance attributes and cannot be given any.",
    "builtins.object.__delattr__" => "Implement delattr(self, name).",
    "builtins.object.__eq__" => "Return self==value.",
    "builtins.object.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.object.__ge__" => "Return self>=value.",
    "builtins.object.__getattribute__" => "Return getattr(self, name).",
    "builtins.object.__getstate__" => "Helper for pickle.",
    "builtins.object.__gt__" => "Return self>value.",
    "builtins.object.__hash__" => "Return hash(self).",
    "builtins.object.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.object.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.object.__le__" => "Return self<=value.",
    "builtins.object.__lt__" => "Return self<value.",
    "builtins.object.__ne__" => "Return self!=value.",
    "builtins.object.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.object.__reduce__" => "Helper for pickle.",
    "builtins.object.__reduce_ex__" => "Helper for pickle.",
    "builtins.object.__repr__" => "Return repr(self).",
    "builtins.object.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.object.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.object.__str__" => "Return str(self).",
    "builtins.object.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.oct" => "Return the octal representation of an integer.\n\n>>> oct(342391)\n'0o1234567'",
    "builtins.ord" => "Return the ordinal value of a character.\n\nIf the argument is a one-character string, return the Unicode code\npoint of that character.\n\nIf the argument is a bytes or bytearray object of length 1, return its\nsingle byte value.",
    "builtins.pow" => "Equivalent to base**exp with 2 arguments or base**exp % mod with 3 arguments\n\nSome types, such as ints, are able to use a more efficient algorithm when\ninvoked using the three argument form.",
    "builtins.print" => "Prints the values to a stream, or to sys.stdout by default.\n\nsep\n  string inserted between values, default a space.\nend\n  string appended after the last value, default a newline.\nfile\n  a file-like object (stream); defaults to the current sys.stdout.\nflush\n  whether to forcibly flush the stream.",
    "builtins.property" => "Property attribute.\n\n  fget\n    function to be used for getting an attribute value\n  fset\n    function to be used for setting an attribute value\n  fdel\n    function to be used for del'ing an attribute\n  doc\n    docstring\n\nTypical use is to define a managed attribute x:\n\nclass C(object):\n    def getx(self): return self._x\n    def setx(self, value): self._x = value\n    def delx(self): del self._x\n    x = property(getx, setx, delx, \"I'm the 'x' property.\")\n\nDecorators make defining new properties or modifying existing ones easy:\n\nclass C(object):\n    @property\n    def x(self):\n        \"I am the 'x' property.\"\n        return self._x\n    @x.setter\n    def x(self, value):\n        self._x = value\n    @x.deleter\n    def x(self):\n        del self._x",
    "builtins.property.__delattr__" => "Implement delattr(self, name).",
    "builtins.property.__delete__" => "Delete an attribute of instance.",
    "builtins.property.__eq__" => "Return self==value.",
    "builtins.property.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.property.__ge__" => "Return self>=value.",
    "builtins.property.__get__" => "Return an attribute of instance, which is of type owner.",
    "builtins.property.__getattribute__" => "Return getattr(self, name).",
    "builtins.property.__getstate__" => "Helper for pickle.",
    "builtins.property.__gt__" => "Return self>value.",
    "builtins.property.__hash__" => "Return hash(self).",
    "builtins.property.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.property.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.property.__le__" => "Return self<=value.",
    "builtins.property.__lt__" => "Return self<value.",
    "builtins.property.__ne__" => "Return self!=value.",
    "builtins.property.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.property.__reduce__" => "Helper for pickle.",
    "builtins.property.__reduce_ex__" => "Helper for pickle.",
    "builtins.property.__repr__" => "Return repr(self).",
    "builtins.property.__set__" => "Set an attribute of instance to value.",
    "builtins.property.__set_name__" => "Method to set name of a property.",
    "builtins.property.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.property.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.property.__str__" => "Return str(self).",
    "builtins.property.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.property.deleter" => "Descriptor to obtain a copy of the property with a different deleter.",
    "builtins.property.getter" => "Descriptor to obtain a copy of the property with a different getter.",
    "builtins.property.setter" => "Descriptor to obtain a copy of the property with a different setter.",
    "builtins.range" => "range(stop) -> range object\nrange(start, stop[, step]) -> range object\n\nReturn an object that produces a sequence of integers from start (inclusive)\nto stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.\nstart defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.\nThese are exactly the valid indices for a list of 4 elements.\nWhen step is given, it specifies the increment (or decrement).",
    "builtins.range.__bool__" => "True if self else False",
    "builtins.range.__contains__" => "Return bool(key in self).",
    "builtins.range.__delattr__" => "Implement delattr(self, name).",
    "builtins.range.__eq__" => "Return self==value.",
    "builtins.range.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.range.__ge__" => "Return self>=value.",
    "builtins.range.__getattribute__" => "Return getattr(self, name).",
    "builtins.range.__getitem__" => "Return self[key].",
    "builtins.range.__getstate__" => "Helper for pickle.",
    "builtins.range.__gt__" => "Return self>value.",
    "builtins.range.__hash__" => "Return hash(self).",
    "builtins.range.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.range.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.range.__iter__" => "Implement iter(self).",
    "builtins.range.__le__" => "Return self<=value.",
    "builtins.range.__len__" => "Return len(self).",
    "builtins.range.__lt__" => "Return self<value.",
    "builtins.range.__ne__" => "Return self!=value.",
    "builtins.range.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.range.__reduce_ex__" => "Helper for pickle.",
    "builtins.range.__repr__" => "Return repr(self).",
    "builtins.range.__reversed__" => "Return a reverse iterator.",
    "builtins.range.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.range.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.range.__str__" => "Return str(self).",
    "builtins.range.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.range.count" => "rangeobject.count(value) -> integer -- return number of occurrences of value",
    "builtins.range.index" => "rangeobject.index(value) -> integer -- return index of value.\nRaise ValueError if the value is not present.",
    "builtins.range_iterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.range_iterator.__eq__" => "Return self==value.",
    "builtins.range_iterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.range_iterator.__ge__" => "Return self>=value.",
    "builtins.range_iterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.range_iterator.__getstate__" => "Helper for pickle.",
    "builtins.range_iterator.__gt__" => "Return self>value.",
    "builtins.range_iterator.__hash__" => "Return hash(self).",
    "builtins.range_iterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.range_iterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.range_iterator.__iter__" => "Implement iter(self).",
    "builtins.range_iterator.__le__" => "Return self<=value.",
    "builtins.range_iterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.range_iterator.__lt__" => "Return self<value.",
    "builtins.range_iterator.__ne__" => "Return self!=value.",
    "builtins.range_iterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.range_iterator.__next__" => "Implement next(self).",
    "builtins.range_iterator.__reduce__" => "Return state information for pickling.",
    "builtins.range_iterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.range_iterator.__repr__" => "Return repr(self).",
    "builtins.range_iterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.range_iterator.__setstate__" => "Set state information for unpickling.",
    "builtins.range_iterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.range_iterator.__str__" => "Return str(self).",
    "builtins.range_iterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.repr" => "Return the canonical string representation of the object.\n\nFor many object types, including most builtins, eval(repr(obj)) == obj.",
    "builtins.reversed" => "Return a reverse iterator over the values of the given sequence.",
    "builtins.reversed.__delattr__" => "Implement delattr(self, name).",
    "builtins.reversed.__eq__" => "Return self==value.",
    "builtins.reversed.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.reversed.__ge__" => "Return self>=value.",
    "builtins.reversed.__getattribute__" => "Return getattr(self, name).",
    "builtins.reversed.__getstate__" => "Helper for pickle.",
    "builtins.reversed.__gt__" => "Return self>value.",
    "builtins.reversed.__hash__" => "Return hash(self).",
    "builtins.reversed.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.reversed.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.reversed.__iter__" => "Implement iter(self).",
    "builtins.reversed.__le__" => "Return self<=value.",
    "builtins.reversed.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.reversed.__lt__" => "Return self<value.",
    "builtins.reversed.__ne__" => "Return self!=value.",
    "builtins.reversed.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.reversed.__next__" => "Implement next(self).",
    "builtins.reversed.__reduce__" => "Return state information for pickling.",
    "builtins.reversed.__reduce_ex__" => "Helper for pickle.",
    "builtins.reversed.__repr__" => "Return repr(self).",
    "builtins.reversed.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.reversed.__setstate__" => "Set state information for unpickling.",
    "builtins.reversed.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.reversed.__str__" => "Return str(self).",
    "builtins.reversed.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.round" => "Round a number to a given precision in decimal digits.\n\nThe return value is an integer if ndigits is omitted or None.  Otherwise\nthe return value has the same type as the number.  ndigits may be negative.",
    "builtins.set" => "Build an unordered collection of unique elements.",
    "builtins.set.__and__" => "Return self&value.",
    "builtins.set.__class_getitem__" => "See PEP 585",
    "builtins.set.__contains__" => "x.__contains__(y) <==> y in x.",
    "builtins.set.__delattr__" => "Implement delattr(self, name).",
    "builtins.set.__eq__" => "Return self==value.",
    "builtins.set.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.set.__ge__" => "Return self>=value.",
    "builtins.set.__getattribute__" => "Return getattr(self, name).",
    "builtins.set.__getstate__" => "Helper for pickle.",
    "builtins.set.__gt__" => "Return self>value.",
    "builtins.set.__iand__" => "Return self&=value.",
    "builtins.set.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.set.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.set.__ior__" => "Return self|=value.",
    "builtins.set.__isub__" => "Return self-=value.",
    "builtins.set.__iter__" => "Implement iter(self).",
    "builtins.set.__ixor__" => "Return self^=value.",
    "builtins.set.__le__" => "Return self<=value.",
    "builtins.set.__len__" => "Return len(self).",
    "builtins.set.__lt__" => "Return self<value.",
    "builtins.set.__ne__" => "Return self!=value.",
    "builtins.set.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.set.__or__" => "Return self|value.",
    "builtins.set.__rand__" => "Return value&self.",
    "builtins.set.__reduce__" => "Return state information for pickling.",
    "builtins.set.__reduce_ex__" => "Helper for pickle.",
    "builtins.set.__repr__" => "Return repr(self).",
    "builtins.set.__ror__" => "Return value|self.",
    "builtins.set.__rsub__" => "Return value-self.",
    "builtins.set.__rxor__" => "Return value^self.",
    "builtins.set.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.set.__sizeof__" => "S.__sizeof__() -> size of S in memory, in bytes.",
    "builtins.set.__str__" => "Return str(self).",
    "builtins.set.__sub__" => "Return self-value.",
    "builtins.set.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.set.__xor__" => "Return self^value.",
    "builtins.set.add" => "Add an element to a set.\n\nThis has no effect if the element is already present.",
    "builtins.set.clear" => "Remove all elements from this set.",
    "builtins.set.copy" => "Return a shallow copy of a set.",
    "builtins.set.difference" => "Return a new set with elements in the set that are not in the others.",
    "builtins.set.difference_update" => "Update the set, removing elements found in others.",
    "builtins.set.discard" => "Remove an element from a set if it is a member.\n\nUnlike set.remove(), the discard() method does not raise\nan exception when an element is missing from the set.",
    "builtins.set.intersection" => "Return a new set with elements common to the set and all others.",
    "builtins.set.intersection_update" => "Update the set, keeping only elements found in it and all others.",
    "builtins.set.isdisjoint" => "Return True if two sets have a null intersection.",
    "builtins.set.issubset" => "Report whether another set contains this set.",
    "builtins.set.issuperset" => "Report whether this set contains another set.",
    "builtins.set.pop" => "Remove and return an arbitrary set element.\n\nRaises KeyError if the set is empty.",
    "builtins.set.remove" => "Remove an element from a set; it must be a member.\n\nIf the element is not a member, raise a KeyError.",
    "builtins.set.symmetric_difference" => "Return a new set with elements in either the set or other but not both.",
    "builtins.set.symmetric_difference_update" => "Update the set, keeping only elements found in either set, but not in both.",
    "builtins.set.union" => "Return a new set with elements from the set and all others.",
    "builtins.set.update" => "Update the set, adding elements from all others.",
    "builtins.set_iterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.set_iterator.__eq__" => "Return self==value.",
    "builtins.set_iterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.set_iterator.__ge__" => "Return self>=value.",
    "builtins.set_iterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.set_iterator.__getstate__" => "Helper for pickle.",
    "builtins.set_iterator.__gt__" => "Return self>value.",
    "builtins.set_iterator.__hash__" => "Return hash(self).",
    "builtins.set_iterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.set_iterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.set_iterator.__iter__" => "Implement iter(self).",
    "builtins.set_iterator.__le__" => "Return self<=value.",
    "builtins.set_iterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.set_iterator.__lt__" => "Return self<value.",
    "builtins.set_iterator.__ne__" => "Return self!=value.",
    "builtins.set_iterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.set_iterator.__next__" => "Implement next(self).",
    "builtins.set_iterator.__reduce__" => "Return state information for pickling.",
    "builtins.set_iterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.set_iterator.__repr__" => "Return repr(self).",
    "builtins.set_iterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.set_iterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.set_iterator.__str__" => "Return str(self).",
    "builtins.set_iterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.setattr" => "Sets the named attribute on the given object to the specified value.\n\nsetattr(x, 'y', v) is equivalent to ``x.y = v``",
    "builtins.slice" => "slice(stop)\nslice(start, stop[, step])\n\nCreate a slice object.  This is used for extended slicing (e.g. a[0:10:2]).",
    "builtins.slice.__delattr__" => "Implement delattr(self, name).",
    "builtins.slice.__eq__" => "Return self==value.",
    "builtins.slice.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.slice.__ge__" => "Return self>=value.",
    "builtins.slice.__getattribute__" => "Return getattr(self, name).",
    "builtins.slice.__getstate__" => "Helper for pickle.",
    "builtins.slice.__gt__" => "Return self>value.",
    "builtins.slice.__hash__" => "Return hash(self).",
    "builtins.slice.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.slice.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.slice.__le__" => "Return self<=value.",
    "builtins.slice.__lt__" => "Return self<value.",
    "builtins.slice.__ne__" => "Return self!=value.",
    "builtins.slice.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.slice.__reduce__" => "Return state information for pickling.",
    "builtins.slice.__reduce_ex__" => "Helper for pickle.",
    "builtins.slice.__repr__" => "Return repr(self).",
    "builtins.slice.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.slice.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.slice.__str__" => "Return str(self).",
    "builtins.slice.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.slice.indices" => "S.indices(len) -> (start, stop, stride)\n\nAssuming a sequence of length len, calculate the start and stop\nindices, and the stride length of the extended slice described by\nS. Out of bounds indices are clipped in a manner consistent with the\nhandling of normal slices.",
    "builtins.sorted" => "Return a new list containing all items from the iterable in ascending order.\n\nA custom key function can be supplied to customize the sort order, and the\nreverse flag can be set to request the result in descending order.",
    "builtins.staticmethod" => "Convert a function to be a static method.\n\nA static method does not receive an implicit first argument.\nTo declare a static method, use this idiom:\n\n     class C:\n         @staticmethod\n         def f(arg1, arg2, argN):\n             ...\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()). Both the class and the instance are ignored, and\nneither is passed implicitly as the first argument to the method.\n\nStatic methods in Python are similar to those found in Java or C++.\nFor a more advanced concept, see the classmethod builtin.",
    "builtins.staticmethod.__call__" => "Call self as a function.",
    "builtins.staticmethod.__delattr__" => "Implement delattr(self, name).",
    "builtins.staticmethod.__eq__" => "Return self==value.",
    "builtins.staticmethod.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.staticmethod.__ge__" => "Return self>=value.",
    "builtins.staticmethod.__get__" => "Return an attribute of instance, which is of type owner.",
    "builtins.staticmethod.__getattribute__" => "Return getattr(self, name).",
    "builtins.staticmethod.__getstate__" => "Helper for pickle.",
    "builtins.staticmethod.__gt__" => "Return self>value.",
    "builtins.staticmethod.__hash__" => "Return hash(self).",
    "builtins.staticmethod.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.staticmethod.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.staticmethod.__le__" => "Return self<=value.",
    "builtins.staticmethod.__lt__" => "Return self<value.",
    "builtins.staticmethod.__ne__" => "Return self!=value.",
    "builtins.staticmethod.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.staticmethod.__reduce__" => "Helper for pickle.",
    "builtins.staticmethod.__reduce_ex__" => "Helper for pickle.",
    "builtins.staticmethod.__repr__" => "Return repr(self).",
    "builtins.staticmethod.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.staticmethod.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.staticmethod.__str__" => "Return str(self).",
    "builtins.staticmethod.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.str" => "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to 'utf-8'.\nerrors defaults to 'strict'.",
    "builtins.str.__add__" => "Return self+value.",
    "builtins.str.__contains__" => "Return bool(key in self).",
    "builtins.str.__delattr__" => "Implement delattr(self, name).",
    "builtins.str.__eq__" => "Return self==value.",
    "builtins.str.__format__" => "Return a formatted version of the string as described by format_spec.",
    "builtins.str.__ge__" => "Return self>=value.",
    "builtins.str.__getattribute__" => "Return getattr(self, name).",
    "builtins.str.__getitem__" => "Return self[key].",
    "builtins.str.__getstate__" => "Helper for pickle.",
    "builtins.str.__gt__" => "Return self>value.",
    "builtins.str.__hash__" => "Return hash(self).",
    "builtins.str.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.str.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.str.__iter__" => "Implement iter(self).",
    "builtins.str.__le__" => "Return self<=value.",
    "builtins.str.__len__" => "Return len(self).",
    "builtins.str.__lt__" => "Return self<value.",
    "builtins.str.__mod__" => "Return self%value.",
    "builtins.str.__mul__" => "Return self*value.",
    "builtins.str.__ne__" => "Return self!=value.",
    "builtins.str.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.str.__reduce__" => "Helper for pickle.",
    "builtins.str.__reduce_ex__" => "Helper for pickle.",
    "builtins.str.__repr__" => "Return repr(self).",
    "builtins.str.__rmod__" => "Return value%self.",
    "builtins.str.__rmul__" => "Return value*self.",
    "builtins.str.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.str.__sizeof__" => "Return the size of the string in memory, in bytes.",
    "builtins.str.__str__" => "Return str(self).",
    "builtins.str.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.str.capitalize" => "Return a capitalized version of the string.\n\nMore specifically, make the first character have upper case and the rest lower\ncase.",
    "builtins.str.casefold" => "Return a version of the string suitable for caseless comparisons.",
    "builtins.str.center" => "Return a centered string of length width.\n\nPadding is done using the specified fill character (default is a space).",
    "builtins.str.count" => "Return the number of non-overlapping occurrences of substring sub in string S[start:end].\n\nOptional arguments start and end are interpreted as in slice notation.",
    "builtins.str.encode" => "Encode the string using the codec registered for encoding.\n\nencoding\n  The encoding in which to encode the string.\nerrors\n  The error handling scheme to use for encoding errors.\n  The default is 'strict' meaning that encoding errors raise a\n  UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and\n  'xmlcharrefreplace' as well as any other name registered with\n  codecs.register_error that can handle UnicodeEncodeErrors.",
    "builtins.str.endswith" => "Return True if the string ends with the specified suffix, False otherwise.\n\nsuffix\n  A string or a tuple of strings to try.\nstart\n  Optional start position. Default: start of the string.\nend\n  Optional stop position. Default: end of the string.",
    "builtins.str.expandtabs" => "Return a copy where all tab characters are expanded using spaces.\n\nIf tabsize is not given, a tab size of 8 characters is assumed.",
    "builtins.str.find" => "Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end].\n\nOptional arguments start and end are interpreted as in slice notation.\nReturn -1 on failure.",
    "builtins.str.format" => "Return a formatted version of the string, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').",
    "builtins.str.format_map" => "Return a formatted version of the string, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').",
    "builtins.str.index" => "Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end].\n\nOptional arguments start and end are interpreted as in slice notation.\nRaises ValueError when the substring is not found.",
    "builtins.str.isalnum" => "Return True if the string is an alpha-numeric string, False otherwise.\n\nA string is alpha-numeric if all characters in the string are alpha-numeric and\nthere is at least one character in the string.",
    "builtins.str.isalpha" => "Return True if the string is an alphabetic string, False otherwise.\n\nA string is alphabetic if all characters in the string are alphabetic and there\nis at least one character in the string.",
    "builtins.str.isascii" => "Return True if all characters in the string are ASCII, False otherwise.\n\nASCII characters have code points in the range U+0000-U+007F.\nEmpty string is ASCII too.",
    "builtins.str.isdecimal" => "Return True if the string is a decimal string, False otherwise.\n\nA string is a decimal string if all characters in the string are decimal and\nthere is at least one character in the string.",
    "builtins.str.isdigit" => "Return True if the string is a digit string, False otherwise.\n\nA string is a digit string if all characters in the string are digits and there\nis at least one character in the string.",
    "builtins.str.isidentifier" => "Return True if the string is a valid Python identifier, False otherwise.\n\nCall keyword.iskeyword(s) to test whether string s is a reserved identifier,\nsuch as \"def\" or \"class\".",
    "builtins.str.islower" => "Return True if the string is a lowercase string, False otherwise.\n\nA string is lowercase if all cased characters in the string are lowercase and\nthere is at least one cased character in the string.",
    "builtins.str.isnumeric" => "Return True if the string is a numeric string, False otherwise.\n\nA string is numeric if all characters in the string are numeric and there is at\nleast one character in the string.",
    "builtins.str.isprintable" => "Return True if all characters in the string are printable, False otherwise.\n\nA character is printable if repr() may use it in its output.",
    "builtins.str.isspace" => "Return True if the string is a whitespace string, False otherwise.\n\nA string is whitespace if all characters in the string are whitespace and there\nis at least one character in the string.",
    "builtins.str.istitle" => "Return True if the string is a title-cased string, False otherwise.\n\nIn a title-cased string, upper- and title-case characters may only\nfollow uncased characters and lowercase characters only cased ones.",
    "builtins.str.isupper" => "Return True if the string is an uppercase string, False otherwise.\n\nA string is uppercase if all cased characters in the string are uppercase and\nthere is at least one cased character in the string.",
    "builtins.str.join" => "Concatenate any number of strings.\n\nThe string whose method is called is inserted in between each given string.\nThe result is returned as a new string.\n\nExample: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'",
    "builtins.str.ljust" => "Return a left-justified string of length width.\n\nPadding is done using the specified fill character (default is a space).",
    "builtins.str.lower" => "Return a copy of the string converted to lowercase.",
    "builtins.str.lstrip" => "Return a copy of the string with leading whitespace removed.\n\nIf chars is given and not None, remove characters in chars instead.",
    "builtins.str.maketrans" => "Return a translation table usable for str.translate().\n\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.",
    "builtins.str.partition" => "Partition the string into three parts using the given separator.\n\nThis will search for the separator in the string.  If the separator is found,\nreturns a 3-tuple containing the part before the separator, the separator\nitself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing the original string\nand two empty strings.",
    "builtins.str.removeprefix" => "Return a str with the given prefix string removed if present.\n\nIf the string starts with the prefix string, return string[len(prefix):].\nOtherwise, return a copy of the original string.",
    "builtins.str.removesuffix" => "Return a str with the given suffix string removed if present.\n\nIf the string ends with the suffix string and that suffix is not empty,\nreturn string[:-len(suffix)]. Otherwise, return a copy of the original\nstring.",
    "builtins.str.replace" => "Return a copy with all occurrences of substring old replaced by new.\n\n  count\n    Maximum number of occurrences to replace.\n    -1 (the default value) means replace all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplaced.",
    "builtins.str.rfind" => "Return the highest index in S where substring sub is found, such that sub is contained within S[start:end].\n\nOptional arguments start and end are interpreted as in slice notation.\nReturn -1 on failure.",
    "builtins.str.rindex" => "Return the highest index in S where substring sub is found, such that sub is contained within S[start:end].\n\nOptional arguments start and end are interpreted as in slice notation.\nRaises ValueError when the substring is not found.",
    "builtins.str.rjust" => "Return a right-justified string of length width.\n\nPadding is done using the specified fill character (default is a space).",
    "builtins.str.rpartition" => "Partition the string into three parts using the given separator.\n\nThis will search for the separator in the string, starting at the end. If\nthe separator is found, returns a 3-tuple containing the part before the\nseparator, the separator itself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing two empty strings\nand the original string.",
    "builtins.str.rsplit" => "Return a list of the substrings in the string, using sep as the separator string.\n\n  sep\n    The separator used to split the string.\n\n    When set to None (the default value), will split on any whitespace\n    character (including \\n \\r \\t \\f and spaces) and will discard\n    empty strings from the result.\n  maxsplit\n    Maximum number of splits.\n    -1 (the default value) means no limit.\n\nSplitting starts at the end of the string and works to the front.",
    "builtins.str.rstrip" => "Return a copy of the string with trailing whitespace removed.\n\nIf chars is given and not None, remove characters in chars instead.",
    "builtins.str.split" => "Return a list of the substrings in the string, using sep as the separator string.\n\n  sep\n    The separator used to split the string.\n\n    When set to None (the default value), will split on any whitespace\n    character (including \\n \\r \\t \\f and spaces) and will discard\n    empty strings from the result.\n  maxsplit\n    Maximum number of splits.\n    -1 (the default value) means no limit.\n\nSplitting starts at the front of the string and works to the end.\n\nNote, str.split() is mainly useful for data that has been intentionally\ndelimited.  With natural text that includes punctuation, consider using\nthe regular expression module.",
    "builtins.str.splitlines" => "Return a list of the lines in the string, breaking at line boundaries.\n\nLine breaks are not included in the resulting list unless keepends is given and\ntrue.",
    "builtins.str.startswith" => "Return True if the string starts with the specified prefix, False otherwise.\n\nprefix\n  A string or a tuple of strings to try.\nstart\n  Optional start position. Default: start of the string.\nend\n  Optional stop position. Default: end of the string.",
    "builtins.str.strip" => "Return a copy of the string with leading and trailing whitespace removed.\n\nIf chars is given and not None, remove characters in chars instead.",
    "builtins.str.swapcase" => "Convert uppercase characters to lowercase and lowercase characters to uppercase.",
    "builtins.str.title" => "Return a version of the string where each word is titlecased.\n\nMore specifically, words start with uppercased characters and all remaining\ncased characters have lower case.",
    "builtins.str.translate" => "Replace each character in the string using the given translation table.\n\n  table\n    Translation table, which must be a mapping of Unicode ordinals to\n    Unicode ordinals, strings, or None.\n\nThe table must implement lookup/indexing via __getitem__, for instance a\ndictionary or list.  If this operation raises LookupError, the character is\nleft untouched.  Characters mapped to None are deleted.",
    "builtins.str.upper" => "Return a copy of the string converted to uppercase.",
    "builtins.str.zfill" => "Pad a numeric string with zeros on the left, to fill a field of the given width.\n\nThe string is never truncated.",
    "builtins.str_ascii_iterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.str_ascii_iterator.__eq__" => "Return self==value.",
    "builtins.str_ascii_iterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.str_ascii_iterator.__ge__" => "Return self>=value.",
    "builtins.str_ascii_iterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.str_ascii_iterator.__getstate__" => "Helper for pickle.",
    "builtins.str_ascii_iterator.__gt__" => "Return self>value.",
    "builtins.str_ascii_iterator.__hash__" => "Return hash(self).",
    "builtins.str_ascii_iterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.str_ascii_iterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.str_ascii_iterator.__iter__" => "Implement iter(self).",
    "builtins.str_ascii_iterator.__le__" => "Return self<=value.",
    "builtins.str_ascii_iterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.str_ascii_iterator.__lt__" => "Return self<value.",
    "builtins.str_ascii_iterator.__ne__" => "Return self!=value.",
    "builtins.str_ascii_iterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.str_ascii_iterator.__next__" => "Implement next(self).",
    "builtins.str_ascii_iterator.__reduce__" => "Return state information for pickling.",
    "builtins.str_ascii_iterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.str_ascii_iterator.__repr__" => "Return repr(self).",
    "builtins.str_ascii_iterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.str_ascii_iterator.__setstate__" => "Set state information for unpickling.",
    "builtins.str_ascii_iterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.str_ascii_iterator.__str__" => "Return str(self).",
    "builtins.str_ascii_iterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.sum" => "Return the sum of a 'start' value (default: 0) plus an iterable of numbers\n\nWhen the iterable is empty, return the start value.\nThis function is intended specifically for use with numeric values and may\nreject non-numeric types.",
    "builtins.super" => "super() -> same as super(__class__, <first argument>)\nsuper(type) -> unbound super object\nsuper(type, obj) -> bound super object; requires isinstance(obj, type)\nsuper(type, type2) -> bound super object; requires issubclass(type2, type)\nTypical use to call a cooperative superclass method:\nclass C(B):\n    def meth(self, arg):\n        super().meth(arg)\nThis works for class methods too:\nclass C(B):\n    @classmethod\n    def cmeth(cls, arg):\n        super().cmeth(arg)",
    "builtins.super.__delattr__" => "Implement delattr(self, name).",
    "builtins.super.__eq__" => "Return self==value.",
    "builtins.super.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.super.__ge__" => "Return self>=value.",
    "builtins.super.__get__" => "Return an attribute of instance, which is of type owner.",
    "builtins.super.__getattribute__" => "Return getattr(self, name).",
    "builtins.super.__getstate__" => "Helper for pickle.",
    "builtins.super.__gt__" => "Return self>value.",
    "builtins.super.__hash__" => "Return hash(self).",
    "builtins.super.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.super.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.super.__le__" => "Return self<=value.",
    "builtins.super.__lt__" => "Return self<value.",
    "builtins.super.__ne__" => "Return self!=value.",
    "builtins.super.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.super.__reduce__" => "Helper for pickle.",
    "builtins.super.__reduce_ex__" => "Helper for pickle.",
    "builtins.super.__repr__" => "Return repr(self).",
    "builtins.super.__self__" => "the instance invoking super(); may be None",
    "builtins.super.__self_class__" => "the type of the instance invoking super(); may be None",
    "builtins.super.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.super.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.super.__str__" => "Return str(self).",
    "builtins.super.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.super.__thisclass__" => "the class invoking super()",
    "builtins.tuple" => "Built-in immutable sequence.\n\nIf no argument is given, the constructor returns an empty tuple.\nIf iterable is specified the tuple is initialized from iterable's items.\n\nIf the argument is a tuple, the return value is the same object.",
    "builtins.tuple.__add__" => "Return self+value.",
    "builtins.tuple.__class_getitem__" => "See PEP 585",
    "builtins.tuple.__contains__" => "Return bool(key in self).",
    "builtins.tuple.__delattr__" => "Implement delattr(self, name).",
    "builtins.tuple.__eq__" => "Return self==value.",
    "builtins.tuple.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.tuple.__ge__" => "Return self>=value.",
    "builtins.tuple.__getattribute__" => "Return getattr(self, name).",
    "builtins.tuple.__getitem__" => "Return self[key].",
    "builtins.tuple.__getstate__" => "Helper for pickle.",
    "builtins.tuple.__gt__" => "Return self>value.",
    "builtins.tuple.__hash__" => "Return hash(self).",
    "builtins.tuple.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.tuple.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.tuple.__iter__" => "Implement iter(self).",
    "builtins.tuple.__le__" => "Return self<=value.",
    "builtins.tuple.__len__" => "Return len(self).",
    "builtins.tuple.__lt__" => "Return self<value.",
    "builtins.tuple.__mul__" => "Return self*value.",
    "builtins.tuple.__ne__" => "Return self!=value.",
    "builtins.tuple.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.tuple.__reduce__" => "Helper for pickle.",
    "builtins.tuple.__reduce_ex__" => "Helper for pickle.",
    "builtins.tuple.__repr__" => "Return repr(self).",
    "builtins.tuple.__rmul__" => "Return value*self.",
    "builtins.tuple.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.tuple.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.tuple.__str__" => "Return str(self).",
    "builtins.tuple.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.tuple.count" => "Return number of occurrences of value.",
    "builtins.tuple.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "builtins.tuple_iterator.__delattr__" => "Implement delattr(self, name).",
    "builtins.tuple_iterator.__eq__" => "Return self==value.",
    "builtins.tuple_iterator.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.tuple_iterator.__ge__" => "Return self>=value.",
    "builtins.tuple_iterator.__getattribute__" => "Return getattr(self, name).",
    "builtins.tuple_iterator.__getstate__" => "Helper for pickle.",
    "builtins.tuple_iterator.__gt__" => "Return self>value.",
    "builtins.tuple_iterator.__hash__" => "Return hash(self).",
    "builtins.tuple_iterator.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.tuple_iterator.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.tuple_iterator.__iter__" => "Implement iter(self).",
    "builtins.tuple_iterator.__le__" => "Return self<=value.",
    "builtins.tuple_iterator.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "builtins.tuple_iterator.__lt__" => "Return self<value.",
    "builtins.tuple_iterator.__ne__" => "Return self!=value.",
    "builtins.tuple_iterator.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.tuple_iterator.__next__" => "Implement next(self).",
    "builtins.tuple_iterator.__reduce__" => "Return state information for pickling.",
    "builtins.tuple_iterator.__reduce_ex__" => "Helper for pickle.",
    "builtins.tuple_iterator.__repr__" => "Return repr(self).",
    "builtins.tuple_iterator.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.tuple_iterator.__setstate__" => "Set state information for unpickling.",
    "builtins.tuple_iterator.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.tuple_iterator.__str__" => "Return str(self).",
    "builtins.tuple_iterator.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.type" => "type(object) -> the object's type\ntype(name, bases, dict, **kwds) -> a new type",
    "builtins.type.__base__" => "The base class of the class hierarchy.\n\nWhen called, it accepts no arguments and returns a new featureless\ninstance that has no instance attributes and cannot be given any.",
    "builtins.type.__base__.__delattr__" => "Implement delattr(self, name).",
    "builtins.type.__base__.__eq__" => "Return self==value.",
    "builtins.type.__base__.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.type.__base__.__ge__" => "Return self>=value.",
    "builtins.type.__base__.__getattribute__" => "Return getattr(self, name).",
    "builtins.type.__base__.__getstate__" => "Helper for pickle.",
    "builtins.type.__base__.__gt__" => "Return self>value.",
    "builtins.type.__base__.__hash__" => "Return hash(self).",
    "builtins.type.__base__.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.type.__base__.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.type.__base__.__le__" => "Return self<=value.",
    "builtins.type.__base__.__lt__" => "Return self<value.",
    "builtins.type.__base__.__ne__" => "Return self!=value.",
    "builtins.type.__base__.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.type.__base__.__reduce__" => "Helper for pickle.",
    "builtins.type.__base__.__reduce_ex__" => "Helper for pickle.",
    "builtins.type.__base__.__repr__" => "Return repr(self).",
    "builtins.type.__base__.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.type.__base__.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.type.__base__.__str__" => "Return str(self).",
    "builtins.type.__base__.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.type.__call__" => "Call self as a function.",
    "builtins.type.__delattr__" => "Implement delattr(self, name).",
    "builtins.type.__eq__" => "Return self==value.",
    "builtins.type.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.type.__ge__" => "Return self>=value.",
    "builtins.type.__getattribute__" => "Return getattr(self, name).",
    "builtins.type.__getstate__" => "Helper for pickle.",
    "builtins.type.__gt__" => "Return self>value.",
    "builtins.type.__hash__" => "Return hash(self).",
    "builtins.type.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.type.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.type.__instancecheck__" => "Check if an object is an instance.",
    "builtins.type.__le__" => "Return self<=value.",
    "builtins.type.__lt__" => "Return self<value.",
    "builtins.type.__ne__" => "Return self!=value.",
    "builtins.type.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.type.__or__" => "Return self|value.",
    "builtins.type.__prepare__" => "Create the namespace for the class statement",
    "builtins.type.__reduce__" => "Helper for pickle.",
    "builtins.type.__reduce_ex__" => "Helper for pickle.",
    "builtins.type.__repr__" => "Return repr(self).",
    "builtins.type.__ror__" => "Return value|self.",
    "builtins.type.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.type.__sizeof__" => "Return memory consumption of the type object.",
    "builtins.type.__str__" => "Return str(self).",
    "builtins.type.__subclasscheck__" => "Check if a class is a subclass.",
    "builtins.type.__subclasses__" => "Return a list of immediate subclasses.",
    "builtins.type.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "builtins.type.mro" => "Return a type's method resolution order.",
    "builtins.vars" => "vars([object]) -> dictionary\n\nWithout arguments, equivalent to locals().\nWith an argument, equivalent to object.__dict__.",
    "builtins.zip" => "The zip object yields n-length tuples, where n is the number of iterables\npassed as positional arguments to zip().  The i-th element in every tuple\ncomes from the i-th iterable argument to zip().  This continues until the\nshortest argument is exhausted.\n\nIf strict is true and one of the arguments is exhausted before the others,\nraise a ValueError.\n\n   >>> list(zip('abcdefg', range(3), range(4)))\n   [('a', 0, 0), ('b', 1, 1), ('c', 2, 2)]",
    "builtins.zip.__delattr__" => "Implement delattr(self, name).",
    "builtins.zip.__eq__" => "Return self==value.",
    "builtins.zip.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "builtins.zip.__ge__" => "Return self>=value.",
    "builtins.zip.__getattribute__" => "Return getattr(self, name).",
    "builtins.zip.__getstate__" => "Helper for pickle.",
    "builtins.zip.__gt__" => "Return self>value.",
    "builtins.zip.__hash__" => "Return hash(self).",
    "builtins.zip.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "builtins.zip.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "builtins.zip.__iter__" => "Implement iter(self).",
    "builtins.zip.__le__" => "Return self<=value.",
    "builtins.zip.__lt__" => "Return self<value.",
    "builtins.zip.__ne__" => "Return self!=value.",
    "builtins.zip.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "builtins.zip.__next__" => "Implement next(self).",
    "builtins.zip.__reduce__" => "Return state information for pickling.",
    "builtins.zip.__reduce_ex__" => "Helper for pickle.",
    "builtins.zip.__repr__" => "Return repr(self).",
    "builtins.zip.__setattr__" => "Implement setattr(self, name, value).",
    "builtins.zip.__setstate__" => "Set state information for unpickling.",
    "builtins.zip.__sizeof__" => "Size of object in memory, in bytes.",
    "builtins.zip.__str__" => "Return str(self).",
    "builtins.zip.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "cmath" => "This module provides access to mathematical functions for complex\nnumbers.",
    "cmath.acos" => "Return the arc cosine of z.",
    "cmath.acosh" => "Return the inverse hyperbolic cosine of z.",
    "cmath.asin" => "Return the arc sine of z.",
    "cmath.asinh" => "Return the inverse hyperbolic sine of z.",
    "cmath.atan" => "Return the arc tangent of z.",
    "cmath.atanh" => "Return the inverse hyperbolic tangent of z.",
    "cmath.cos" => "Return the cosine of z.",
    "cmath.cosh" => "Return the hyperbolic cosine of z.",
    "cmath.exp" => "Return the exponential value e**z.",
    "cmath.isclose" => "Determine whether two complex numbers are close in value.\n\n  rel_tol\n    maximum difference for being considered \"close\", relative to the\n    magnitude of the input values\n  abs_tol\n    maximum difference for being considered \"close\", regardless of the\n    magnitude of the input values\n\nReturn True if a is close in value to b, and False otherwise.\n\nFor the values to be considered close, the difference between them must be\nsmaller than at least one of the tolerances.\n\n-inf, inf and NaN behave similarly to the IEEE 754 Standard. That is, NaN is\nnot close to anything, even itself. inf and -inf are only close to themselves.",
    "cmath.isfinite" => "Return True if both the real and imaginary parts of z are finite, else False.",
    "cmath.isinf" => "Checks if the real or imaginary part of z is infinite.",
    "cmath.isnan" => "Checks if the real or imaginary part of z not a number (NaN).",
    "cmath.log" => "log(z[, base]) -> the logarithm of z to the given base.\n\nIf the base is not specified, returns the natural logarithm (base e) of z.",
    "cmath.log10" => "Return the base-10 logarithm of z.",
    "cmath.phase" => "Return argument, also known as the phase angle, of a complex.",
    "cmath.polar" => "Convert a complex from rectangular coordinates to polar coordinates.\n\nr is the distance from 0 and phi the phase angle.",
    "cmath.rect" => "Convert from polar coordinates to rectangular coordinates.",
    "cmath.sin" => "Return the sine of z.",
    "cmath.sinh" => "Return the hyperbolic sine of z.",
    "cmath.sqrt" => "Return the square root of z.",
    "cmath.tan" => "Return the tangent of z.",
    "cmath.tanh" => "Return the hyperbolic tangent of z.",
    "errno" => "This module makes available standard errno system symbols.\n\nThe value of each symbol is the corresponding integer value,\ne.g., on most systems, errno.ENOENT equals the integer 2.\n\nThe dictionary errno.errorcode maps numeric codes to symbol names,\ne.g., errno.errorcode[2] could be the string 'ENOENT'.\n\nSymbols that are not relevant to the underlying system are not defined.\n\nTo map error codes to error messages, use the function os.strerror(),\ne.g. os.strerror(2) could return 'No such file or directory'.",
    "faulthandler" => "faulthandler module.",
    "faulthandler._fatal_error_c_thread" => "Call Py_FatalError() in a new C thread.",
    "faulthandler._raise_exception" => "Call RaiseException(code, flags).",
    "faulthandler._read_null" => "Read from NULL, raise a SIGSEGV or SIGBUS signal depending on the platform.",
    "faulthandler._sigabrt" => "Raise a SIGABRT signal.",
    "faulthandler._sigfpe" => "Raise a SIGFPE signal.",
    "faulthandler._sigsegv" => "Raise a SIGSEGV signal.",
    "faulthandler.cancel_dump_traceback_later" => "Cancel the previous call to dump_traceback_later().",
    "faulthandler.disable" => "Disable the fault handler.",
    "faulthandler.dump_traceback" => "Dump the traceback of the current thread, or of all threads if all_threads is True, into file.",
    "faulthandler.dump_traceback_later" => "Dump the traceback of all threads in timeout seconds,\nor each timeout seconds if repeat is True. If exit is True, call _exit(1) which is not safe.",
    "faulthandler.enable" => "Enable the fault handler.",
    "faulthandler.is_enabled" => "Check if the handler is enabled.",
    "gc" => "This module provides access to the garbage collector for reference cycles.\n\nenable() -- Enable automatic garbage collection.\ndisable() -- Disable automatic garbage collection.\nisenabled() -- Returns true if automatic collection is enabled.\ncollect() -- Do a full collection right now.\nget_count() -- Return the current collection counts.\nget_stats() -- Return list of dictionaries containing per-generation stats.\nset_debug() -- Set debugging flags.\nget_debug() -- Get debugging flags.\nset_threshold() -- Set the collection thresholds.\nget_threshold() -- Return the current collection thresholds.\nget_objects() -- Return a list of all objects tracked by the collector.\nis_tracked() -- Returns true if a given object is tracked.\nis_finalized() -- Returns true if a given object has been already finalized.\nget_referrers() -- Return the list of objects that refer to an object.\nget_referents() -- Return the list of objects that an object refers to.\nfreeze() -- Freeze all tracked objects and ignore them for future collections.\nunfreeze() -- Unfreeze all objects in the permanent generation.\nget_freeze_count() -- Return the number of objects in the permanent generation.",
    "gc.collect" => "Run the garbage collector.\n\nWith no arguments, run a full collection.  The optional argument\nmay be an integer specifying which generation to collect.  A ValueError\nis raised if the generation number is invalid.\n\nThe number of unreachable objects is returned.",
    "gc.disable" => "Disable automatic garbage collection.",
    "gc.enable" => "Enable automatic garbage collection.",
    "gc.freeze" => "Freeze all current tracked objects and ignore them for future collections.\n\nThis can be used before a POSIX fork() call to make the gc copy-on-write friendly.\nNote: collection before a POSIX fork() call may free pages for future allocation\nwhich can cause copy-on-write.",
    "gc.get_count" => "Return a three-tuple of the current collection counts.",
    "gc.get_debug" => "Get the garbage collection debugging flags.",
    "gc.get_freeze_count" => "Return the number of objects in the permanent generation.",
    "gc.get_objects" => "Return a list of objects tracked by the collector (excluding the list returned).\n\n  generation\n    Generation to extract the objects from.\n\nIf generation is not None, return only the objects tracked by the collector\nthat are in that generation.",
    "gc.get_referents" => "Return the list of objects that are directly referred to by 'objs'.",
    "gc.get_referrers" => "Return the list of objects that directly refer to any of 'objs'.",
    "gc.get_stats" => "Return a list of dictionaries containing per-generation statistics.",
    "gc.get_threshold" => "Return the current collection thresholds.",
    "gc.is_finalized" => "Returns true if the object has been already finalized by the GC.",
    "gc.is_tracked" => "Returns true if the object is tracked by the garbage collector.\n\nSimple atomic objects will return false.",
    "gc.isenabled" => "Returns true if automatic garbage collection is enabled.",
    "gc.set_debug" => "Set the garbage collection debugging flags.\n\n  flags\n    An integer that can have the following bits turned on:\n      DEBUG_STATS - Print statistics during collection.\n      DEBUG_COLLECTABLE - Print collectable objects found.\n      DEBUG_UNCOLLECTABLE - Print unreachable but uncollectable objects\n        found.\n      DEBUG_SAVEALL - Save objects to gc.garbage rather than freeing them.\n      DEBUG_LEAK - Debug leaking programs (everything but STATS).\n\nDebugging information is written to sys.stderr.",
    "gc.set_threshold" => "set_threshold(threshold0, [threshold1, [threshold2]])\nSet the collection thresholds (the collection frequency).\n\nSetting 'threshold0' to zero disables collection.",
    "gc.unfreeze" => "Unfreeze all objects in the permanent generation.\n\nPut all objects in the permanent generation back into oldest generation.",
    "itertools" => "Functional tools for creating and using iterators.\n\nInfinite iterators:\ncount(start=0, step=1) --> start, start+step, start+2*step, ...\ncycle(p) --> p0, p1, ... plast, p0, p1, ...\nrepeat(elem [,n]) --> elem, elem, elem, ... endlessly or up to n times\n\nIterators terminating on the shortest input sequence:\naccumulate(p[, func]) --> p0, p0+p1, p0+p1+p2\nbatched(p, n) --> [p0, p1, ..., p_n-1], [p_n, p_n+1, ..., p_2n-1], ...\nchain(p, q, ...) --> p0, p1, ... plast, q0, q1, ...\nchain.from_iterable([p, q, ...]) --> p0, p1, ... plast, q0, q1, ...\ncompress(data, selectors) --> (d[0] if s[0]), (d[1] if s[1]), ...\ndropwhile(predicate, seq) --> seq[n], seq[n+1], starting when predicate fails\ngroupby(iterable[, keyfunc]) --> sub-iterators grouped by value of keyfunc(v)\nfilterfalse(predicate, seq) --> elements of seq where predicate(elem) is False\nislice(seq, [start,] stop [, step]) --> elements from\n       seq[start:stop:step]\npairwise(s) --> (s[0],s[1]), (s[1],s[2]), (s[2], s[3]), ...\nstarmap(fun, seq) --> fun(*seq[0]), fun(*seq[1]), ...\ntee(it, n=2) --> (it1, it2 , ... itn) splits one iterator into n\ntakewhile(predicate, seq) --> seq[0], seq[1], until predicate fails\nzip_longest(p, q, ...) --> (p[0], q[0]), (p[1], q[1]), ...\n\nCombinatoric generators:\nproduct(p, q, ... [repeat=1]) --> cartesian product\npermutations(p[, r])\ncombinations(p, r)\ncombinations_with_replacement(p, r)",
    "itertools._grouper.__delattr__" => "Implement delattr(self, name).",
    "itertools._grouper.__eq__" => "Return self==value.",
    "itertools._grouper.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools._grouper.__ge__" => "Return self>=value.",
    "itertools._grouper.__getattribute__" => "Return getattr(self, name).",
    "itertools._grouper.__getstate__" => "Helper for pickle.",
    "itertools._grouper.__gt__" => "Return self>value.",
    "itertools._grouper.__hash__" => "Return hash(self).",
    "itertools._grouper.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools._grouper.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools._grouper.__iter__" => "Implement iter(self).",
    "itertools._grouper.__le__" => "Return self<=value.",
    "itertools._grouper.__lt__" => "Return self<value.",
    "itertools._grouper.__ne__" => "Return self!=value.",
    "itertools._grouper.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools._grouper.__next__" => "Implement next(self).",
    "itertools._grouper.__reduce__" => "Return state information for pickling.",
    "itertools._grouper.__reduce_ex__" => "Helper for pickle.",
    "itertools._grouper.__repr__" => "Return repr(self).",
    "itertools._grouper.__setattr__" => "Implement setattr(self, name, value).",
    "itertools._grouper.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools._grouper.__str__" => "Return str(self).",
    "itertools._grouper.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools._tee" => "Iterator wrapped to make it copyable.",
    "itertools._tee.__copy__" => "Returns an independent iterator.",
    "itertools._tee.__delattr__" => "Implement delattr(self, name).",
    "itertools._tee.__eq__" => "Return self==value.",
    "itertools._tee.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools._tee.__ge__" => "Return self>=value.",
    "itertools._tee.__getattribute__" => "Return getattr(self, name).",
    "itertools._tee.__getstate__" => "Helper for pickle.",
    "itertools._tee.__gt__" => "Return self>value.",
    "itertools._tee.__hash__" => "Return hash(self).",
    "itertools._tee.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools._tee.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools._tee.__iter__" => "Implement iter(self).",
    "itertools._tee.__le__" => "Return self<=value.",
    "itertools._tee.__lt__" => "Return self<value.",
    "itertools._tee.__ne__" => "Return self!=value.",
    "itertools._tee.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools._tee.__next__" => "Implement next(self).",
    "itertools._tee.__reduce__" => "Return state information for pickling.",
    "itertools._tee.__reduce_ex__" => "Helper for pickle.",
    "itertools._tee.__repr__" => "Return repr(self).",
    "itertools._tee.__setattr__" => "Implement setattr(self, name, value).",
    "itertools._tee.__setstate__" => "Set state information for unpickling.",
    "itertools._tee.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools._tee.__str__" => "Return str(self).",
    "itertools._tee.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools._tee_dataobject" => "teedataobject(iterable, values, next, /)\n--\n\nData container common to multiple tee objects.",
    "itertools._tee_dataobject.__delattr__" => "Implement delattr(self, name).",
    "itertools._tee_dataobject.__eq__" => "Return self==value.",
    "itertools._tee_dataobject.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools._tee_dataobject.__ge__" => "Return self>=value.",
    "itertools._tee_dataobject.__getattribute__" => "Return getattr(self, name).",
    "itertools._tee_dataobject.__getstate__" => "Helper for pickle.",
    "itertools._tee_dataobject.__gt__" => "Return self>value.",
    "itertools._tee_dataobject.__hash__" => "Return hash(self).",
    "itertools._tee_dataobject.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools._tee_dataobject.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools._tee_dataobject.__le__" => "Return self<=value.",
    "itertools._tee_dataobject.__lt__" => "Return self<value.",
    "itertools._tee_dataobject.__ne__" => "Return self!=value.",
    "itertools._tee_dataobject.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools._tee_dataobject.__reduce__" => "Return state information for pickling.",
    "itertools._tee_dataobject.__reduce_ex__" => "Helper for pickle.",
    "itertools._tee_dataobject.__repr__" => "Return repr(self).",
    "itertools._tee_dataobject.__setattr__" => "Implement setattr(self, name, value).",
    "itertools._tee_dataobject.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools._tee_dataobject.__str__" => "Return str(self).",
    "itertools._tee_dataobject.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.accumulate" => "Return series of accumulated sums (or other binary function results).",
    "itertools.accumulate.__delattr__" => "Implement delattr(self, name).",
    "itertools.accumulate.__eq__" => "Return self==value.",
    "itertools.accumulate.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.accumulate.__ge__" => "Return self>=value.",
    "itertools.accumulate.__getattribute__" => "Return getattr(self, name).",
    "itertools.accumulate.__getstate__" => "Helper for pickle.",
    "itertools.accumulate.__gt__" => "Return self>value.",
    "itertools.accumulate.__hash__" => "Return hash(self).",
    "itertools.accumulate.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.accumulate.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.accumulate.__iter__" => "Implement iter(self).",
    "itertools.accumulate.__le__" => "Return self<=value.",
    "itertools.accumulate.__lt__" => "Return self<value.",
    "itertools.accumulate.__ne__" => "Return self!=value.",
    "itertools.accumulate.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.accumulate.__next__" => "Implement next(self).",
    "itertools.accumulate.__reduce__" => "Return state information for pickling.",
    "itertools.accumulate.__reduce_ex__" => "Helper for pickle.",
    "itertools.accumulate.__repr__" => "Return repr(self).",
    "itertools.accumulate.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.accumulate.__setstate__" => "Set state information for unpickling.",
    "itertools.accumulate.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.accumulate.__str__" => "Return str(self).",
    "itertools.accumulate.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.batched" => "Batch data into tuples of length n. The last batch may be shorter than n.\n\nLoops over the input iterable and accumulates data into tuples\nup to size n.  The input is consumed lazily, just enough to\nfill a batch.  The result is yielded as soon as a batch is full\nor when the input iterable is exhausted.\n\n    >>> for batch in batched('ABCDEFG', 3):\n    ...     print(batch)\n    ...\n    ('A', 'B', 'C')\n    ('D', 'E', 'F')\n    ('G',)\n\nIf \"strict\" is True, raises a ValueError if the final batch is shorter\nthan n.",
    "itertools.batched.__delattr__" => "Implement delattr(self, name).",
    "itertools.batched.__eq__" => "Return self==value.",
    "itertools.batched.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.batched.__ge__" => "Return self>=value.",
    "itertools.batched.__getattribute__" => "Return getattr(self, name).",
    "itertools.batched.__getstate__" => "Helper for pickle.",
    "itertools.batched.__gt__" => "Return self>value.",
    "itertools.batched.__hash__" => "Return hash(self).",
    "itertools.batched.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.batched.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.batched.__iter__" => "Implement iter(self).",
    "itertools.batched.__le__" => "Return self<=value.",
    "itertools.batched.__lt__" => "Return self<value.",
    "itertools.batched.__ne__" => "Return self!=value.",
    "itertools.batched.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.batched.__next__" => "Implement next(self).",
    "itertools.batched.__reduce__" => "Helper for pickle.",
    "itertools.batched.__reduce_ex__" => "Helper for pickle.",
    "itertools.batched.__repr__" => "Return repr(self).",
    "itertools.batched.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.batched.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.batched.__str__" => "Return str(self).",
    "itertools.batched.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.chain" => "Return a chain object whose .__next__() method returns elements from the\nfirst iterable until it is exhausted, then elements from the next\niterable, until all of the iterables are exhausted.",
    "itertools.chain.__class_getitem__" => "See PEP 585",
    "itertools.chain.__delattr__" => "Implement delattr(self, name).",
    "itertools.chain.__eq__" => "Return self==value.",
    "itertools.chain.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.chain.__ge__" => "Return self>=value.",
    "itertools.chain.__getattribute__" => "Return getattr(self, name).",
    "itertools.chain.__getstate__" => "Helper for pickle.",
    "itertools.chain.__gt__" => "Return self>value.",
    "itertools.chain.__hash__" => "Return hash(self).",
    "itertools.chain.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.chain.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.chain.__iter__" => "Implement iter(self).",
    "itertools.chain.__le__" => "Return self<=value.",
    "itertools.chain.__lt__" => "Return self<value.",
    "itertools.chain.__ne__" => "Return self!=value.",
    "itertools.chain.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.chain.__next__" => "Implement next(self).",
    "itertools.chain.__reduce__" => "Return state information for pickling.",
    "itertools.chain.__reduce_ex__" => "Helper for pickle.",
    "itertools.chain.__repr__" => "Return repr(self).",
    "itertools.chain.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.chain.__setstate__" => "Set state information for unpickling.",
    "itertools.chain.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.chain.__str__" => "Return str(self).",
    "itertools.chain.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.chain.from_iterable" => "Alternative chain() constructor taking a single iterable argument that evaluates lazily.",
    "itertools.combinations" => "Return successive r-length combinations of elements in the iterable.\n\ncombinations(range(4), 3) --> (0,1,2), (0,1,3), (0,2,3), (1,2,3)",
    "itertools.combinations.__delattr__" => "Implement delattr(self, name).",
    "itertools.combinations.__eq__" => "Return self==value.",
    "itertools.combinations.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.combinations.__ge__" => "Return self>=value.",
    "itertools.combinations.__getattribute__" => "Return getattr(self, name).",
    "itertools.combinations.__getstate__" => "Helper for pickle.",
    "itertools.combinations.__gt__" => "Return self>value.",
    "itertools.combinations.__hash__" => "Return hash(self).",
    "itertools.combinations.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.combinations.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.combinations.__iter__" => "Implement iter(self).",
    "itertools.combinations.__le__" => "Return self<=value.",
    "itertools.combinations.__lt__" => "Return self<value.",
    "itertools.combinations.__ne__" => "Return self!=value.",
    "itertools.combinations.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.combinations.__next__" => "Implement next(self).",
    "itertools.combinations.__reduce__" => "Return state information for pickling.",
    "itertools.combinations.__reduce_ex__" => "Helper for pickle.",
    "itertools.combinations.__repr__" => "Return repr(self).",
    "itertools.combinations.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.combinations.__setstate__" => "Set state information for unpickling.",
    "itertools.combinations.__sizeof__" => "Returns size in memory, in bytes.",
    "itertools.combinations.__str__" => "Return str(self).",
    "itertools.combinations.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.combinations_with_replacement" => "Return successive r-length combinations of elements in the iterable allowing individual elements to have successive repeats.\n\ncombinations_with_replacement('ABC', 2) --> ('A','A'), ('A','B'), ('A','C'), ('B','B'), ('B','C'), ('C','C')",
    "itertools.combinations_with_replacement.__delattr__" => "Implement delattr(self, name).",
    "itertools.combinations_with_replacement.__eq__" => "Return self==value.",
    "itertools.combinations_with_replacement.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.combinations_with_replacement.__ge__" => "Return self>=value.",
    "itertools.combinations_with_replacement.__getattribute__" => "Return getattr(self, name).",
    "itertools.combinations_with_replacement.__getstate__" => "Helper for pickle.",
    "itertools.combinations_with_replacement.__gt__" => "Return self>value.",
    "itertools.combinations_with_replacement.__hash__" => "Return hash(self).",
    "itertools.combinations_with_replacement.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.combinations_with_replacement.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.combinations_with_replacement.__iter__" => "Implement iter(self).",
    "itertools.combinations_with_replacement.__le__" => "Return self<=value.",
    "itertools.combinations_with_replacement.__lt__" => "Return self<value.",
    "itertools.combinations_with_replacement.__ne__" => "Return self!=value.",
    "itertools.combinations_with_replacement.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.combinations_with_replacement.__next__" => "Implement next(self).",
    "itertools.combinations_with_replacement.__reduce__" => "Return state information for pickling.",
    "itertools.combinations_with_replacement.__reduce_ex__" => "Helper for pickle.",
    "itertools.combinations_with_replacement.__repr__" => "Return repr(self).",
    "itertools.combinations_with_replacement.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.combinations_with_replacement.__setstate__" => "Set state information for unpickling.",
    "itertools.combinations_with_replacement.__sizeof__" => "Returns size in memory, in bytes.",
    "itertools.combinations_with_replacement.__str__" => "Return str(self).",
    "itertools.combinations_with_replacement.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.compress" => "Return data elements corresponding to true selector elements.\n\nForms a shorter iterator from selected data elements using the selectors to\nchoose the data elements.",
    "itertools.compress.__delattr__" => "Implement delattr(self, name).",
    "itertools.compress.__eq__" => "Return self==value.",
    "itertools.compress.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.compress.__ge__" => "Return self>=value.",
    "itertools.compress.__getattribute__" => "Return getattr(self, name).",
    "itertools.compress.__getstate__" => "Helper for pickle.",
    "itertools.compress.__gt__" => "Return self>value.",
    "itertools.compress.__hash__" => "Return hash(self).",
    "itertools.compress.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.compress.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.compress.__iter__" => "Implement iter(self).",
    "itertools.compress.__le__" => "Return self<=value.",
    "itertools.compress.__lt__" => "Return self<value.",
    "itertools.compress.__ne__" => "Return self!=value.",
    "itertools.compress.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.compress.__next__" => "Implement next(self).",
    "itertools.compress.__reduce__" => "Return state information for pickling.",
    "itertools.compress.__reduce_ex__" => "Helper for pickle.",
    "itertools.compress.__repr__" => "Return repr(self).",
    "itertools.compress.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.compress.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.compress.__str__" => "Return str(self).",
    "itertools.compress.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.count" => "Return a count object whose .__next__() method returns consecutive values.\n\nEquivalent to:\n    def count(firstval=0, step=1):\n        x = firstval\n        while 1:\n            yield x\n            x += step",
    "itertools.count.__delattr__" => "Implement delattr(self, name).",
    "itertools.count.__eq__" => "Return self==value.",
    "itertools.count.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.count.__ge__" => "Return self>=value.",
    "itertools.count.__getattribute__" => "Return getattr(self, name).",
    "itertools.count.__getstate__" => "Helper for pickle.",
    "itertools.count.__gt__" => "Return self>value.",
    "itertools.count.__hash__" => "Return hash(self).",
    "itertools.count.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.count.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.count.__iter__" => "Implement iter(self).",
    "itertools.count.__le__" => "Return self<=value.",
    "itertools.count.__lt__" => "Return self<value.",
    "itertools.count.__ne__" => "Return self!=value.",
    "itertools.count.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.count.__next__" => "Implement next(self).",
    "itertools.count.__reduce__" => "Return state information for pickling.",
    "itertools.count.__reduce_ex__" => "Helper for pickle.",
    "itertools.count.__repr__" => "Return repr(self).",
    "itertools.count.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.count.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.count.__str__" => "Return str(self).",
    "itertools.count.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.cycle" => "Return elements from the iterable until it is exhausted. Then repeat the sequence indefinitely.",
    "itertools.cycle.__delattr__" => "Implement delattr(self, name).",
    "itertools.cycle.__eq__" => "Return self==value.",
    "itertools.cycle.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.cycle.__ge__" => "Return self>=value.",
    "itertools.cycle.__getattribute__" => "Return getattr(self, name).",
    "itertools.cycle.__getstate__" => "Helper for pickle.",
    "itertools.cycle.__gt__" => "Return self>value.",
    "itertools.cycle.__hash__" => "Return hash(self).",
    "itertools.cycle.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.cycle.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.cycle.__iter__" => "Implement iter(self).",
    "itertools.cycle.__le__" => "Return self<=value.",
    "itertools.cycle.__lt__" => "Return self<value.",
    "itertools.cycle.__ne__" => "Return self!=value.",
    "itertools.cycle.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.cycle.__next__" => "Implement next(self).",
    "itertools.cycle.__reduce__" => "Return state information for pickling.",
    "itertools.cycle.__reduce_ex__" => "Helper for pickle.",
    "itertools.cycle.__repr__" => "Return repr(self).",
    "itertools.cycle.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.cycle.__setstate__" => "Set state information for unpickling.",
    "itertools.cycle.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.cycle.__str__" => "Return str(self).",
    "itertools.cycle.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.dropwhile" => "Drop items from the iterable while predicate(item) is true.\n\nAfterwards, return every element until the iterable is exhausted.",
    "itertools.dropwhile.__delattr__" => "Implement delattr(self, name).",
    "itertools.dropwhile.__eq__" => "Return self==value.",
    "itertools.dropwhile.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.dropwhile.__ge__" => "Return self>=value.",
    "itertools.dropwhile.__getattribute__" => "Return getattr(self, name).",
    "itertools.dropwhile.__getstate__" => "Helper for pickle.",
    "itertools.dropwhile.__gt__" => "Return self>value.",
    "itertools.dropwhile.__hash__" => "Return hash(self).",
    "itertools.dropwhile.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.dropwhile.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.dropwhile.__iter__" => "Implement iter(self).",
    "itertools.dropwhile.__le__" => "Return self<=value.",
    "itertools.dropwhile.__lt__" => "Return self<value.",
    "itertools.dropwhile.__ne__" => "Return self!=value.",
    "itertools.dropwhile.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.dropwhile.__next__" => "Implement next(self).",
    "itertools.dropwhile.__reduce__" => "Return state information for pickling.",
    "itertools.dropwhile.__reduce_ex__" => "Helper for pickle.",
    "itertools.dropwhile.__repr__" => "Return repr(self).",
    "itertools.dropwhile.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.dropwhile.__setstate__" => "Set state information for unpickling.",
    "itertools.dropwhile.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.dropwhile.__str__" => "Return str(self).",
    "itertools.dropwhile.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.filterfalse" => "Return those items of iterable for which function(item) is false.\n\nIf function is None, return the items that are false.",
    "itertools.filterfalse.__delattr__" => "Implement delattr(self, name).",
    "itertools.filterfalse.__eq__" => "Return self==value.",
    "itertools.filterfalse.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.filterfalse.__ge__" => "Return self>=value.",
    "itertools.filterfalse.__getattribute__" => "Return getattr(self, name).",
    "itertools.filterfalse.__getstate__" => "Helper for pickle.",
    "itertools.filterfalse.__gt__" => "Return self>value.",
    "itertools.filterfalse.__hash__" => "Return hash(self).",
    "itertools.filterfalse.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.filterfalse.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.filterfalse.__iter__" => "Implement iter(self).",
    "itertools.filterfalse.__le__" => "Return self<=value.",
    "itertools.filterfalse.__lt__" => "Return self<value.",
    "itertools.filterfalse.__ne__" => "Return self!=value.",
    "itertools.filterfalse.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.filterfalse.__next__" => "Implement next(self).",
    "itertools.filterfalse.__reduce__" => "Return state information for pickling.",
    "itertools.filterfalse.__reduce_ex__" => "Helper for pickle.",
    "itertools.filterfalse.__repr__" => "Return repr(self).",
    "itertools.filterfalse.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.filterfalse.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.filterfalse.__str__" => "Return str(self).",
    "itertools.filterfalse.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.groupby" => "make an iterator that returns consecutive keys and groups from the iterable\n\niterable\n  Elements to divide into groups according to the key function.\nkey\n  A function for computing the group category for each element.\n  If the key function is not specified or is None, the element itself\n  is used for grouping.",
    "itertools.groupby.__delattr__" => "Implement delattr(self, name).",
    "itertools.groupby.__eq__" => "Return self==value.",
    "itertools.groupby.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.groupby.__ge__" => "Return self>=value.",
    "itertools.groupby.__getattribute__" => "Return getattr(self, name).",
    "itertools.groupby.__getstate__" => "Helper for pickle.",
    "itertools.groupby.__gt__" => "Return self>value.",
    "itertools.groupby.__hash__" => "Return hash(self).",
    "itertools.groupby.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.groupby.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.groupby.__iter__" => "Implement iter(self).",
    "itertools.groupby.__le__" => "Return self<=value.",
    "itertools.groupby.__lt__" => "Return self<value.",
    "itertools.groupby.__ne__" => "Return self!=value.",
    "itertools.groupby.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.groupby.__next__" => "Implement next(self).",
    "itertools.groupby.__reduce__" => "Return state information for pickling.",
    "itertools.groupby.__reduce_ex__" => "Helper for pickle.",
    "itertools.groupby.__repr__" => "Return repr(self).",
    "itertools.groupby.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.groupby.__setstate__" => "Set state information for unpickling.",
    "itertools.groupby.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.groupby.__str__" => "Return str(self).",
    "itertools.groupby.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.islice" => "islice(iterable, stop) --> islice object\nislice(iterable, start, stop[, step]) --> islice object\n\nReturn an iterator whose next() method returns selected values from an\niterable.  If start is specified, will skip all preceding elements;\notherwise, start defaults to zero.  Step defaults to one.  If\nspecified as another value, step determines how many values are\nskipped between successive calls.  Works like a slice() on a list\nbut returns an iterator.",
    "itertools.islice.__delattr__" => "Implement delattr(self, name).",
    "itertools.islice.__eq__" => "Return self==value.",
    "itertools.islice.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.islice.__ge__" => "Return self>=value.",
    "itertools.islice.__getattribute__" => "Return getattr(self, name).",
    "itertools.islice.__getstate__" => "Helper for pickle.",
    "itertools.islice.__gt__" => "Return self>value.",
    "itertools.islice.__hash__" => "Return hash(self).",
    "itertools.islice.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.islice.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.islice.__iter__" => "Implement iter(self).",
    "itertools.islice.__le__" => "Return self<=value.",
    "itertools.islice.__lt__" => "Return self<value.",
    "itertools.islice.__ne__" => "Return self!=value.",
    "itertools.islice.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.islice.__next__" => "Implement next(self).",
    "itertools.islice.__reduce__" => "Return state information for pickling.",
    "itertools.islice.__reduce_ex__" => "Helper for pickle.",
    "itertools.islice.__repr__" => "Return repr(self).",
    "itertools.islice.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.islice.__setstate__" => "Set state information for unpickling.",
    "itertools.islice.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.islice.__str__" => "Return str(self).",
    "itertools.islice.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.pairwise" => "Return an iterator of overlapping pairs taken from the input iterator.\n\ns -> (s0,s1), (s1,s2), (s2, s3), ...",
    "itertools.pairwise.__delattr__" => "Implement delattr(self, name).",
    "itertools.pairwise.__eq__" => "Return self==value.",
    "itertools.pairwise.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.pairwise.__ge__" => "Return self>=value.",
    "itertools.pairwise.__getattribute__" => "Return getattr(self, name).",
    "itertools.pairwise.__getstate__" => "Helper for pickle.",
    "itertools.pairwise.__gt__" => "Return self>value.",
    "itertools.pairwise.__hash__" => "Return hash(self).",
    "itertools.pairwise.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.pairwise.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.pairwise.__iter__" => "Implement iter(self).",
    "itertools.pairwise.__le__" => "Return self<=value.",
    "itertools.pairwise.__lt__" => "Return self<value.",
    "itertools.pairwise.__ne__" => "Return self!=value.",
    "itertools.pairwise.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.pairwise.__next__" => "Implement next(self).",
    "itertools.pairwise.__reduce__" => "Helper for pickle.",
    "itertools.pairwise.__reduce_ex__" => "Helper for pickle.",
    "itertools.pairwise.__repr__" => "Return repr(self).",
    "itertools.pairwise.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.pairwise.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.pairwise.__str__" => "Return str(self).",
    "itertools.pairwise.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.permutations" => "Return successive r-length permutations of elements in the iterable.\n\npermutations(range(3), 2) --> (0,1), (0,2), (1,0), (1,2), (2,0), (2,1)",
    "itertools.permutations.__delattr__" => "Implement delattr(self, name).",
    "itertools.permutations.__eq__" => "Return self==value.",
    "itertools.permutations.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.permutations.__ge__" => "Return self>=value.",
    "itertools.permutations.__getattribute__" => "Return getattr(self, name).",
    "itertools.permutations.__getstate__" => "Helper for pickle.",
    "itertools.permutations.__gt__" => "Return self>value.",
    "itertools.permutations.__hash__" => "Return hash(self).",
    "itertools.permutations.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.permutations.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.permutations.__iter__" => "Implement iter(self).",
    "itertools.permutations.__le__" => "Return self<=value.",
    "itertools.permutations.__lt__" => "Return self<value.",
    "itertools.permutations.__ne__" => "Return self!=value.",
    "itertools.permutations.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.permutations.__next__" => "Implement next(self).",
    "itertools.permutations.__reduce__" => "Return state information for pickling.",
    "itertools.permutations.__reduce_ex__" => "Helper for pickle.",
    "itertools.permutations.__repr__" => "Return repr(self).",
    "itertools.permutations.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.permutations.__setstate__" => "Set state information for unpickling.",
    "itertools.permutations.__sizeof__" => "Returns size in memory, in bytes.",
    "itertools.permutations.__str__" => "Return str(self).",
    "itertools.permutations.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.product" => "Cartesian product of input iterables.  Equivalent to nested for-loops.\n\nFor example, product(A, B) returns the same as:  ((x,y) for x in A for y in B).\nThe leftmost iterators are in the outermost for-loop, so the output tuples\ncycle in a manner similar to an odometer (with the rightmost element changing\non every iteration).\n\nTo compute the product of an iterable with itself, specify the number\nof repetitions with the optional repeat keyword argument. For example,\nproduct(A, repeat=4) means the same as product(A, A, A, A).\n\nproduct('ab', range(3)) --> ('a',0) ('a',1) ('a',2) ('b',0) ('b',1) ('b',2)\nproduct((0,1), (0,1), (0,1)) --> (0,0,0) (0,0,1) (0,1,0) (0,1,1) (1,0,0) ...",
    "itertools.product.__delattr__" => "Implement delattr(self, name).",
    "itertools.product.__eq__" => "Return self==value.",
    "itertools.product.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.product.__ge__" => "Return self>=value.",
    "itertools.product.__getattribute__" => "Return getattr(self, name).",
    "itertools.product.__getstate__" => "Helper for pickle.",
    "itertools.product.__gt__" => "Return self>value.",
    "itertools.product.__hash__" => "Return hash(self).",
    "itertools.product.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.product.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.product.__iter__" => "Implement iter(self).",
    "itertools.product.__le__" => "Return self<=value.",
    "itertools.product.__lt__" => "Return self<value.",
    "itertools.product.__ne__" => "Return self!=value.",
    "itertools.product.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.product.__next__" => "Implement next(self).",
    "itertools.product.__reduce__" => "Return state information for pickling.",
    "itertools.product.__reduce_ex__" => "Helper for pickle.",
    "itertools.product.__repr__" => "Return repr(self).",
    "itertools.product.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.product.__setstate__" => "Set state information for unpickling.",
    "itertools.product.__sizeof__" => "Returns size in memory, in bytes.",
    "itertools.product.__str__" => "Return str(self).",
    "itertools.product.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.repeat" => "repeat(object [,times]) -> create an iterator which returns the object\nfor the specified number of times.  If not specified, returns the object\nendlessly.",
    "itertools.repeat.__delattr__" => "Implement delattr(self, name).",
    "itertools.repeat.__eq__" => "Return self==value.",
    "itertools.repeat.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.repeat.__ge__" => "Return self>=value.",
    "itertools.repeat.__getattribute__" => "Return getattr(self, name).",
    "itertools.repeat.__getstate__" => "Helper for pickle.",
    "itertools.repeat.__gt__" => "Return self>value.",
    "itertools.repeat.__hash__" => "Return hash(self).",
    "itertools.repeat.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.repeat.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.repeat.__iter__" => "Implement iter(self).",
    "itertools.repeat.__le__" => "Return self<=value.",
    "itertools.repeat.__length_hint__" => "Private method returning an estimate of len(list(it)).",
    "itertools.repeat.__lt__" => "Return self<value.",
    "itertools.repeat.__ne__" => "Return self!=value.",
    "itertools.repeat.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.repeat.__next__" => "Implement next(self).",
    "itertools.repeat.__reduce__" => "Return state information for pickling.",
    "itertools.repeat.__reduce_ex__" => "Helper for pickle.",
    "itertools.repeat.__repr__" => "Return repr(self).",
    "itertools.repeat.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.repeat.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.repeat.__str__" => "Return str(self).",
    "itertools.repeat.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.starmap" => "Return an iterator whose values are returned from the function evaluated with an argument tuple taken from the given sequence.",
    "itertools.starmap.__delattr__" => "Implement delattr(self, name).",
    "itertools.starmap.__eq__" => "Return self==value.",
    "itertools.starmap.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.starmap.__ge__" => "Return self>=value.",
    "itertools.starmap.__getattribute__" => "Return getattr(self, name).",
    "itertools.starmap.__getstate__" => "Helper for pickle.",
    "itertools.starmap.__gt__" => "Return self>value.",
    "itertools.starmap.__hash__" => "Return hash(self).",
    "itertools.starmap.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.starmap.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.starmap.__iter__" => "Implement iter(self).",
    "itertools.starmap.__le__" => "Return self<=value.",
    "itertools.starmap.__lt__" => "Return self<value.",
    "itertools.starmap.__ne__" => "Return self!=value.",
    "itertools.starmap.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.starmap.__next__" => "Implement next(self).",
    "itertools.starmap.__reduce__" => "Return state information for pickling.",
    "itertools.starmap.__reduce_ex__" => "Helper for pickle.",
    "itertools.starmap.__repr__" => "Return repr(self).",
    "itertools.starmap.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.starmap.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.starmap.__str__" => "Return str(self).",
    "itertools.starmap.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.takewhile" => "Return successive entries from an iterable as long as the predicate evaluates to true for each entry.",
    "itertools.takewhile.__delattr__" => "Implement delattr(self, name).",
    "itertools.takewhile.__eq__" => "Return self==value.",
    "itertools.takewhile.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.takewhile.__ge__" => "Return self>=value.",
    "itertools.takewhile.__getattribute__" => "Return getattr(self, name).",
    "itertools.takewhile.__getstate__" => "Helper for pickle.",
    "itertools.takewhile.__gt__" => "Return self>value.",
    "itertools.takewhile.__hash__" => "Return hash(self).",
    "itertools.takewhile.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.takewhile.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.takewhile.__iter__" => "Implement iter(self).",
    "itertools.takewhile.__le__" => "Return self<=value.",
    "itertools.takewhile.__lt__" => "Return self<value.",
    "itertools.takewhile.__ne__" => "Return self!=value.",
    "itertools.takewhile.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.takewhile.__next__" => "Implement next(self).",
    "itertools.takewhile.__reduce__" => "Return state information for pickling.",
    "itertools.takewhile.__reduce_ex__" => "Helper for pickle.",
    "itertools.takewhile.__repr__" => "Return repr(self).",
    "itertools.takewhile.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.takewhile.__setstate__" => "Set state information for unpickling.",
    "itertools.takewhile.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.takewhile.__str__" => "Return str(self).",
    "itertools.takewhile.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "itertools.tee" => "Returns a tuple of n independent iterators.",
    "itertools.zip_longest" => "Return a zip_longest object whose .__next__() method returns a tuple where\nthe i-th element comes from the i-th iterable argument.  The .__next__()\nmethod continues until the longest iterable in the argument sequence\nis exhausted and then it raises StopIteration.  When the shorter iterables\nare exhausted, the fillvalue is substituted in their place.  The fillvalue\ndefaults to None or can be specified by a keyword argument.",
    "itertools.zip_longest.__delattr__" => "Implement delattr(self, name).",
    "itertools.zip_longest.__eq__" => "Return self==value.",
    "itertools.zip_longest.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "itertools.zip_longest.__ge__" => "Return self>=value.",
    "itertools.zip_longest.__getattribute__" => "Return getattr(self, name).",
    "itertools.zip_longest.__getstate__" => "Helper for pickle.",
    "itertools.zip_longest.__gt__" => "Return self>value.",
    "itertools.zip_longest.__hash__" => "Return hash(self).",
    "itertools.zip_longest.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "itertools.zip_longest.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "itertools.zip_longest.__iter__" => "Implement iter(self).",
    "itertools.zip_longest.__le__" => "Return self<=value.",
    "itertools.zip_longest.__lt__" => "Return self<value.",
    "itertools.zip_longest.__ne__" => "Return self!=value.",
    "itertools.zip_longest.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "itertools.zip_longest.__next__" => "Implement next(self).",
    "itertools.zip_longest.__reduce__" => "Return state information for pickling.",
    "itertools.zip_longest.__reduce_ex__" => "Helper for pickle.",
    "itertools.zip_longest.__repr__" => "Return repr(self).",
    "itertools.zip_longest.__setattr__" => "Implement setattr(self, name, value).",
    "itertools.zip_longest.__setstate__" => "Set state information for unpickling.",
    "itertools.zip_longest.__sizeof__" => "Size of object in memory, in bytes.",
    "itertools.zip_longest.__str__" => "Return str(self).",
    "itertools.zip_longest.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "marshal" => "This module contains functions that can read and write Python values in\na binary format. The format is specific to Python, but independent of\nmachine architecture issues.\n\nNot all Python object types are supported; in general, only objects\nwhose value is independent from a particular invocation of Python can be\nwritten and read by this module. The following types are supported:\nNone, integers, floating-point numbers, strings, bytes, bytearrays,\ntuples, lists, sets, dictionaries, and code objects, where it\nshould be understood that tuples, lists and dictionaries are only\nsupported as long as the values contained therein are themselves\nsupported; and recursive lists and dictionaries should not be written\n(they will cause infinite loops).\n\nVariables:\n\nversion -- indicates the format that the module uses. Version 0 is the\n    historical format, version 1 shares interned strings and version 2\n    uses a binary format for floating-point numbers.\n    Version 3 shares common object references (New in version 3.4).\n\nFunctions:\n\ndump() -- write value to a file\nload() -- read value from a file\ndumps() -- marshal value as a bytes object\nloads() -- read value from a bytes-like object",
    "marshal.dump" => "Write the value on the open file.\n\n  value\n    Must be a supported type.\n  file\n    Must be a writeable binary file.\n  version\n    Indicates the data format that dump should use.\n  allow_code\n    Allow to write code objects.\n\nIf the value has (or contains an object that has) an unsupported type, a\nValueError exception is raised - but garbage data will also be written\nto the file. The object will not be properly read back by load().",
    "marshal.dumps" => "Return the bytes object that would be written to a file by dump(value, file).\n\n  value\n    Must be a supported type.\n  version\n    Indicates the data format that dumps should use.\n  allow_code\n    Allow to write code objects.\n\nRaise a ValueError exception if value has (or contains an object that has) an\nunsupported type.",
    "marshal.load" => "Read one value from the open file and return it.\n\n  file\n    Must be readable binary file.\n  allow_code\n    Allow to load code objects.\n\nIf no valid value is read (e.g. because the data has a different Python\nversion's incompatible marshal format), raise EOFError, ValueError or\nTypeError.\n\nNote: If an object containing an unsupported type was marshalled with\ndump(), load() will substitute None for the unmarshallable type.",
    "marshal.loads" => "Convert the bytes-like object to a value.\n\n  allow_code\n    Allow to load code objects.\n\nIf no valid value is found, raise EOFError, ValueError or TypeError.  Extra\nbytes in the input are ignored.",
    "math" => "This module provides access to the mathematical functions\ndefined by the C standard.",
    "math.acos" => "Return the arc cosine (measured in radians) of x.\n\nThe result is between 0 and pi.",
    "math.acosh" => "Return the inverse hyperbolic cosine of x.",
    "math.asin" => "Return the arc sine (measured in radians) of x.\n\nThe result is between -pi/2 and pi/2.",
    "math.asinh" => "Return the inverse hyperbolic sine of x.",
    "math.atan" => "Return the arc tangent (measured in radians) of x.\n\nThe result is between -pi/2 and pi/2.",
    "math.atan2" => "Return the arc tangent (measured in radians) of y/x.\n\nUnlike atan(y/x), the signs of both x and y are considered.",
    "math.atanh" => "Return the inverse hyperbolic tangent of x.",
    "math.cbrt" => "Return the cube root of x.",
    "math.ceil" => "Return the ceiling of x as an Integral.\n\nThis is the smallest integer >= x.",
    "math.comb" => "Number of ways to choose k items from n items without repetition and without order.\n\nEvaluates to n! / (k! * (n - k)!) when k <= n and evaluates\nto zero when k > n.\n\nAlso called the binomial coefficient because it is equivalent\nto the coefficient of k-th term in polynomial expansion of the\nexpression (1 + x)**n.\n\nRaises TypeError if either of the arguments are not integers.\nRaises ValueError if either of the arguments are negative.",
    "math.copysign" => "Return a float with the magnitude (absolute value) of x but the sign of y.\n\nOn platforms that support signed zeros, copysign(1.0, -0.0)\nreturns -1.0.",
    "math.cos" => "Return the cosine of x (measured in radians).",
    "math.cosh" => "Return the hyperbolic cosine of x.",
    "math.degrees" => "Convert angle x from radians to degrees.",
    "math.dist" => "Return the Euclidean distance between two points p and q.\n\nThe points should be specified as sequences (or iterables) of\ncoordinates.  Both inputs must have the same dimension.\n\nRoughly equivalent to:\n    sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q)))",
    "math.erf" => "Error function at x.",
    "math.erfc" => "Complementary error function at x.",
    "math.exp" => "Return e raised to the power of x.",
    "math.exp2" => "Return 2 raised to the power of x.",
    "math.expm1" => "Return exp(x)-1.\n\nThis function avoids the loss of precision involved in the direct evaluation of exp(x)-1 for small x.",
    "math.fabs" => "Return the absolute value of the float x.",
    "math.factorial" => "Find n!.",
    "math.floor" => "Return the floor of x as an Integral.\n\nThis is the largest integer <= x.",
    "math.fma" => "Fused multiply-add operation.\n\nCompute (x * y) + z with a single round.",
    "math.fmod" => "Return fmod(x, y), according to platform C.\n\nx % y may differ.",
    "math.frexp" => "Return the mantissa and exponent of x, as pair (m, e).\n\nm is a float and e is an int, such that x = m * 2.**e.\nIf x is 0, m and e are both 0.  Else 0.5 <= abs(m) < 1.0.",
    "math.fsum" => "Return an accurate floating-point sum of values in the iterable seq.\n\nAssumes IEEE-754 floating-point arithmetic.",
    "math.gamma" => "Gamma function at x.",
    "math.gcd" => "Greatest Common Divisor.",
    "math.hypot" => "hypot(*coordinates) -> value\n\nMultidimensional Euclidean distance from the origin to a point.\n\nRoughly equivalent to:\n    sqrt(sum(x**2 for x in coordinates))\n\nFor a two dimensional point (x, y), gives the hypotenuse\nusing the Pythagorean theorem:  sqrt(x*x + y*y).\n\nFor example, the hypotenuse of a 3/4/5 right triangle is:\n\n    >>> hypot(3.0, 4.0)\n    5.0",
    "math.isclose" => "Determine whether two floating-point numbers are close in value.\n\n  rel_tol\n    maximum difference for being considered \"close\", relative to the\n    magnitude of the input values\n  abs_tol\n    maximum difference for being considered \"close\", regardless of the\n    magnitude of the input values\n\nReturn True if a is close in value to b, and False otherwise.\n\nFor the values to be considered close, the difference between them\nmust be smaller than at least one of the tolerances.\n\n-inf, inf and NaN behave similarly to the IEEE 754 Standard.  That\nis, NaN is not close to anything, even itself.  inf and -inf are\nonly close to themselves.",
    "math.isfinite" => "Return True if x is neither an infinity nor a NaN, and False otherwise.",
    "math.isinf" => "Return True if x is a positive or negative infinity, and False otherwise.",
    "math.isnan" => "Return True if x is a NaN (not a number), and False otherwise.",
    "math.isqrt" => "Return the integer part of the square root of the input.",
    "math.lcm" => "Least Common Multiple.",
    "math.ldexp" => "Return x * (2**i).\n\nThis is essentially the inverse of frexp().",
    "math.lgamma" => "Natural logarithm of absolute value of Gamma function at x.",
    "math.log" => "log(x, [base=math.e])\nReturn the logarithm of x to the given base.\n\nIf the base is not specified, returns the natural logarithm (base e) of x.",
    "math.log10" => "Return the base 10 logarithm of x.",
    "math.log1p" => "Return the natural logarithm of 1+x (base e).\n\nThe result is computed in a way which is accurate for x near zero.",
    "math.log2" => "Return the base 2 logarithm of x.",
    "math.modf" => "Return the fractional and integer parts of x.\n\nBoth results carry the sign of x and are floats.",
    "math.nextafter" => "Return the floating-point value the given number of steps after x towards y.\n\nIf steps is not specified or is None, it defaults to 1.\n\nRaises a TypeError, if x or y is not a double, or if steps is not an integer.\nRaises ValueError if steps is negative.",
    "math.perm" => "Number of ways to choose k items from n items without repetition and with order.\n\nEvaluates to n! / (n - k)! when k <= n and evaluates\nto zero when k > n.\n\nIf k is not specified or is None, then k defaults to n\nand the function returns n!.\n\nRaises TypeError if either of the arguments are not integers.\nRaises ValueError if either of the arguments are negative.",
    "math.pow" => "Return x**y (x to the power of y).",
    "math.prod" => "Calculate the product of all the elements in the input iterable.\n\nThe default start value for the product is 1.\n\nWhen the iterable is empty, return the start value.  This function is\nintended specifically for use with numeric values and may reject\nnon-numeric types.",
    "math.radians" => "Convert angle x from degrees to radians.",
    "math.remainder" => "Difference between x and the closest integer multiple of y.\n\nReturn x - n*y where n*y is the closest integer multiple of y.\nIn the case where x is exactly halfway between two multiples of\ny, the nearest even value of n is used. The result is always exact.",
    "math.sin" => "Return the sine of x (measured in radians).",
    "math.sinh" => "Return the hyperbolic sine of x.",
    "math.sqrt" => "Return the square root of x.",
    "math.sumprod" => "Return the sum of products of values from two iterables p and q.\n\nRoughly equivalent to:\n\n    sum(itertools.starmap(operator.mul, zip(p, q, strict=True)))\n\nFor float and mixed int/float inputs, the intermediate products\nand sums are computed with extended precision.",
    "math.tan" => "Return the tangent of x (measured in radians).",
    "math.tanh" => "Return the hyperbolic tangent of x.",
    "math.trunc" => "Truncates the Real x to the nearest Integral toward 0.\n\nUses the __trunc__ magic method.",
    "math.ulp" => "Return the value of the least significant bit of the float x.",
    "mmap.mmap" => "Windows: mmap(fileno, length[, tagname[, access[, offset]]])\n\nMaps length bytes from the file specified by the file handle fileno,\nand returns a mmap object.  If length is larger than the current size\nof the file, the file is extended to contain length bytes.  If length\nis 0, the maximum length of the map is the current size of the file,\nexcept that if the file is empty Windows raises an exception (you cannot\ncreate an empty mapping on Windows).\n\nUnix: mmap(fileno, length[, flags[, prot[, access[, offset[, trackfd]]]]])\n\nMaps length bytes from the file specified by the file descriptor fileno,\nand returns a mmap object.  If length is 0, the maximum length of the map\nwill be the current size of the file when mmap is called.\nflags specifies the nature of the mapping. MAP_PRIVATE creates a\nprivate copy-on-write mapping, so changes to the contents of the mmap\nobject will be private to this process, and MAP_SHARED creates a mapping\nthat's shared with all other processes mapping the same areas of the file.\nThe default value is MAP_SHARED.\n\nTo map anonymous memory, pass -1 as the fileno (both versions).",
    "mmap.mmap.__buffer__" => "Return a buffer object that exposes the underlying memory of the object.",
    "mmap.mmap.__delattr__" => "Implement delattr(self, name).",
    "mmap.mmap.__delitem__" => "Delete self[key].",
    "mmap.mmap.__eq__" => "Return self==value.",
    "mmap.mmap.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "mmap.mmap.__ge__" => "Return self>=value.",
    "mmap.mmap.__getattribute__" => "Return getattr(self, name).",
    "mmap.mmap.__getitem__" => "Return self[key].",
    "mmap.mmap.__getstate__" => "Helper for pickle.",
    "mmap.mmap.__gt__" => "Return self>value.",
    "mmap.mmap.__hash__" => "Return hash(self).",
    "mmap.mmap.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "mmap.mmap.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "mmap.mmap.__le__" => "Return self<=value.",
    "mmap.mmap.__len__" => "Return len(self).",
    "mmap.mmap.__lt__" => "Return self<value.",
    "mmap.mmap.__ne__" => "Return self!=value.",
    "mmap.mmap.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "mmap.mmap.__reduce__" => "Helper for pickle.",
    "mmap.mmap.__reduce_ex__" => "Helper for pickle.",
    "mmap.mmap.__release_buffer__" => "Release the buffer object that exposes the underlying memory of the object.",
    "mmap.mmap.__repr__" => "Return repr(self).",
    "mmap.mmap.__setattr__" => "Implement setattr(self, name, value).",
    "mmap.mmap.__setitem__" => "Set self[key] to value.",
    "mmap.mmap.__str__" => "Return str(self).",
    "mmap.mmap.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "msvcrt.GetErrorMode" => "Wrapper around GetErrorMode.",
    "msvcrt.SetErrorMode" => "Wrapper around SetErrorMode.",
    "msvcrt.get_osfhandle" => "Return the file handle for the file descriptor fd.\n\nRaises OSError if fd is not recognized.",
    "msvcrt.getch" => "Read a keypress and return the resulting character as a byte string.\n\nNothing is echoed to the console. This call will block if a keypress is\nnot already available, but will not wait for Enter to be pressed. If the\npressed key was a special function key, this will return '\\000' or\n'\\xe0'; the next call will return the keycode. The Control-C keypress\ncannot be read with this function.",
    "msvcrt.getche" => "Similar to getch(), but the keypress will be echoed if possible.",
    "msvcrt.getwch" => "Wide char variant of getch(), returning a Unicode value.",
    "msvcrt.getwche" => "Wide char variant of getche(), returning a Unicode value.",
    "msvcrt.heapmin" => "Minimize the malloc() heap.\n\nForce the malloc() heap to clean itself up and return unused blocks\nto the operating system. On failure, this raises OSError.",
    "msvcrt.kbhit" => "Returns a nonzero value if a keypress is waiting to be read. Otherwise, return 0.",
    "msvcrt.locking" => "Lock part of a file based on file descriptor fd from the C runtime.\n\nRaises OSError on failure. The locked region of the file extends from\nthe current file position for nbytes bytes, and may continue beyond\nthe end of the file. mode must be one of the LK_* constants listed\nbelow. Multiple regions in a file may be locked at the same time, but\nmay not overlap. Adjacent regions are not merged; they must be unlocked\nindividually.",
    "msvcrt.open_osfhandle" => "Create a C runtime file descriptor from the file handle handle.\n\nThe flags parameter should be a bitwise OR of os.O_APPEND, os.O_RDONLY,\nand os.O_TEXT. The returned file descriptor may be used as a parameter\nto os.fdopen() to create a file object.",
    "msvcrt.putch" => "Print the byte string char to the console without buffering.",
    "msvcrt.putwch" => "Wide char variant of putch(), accepting a Unicode value.",
    "msvcrt.setmode" => "Set the line-end translation mode for the file descriptor fd.\n\nTo set it to text mode, flags should be os.O_TEXT; for binary, it\nshould be os.O_BINARY.\n\nReturn value is the previous mode.",
    "msvcrt.ungetch" => "Opposite of getch.\n\nCause the byte string char to be \"pushed back\" into the\nconsole buffer; it will be the next character read by\ngetch() or getche().",
    "msvcrt.ungetwch" => "Wide char variant of ungetch(), accepting a Unicode value.",
    "nt" => "This module provides access to operating system functionality that is\nstandardized by the C Standard and the POSIX standard (a thinly\ndisguised Unix interface).  Refer to the library manual and\ncorresponding Unix manual entries for more information on calls.",
    "nt.DirEntry.__class_getitem__" => "See PEP 585",
    "nt.DirEntry.__delattr__" => "Implement delattr(self, name).",
    "nt.DirEntry.__eq__" => "Return self==value.",
    "nt.DirEntry.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "nt.DirEntry.__fspath__" => "Returns the path for the entry.",
    "nt.DirEntry.__ge__" => "Return self>=value.",
    "nt.DirEntry.__getattribute__" => "Return getattr(self, name).",
    "nt.DirEntry.__getstate__" => "Helper for pickle.",
    "nt.DirEntry.__gt__" => "Return self>value.",
    "nt.DirEntry.__hash__" => "Return hash(self).",
    "nt.DirEntry.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "nt.DirEntry.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "nt.DirEntry.__le__" => "Return self<=value.",
    "nt.DirEntry.__lt__" => "Return self<value.",
    "nt.DirEntry.__ne__" => "Return self!=value.",
    "nt.DirEntry.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "nt.DirEntry.__reduce__" => "Helper for pickle.",
    "nt.DirEntry.__reduce_ex__" => "Helper for pickle.",
    "nt.DirEntry.__repr__" => "Return repr(self).",
    "nt.DirEntry.__setattr__" => "Implement setattr(self, name, value).",
    "nt.DirEntry.__sizeof__" => "Size of object in memory, in bytes.",
    "nt.DirEntry.__str__" => "Return str(self).",
    "nt.DirEntry.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "nt.DirEntry.inode" => "Return inode of the entry; cached per entry.",
    "nt.DirEntry.is_dir" => "Return True if the entry is a directory; cached per entry.",
    "nt.DirEntry.is_file" => "Return True if the entry is a file; cached per entry.",
    "nt.DirEntry.is_junction" => "Return True if the entry is a junction; cached per entry.",
    "nt.DirEntry.is_symlink" => "Return True if the entry is a symbolic link; cached per entry.",
    "nt.DirEntry.name" => "the entry's base filename, relative to scandir() \"path\" argument",
    "nt.DirEntry.path" => "the entry's full path name; equivalent to os.path.join(scandir_path, entry.name)",
    "nt.DirEntry.stat" => "Return stat_result object for the entry; cached per entry.",
    "nt._add_dll_directory" => "Add a path to the DLL search path.\n\nThis search path is used when resolving dependencies for imported\nextension modules (the module itself is resolved through sys.path),\nand also by ctypes.\n\nReturns an opaque value that may be passed to os.remove_dll_directory\nto remove this directory from the search path.",
    "nt._exit" => "Exit to the system with specified status, without normal exit processing.",
    "nt._findfirstfile" => "A function to get the real file name without accessing the file in Windows.",
    "nt._getdiskusage" => "Return disk usage statistics about the given path as a (total, free) tuple.",
    "nt._getfinalpathname" => "A helper function for samepath on windows.",
    "nt._getvolumepathname" => "A helper function for ismount on Win32.",
    "nt._inputhook" => "Calls PyOS_CallInputHook droppong the GIL first",
    "nt._is_inputhook_installed" => "Checks if PyOS_CallInputHook is set",
    "nt._path_exists" => "Test whether a path exists.  Returns False for broken symbolic links.",
    "nt._path_isdevdrive" => "Determines whether the specified path is on a Windows Dev Drive.",
    "nt._path_isdir" => "Return true if the pathname refers to an existing directory.",
    "nt._path_isfile" => "Test whether a path is a regular file",
    "nt._path_isjunction" => "Test whether a path is a junction",
    "nt._path_islink" => "Test whether a path is a symbolic link",
    "nt._path_lexists" => "Test whether a path exists.  Returns True for broken symbolic links.",
    "nt._path_normpath" => "Normalize path, eliminating double slashes, etc.",
    "nt._path_splitroot" => "Removes everything after the root on Win32.",
    "nt._path_splitroot_ex" => "Split a pathname into drive, root and tail.\n\nThe tail contains anything after the root.",
    "nt._remove_dll_directory" => "Removes a path from the DLL search path.\n\nThe parameter is an opaque value that was returned from\nos.add_dll_directory. You can only remove directories that you added\nyourself.",
    "nt._supports_virtual_terminal" => "Checks if virtual terminal is supported in windows",
    "nt.abort" => "Abort the interpreter immediately.\n\nThis function 'dumps core' or otherwise fails in the hardest way possible\non the hosting operating system.  This function never returns.",
    "nt.access" => "Use the real uid/gid to test for access to a path.\n\n  path\n    Path to be tested; can be string, bytes, or a path-like object.\n  mode\n    Operating-system mode bitfield.  Can be F_OK to test existence,\n    or the inclusive-OR of R_OK, W_OK, and X_OK.\n  dir_fd\n    If not None, it should be a file descriptor open to a directory,\n    and path should be relative; path will then be relative to that\n    directory.\n  effective_ids\n    If True, access will use the effective uid/gid instead of\n    the real uid/gid.\n  follow_symlinks\n    If False, and the last element of the path is a symbolic link,\n    access will examine the symbolic link itself instead of the file\n    the link points to.\n\ndir_fd, effective_ids, and follow_symlinks may not be implemented\n  on your platform.  If they are unavailable, using them will raise a\n  NotImplementedError.\n\nNote that most operations will use the effective uid/gid, therefore this\n  routine can be used in a suid/sgid environment to test if the invoking user\n  has the specified access to the path.",
    "nt.chdir" => "Change the current working directory to the specified path.\n\npath may always be specified as a string.\nOn some platforms, path may also be specified as an open file descriptor.\nIf this functionality is unavailable, using it raises an exception.",
    "nt.chmod" => "Change the access permissions of a file.\n\n  path\n    Path to be modified.  May always be specified as a str, bytes, or a path-like object.\n    On some platforms, path may also be specified as an open file descriptor.\n    If this functionality is unavailable, using it raises an exception.\n  mode\n    Operating-system mode bitfield.\n    Be careful when using number literals for *mode*. The conventional UNIX notation for\n    numeric modes uses an octal base, which needs to be indicated with a ``0o`` prefix in\n    Python.\n  dir_fd\n    If not None, it should be a file descriptor open to a directory,\n    and path should be relative; path will then be relative to that\n    directory.\n  follow_symlinks\n    If False, and the last element of the path is a symbolic link,\n    chmod will modify the symbolic link itself instead of the file\n    the link points to.\n\nIt is an error to use dir_fd or follow_symlinks when specifying path as\n  an open file descriptor.\ndir_fd and follow_symlinks may not be implemented on your platform.\n  If they are unavailable, using them will raise a NotImplementedError.",
    "nt.close" => "Close a file descriptor.",
    "nt.closerange" => "Closes all file descriptors in [fd_low, fd_high), ignoring errors.",
    "nt.cpu_count" => "Return the number of logical CPUs in the system.\n\nReturn None if indeterminable.",
    "nt.device_encoding" => "Return a string describing the encoding of a terminal's file descriptor.\n\nThe file descriptor must be attached to a terminal.\nIf the device is not a terminal, return None.",
    "nt.dup" => "Return a duplicate of a file descriptor.",
    "nt.dup2" => "Duplicate file descriptor.",
    "nt.execv" => "Execute an executable path with arguments, replacing current process.\n\npath\n  Path of executable file.\nargv\n  Tuple or list of strings.",
    "nt.execve" => "Execute an executable path with arguments, replacing current process.\n\npath\n  Path of executable file.\nargv\n  Tuple or list of strings.\nenv\n  Dictionary of strings mapping to strings.",
    "nt.fchmod" => "Change the access permissions of the file given by file descriptor fd.\n\n  fd\n    The file descriptor of the file to be modified.\n  mode\n    Operating-system mode bitfield.\n    Be careful when using number literals for *mode*. The conventional UNIX notation for\n    numeric modes uses an octal base, which needs to be indicated with a ``0o`` prefix in\n    Python.\n\nEquivalent to os.chmod(fd, mode).",
    "nt.fspath" => "Return the file system path representation of the object.\n\nIf the object is str or bytes, then allow it to pass through as-is. If the\nobject defines __fspath__(), then return the result of that method. All other\ntypes raise a TypeError.",
    "nt.fstat" => "Perform a stat system call on the given file descriptor.\n\nLike stat(), but for an open file descriptor.\nEquivalent to os.stat(fd).",
    "nt.fsync" => "Force write of fd to disk.",
    "nt.ftruncate" => "Truncate a file, specified by file descriptor, to a specific length.",
    "nt.get_blocking" => "Get the blocking mode of the file descriptor.\n\nReturn False if the O_NONBLOCK flag is set, True if the flag is cleared.",
    "nt.get_handle_inheritable" => "Get the close-on-exe flag of the specified file descriptor.",
    "nt.get_inheritable" => "Get the close-on-exe flag of the specified file descriptor.",
    "nt.get_terminal_size" => "Return the size of the terminal window as (columns, lines).\n\nThe optional argument fd (default standard output) specifies\nwhich file descriptor should be queried.\n\nIf the file descriptor is not connected to a terminal, an OSError\nis thrown.\n\nThis function will only be defined if an implementation is\navailable for this system.\n\nshutil.get_terminal_size is the high-level function which should\nnormally be used, os.get_terminal_size is the low-level implementation.",
    "nt.getcwd" => "Return a unicode string representing the current working directory.",
    "nt.getcwdb" => "Return a bytes string representing the current working directory.",
    "nt.getlogin" => "Return the actual login name.",
    "nt.getpid" => "Return the current process id.",
    "nt.getppid" => "Return the parent's process id.\n\nIf the parent process has already exited, Windows machines will still\nreturn its id; others systems will return the id of the 'init' process (1).",
    "nt.isatty" => "Return True if the fd is connected to a terminal.\n\nReturn True if the file descriptor is an open file descriptor\nconnected to the slave end of a terminal.",
    "nt.kill" => "Kill a process with a signal.",
    "nt.lchmod" => "Change the access permissions of a file, without following symbolic links.\n\nIf path is a symlink, this affects the link itself rather than the target.\nEquivalent to chmod(path, mode, follow_symlinks=False).\"",
    "nt.link" => "Create a hard link to a file.\n\nIf either src_dir_fd or dst_dir_fd is not None, it should be a file\n  descriptor open to a directory, and the respective path string (src or dst)\n  should be relative; the path will then be relative to that directory.\nIf follow_symlinks is False, and the last element of src is a symbolic\n  link, link will create a link to the symbolic link itself instead of the\n  file the link points to.\nsrc_dir_fd, dst_dir_fd, and follow_symlinks may not be implemented on your\n  platform.  If they are unavailable, using them will raise a\n  NotImplementedError.",
    "nt.listdir" => "Return a list containing the names of the files in the directory.\n\npath can be specified as either str, bytes, or a path-like object.  If path is bytes,\n  the filenames returned will also be bytes; in all other circumstances\n  the filenames returned will be str.\nIf path is None, uses the path='.'.\nOn some platforms, path may also be specified as an open file descriptor;\\\n  the file descriptor must refer to a directory.\n  If this functionality is unavailable, using it raises NotImplementedError.\n\nThe list is in arbitrary order.  It does not include the special\nentries '.' and '..' even if they are present in the directory.",
    "nt.listdrives" => "Return a list containing the names of drives in the system.\n\nA drive name typically looks like 'C:\\\\'.",
    "nt.listmounts" => "Return a list containing mount points for a particular volume.\n\n'volume' should be a GUID path as returned from os.listvolumes.",
    "nt.listvolumes" => "Return a list containing the volumes in the system.\n\nVolumes are typically represented as a GUID path.",
    "nt.lseek" => "Set the position of a file descriptor.  Return the new position.\n\n  fd\n    An open file descriptor, as returned by os.open().\n  position\n    Position, interpreted relative to 'whence'.\n  whence\n    The relative position to seek from. Valid values are:\n    - SEEK_SET: seek from the start of the file.\n    - SEEK_CUR: seek from the current file position.\n    - SEEK_END: seek from the end of the file.\n\nThe return value is the number of bytes relative to the beginning of the file.",
    "nt.lstat" => "Perform a stat system call on the given path, without following symbolic links.\n\nLike stat(), but do not follow symbolic links.\nEquivalent to stat(path, follow_symlinks=False).",
    "nt.mkdir" => "Create a directory.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.\n\nThe mode argument is ignored on Windows. Where it is used, the current umask\nvalue is first masked out.",
    "nt.open" => "Open a file for low level IO.  Returns a file descriptor (integer).\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.",
    "nt.pipe" => "Create a pipe.\n\nReturns a tuple of two file descriptors:\n  (read_fd, write_fd)",
    "nt.putenv" => "Change or add an environment variable.",
    "nt.read" => "Read from a file descriptor.  Returns a bytes object.",
    "nt.readlink" => "Return a string representing the path to which the symbolic link points.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\nand path should be relative; path will then be relative to that directory.\n\ndir_fd may not be implemented on your platform.  If it is unavailable,\nusing it will raise a NotImplementedError.",
    "nt.remove" => "Remove a file (same as unlink()).\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.",
    "nt.rename" => "Rename a file or directory.\n\nIf either src_dir_fd or dst_dir_fd is not None, it should be a file\n  descriptor open to a directory, and the respective path string (src or dst)\n  should be relative; the path will then be relative to that directory.\nsrc_dir_fd and dst_dir_fd, may not be implemented on your platform.\n  If they are unavailable, using them will raise a NotImplementedError.",
    "nt.replace" => "Rename a file or directory, overwriting the destination.\n\nIf either src_dir_fd or dst_dir_fd is not None, it should be a file\n  descriptor open to a directory, and the respective path string (src or dst)\n  should be relative; the path will then be relative to that directory.\nsrc_dir_fd and dst_dir_fd, may not be implemented on your platform.\n  If they are unavailable, using them will raise a NotImplementedError.",
    "nt.rmdir" => "Remove a directory.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.",
    "nt.scandir" => "Return an iterator of DirEntry objects for given path.\n\npath can be specified as either str, bytes, or a path-like object.  If path\nis bytes, the names of yielded DirEntry objects will also be bytes; in\nall other circumstances they will be str.\n\nIf path is None, uses the path='.'.",
    "nt.set_blocking" => "Set the blocking mode of the specified file descriptor.\n\nSet the O_NONBLOCK flag if blocking is False,\nclear the O_NONBLOCK flag otherwise.",
    "nt.set_handle_inheritable" => "Set the inheritable flag of the specified handle.",
    "nt.set_inheritable" => "Set the inheritable flag of the specified file descriptor.",
    "nt.spawnv" => "Execute the program specified by path in a new process.\n\nmode\n  Mode of process creation.\npath\n  Path of executable file.\nargv\n  Tuple or list of strings.",
    "nt.spawnve" => "Execute the program specified by path in a new process.\n\nmode\n  Mode of process creation.\npath\n  Path of executable file.\nargv\n  Tuple or list of strings.\nenv\n  Dictionary of strings mapping to strings.",
    "nt.startfile" => "Start a file with its associated application.\n\nWhen \"operation\" is not specified or \"open\", this acts like\ndouble-clicking the file in Explorer, or giving the file name as an\nargument to the DOS \"start\" command: the file is opened with whatever\napplication (if any) its extension is associated.\nWhen another \"operation\" is given, it specifies what should be done with\nthe file.  A typical operation is \"print\".\n\n\"arguments\" is passed to the application, but should be omitted if the\nfile is a document.\n\n\"cwd\" is the working directory for the operation. If \"filepath\" is\nrelative, it will be resolved against this directory. This argument\nshould usually be an absolute path.\n\n\"show_cmd\" can be used to override the recommended visibility option.\nSee the Windows ShellExecute documentation for values.\n\nstartfile returns as soon as the associated application is launched.\nThere is no option to wait for the application to close, and no way\nto retrieve the application's exit status.\n\nThe filepath is relative to the current directory.  If you want to use\nan absolute path, make sure the first character is not a slash (\"/\");\nthe underlying Win32 ShellExecute function doesn't work if it is.",
    "nt.stat" => "Perform a stat system call on the given path.\n\n  path\n    Path to be examined; can be string, bytes, a path-like object or\n    open-file-descriptor int.\n  dir_fd\n    If not None, it should be a file descriptor open to a directory,\n    and path should be a relative string; path will then be relative to\n    that directory.\n  follow_symlinks\n    If False, and the last element of the path is a symbolic link,\n    stat will examine the symbolic link itself instead of the file\n    the link points to.\n\ndir_fd and follow_symlinks may not be implemented\n  on your platform.  If they are unavailable, using them will raise a\n  NotImplementedError.\n\nIt's an error to use dir_fd or follow_symlinks when specifying path as\n  an open file descriptor.",
    "nt.strerror" => "Translate an error code to a message string.",
    "nt.symlink" => "Create a symbolic link pointing to src named dst.\n\ntarget_is_directory is required on Windows if the target is to be\n  interpreted as a directory.  (On Windows, symlink requires\n  Windows 6.0 or greater, and raises a NotImplementedError otherwise.)\n  target_is_directory is ignored on non-Windows platforms.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.",
    "nt.system" => "Execute the command in a subshell.",
    "nt.times" => "Return a collection containing process timing information.\n\nThe object returned behaves like a named tuple with these fields:\n  (utime, stime, cutime, cstime, elapsed_time)\nAll fields are floating-point numbers.",
    "nt.times_result" => "times_result: Result from os.times().\n\nThis object may be accessed either as a tuple of\n  (user, system, children_user, children_system, elapsed),\nor via the attributes user, system, children_user, children_system,\nand elapsed.\n\nSee os.times for more information.",
    "nt.times_result.__add__" => "Return self+value.",
    "nt.times_result.__class_getitem__" => "See PEP 585",
    "nt.times_result.__contains__" => "Return bool(key in self).",
    "nt.times_result.__delattr__" => "Implement delattr(self, name).",
    "nt.times_result.__eq__" => "Return self==value.",
    "nt.times_result.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "nt.times_result.__ge__" => "Return self>=value.",
    "nt.times_result.__getattribute__" => "Return getattr(self, name).",
    "nt.times_result.__getitem__" => "Return self[key].",
    "nt.times_result.__getstate__" => "Helper for pickle.",
    "nt.times_result.__gt__" => "Return self>value.",
    "nt.times_result.__hash__" => "Return hash(self).",
    "nt.times_result.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "nt.times_result.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "nt.times_result.__iter__" => "Implement iter(self).",
    "nt.times_result.__le__" => "Return self<=value.",
    "nt.times_result.__len__" => "Return len(self).",
    "nt.times_result.__lt__" => "Return self<value.",
    "nt.times_result.__mul__" => "Return self*value.",
    "nt.times_result.__ne__" => "Return self!=value.",
    "nt.times_result.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "nt.times_result.__reduce_ex__" => "Helper for pickle.",
    "nt.times_result.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "nt.times_result.__repr__" => "Return repr(self).",
    "nt.times_result.__rmul__" => "Return value*self.",
    "nt.times_result.__setattr__" => "Implement setattr(self, name, value).",
    "nt.times_result.__sizeof__" => "Size of object in memory, in bytes.",
    "nt.times_result.__str__" => "Return str(self).",
    "nt.times_result.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "nt.times_result.children_system" => "system time of children",
    "nt.times_result.children_user" => "user time of children",
    "nt.times_result.count" => "Return number of occurrences of value.",
    "nt.times_result.elapsed" => "elapsed time since an arbitrary point in the past",
    "nt.times_result.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "nt.times_result.system" => "system time",
    "nt.times_result.user" => "user time",
    "nt.truncate" => "Truncate a file, specified by path, to a specific length.\n\nOn some platforms, path may also be specified as an open file descriptor.\n  If this functionality is unavailable, using it raises an exception.",
    "nt.umask" => "Set the current numeric umask and return the previous umask.",
    "nt.uname_result" => "uname_result: Result from os.uname().\n\nThis object may be accessed either as a tuple of\n  (sysname, nodename, release, version, machine),\nor via the attributes sysname, nodename, release, version, and machine.\n\nSee os.uname for more information.",
    "nt.uname_result.__add__" => "Return self+value.",
    "nt.uname_result.__class_getitem__" => "See PEP 585",
    "nt.uname_result.__contains__" => "Return bool(key in self).",
    "nt.uname_result.__delattr__" => "Implement delattr(self, name).",
    "nt.uname_result.__eq__" => "Return self==value.",
    "nt.uname_result.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "nt.uname_result.__ge__" => "Return self>=value.",
    "nt.uname_result.__getattribute__" => "Return getattr(self, name).",
    "nt.uname_result.__getitem__" => "Return self[key].",
    "nt.uname_result.__getstate__" => "Helper for pickle.",
    "nt.uname_result.__gt__" => "Return self>value.",
    "nt.uname_result.__hash__" => "Return hash(self).",
    "nt.uname_result.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "nt.uname_result.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "nt.uname_result.__iter__" => "Implement iter(self).",
    "nt.uname_result.__le__" => "Return self<=value.",
    "nt.uname_result.__len__" => "Return len(self).",
    "nt.uname_result.__lt__" => "Return self<value.",
    "nt.uname_result.__mul__" => "Return self*value.",
    "nt.uname_result.__ne__" => "Return self!=value.",
    "nt.uname_result.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "nt.uname_result.__reduce_ex__" => "Helper for pickle.",
    "nt.uname_result.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "nt.uname_result.__repr__" => "Return repr(self).",
    "nt.uname_result.__rmul__" => "Return value*self.",
    "nt.uname_result.__setattr__" => "Implement setattr(self, name, value).",
    "nt.uname_result.__sizeof__" => "Size of object in memory, in bytes.",
    "nt.uname_result.__str__" => "Return str(self).",
    "nt.uname_result.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "nt.uname_result.count" => "Return number of occurrences of value.",
    "nt.uname_result.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "nt.uname_result.machine" => "hardware identifier",
    "nt.uname_result.nodename" => "name of machine on network (implementation-defined)",
    "nt.uname_result.release" => "operating system release",
    "nt.uname_result.sysname" => "operating system name",
    "nt.uname_result.version" => "operating system version",
    "nt.unlink" => "Remove a file (same as remove()).\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\ndir_fd may not be implemented on your platform.\n  If it is unavailable, using it will raise a NotImplementedError.",
    "nt.unsetenv" => "Delete an environment variable.",
    "nt.urandom" => "Return a bytes object containing random bytes suitable for cryptographic use.",
    "nt.utime" => "Set the access and modified time of path.\n\npath may always be specified as a string.\nOn some platforms, path may also be specified as an open file descriptor.\n  If this functionality is unavailable, using it raises an exception.\n\nIf times is not None, it must be a tuple (atime, mtime);\n    atime and mtime should be expressed as float seconds since the epoch.\nIf ns is specified, it must be a tuple (atime_ns, mtime_ns);\n    atime_ns and mtime_ns should be expressed as integer nanoseconds\n    since the epoch.\nIf times is None and ns is unspecified, utime uses the current time.\nSpecifying tuples for both times and ns is an error.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and path should be relative; path will then be relative to that directory.\nIf follow_symlinks is False, and the last element of the path is a symbolic\n  link, utime will modify the symbolic link itself instead of the file the\n  link points to.\nIt is an error to use dir_fd or follow_symlinks when specifying path\n  as an open file descriptor.\ndir_fd and follow_symlinks may not be available on your platform.\n  If they are unavailable, using them will raise a NotImplementedError.",
    "nt.waitpid" => "Wait for completion of a given process.\n\nReturns a tuple of information regarding the process:\n    (pid, status << 8)\n\nThe options argument is ignored on Windows.",
    "nt.waitstatus_to_exitcode" => "Convert a wait status to an exit code.\n\nOn Unix:\n\n* If WIFEXITED(status) is true, return WEXITSTATUS(status).\n* If WIFSIGNALED(status) is true, return -WTERMSIG(status).\n* Otherwise, raise a ValueError.\n\nOn Windows, return status shifted right by 8 bits.\n\nOn Unix, if the process is being traced or if waitpid() was called with\nWUNTRACED option, the caller must first check if WIFSTOPPED(status) is true.\nThis function must not be called if WIFSTOPPED(status) is true.",
    "nt.write" => "Write a bytes object to a file descriptor.",
    "pyexpat" => "Python wrapper for Expat parser.",
    "pyexpat.ErrorString" => "Returns string error for given number.",
    "pyexpat.ParserCreate" => "Return a new XML parser object.",
    "pyexpat.XMLParserType" => "XML parser",
    "pyexpat.XMLParserType.ExternalEntityParserCreate" => "Create a parser for parsing an external entity based on the information passed to the ExternalEntityRefHandler.",
    "pyexpat.XMLParserType.GetBase" => "Return base URL string for the parser.",
    "pyexpat.XMLParserType.GetInputContext" => "Return the untranslated text of the input that caused the current event.\n\nIf the event was generated by a large amount of text (such as a start tag\nfor an element with many attributes), not all of the text may be available.",
    "pyexpat.XMLParserType.GetReparseDeferralEnabled" => "Retrieve reparse deferral enabled status; always returns false with Expat <2.6.0.",
    "pyexpat.XMLParserType.Parse" => "Parse XML data.\n\n`isfinal' should be true at end of input.",
    "pyexpat.XMLParserType.ParseFile" => "Parse XML data from file-like object.",
    "pyexpat.XMLParserType.SetBase" => "Set the base URL for the parser.",
    "pyexpat.XMLParserType.SetParamEntityParsing" => "Controls parsing of parameter entities (including the external DTD subset).\n\nPossible flag values are XML_PARAM_ENTITY_PARSING_NEVER,\nXML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE and\nXML_PARAM_ENTITY_PARSING_ALWAYS. Returns true if setting the flag\nwas successful.",
    "pyexpat.XMLParserType.SetReparseDeferralEnabled" => "Enable/Disable reparse deferral; enabled by default with Expat >=2.6.0.",
    "pyexpat.XMLParserType.UseForeignDTD" => "Allows the application to provide an artificial external subset if one is not specified as part of the document instance.\n\nThis readily allows the use of a 'default' document type controlled by the\napplication, while still getting the advantage of providing document type\ninformation to the parser. 'flag' defaults to True if not provided.",
    "pyexpat.XMLParserType.__delattr__" => "Implement delattr(self, name).",
    "pyexpat.XMLParserType.__eq__" => "Return self==value.",
    "pyexpat.XMLParserType.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "pyexpat.XMLParserType.__ge__" => "Return self>=value.",
    "pyexpat.XMLParserType.__getattribute__" => "Return getattr(self, name).",
    "pyexpat.XMLParserType.__getstate__" => "Helper for pickle.",
    "pyexpat.XMLParserType.__gt__" => "Return self>value.",
    "pyexpat.XMLParserType.__hash__" => "Return hash(self).",
    "pyexpat.XMLParserType.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "pyexpat.XMLParserType.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "pyexpat.XMLParserType.__le__" => "Return self<=value.",
    "pyexpat.XMLParserType.__lt__" => "Return self<value.",
    "pyexpat.XMLParserType.__ne__" => "Return self!=value.",
    "pyexpat.XMLParserType.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "pyexpat.XMLParserType.__reduce__" => "Helper for pickle.",
    "pyexpat.XMLParserType.__reduce_ex__" => "Helper for pickle.",
    "pyexpat.XMLParserType.__repr__" => "Return repr(self).",
    "pyexpat.XMLParserType.__setattr__" => "Implement setattr(self, name, value).",
    "pyexpat.XMLParserType.__sizeof__" => "Size of object in memory, in bytes.",
    "pyexpat.XMLParserType.__str__" => "Return str(self).",
    "pyexpat.XMLParserType.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "select" => "This module supports asynchronous I/O on multiple file descriptors.\n\n*** IMPORTANT NOTICE ***\nOn Windows, only sockets are supported; on Unix, all file descriptors.",
    "select.select" => "Wait until one or more file descriptors are ready for some kind of I/O.\n\nThe first three arguments are iterables of file descriptors to be waited for:\nrlist -- wait until ready for reading\nwlist -- wait until ready for writing\nxlist -- wait for an \"exceptional condition\"\nIf only one kind of condition is required, pass [] for the other lists.\n\nA file descriptor is either a socket or file object, or a small integer\ngotten from a fileno() method call on one of those.\n\nThe optional 4th argument specifies a timeout in seconds; it may be\na floating-point number to specify fractions of seconds.  If it is absent\nor None, the call will never time out.\n\nThe return value is a tuple of three lists corresponding to the first three\narguments; each contains the subset of the corresponding file descriptors\nthat are ready.\n\n*** IMPORTANT NOTICE ***\nOn Windows, only sockets are supported; on Unix, all file\ndescriptors can be used.",
    "sys" => "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_exc - the last uncaught exception\n  Only available in an interactive session after a\n  traceback has been printed.\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are the (deprecated) legacy representation of last_exc.\n\nStatic objects:\n\nbuiltin_module_names -- tuple of module names built into this interpreter\ncopyright -- copyright notice pertaining to this interpreter\nexec_prefix -- prefix used to find the machine-specific Python library\nexecutable -- absolute path of the executable binary of the Python interpreter\nfloat_info -- a named tuple with information about the float implementation.\nfloat_repr_style -- string indicating the style of repr() output for floats\nhash_info -- a named tuple with information about the hash algorithm.\nhexversion -- version information encoded as a single integer\nimplementation -- Python implementation information.\nint_info -- a named tuple with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the value of the largest Unicode code point\nplatform -- platform identifier\nprefix -- prefix used to find the Python library\nthread_info -- a named tuple with information about the thread implementation.\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\ndllhandle -- [Windows only] integer handle of the Python DLL\nwinver -- [Windows only] version number of the Python DLL\n_enablelegacywindowsfsencoding -- [Windows only]\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexception() -- return the current thread's active exception\nexc_info() -- return information about the current thread's active exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function",
    "sys.__breakpointhook__" => "This hook function is called by built-in breakpoint().",
    "sys.__displayhook__" => "Print an object to sys.stdout and also save it in builtins._",
    "sys.__excepthook__" => "Handle an exception by displaying it with a traceback on sys.stderr.",
    "sys.__unraisablehook__" => "Handle an unraisable exception.\n\nThe unraisable argument has the following attributes:\n\n* exc_type: Exception type.\n* exc_value: Exception value, can be None.\n* exc_traceback: Exception traceback, can be None.\n* err_msg: Error message, can be None.\n* object: Object causing the exception, can be None.",
    "sys._baserepl" => "Private function for getting the base REPL",
    "sys._clear_internal_caches" => "Clear all internal performance-related caches.",
    "sys._clear_type_cache" => "Clear the internal type lookup cache.",
    "sys._current_exceptions" => "Return a dict mapping each thread's identifier to its current raised exception.\n\nThis function should be used for specialized purposes only.",
    "sys._current_frames" => "Return a dict mapping each thread's thread id to its current stack frame.\n\nThis function should be used for specialized purposes only.",
    "sys._debugmallocstats" => "Print summary info to stderr about the state of pymalloc's structures.\n\nIn Py_DEBUG mode, also perform some expensive internal consistency\nchecks.",
    "sys._enablelegacywindowsfsencoding" => "Changes the default filesystem encoding to mbcs:replace.\n\nThis is done for consistency with earlier versions of Python. See PEP\n529 for more information.\n\nThis is equivalent to defining the PYTHONLEGACYWINDOWSFSENCODING\nenvironment variable before launching Python.",
    "sys._get_cpu_count_config" => "Private function for getting PyConfig.cpu_count",
    "sys._getframe" => "Return a frame object from the call stack.\n\nIf optional integer depth is given, return the frame object that many\ncalls below the top of the stack.  If that is deeper than the call\nstack, ValueError is raised.  The default for depth is zero, returning\nthe frame at the top of the call stack.\n\nThis function should be used for internal and specialized purposes\nonly.",
    "sys._getframemodulename" => "Return the name of the module for a calling frame.\n\nThe default depth returns the module containing the call to this API.\nA more typical use in a library will pass a depth of 1 to get the user's\nmodule rather than the library module.\n\nIf no frame, module, or name can be found, returns None.",
    "sys._is_gil_enabled" => "Return True if the GIL is currently enabled and False otherwise.",
    "sys._is_interned" => "Return True if the given string is \"interned\".",
    "sys._setprofileallthreads" => "Set the profiling function in all running threads belonging to the current interpreter.\n\nIt will be called on each function call and return.  See the profiler\nchapter in the library manual.",
    "sys._settraceallthreads" => "Set the global debug tracing function in all running threads belonging to the current interpreter.\n\nIt will be called on each function call. See the debugger chapter\nin the library manual.",
    "sys.activate_stack_trampoline" => "Activate stack profiler trampoline *backend*.",
    "sys.addaudithook" => "Adds a new audit hook callback.",
    "sys.audit" => "Passes the event to any audit hooks that are attached.",
    "sys.breakpointhook" => "This hook function is called by built-in breakpoint().",
    "sys.call_tracing" => "Call func(*args), while tracing is enabled.\n\nThe tracing state is saved, and restored afterwards.  This is intended\nto be called from a debugger from a checkpoint, to recursively debug\nsome other code.",
    "sys.deactivate_stack_trampoline" => "Deactivate the current stack profiler trampoline backend.\n\nIf no stack profiler is activated, this function has no effect.",
    "sys.displayhook" => "Print an object to sys.stdout and also save it in builtins._",
    "sys.exc_info" => "Return current exception information: (type, value, traceback).\n\nReturn information about the most recent exception caught by an except\nclause in the current stack frame or in an older stack frame.",
    "sys.excepthook" => "Handle an exception by displaying it with a traceback on sys.stderr.",
    "sys.exception" => "Return the current exception.\n\nReturn the most recent exception caught by an except clause\nin the current stack frame or in an older stack frame, or None\nif no such exception exists.",
    "sys.exit" => "Exit the interpreter by raising SystemExit(status).\n\nIf the status is omitted or None, it defaults to zero (i.e., success).\nIf the status is an integer, it will be used as the system exit status.\nIf it is another kind of object, it will be printed and the system\nexit status will be one (i.e., failure).",
    "sys.get_asyncgen_hooks" => "Return the installed asynchronous generators hooks.\n\nThis returns a namedtuple of the form (firstiter, finalizer).",
    "sys.get_coroutine_origin_tracking_depth" => "Check status of origin tracking for coroutine objects in this thread.",
    "sys.get_int_max_str_digits" => "Return the maximum string digits limit for non-binary int<->str conversions.",
    "sys.getallocatedblocks" => "Return the number of memory blocks currently allocated.",
    "sys.getdefaultencoding" => "Return the current default encoding used by the Unicode implementation.",
    "sys.getfilesystemencodeerrors" => "Return the error mode used Unicode to OS filename conversion.",
    "sys.getfilesystemencoding" => "Return the encoding used to convert Unicode filenames to OS filenames.",
    "sys.getprofile" => "Return the profiling function set with sys.setprofile.\n\nSee the profiler chapter in the library manual.",
    "sys.getrecursionlimit" => "Return the current value of the recursion limit.\n\nThe recursion limit is the maximum depth of the Python interpreter\nstack.  This limit prevents infinite recursion from causing an overflow\nof the C stack and crashing Python.",
    "sys.getrefcount" => "Return the reference count of object.\n\nThe count returned is generally one higher than you might expect,\nbecause it includes the (temporary) reference as an argument to\ngetrefcount().",
    "sys.getsizeof" => "getsizeof(object [, default]) -> int\n\nReturn the size of object in bytes.",
    "sys.getswitchinterval" => "Return the current thread switch interval; see sys.setswitchinterval().",
    "sys.gettrace" => "Return the global debug tracing function set with sys.settrace.\n\nSee the debugger chapter in the library manual.",
    "sys.getunicodeinternedsize" => "Return the number of elements of the unicode interned dictionary",
    "sys.getwindowsversion" => "Return info about the running version of Windows as a named tuple.\n\nThe members are named: major, minor, build, platform, service_pack,\nservice_pack_major, service_pack_minor, suite_mask, product_type and\nplatform_version. For backward compatibility, only the first 5 items\nare available by indexing. All elements are numbers, except\nservice_pack and platform_type which are strings, and platform_version\nwhich is a 3-tuple. Platform is always 2. Product_type may be 1 for a\nworkstation, 2 for a domain controller, 3 for a server.\nPlatform_version is a 3-tuple containing a version number that is\nintended for identifying the OS rather than feature detection.",
    "sys.intern" => "``Intern'' the given string.\n\nThis enters the string in the (global) table of interned strings whose\npurpose is to speed up dictionary lookups. Return the string itself or\nthe previously interned string object with the same value.",
    "sys.is_finalizing" => "Return True if Python is exiting.",
    "sys.is_stack_trampoline_active" => "Return *True* if a stack profiler trampoline is active.",
    "sys.set_asyncgen_hooks" => "set_asyncgen_hooks([firstiter] [, finalizer])\n\nSet a finalizer for async generators objects.",
    "sys.set_coroutine_origin_tracking_depth" => "Enable or disable origin tracking for coroutine objects in this thread.\n\nCoroutine objects will track 'depth' frames of traceback information\nabout where they came from, available in their cr_origin attribute.\n\nSet a depth of 0 to disable.",
    "sys.set_int_max_str_digits" => "Set the maximum string digits limit for non-binary int<->str conversions.",
    "sys.setprofile" => "Set the profiling function.\n\nIt will be called on each function call and return.  See the profiler\nchapter in the library manual.",
    "sys.setrecursionlimit" => "Set the maximum depth of the Python interpreter stack to n.\n\nThis limit prevents infinite recursion from causing an overflow of the C\nstack and crashing Python.  The highest possible limit is platform-\ndependent.",
    "sys.setswitchinterval" => "Set the ideal thread switching delay inside the Python interpreter.\n\nThe actual frequency of switching threads can be lower if the\ninterpreter executes long sequences of uninterruptible code\n(this is implementation-specific and workload-dependent).\n\nThe parameter must represent the desired switching delay in seconds\nA typical value is 0.005 (5 milliseconds).",
    "sys.settrace" => "Set the global debug tracing function.\n\nIt will be called on each function call.  See the debugger chapter\nin the library manual.",
    "sys.unraisablehook" => "Handle an unraisable exception.\n\nThe unraisable argument has the following attributes:\n\n* exc_type: Exception type.\n* exc_value: Exception value, can be None.\n* exc_traceback: Exception traceback, can be None.\n* err_msg: Error message, can be None.\n* object: Object causing the exception, can be None.",
    "time" => "This module provides various functions to manipulate time values.\n\nThere are two standard representations of time.  One is the number\nof seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\nor a floating-point number (to represent fractions of seconds).\nThe epoch is the point where the time starts, the return value of time.gmtime(0).\nIt is January 1, 1970, 00:00:00 (UTC) on all platforms.\n\nThe other representation is a tuple of 9 integers giving local time.\nThe tuple items are:\n  year (including century, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\nIf the DST flag is 0, the time is given in the regular time zone;\nif it is 1, the time is given in the DST time zone;\nif it is -1, mktime() should guess based on the date and time.",
    "time.asctime" => "asctime([tuple]) -> string\n\nConvert a time tuple to a string, e.g. 'Sat Jun 06 16:26:11 1998'.\nWhen the time tuple is not present, current time as returned by localtime()\nis used.",
    "time.ctime" => "ctime(seconds) -> string\n\nConvert a time in seconds since the Epoch to a string in local time.\nThis is equivalent to asctime(localtime(seconds)). When the time tuple is\nnot present, current time as returned by localtime() is used.",
    "time.get_clock_info" => "get_clock_info(name: str) -> dict\n\nGet information of the specified clock.",
    "time.gmtime" => "gmtime([seconds]) -> (tm_year, tm_mon, tm_mday, tm_hour, tm_min,\n                       tm_sec, tm_wday, tm_yday, tm_isdst)\n\nConvert seconds since the Epoch to a time tuple expressing UTC (a.k.a.\nGMT).  When 'seconds' is not passed in, convert the current time instead.\n\nIf the platform supports the tm_gmtoff and tm_zone, they are available as\nattributes only.",
    "time.localtime" => "localtime([seconds]) -> (tm_year,tm_mon,tm_mday,tm_hour,tm_min,\n                          tm_sec,tm_wday,tm_yday,tm_isdst)\n\nConvert seconds since the Epoch to a time tuple expressing local time.\nWhen 'seconds' is not passed in, convert the current time instead.",
    "time.mktime" => "mktime(tuple) -> floating-point number\n\nConvert a time tuple in local time to seconds since the Epoch.\nNote that mktime(gmtime(0)) will not generally return zero for most\ntime zones; instead the returned value will either be equal to that\nof the timezone or altzone attributes on the time module.",
    "time.monotonic" => "monotonic() -> float\n\nMonotonic clock, cannot go backward.",
    "time.monotonic_ns" => "monotonic_ns() -> int\n\nMonotonic clock, cannot go backward, as nanoseconds.",
    "time.perf_counter" => "perf_counter() -> float\n\nPerformance counter for benchmarking.",
    "time.perf_counter_ns" => "perf_counter_ns() -> int\n\nPerformance counter for benchmarking as nanoseconds.",
    "time.process_time" => "process_time() -> float\n\nProcess time for profiling: sum of the kernel and user-space CPU time.",
    "time.process_time_ns" => "process_time() -> int\n\nProcess time for profiling as nanoseconds:\nsum of the kernel and user-space CPU time.",
    "time.sleep" => "sleep(seconds)\n\nDelay execution for a given number of seconds.  The argument may be\na floating-point number for subsecond precision.",
    "time.strftime" => "strftime(format[, tuple]) -> string\n\nConvert a time tuple to a string according to a format specification.\nSee the library reference manual for formatting codes. When the time tuple\nis not present, current time as returned by localtime() is used.\n\nCommonly used format codes:\n\n%Y  Year with century as a decimal number.\n%m  Month as a decimal number [01,12].\n%d  Day of the month as a decimal number [01,31].\n%H  Hour (24-hour clock) as a decimal number [00,23].\n%M  Minute as a decimal number [00,59].\n%S  Second as a decimal number [00,61].\n%z  Time zone offset from UTC.\n%a  Locale's abbreviated weekday name.\n%A  Locale's full weekday name.\n%b  Locale's abbreviated month name.\n%B  Locale's full month name.\n%c  Locale's appropriate date and time representation.\n%I  Hour (12-hour clock) as a decimal number [01,12].\n%p  Locale's equivalent of either AM or PM.\n\nOther codes may be available on your platform.  See documentation for\nthe C library strftime function.",
    "time.strptime" => "strptime(string, format) -> struct_time\n\nParse a string to a time tuple according to a format specification.\nSee the library reference manual for formatting codes (same as\nstrftime()).\n\nCommonly used format codes:\n\n%Y  Year with century as a decimal number.\n%m  Month as a decimal number [01,12].\n%d  Day of the month as a decimal number [01,31].\n%H  Hour (24-hour clock) as a decimal number [00,23].\n%M  Minute as a decimal number [00,59].\n%S  Second as a decimal number [00,61].\n%z  Time zone offset from UTC.\n%a  Locale's abbreviated weekday name.\n%A  Locale's full weekday name.\n%b  Locale's abbreviated month name.\n%B  Locale's full month name.\n%c  Locale's appropriate date and time representation.\n%I  Hour (12-hour clock) as a decimal number [01,12].\n%p  Locale's equivalent of either AM or PM.\n\nOther codes may be available on your platform.  See documentation for\nthe C library strftime function.",
    "time.struct_time" => "The time value as returned by gmtime(), localtime(), and strptime(), and\naccepted by asctime(), mktime() and strftime().  May be considered as a\nsequence of 9 integers.\n\nNote that several fields' values are not the same as those defined by\nthe C language standard for struct tm.  For example, the value of the\nfield tm_year is the actual year, not year - 1900.  See individual\nfields' descriptions for details.",
    "time.struct_time.__add__" => "Return self+value.",
    "time.struct_time.__class_getitem__" => "See PEP 585",
    "time.struct_time.__contains__" => "Return bool(key in self).",
    "time.struct_time.__delattr__" => "Implement delattr(self, name).",
    "time.struct_time.__eq__" => "Return self==value.",
    "time.struct_time.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "time.struct_time.__ge__" => "Return self>=value.",
    "time.struct_time.__getattribute__" => "Return getattr(self, name).",
    "time.struct_time.__getitem__" => "Return self[key].",
    "time.struct_time.__getstate__" => "Helper for pickle.",
    "time.struct_time.__gt__" => "Return self>value.",
    "time.struct_time.__hash__" => "Return hash(self).",
    "time.struct_time.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "time.struct_time.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "time.struct_time.__iter__" => "Implement iter(self).",
    "time.struct_time.__le__" => "Return self<=value.",
    "time.struct_time.__len__" => "Return len(self).",
    "time.struct_time.__lt__" => "Return self<value.",
    "time.struct_time.__mul__" => "Return self*value.",
    "time.struct_time.__ne__" => "Return self!=value.",
    "time.struct_time.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "time.struct_time.__reduce_ex__" => "Helper for pickle.",
    "time.struct_time.__replace__" => "Return a copy of the structure with new values for the specified fields.",
    "time.struct_time.__repr__" => "Return repr(self).",
    "time.struct_time.__rmul__" => "Return value*self.",
    "time.struct_time.__setattr__" => "Implement setattr(self, name, value).",
    "time.struct_time.__sizeof__" => "Size of object in memory, in bytes.",
    "time.struct_time.__str__" => "Return str(self).",
    "time.struct_time.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "time.struct_time.count" => "Return number of occurrences of value.",
    "time.struct_time.index" => "Return first index of value.\n\nRaises ValueError if the value is not present.",
    "time.struct_time.tm_gmtoff" => "offset from UTC in seconds",
    "time.struct_time.tm_hour" => "hours, range [0, 23]",
    "time.struct_time.tm_isdst" => "1 if summer time is in effect, 0 if not, and -1 if unknown",
    "time.struct_time.tm_mday" => "day of month, range [1, 31]",
    "time.struct_time.tm_min" => "minutes, range [0, 59]",
    "time.struct_time.tm_mon" => "month of year, range [1, 12]",
    "time.struct_time.tm_sec" => "seconds, range [0, 61])",
    "time.struct_time.tm_wday" => "day of week, range [0, 6], Monday is 0",
    "time.struct_time.tm_yday" => "day of year, range [1, 366]",
    "time.struct_time.tm_year" => "year, for example, 1993",
    "time.struct_time.tm_zone" => "abbreviation of timezone name",
    "time.thread_time" => "thread_time() -> float\n\nThread time for profiling: sum of the kernel and user-space CPU time.",
    "time.thread_time_ns" => "thread_time() -> int\n\nThread time for profiling as nanoseconds:\nsum of the kernel and user-space CPU time.",
    "time.time" => "time() -> floating-point number\n\nReturn the current time in seconds since the Epoch.\nFractions of a second may be present if the system clock provides them.",
    "time.time_ns" => "time_ns() -> int\n\nReturn the current time in nanoseconds since the Epoch.",
    "unicodedata" => "This module provides access to the Unicode Character Database which\ndefines character properties for all Unicode characters. The data in\nthis database is based on the UnicodeData.txt file version\n15.1.0 which is publicly available from ftp://ftp.unicode.org/.\n\nThe module uses the same names and symbols as defined by the\nUnicodeData File Format 15.1.0.",
    "unicodedata.UCD.__delattr__" => "Implement delattr(self, name).",
    "unicodedata.UCD.__eq__" => "Return self==value.",
    "unicodedata.UCD.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "unicodedata.UCD.__ge__" => "Return self>=value.",
    "unicodedata.UCD.__getattribute__" => "Return getattr(self, name).",
    "unicodedata.UCD.__getstate__" => "Helper for pickle.",
    "unicodedata.UCD.__gt__" => "Return self>value.",
    "unicodedata.UCD.__hash__" => "Return hash(self).",
    "unicodedata.UCD.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "unicodedata.UCD.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "unicodedata.UCD.__le__" => "Return self<=value.",
    "unicodedata.UCD.__lt__" => "Return self<value.",
    "unicodedata.UCD.__ne__" => "Return self!=value.",
    "unicodedata.UCD.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "unicodedata.UCD.__reduce__" => "Helper for pickle.",
    "unicodedata.UCD.__reduce_ex__" => "Helper for pickle.",
    "unicodedata.UCD.__repr__" => "Return repr(self).",
    "unicodedata.UCD.__setattr__" => "Implement setattr(self, name, value).",
    "unicodedata.UCD.__sizeof__" => "Size of object in memory, in bytes.",
    "unicodedata.UCD.__str__" => "Return str(self).",
    "unicodedata.UCD.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "unicodedata.UCD.bidirectional" => "Returns the bidirectional class assigned to the character chr as string.\n\nIf no such value is defined, an empty string is returned.",
    "unicodedata.UCD.category" => "Returns the general category assigned to the character chr as string.",
    "unicodedata.UCD.combining" => "Returns the canonical combining class assigned to the character chr as integer.\n\nReturns 0 if no combining class is defined.",
    "unicodedata.UCD.decimal" => "Converts a Unicode character into its equivalent decimal value.\n\nReturns the decimal value assigned to the character chr as integer.\nIf no such value is defined, default is returned, or, if not given,\nValueError is raised.",
    "unicodedata.UCD.decomposition" => "Returns the character decomposition mapping assigned to the character chr as string.\n\nAn empty string is returned in case no such mapping is defined.",
    "unicodedata.UCD.digit" => "Converts a Unicode character into its equivalent digit value.\n\nReturns the digit value assigned to the character chr as integer.\nIf no such value is defined, default is returned, or, if not given,\nValueError is raised.",
    "unicodedata.UCD.east_asian_width" => "Returns the east asian width assigned to the character chr as string.",
    "unicodedata.UCD.is_normalized" => "Return whether the Unicode string unistr is in the normal form 'form'.\n\nValid values for form are 'NFC', 'NFKC', 'NFD', and 'NFKD'.",
    "unicodedata.UCD.lookup" => "Look up character by name.\n\nIf a character with the given name is found, return the\ncorresponding character.  If not found, KeyError is raised.",
    "unicodedata.UCD.mirrored" => "Returns the mirrored property assigned to the character chr as integer.\n\nReturns 1 if the character has been identified as a \"mirrored\"\ncharacter in bidirectional text, 0 otherwise.",
    "unicodedata.UCD.name" => "Returns the name assigned to the character chr as a string.\n\nIf no name is defined, default is returned, or, if not given,\nValueError is raised.",
    "unicodedata.UCD.normalize" => "Return the normal form 'form' for the Unicode string unistr.\n\nValid values for form are 'NFC', 'NFKC', 'NFD', and 'NFKD'.",
    "unicodedata.UCD.numeric" => "Converts a Unicode character into its equivalent numeric value.\n\nReturns the numeric value assigned to the character chr as float.\nIf no such value is defined, default is returned, or, if not given,\nValueError is raised.",
    "unicodedata.bidirectional" => "Returns the bidirectional class assigned to the character chr as string.\n\nIf no such value is defined, an empty string is returned.",
    "unicodedata.category" => "Returns the general category assigned to the character chr as string.",
    "unicodedata.combining" => "Returns the canonical combining class assigned to the character chr as integer.\n\nReturns 0 if no combining class is defined.",
    "unicodedata.decimal" => "Converts a Unicode character into its equivalent decimal value.\n\nReturns the decimal value assigned to the character chr as integer.\nIf no such value is defined, default is returned, or, if not given,\nValueError is raised.",
    "unicodedata.decomposition" => "Returns the character decomposition mapping assigned to the character chr as string.\n\nAn empty string is returned in case no such mapping is defined.",
    "unicodedata.digit" => "Converts a Unicode character into its equivalent digit value.\n\nReturns the digit value assigned to the character chr as integer.\nIf no such value is defined, default is returned, or, if not given,\nValueError is raised.",
    "unicodedata.east_asian_width" => "Returns the east asian width assigned to the character chr as string.",
    "unicodedata.is_normalized" => "Return whether the Unicode string unistr is in the normal form 'form'.\n\nValid values for form are 'NFC', 'NFKC', 'NFD', and 'NFKD'.",
    "unicodedata.lookup" => "Look up character by name.\n\nIf a character with the given name is found, return the\ncorresponding character.  If not found, KeyError is raised.",
    "unicodedata.mirrored" => "Returns the mirrored property assigned to the character chr as integer.\n\nReturns 1 if the character has been identified as a \"mirrored\"\ncharacter in bidirectional text, 0 otherwise.",
    "unicodedata.name" => "Returns the name assigned to the character chr as a string.\n\nIf no name is defined, default is returned, or, if not given,\nValueError is raised.",
    "unicodedata.normalize" => "Return the normal form 'form' for the Unicode string unistr.\n\nValid values for form are 'NFC', 'NFKC', 'NFD', and 'NFKD'.",
    "unicodedata.numeric" => "Converts a Unicode character into its equivalent numeric value.\n\nReturns the numeric value assigned to the character chr as float.\nIf no such value is defined, default is returned, or, if not given,\nValueError is raised.",
    "winreg" => "This module provides access to the Windows registry API.\n\nFunctions:\n\nCloseKey() - Closes a registry key.\nConnectRegistry() - Establishes a connection to a predefined registry handle\n                    on another computer.\nCreateKey() - Creates the specified key, or opens it if it already exists.\nDeleteKey() - Deletes the specified key.\nDeleteValue() - Removes a named value from the specified registry key.\nEnumKey() - Enumerates subkeys of the specified open registry key.\nEnumValue() - Enumerates values of the specified open registry key.\nExpandEnvironmentStrings() - Expand the env strings in a REG_EXPAND_SZ\n                             string.\nFlushKey() - Writes all the attributes of the specified key to the registry.\nLoadKey() - Creates a subkey under HKEY_USER or HKEY_LOCAL_MACHINE and\n            stores registration information from a specified file into that\n            subkey.\nOpenKey() - Opens the specified key.\nOpenKeyEx() - Alias of OpenKey().\nQueryValue() - Retrieves the value associated with the unnamed value for a\n               specified key in the registry.\nQueryValueEx() - Retrieves the type and data for a specified value name\n                 associated with an open registry key.\nQueryInfoKey() - Returns information about the specified key.\nSaveKey() - Saves the specified key, and all its subkeys a file.\nSetValue() - Associates a value with a specified key.\nSetValueEx() - Stores data in the value field of an open registry key.\n\nSpecial objects:\n\nHKEYType -- type object for HKEY objects\nerror -- exception raised for Win32 errors\n\nInteger constants:\nMany constants are defined - see the documentation for each function\nto see what constants are used, and where.",
    "winreg.CloseKey" => "Closes a previously opened registry key.\n\n  hkey\n    A previously opened key.\n\nNote that if the key is not closed using this method, it will be\nclosed when the hkey object is destroyed by Python.",
    "winreg.ConnectRegistry" => "Establishes a connection to the registry on another computer.\n\n  computer_name\n    The name of the remote computer, of the form r\"\\\\computername\".  If\n    None, the local computer is used.\n  key\n    The predefined key to connect to.\n\nThe return value is the handle of the opened key.\nIf the function fails, an OSError exception is raised.",
    "winreg.CreateKey" => "Creates or opens the specified key.\n\n  key\n    An already open key, or one of the predefined HKEY_* constants.\n  sub_key\n    The name of the key this method opens or creates.\n\nIf key is one of the predefined keys, sub_key may be None. In that case,\nthe handle returned is the same key handle passed in to the function.\n\nIf the key already exists, this function opens the existing key.\n\nThe return value is the handle of the opened key.\nIf the function fails, an OSError exception is raised.",
    "winreg.CreateKeyEx" => "Creates or opens the specified key.\n\n  key\n    An already open key, or one of the predefined HKEY_* constants.\n  sub_key\n    The name of the key this method opens or creates.\n  reserved\n    A reserved integer, and must be zero.  Default is zero.\n  access\n    An integer that specifies an access mask that describes the\n    desired security access for the key. Default is KEY_WRITE.\n\nIf key is one of the predefined keys, sub_key may be None. In that case,\nthe handle returned is the same key handle passed in to the function.\n\nIf the key already exists, this function opens the existing key\n\nThe return value is the handle of the opened key.\nIf the function fails, an OSError exception is raised.",
    "winreg.DeleteKey" => "Deletes the specified key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  sub_key\n    A string that must be the name of a subkey of the key identified by\n    the key parameter. This value must not be None, and the key may not\n    have subkeys.\n\nThis method can not delete keys with subkeys.\n\nIf the function succeeds, the entire key, including all of its values,\nis removed.  If the function fails, an OSError exception is raised.",
    "winreg.DeleteKeyEx" => "Deletes the specified key (intended for 64-bit OS).\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  sub_key\n    A string that must be the name of a subkey of the key identified by\n    the key parameter. This value must not be None, and the key may not\n    have subkeys.\n  access\n    An integer that specifies an access mask that describes the\n    desired security access for the key. Default is KEY_WOW64_64KEY.\n  reserved\n    A reserved integer, and must be zero.  Default is zero.\n\nWhile this function is intended to be used for 64-bit OS, it is also\n available on 32-bit systems.\n\nThis method can not delete keys with subkeys.\n\nIf the function succeeds, the entire key, including all of its values,\nis removed.  If the function fails, an OSError exception is raised.\nOn unsupported Windows versions, NotImplementedError is raised.",
    "winreg.DeleteValue" => "Removes a named value from a registry key.\n\nkey\n  An already open key, or any one of the predefined HKEY_* constants.\nvalue\n  A string that identifies the value to remove.",
    "winreg.DisableReflectionKey" => "Disables registry reflection for 32bit processes running on a 64bit OS.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n\nWill generally raise NotImplementedError if executed on a 32bit OS.\n\nIf the key is not on the reflection list, the function succeeds but has\nno effect.  Disabling reflection for a key does not affect reflection\nof any subkeys.",
    "winreg.EnableReflectionKey" => "Restores registry reflection for the specified disabled key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n\nWill generally raise NotImplementedError if executed on a 32bit OS.\nRestoring reflection for a key does not affect reflection of any\nsubkeys.",
    "winreg.EnumKey" => "Enumerates subkeys of an open registry key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  index\n    An integer that identifies the index of the key to retrieve.\n\nThe function retrieves the name of one subkey each time it is called.\nIt is typically called repeatedly until an OSError exception is\nraised, indicating no more values are available.",
    "winreg.EnumValue" => "Enumerates values of an open registry key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  index\n    An integer that identifies the index of the value to retrieve.\n\nThe function retrieves the name of one subkey each time it is called.\nIt is typically called repeatedly, until an OSError exception\nis raised, indicating no more values.\n\nThe result is a tuple of 3 items:\n  value_name\n    A string that identifies the value.\n  value_data\n    An object that holds the value data, and whose type depends\n    on the underlying registry type.\n  data_type\n    An integer that identifies the type of the value data.",
    "winreg.ExpandEnvironmentStrings" => "Expand environment vars.",
    "winreg.FlushKey" => "Writes all the attributes of a key to the registry.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n\nIt is not necessary to call FlushKey to change a key.  Registry changes\nare flushed to disk by the registry using its lazy flusher.  Registry\nchanges are also flushed to disk at system shutdown.  Unlike\nCloseKey(), the FlushKey() method returns only when all the data has\nbeen written to the registry.\n\nAn application should only call FlushKey() if it requires absolute\ncertainty that registry changes are on disk.  If you don't know whether\na FlushKey() call is required, it probably isn't.",
    "winreg.HKEYType" => "PyHKEY Object - A Python object, representing a win32 registry key.\n\nThis object wraps a Windows HKEY object, automatically closing it when\nthe object is destroyed.  To guarantee cleanup, you can call either\nthe Close() method on the PyHKEY, or the CloseKey() method.\n\nAll functions which accept a handle object also accept an integer --\nhowever, use of the handle object is encouraged.\n\nFunctions:\nClose() - Closes the underlying handle.\nDetach() - Returns the integer Win32 handle, detaching it from the object\n\nProperties:\nhandle - The integer Win32 handle.\n\nOperations:\n__bool__ - Handles with an open object return true, otherwise false.\n__int__ - Converting a handle to an integer returns the Win32 handle.\nrich comparison - Handle objects are compared using the handle value.",
    "winreg.HKEYType.Close" => "Closes the underlying Windows handle.\n\nIf the handle is already closed, no error is raised.",
    "winreg.HKEYType.Detach" => "Detaches the Windows handle from the handle object.\n\nThe result is the value of the handle before it is detached.  If the\nhandle is already detached, this will return zero.\n\nAfter calling this function, the handle is effectively invalidated,\nbut the handle is not closed.  You would call this function when you\nneed the underlying win32 handle to exist beyond the lifetime of the\nhandle object.",
    "winreg.HKEYType.__abs__" => "abs(self)",
    "winreg.HKEYType.__add__" => "Return self+value.",
    "winreg.HKEYType.__and__" => "Return self&value.",
    "winreg.HKEYType.__bool__" => "True if self else False",
    "winreg.HKEYType.__delattr__" => "Implement delattr(self, name).",
    "winreg.HKEYType.__divmod__" => "Return divmod(self, value).",
    "winreg.HKEYType.__eq__" => "Return self==value.",
    "winreg.HKEYType.__float__" => "float(self)",
    "winreg.HKEYType.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "winreg.HKEYType.__ge__" => "Return self>=value.",
    "winreg.HKEYType.__getattribute__" => "Return getattr(self, name).",
    "winreg.HKEYType.__getstate__" => "Helper for pickle.",
    "winreg.HKEYType.__gt__" => "Return self>value.",
    "winreg.HKEYType.__hash__" => "Return hash(self).",
    "winreg.HKEYType.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "winreg.HKEYType.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "winreg.HKEYType.__int__" => "int(self)",
    "winreg.HKEYType.__invert__" => "~self",
    "winreg.HKEYType.__le__" => "Return self<=value.",
    "winreg.HKEYType.__lshift__" => "Return self<<value.",
    "winreg.HKEYType.__lt__" => "Return self<value.",
    "winreg.HKEYType.__mod__" => "Return self%value.",
    "winreg.HKEYType.__mul__" => "Return self*value.",
    "winreg.HKEYType.__ne__" => "Return self!=value.",
    "winreg.HKEYType.__neg__" => "-self",
    "winreg.HKEYType.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "winreg.HKEYType.__or__" => "Return self|value.",
    "winreg.HKEYType.__pos__" => "+self",
    "winreg.HKEYType.__pow__" => "Return pow(self, value, mod).",
    "winreg.HKEYType.__radd__" => "Return value+self.",
    "winreg.HKEYType.__rand__" => "Return value&self.",
    "winreg.HKEYType.__rdivmod__" => "Return divmod(value, self).",
    "winreg.HKEYType.__reduce__" => "Helper for pickle.",
    "winreg.HKEYType.__reduce_ex__" => "Helper for pickle.",
    "winreg.HKEYType.__repr__" => "Return repr(self).",
    "winreg.HKEYType.__rlshift__" => "Return value<<self.",
    "winreg.HKEYType.__rmod__" => "Return value%self.",
    "winreg.HKEYType.__rmul__" => "Return value*self.",
    "winreg.HKEYType.__ror__" => "Return value|self.",
    "winreg.HKEYType.__rpow__" => "Return pow(value, self, mod).",
    "winreg.HKEYType.__rrshift__" => "Return value>>self.",
    "winreg.HKEYType.__rshift__" => "Return self>>value.",
    "winreg.HKEYType.__rsub__" => "Return value-self.",
    "winreg.HKEYType.__rxor__" => "Return value^self.",
    "winreg.HKEYType.__setattr__" => "Implement setattr(self, name, value).",
    "winreg.HKEYType.__sizeof__" => "Size of object in memory, in bytes.",
    "winreg.HKEYType.__str__" => "Return str(self).",
    "winreg.HKEYType.__sub__" => "Return self-value.",
    "winreg.HKEYType.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "winreg.HKEYType.__xor__" => "Return self^value.",
    "winreg.LoadKey" => "Insert data into the registry from a file.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  sub_key\n    A string that identifies the sub-key to load.\n  file_name\n    The name of the file to load registry data from.  This file must\n    have been created with the SaveKey() function.  Under the file\n    allocation table (FAT) file system, the filename may not have an\n    extension.\n\nCreates a subkey under the specified key and stores registration\ninformation from a specified file into that subkey.\n\nA call to LoadKey() fails if the calling process does not have the\nSE_RESTORE_PRIVILEGE privilege.\n\nIf key is a handle returned by ConnectRegistry(), then the path\nspecified in fileName is relative to the remote computer.\n\nThe MSDN docs imply key must be in the HKEY_USER or HKEY_LOCAL_MACHINE\ntree.",
    "winreg.OpenKey" => "Opens the specified key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  sub_key\n    A string that identifies the sub_key to open.\n  reserved\n    A reserved integer that must be zero.  Default is zero.\n  access\n    An integer that specifies an access mask that describes the desired\n    security access for the key.  Default is KEY_READ.\n\nThe result is a new handle to the specified key.\nIf the function fails, an OSError exception is raised.",
    "winreg.OpenKeyEx" => "Opens the specified key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  sub_key\n    A string that identifies the sub_key to open.\n  reserved\n    A reserved integer that must be zero.  Default is zero.\n  access\n    An integer that specifies an access mask that describes the desired\n    security access for the key.  Default is KEY_READ.\n\nThe result is a new handle to the specified key.\nIf the function fails, an OSError exception is raised.",
    "winreg.QueryInfoKey" => "Returns information about a key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n\nThe result is a tuple of 3 items:\nAn integer that identifies the number of sub keys this key has.\nAn integer that identifies the number of values this key has.\nAn integer that identifies when the key was last modified (if available)\nas 100's of nanoseconds since Jan 1, 1600.",
    "winreg.QueryReflectionKey" => "Returns the reflection state for the specified key as a bool.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n\nWill generally raise NotImplementedError if executed on a 32bit OS.",
    "winreg.QueryValue" => "Retrieves the unnamed value for a key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  sub_key\n    A string that holds the name of the subkey with which the value\n    is associated.  If this parameter is None or empty, the function\n    retrieves the value set by the SetValue() method for the key\n    identified by key.\n\nValues in the registry have name, type, and data components. This method\nretrieves the data for a key's first value that has a NULL name.\nBut since the underlying API call doesn't return the type, you'll\nprobably be happier using QueryValueEx; this function is just here for\ncompleteness.",
    "winreg.QueryValueEx" => "Retrieves the type and value of a specified sub-key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  name\n    A string indicating the value to query.\n\nBehaves mostly like QueryValue(), but also returns the type of the\nspecified value name associated with the given open registry key.\n\nThe return value is a tuple of the value and the type_id.",
    "winreg.SaveKey" => "Saves the specified key, and all its subkeys to the specified file.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  file_name\n    The name of the file to save registry data to.  This file cannot\n    already exist. If this filename includes an extension, it cannot be\n    used on file allocation table (FAT) file systems by the LoadKey(),\n    ReplaceKey() or RestoreKey() methods.\n\nIf key represents a key on a remote computer, the path described by\nfile_name is relative to the remote computer.\n\nThe caller of this method must possess the SeBackupPrivilege\nsecurity privilege.  This function passes NULL for security_attributes\nto the API.",
    "winreg.SetValue" => "Associates a value with a specified key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  sub_key\n    A string that names the subkey with which the value is associated.\n  type\n    An integer that specifies the type of the data.  Currently this must\n    be REG_SZ, meaning only strings are supported.\n  value\n    A string that specifies the new value.\n\nIf the key specified by the sub_key parameter does not exist, the\nSetValue function creates it.\n\nValue lengths are limited by available memory. Long values (more than\n2048 bytes) should be stored as files with the filenames stored in\nthe configuration registry to help the registry perform efficiently.\n\nThe key identified by the key parameter must have been opened with\nKEY_SET_VALUE access.",
    "winreg.SetValueEx" => "Stores data in the value field of an open registry key.\n\n  key\n    An already open key, or any one of the predefined HKEY_* constants.\n  value_name\n    A string containing the name of the value to set, or None.\n  reserved\n    Can be anything - zero is always passed to the API.\n  type\n    An integer that specifies the type of the data, one of:\n    REG_BINARY -- Binary data in any form.\n    REG_DWORD -- A 32-bit number.\n    REG_DWORD_LITTLE_ENDIAN -- A 32-bit number in little-endian format. Equivalent to REG_DWORD\n    REG_DWORD_BIG_ENDIAN -- A 32-bit number in big-endian format.\n    REG_EXPAND_SZ -- A null-terminated string that contains unexpanded\n                     references to environment variables (for example,\n                     %PATH%).\n    REG_LINK -- A Unicode symbolic link.\n    REG_MULTI_SZ -- A sequence of null-terminated strings, terminated\n                    by two null characters.  Note that Python handles\n                    this termination automatically.\n    REG_NONE -- No defined value type.\n    REG_QWORD -- A 64-bit number.\n    REG_QWORD_LITTLE_ENDIAN -- A 64-bit number in little-endian format. Equivalent to REG_QWORD.\n    REG_RESOURCE_LIST -- A device-driver resource list.\n    REG_SZ -- A null-terminated string.\n  value\n    A string that specifies the new value.\n\nThis method can also set additional value and type information for the\nspecified key.  The key identified by the key parameter must have been\nopened with KEY_SET_VALUE access.\n\nTo open the key, use the CreateKeyEx() or OpenKeyEx() methods.\n\nValue lengths are limited by available memory. Long values (more than\n2048 bytes) should be stored as files with the filenames stored in\nthe configuration registry to help the registry perform efficiently.",
    "winsound" => "PlaySound(sound, flags) - play a sound\nSND_FILENAME - sound is a wav file name\nSND_ALIAS - sound is a registry sound association name\nSND_LOOP - Play the sound repeatedly; must also specify SND_ASYNC\nSND_MEMORY - sound is a memory image of a wav file\nSND_PURGE - stop all instances of the specified sound\nSND_ASYNC - PlaySound returns immediately\nSND_NODEFAULT - Do not play a default beep if the sound can not be found\nSND_NOSTOP - Do not interrupt any sounds currently playing\nSND_NOWAIT - Return immediately if the sound driver is busy\nSND_APPLICATION - sound is an application-specific alias in the registry.\nBeep(frequency, duration) - Make a beep through the PC speaker.\nMessageBeep(type) - Call Windows MessageBeep.",
    "winsound.Beep" => "A wrapper around the Windows Beep API.\n\nfrequency\n  Frequency of the sound in hertz.\n  Must be in the range 37 through 32,767.\nduration\n  How long the sound should play, in milliseconds.",
    "winsound.MessageBeep" => "Call Windows MessageBeep(x).\n\nx defaults to MB_OK.",
    "winsound.PlaySound" => "A wrapper around the Windows PlaySound API.\n\nsound\n  The sound to play; a filename, data, or None.\nflags\n  Flag values, ored together.  See module documentation.",
    "zlib" => "The functions in this module allow compression and decompression using the\nzlib library, which is based on GNU zip.\n\nadler32(string[, start]) -- Compute an Adler-32 checksum.\ncompress(data[, level]) -- Compress data, with compression level 0-9 or -1.\ncompressobj([level[, ...]]) -- Return a compressor object.\ncrc32(string[, start]) -- Compute a CRC-32 checksum.\ndecompress(string,[wbits],[bufsize]) -- Decompresses a compressed string.\ndecompressobj([wbits[, zdict]]) -- Return a decompressor object.\n\n'wbits' is window buffer size and container format.\nCompressor objects support compress() and flush() methods; decompressor\nobjects support decompress() and flush().",
    "zlib._ZlibDecompressor" => "Create a decompressor object for decompressing data incrementally.\n\nwbits = 15\nzdict\n   The predefined compression dictionary. This is a sequence of bytes\n   (such as a bytes object) containing subsequences that are expected\n   to occur frequently in the data that is to be compressed. Those\n   subsequences that are expected to be most common should come at the\n   end of the dictionary. This must be the same dictionary as used by the\n   compressor that produced the input data.",
    "zlib._ZlibDecompressor.__delattr__" => "Implement delattr(self, name).",
    "zlib._ZlibDecompressor.__eq__" => "Return self==value.",
    "zlib._ZlibDecompressor.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "zlib._ZlibDecompressor.__ge__" => "Return self>=value.",
    "zlib._ZlibDecompressor.__getattribute__" => "Return getattr(self, name).",
    "zlib._ZlibDecompressor.__getstate__" => "Helper for pickle.",
    "zlib._ZlibDecompressor.__gt__" => "Return self>value.",
    "zlib._ZlibDecompressor.__hash__" => "Return hash(self).",
    "zlib._ZlibDecompressor.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "zlib._ZlibDecompressor.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "zlib._ZlibDecompressor.__le__" => "Return self<=value.",
    "zlib._ZlibDecompressor.__lt__" => "Return self<value.",
    "zlib._ZlibDecompressor.__ne__" => "Return self!=value.",
    "zlib._ZlibDecompressor.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "zlib._ZlibDecompressor.__reduce__" => "Helper for pickle.",
    "zlib._ZlibDecompressor.__reduce_ex__" => "Helper for pickle.",
    "zlib._ZlibDecompressor.__repr__" => "Return repr(self).",
    "zlib._ZlibDecompressor.__setattr__" => "Implement setattr(self, name, value).",
    "zlib._ZlibDecompressor.__sizeof__" => "Size of object in memory, in bytes.",
    "zlib._ZlibDecompressor.__str__" => "Return str(self).",
    "zlib._ZlibDecompressor.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "zlib._ZlibDecompressor.decompress" => "Decompress *data*, returning uncompressed data as bytes.\n\nIf *max_length* is nonnegative, returns at most *max_length* bytes of\ndecompressed data. If this limit is reached and further output can be\nproduced, *self.needs_input* will be set to ``False``. In this case, the next\ncall to *decompress()* may provide *data* as b'' to obtain more of the output.\n\nIf all of the input data was decompressed and returned (either because this\nwas less than *max_length* bytes, or because *max_length* was negative),\n*self.needs_input* will be set to True.\n\nAttempting to decompress data after the end of stream is reached raises an\nEOFError.  Any data found after the end of the stream is ignored and saved in\nthe unused_data attribute.",
    "zlib._ZlibDecompressor.eof" => "True if the end-of-stream marker has been reached.",
    "zlib._ZlibDecompressor.needs_input" => "True if more input is needed before more decompressed data can be produced.",
    "zlib._ZlibDecompressor.unused_data" => "Data found after the end of the compressed stream.",
    "zlib.adler32" => "Compute an Adler-32 checksum of data.\n\n  value\n    Starting value of the checksum.\n\nThe returned checksum is an integer.",
    "zlib.compress" => "Returns a bytes object containing compressed data.\n\ndata\n  Binary data to be compressed.\nlevel\n  Compression level, in 0-9 or -1.\nwbits\n  The window buffer size and container format.",
    "zlib.compressobj" => "Return a compressor object.\n\nlevel\n  The compression level (an integer in the range 0-9 or -1; default is\n  currently equivalent to 6).  Higher compression levels are slower,\n  but produce smaller results.\nmethod\n  The compression algorithm.  If given, this must be DEFLATED.\nwbits\n  +9 to +15: The base-two logarithm of the window size.  Include a zlib\n      container.\n  -9 to -15: Generate a raw stream.\n  +25 to +31: Include a gzip container.\nmemLevel\n  Controls the amount of memory used for internal compression state.\n  Valid values range from 1 to 9.  Higher values result in higher memory\n  usage, faster compression, and smaller output.\nstrategy\n  Used to tune the compression algorithm.  Possible values are\n  Z_DEFAULT_STRATEGY, Z_FILTERED, and Z_HUFFMAN_ONLY.\nzdict\n  The predefined compression dictionary - a sequence of bytes\n  containing subsequences that are likely to occur in the input data.",
    "zlib.crc32" => "Compute a CRC-32 checksum of data.\n\n  value\n    Starting value of the checksum.\n\nThe returned checksum is an integer.",
    "zlib.decompress" => "Returns a bytes object containing the uncompressed data.\n\ndata\n  Compressed data.\nwbits\n  The window buffer size and container format.\nbufsize\n  The initial output buffer size.",
    "zlib.decompressobj" => "Return a decompressor object.\n\nwbits\n  The window buffer size and container format.\nzdict\n  The predefined compression dictionary.  This must be the same\n  dictionary as used by the compressor that produced the input data.",
    "zlib.error.__cause__" => "exception cause",
    "zlib.error.__context__" => "exception context",
    "zlib.error.__delattr__" => "Implement delattr(self, name).",
    "zlib.error.__eq__" => "Return self==value.",
    "zlib.error.__format__" => "Default object formatter.\n\nReturn str(self) if format_spec is empty. Raise TypeError otherwise.",
    "zlib.error.__ge__" => "Return self>=value.",
    "zlib.error.__getattribute__" => "Return getattr(self, name).",
    "zlib.error.__getstate__" => "Helper for pickle.",
    "zlib.error.__gt__" => "Return self>value.",
    "zlib.error.__hash__" => "Return hash(self).",
    "zlib.error.__init__" => "Initialize self.  See help(type(self)) for accurate signature.",
    "zlib.error.__init_subclass__" => "This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.",
    "zlib.error.__le__" => "Return self<=value.",
    "zlib.error.__lt__" => "Return self<value.",
    "zlib.error.__ne__" => "Return self!=value.",
    "zlib.error.__new__" => "Create and return a new object.  See help(type) for accurate signature.",
    "zlib.error.__reduce_ex__" => "Helper for pickle.",
    "zlib.error.__repr__" => "Return repr(self).",
    "zlib.error.__setattr__" => "Implement setattr(self, name, value).",
    "zlib.error.__sizeof__" => "Size of object in memory, in bytes.",
    "zlib.error.__str__" => "Return str(self).",
    "zlib.error.__subclasshook__" => "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).",
    "zlib.error.__weakref__" => "list of weak references to the object",
    "zlib.error.add_note" => "Exception.add_note(note) --\nadd a note to the exception",
    "zlib.error.with_traceback" => "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self."
};
