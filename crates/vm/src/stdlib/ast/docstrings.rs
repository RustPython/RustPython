// @generated from cpython/Python/Python-ast.c
pub const AST_DOCS: &[(&str, &str)] = &[
    ("Add", "Add"),
    ("And", "And"),
    (
        "AnnAssign",
        "AnnAssign(expr target, expr annotation, expr? value, int simple)",
    ),
    ("Assert", "Assert(expr test, expr? msg)"),
    (
        "Assign",
        "Assign(expr* targets, expr value, string? type_comment)",
    ),
    (
        "AsyncFor",
        "AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)",
    ),
    (
        "AsyncFunctionDef",
        "AsyncFunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment, type_param* type_params)",
    ),
    (
        "AsyncWith",
        "AsyncWith(withitem* items, stmt* body, string? type_comment)",
    ),
    (
        "Attribute",
        "Attribute(expr value, identifier attr, expr_context ctx)",
    ),
    (
        "AugAssign",
        "AugAssign(expr target, operator op, expr value)",
    ),
    ("Await", "Await(expr value)"),
    ("BinOp", "BinOp(expr left, operator op, expr right)"),
    ("BitAnd", "BitAnd"),
    ("BitOr", "BitOr"),
    ("BitXor", "BitXor"),
    ("BoolOp", "BoolOp(boolop op, expr* values)"),
    ("Break", "Break"),
    ("Call", "Call(expr func, expr* args, keyword* keywords)"),
    (
        "ClassDef",
        "ClassDef(identifier name, expr* bases, keyword* keywords, stmt* body, expr* decorator_list, type_param* type_params)",
    ),
    (
        "Compare",
        "Compare(expr left, cmpop* ops, expr* comparators)",
    ),
    ("Constant", "Constant(constant value, string? kind)"),
    ("Continue", "Continue"),
    ("Del", "Del"),
    ("Delete", "Delete(expr* targets)"),
    ("Dict", "Dict(expr?* keys, expr* values)"),
    (
        "DictComp",
        "DictComp(expr key, expr value, comprehension* generators)",
    ),
    ("Div", "Div"),
    ("Eq", "Eq"),
    (
        "ExceptHandler",
        "ExceptHandler(expr? type, identifier? name, stmt* body)",
    ),
    ("Expr", "Expr(expr value)"),
    ("Expression", "Expression(expr body)"),
    ("FloorDiv", "FloorDiv"),
    (
        "For",
        "For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)",
    ),
    (
        "FormattedValue",
        "FormattedValue(expr value, int conversion, expr? format_spec)",
    ),
    (
        "FunctionDef",
        "FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment, type_param* type_params)",
    ),
    ("FunctionType", "FunctionType(expr* argtypes, expr returns)"),
    (
        "GeneratorExp",
        "GeneratorExp(expr elt, comprehension* generators)",
    ),
    ("Global", "Global(identifier* names)"),
    ("Gt", "Gt"),
    ("GtE", "GtE"),
    ("If", "If(expr test, stmt* body, stmt* orelse)"),
    ("IfExp", "IfExp(expr test, expr body, expr orelse)"),
    ("Import", "Import(alias* names)"),
    (
        "ImportFrom",
        "ImportFrom(identifier? module, alias* names, int? level)",
    ),
    ("In", "In"),
    ("Interactive", "Interactive(stmt* body)"),
    (
        "Interpolation",
        "Interpolation(expr value, constant str, int conversion, expr? format_spec)",
    ),
    ("Invert", "Invert"),
    ("Is", "Is"),
    ("IsNot", "IsNot"),
    ("JoinedStr", "JoinedStr(expr* values)"),
    ("LShift", "LShift"),
    ("Lambda", "Lambda(arguments args, expr body)"),
    ("List", "List(expr* elts, expr_context ctx)"),
    ("ListComp", "ListComp(expr elt, comprehension* generators)"),
    ("Load", "Load"),
    ("Lt", "Lt"),
    ("LtE", "LtE"),
    ("MatMult", "MatMult"),
    ("Match", "Match(expr subject, match_case* cases)"),
    ("MatchAs", "MatchAs(pattern? pattern, identifier? name)"),
    (
        "MatchClass",
        "MatchClass(expr cls, pattern* patterns, identifier* kwd_attrs, pattern* kwd_patterns)",
    ),
    (
        "MatchMapping",
        "MatchMapping(expr* keys, pattern* patterns, identifier? rest)",
    ),
    ("MatchOr", "MatchOr(pattern* patterns)"),
    ("MatchSequence", "MatchSequence(pattern* patterns)"),
    ("MatchSingleton", "MatchSingleton(constant value)"),
    ("MatchStar", "MatchStar(identifier? name)"),
    ("MatchValue", "MatchValue(expr value)"),
    ("Mod", "Mod"),
    ("Module", "Module(stmt* body, type_ignore* type_ignores)"),
    ("Mult", "Mult"),
    ("Name", "Name(identifier id, expr_context ctx)"),
    ("NamedExpr", "NamedExpr(expr target, expr value)"),
    ("Nonlocal", "Nonlocal(identifier* names)"),
    ("Not", "Not"),
    ("NotEq", "NotEq"),
    ("NotIn", "NotIn"),
    ("Or", "Or"),
    (
        "ParamSpec",
        "ParamSpec(identifier name, expr? default_value)",
    ),
    ("Pass", "Pass"),
    ("Pow", "Pow"),
    ("RShift", "RShift"),
    ("Raise", "Raise(expr? exc, expr? cause)"),
    ("Return", "Return(expr? value)"),
    ("Set", "Set(expr* elts)"),
    ("SetComp", "SetComp(expr elt, comprehension* generators)"),
    ("Slice", "Slice(expr? lower, expr? upper, expr? step)"),
    ("Starred", "Starred(expr value, expr_context ctx)"),
    ("Store", "Store"),
    ("Sub", "Sub"),
    (
        "Subscript",
        "Subscript(expr value, expr slice, expr_context ctx)",
    ),
    ("TemplateStr", "TemplateStr(expr* values)"),
    (
        "Try",
        "Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)",
    ),
    (
        "TryStar",
        "TryStar(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)",
    ),
    ("Tuple", "Tuple(expr* elts, expr_context ctx)"),
    (
        "TypeAlias",
        "TypeAlias(expr name, type_param* type_params, expr value)",
    ),
    ("TypeIgnore", "TypeIgnore(int lineno, string tag)"),
    (
        "TypeVar",
        "TypeVar(identifier name, expr? bound, expr? default_value)",
    ),
    (
        "TypeVarTuple",
        "TypeVarTuple(identifier name, expr? default_value)",
    ),
    ("UAdd", "UAdd"),
    ("USub", "USub"),
    ("UnaryOp", "UnaryOp(unaryop op, expr operand)"),
    ("While", "While(expr test, stmt* body, stmt* orelse)"),
    (
        "With",
        "With(withitem* items, stmt* body, string? type_comment)",
    ),
    ("Yield", "Yield(expr? value)"),
    ("YieldFrom", "YieldFrom(expr value)"),
    ("alias", "alias(identifier name, identifier? asname)"),
    (
        "arg",
        "arg(identifier arg, expr? annotation, string? type_comment)",
    ),
    (
        "arguments",
        "arguments(arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs, expr* kw_defaults, arg? kwarg, expr* defaults)",
    ),
    ("boolop", "boolop = And | Or"),
    (
        "cmpop",
        "cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn",
    ),
    (
        "comprehension",
        "comprehension(expr target, expr iter, expr* ifs, int is_async)",
    ),
    (
        "excepthandler",
        "excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)",
    ),
    (
        "expr",
        "expr = BoolOp(boolop op, expr* values)\n     | NamedExpr(expr target, expr value)\n     | BinOp(expr left, operator op, expr right)\n     | UnaryOp(unaryop op, expr operand)\n     | Lambda(arguments args, expr body)\n     | IfExp(expr test, expr body, expr orelse)\n     | Dict(expr?* keys, expr* values)\n     | Set(expr* elts)\n     | ListComp(expr elt, comprehension* generators)\n     | SetComp(expr elt, comprehension* generators)\n     | DictComp(expr key, expr value, comprehension* generators)\n     | GeneratorExp(expr elt, comprehension* generators)\n     | Await(expr value)\n     | Yield(expr? value)\n     | YieldFrom(expr value)\n     | Compare(expr left, cmpop* ops, expr* comparators)\n     | Call(expr func, expr* args, keyword* keywords)\n     | FormattedValue(expr value, int conversion, expr? format_spec)\n     | Interpolation(expr value, constant str, int conversion, expr? format_spec)\n     | JoinedStr(expr* values)\n     | TemplateStr(expr* values)\n     | Constant(constant value, string? kind)\n     | Attribute(expr value, identifier attr, expr_context ctx)\n     | Subscript(expr value, expr slice, expr_context ctx)\n     | Starred(expr value, expr_context ctx)\n     | Name(identifier id, expr_context ctx)\n     | List(expr* elts, expr_context ctx)\n     | Tuple(expr* elts, expr_context ctx)\n     | Slice(expr? lower, expr? upper, expr? step)",
    ),
    ("expr_context", "expr_context = Load | Store | Del"),
    ("keyword", "keyword(identifier? arg, expr value)"),
    (
        "match_case",
        "match_case(pattern pattern, expr? guard, stmt* body)",
    ),
    (
        "mod",
        "mod = Module(stmt* body, type_ignore* type_ignores)\n    | Interactive(stmt* body)\n    | Expression(expr body)\n    | FunctionType(expr* argtypes, expr returns)",
    ),
    (
        "operator",
        "operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift | RShift | BitOr | BitXor | BitAnd | FloorDiv",
    ),
    (
        "pattern",
        "pattern = MatchValue(expr value)\n        | MatchSingleton(constant value)\n        | MatchSequence(pattern* patterns)\n        | MatchMapping(expr* keys, pattern* patterns, identifier? rest)\n        | MatchClass(expr cls, pattern* patterns, identifier* kwd_attrs, pattern* kwd_patterns)\n        | MatchStar(identifier? name)\n        | MatchAs(pattern? pattern, identifier? name)\n        | MatchOr(pattern* patterns)",
    ),
    (
        "stmt",
        "stmt = FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment, type_param* type_params)\n     | AsyncFunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment, type_param* type_params)\n     | ClassDef(identifier name, expr* bases, keyword* keywords, stmt* body, expr* decorator_list, type_param* type_params)\n     | Return(expr? value)\n     | Delete(expr* targets)\n     | Assign(expr* targets, expr value, string? type_comment)\n     | TypeAlias(expr name, type_param* type_params, expr value)\n     | AugAssign(expr target, operator op, expr value)\n     | AnnAssign(expr target, expr annotation, expr? value, int simple)\n     | For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)\n     | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)\n     | While(expr test, stmt* body, stmt* orelse)\n     | If(expr test, stmt* body, stmt* orelse)\n     | With(withitem* items, stmt* body, string? type_comment)\n     | AsyncWith(withitem* items, stmt* body, string? type_comment)\n     | Match(expr subject, match_case* cases)\n     | Raise(expr? exc, expr? cause)\n     | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)\n     | TryStar(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)\n     | Assert(expr test, expr? msg)\n     | Import(alias* names)\n     | ImportFrom(identifier? module, alias* names, int? level)\n     | Global(identifier* names)\n     | Nonlocal(identifier* names)\n     | Expr(expr value)\n     | Pass\n     | Break\n     | Continue",
    ),
    (
        "type_ignore",
        "type_ignore = TypeIgnore(int lineno, string tag)",
    ),
    (
        "type_param",
        "type_param = TypeVar(identifier name, expr? bound, expr? default_value)\n           | ParamSpec(identifier name, expr? default_value)\n           | TypeVarTuple(identifier name, expr? default_value)",
    ),
    ("unaryop", "unaryop = Invert | Not | UAdd | USub"),
    (
        "withitem",
        "withitem(expr context_expr, expr? optional_vars)",
    ),
];
